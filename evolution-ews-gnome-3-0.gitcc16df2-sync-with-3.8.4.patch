diff -up evolution-ews-gnome-3-0.gitcc16df2/config.h.in.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/config.h.in
--- evolution-ews-gnome-3-0.gitcc16df2/config.h.in.sync-with-3.8.4	2013-05-28 08:55:09.000000000 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/config.h.in	2013-07-24 07:30:27.313435567 +0200
@@ -79,6 +79,9 @@
 /* Define to 1 if you have the ANSI C header files. */
 #undef STDC_HEADERS
 
+/* libmspack has OAB support */
+#undef USE_MSPACK
+
 /* Version number of package */
 #undef VERSION
 
diff -up evolution-ews-gnome-3-0.gitcc16df2/configure.ac.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/configure.ac
--- evolution-ews-gnome-3-0.gitcc16df2/configure.ac.sync-with-3.8.4	2013-07-24 07:30:27.229435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/configure.ac	2013-07-24 07:30:27.314435567 +0200
@@ -180,6 +180,20 @@ AC_SUBST(SOUP_LIBS)
 LIBSOUP_REQUIRED=libsoup_minimum_version
 AC_SUBST(LIBSOUP_REQUIRED)
 
+dnl ****************************
+dnl Check for libmspack with OAB support
+dnl ****************************
+AC_ARG_WITH([internal-lzx],
+	AS_HELP_STRING([--with-internal-lzx],
+	    [Use internal LZX decompressor instead of libmspack [default=no]]),
+	    [have_mspack=no],
+	    [PKG_CHECK_MODULES(MSPACK, libmspack >= 0.4,
+		[AC_DEFINE(USE_MSPACK, [1], [libmspack has OAB support])
+		 have_mspack=yes],
+		[AC_ERROR([libmspack >= 0.4 not found.]
+[Make sure it is installed or run configure with --with-internal-lzx])])])
+AM_CONDITIONAL(HAVE_MSPACK, [test "$have_mspack" = "yes"])
+
 dnl ********************************
 dnl Check for remaining evolution-data-server modules
 dnl ********************************
@@ -277,7 +291,6 @@ src/server/libeews.pc
 src/utils/Makefile
 src/account-setup-eplugin/Makefile
 src/addressbook/Makefile
-src/addressbook/lzx/Makefile
 src/calendar/Makefile
 src/camel/Makefile
 po/Makefile.in
diff -up evolution-ews-gnome-3-0.gitcc16df2/po/el.po.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/po/el.po
--- evolution-ews-gnome-3-0.gitcc16df2/po/el.po.sync-with-3.8.4	2013-07-24 07:30:27.316435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/po/el.po	2013-07-24 07:30:27.316435567 +0200
@@ -0,0 +1,1099 @@
+# Greek translation for evolution-ews.
+# Copyright (C) 2013 evolution-ews's COPYRIGHT HOLDER
+# This file is distributed under the same license as the evolution-ews package.
+# Dimitris Spingos <dmtrs32@gmail.com>, 2013.
+# Dimitris Spingos (Δημήτρης Σπίγγος) <dmtrs32@gmail.com>, 2013.
+msgid ""
+msgstr ""
+"Project-Id-Version: evolution-ews gnome-3-8\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product"
+"=evolution-ews&keywords=I18N+L10N&component=general\n"
+"POT-Creation-Date: 2013-07-15 16:05+0000\n"
+"PO-Revision-Date: 2013-07-16 06:10+0300\n"
+"Last-Translator: Dimitris Spingos (Δημήτρης Σπίγγος) <dmtrs32@gmail.com>\n"
+"Language-Team: team@gnome.gr\n"
+"Language: el\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+"X-Generator: Virtaal 0.7.1\n"
+"X-Project-Style: gnome\n"
+
+#: ../src/addressbook/e-book-backend-ews.c:1038
+msgid "The backend does not support bulk additions"
+msgstr "Το νωτιαίο σύστημα δεν υποστηρίζει μαζικές προσθήκες"
+
+#: ../src/addressbook/e-book-backend-ews.c:1325
+msgid "The backend does not support bulk modifications"
+msgstr "Η νωτιαία υποστήριξη δεν υποστηρίζει μαζικές τροποποιήσεις"
+
+#: ../src/addressbook/e-book-backend-ews.c:1513
+msgid "Wait till syncing is done"
+msgstr "Περιμένετε μέχρι την ολοκλήρωση του συγχρονισμού"
+
+#: ../src/addressbook/e-book-backend-ews.c:1922
+#, c-format
+msgid "Downloading contacts in %s %d%% completed... "
+msgstr "Η μεταφόρτωση επαφών στο %s%d%% ολοκληρώθηκε... "
+
+#: ../src/addressbook/e-book-backend-ews.c:2535
+msgid "Syncing contacts..."
+msgstr "Συγχρονισμός επαφών..."
+
+#: ../src/addressbook/e-book-backend-ews.c:2757
+#: ../src/configuration/e-ews-search-user.c:365
+msgid "Searching..."
+msgstr "Αναζήτηση..."
+
+#: ../src/calendar/e-cal-backend-ews.c:1055
+msgid "EWS does not support bulk removals"
+msgstr "Το EWS δεν υποστηρίζει μαζικές αφαιρέσεις"
+
+#: ../src/calendar/e-cal-backend-ews.c:1698
+msgid "EWS does not support bulk additions"
+msgstr "Το EWS δεν υποστηρίζει μαζικές προσθήκες"
+
+#: ../src/calendar/e-cal-backend-ews.c:2281
+msgid "EWS does not support bulk modifications"
+msgstr "Το EWS δεν υποστηρίζει μαζικές τροποποιήσεις"
+
+#: ../src/camel/camel-ews-folder.c:268
+#, c-format
+msgid "Unable to open mimecontent temporary file!"
+msgstr "Αδύνατο το άνοιγμα περιεχομένου mime προσωρινού αρχείου!"
+
+#: ../src/camel/camel-ews-folder.c:276
+#, c-format
+msgid "Unable to generate parser from mimecontent!"
+msgstr "Αδύνατη η δημιουργία αναλυτή από περιεχόμενο mime!"
+
+#: ../src/camel/camel-ews-folder.c:285
+#, c-format
+msgid "Unable to parse meeting request mimecontent!"
+msgstr "Αδύνατη η ανάλυση αιτήματος συγκέντρωσης περιεχομένου mime!"
+
+#: ../src/camel/camel-ews-folder.c:346
+#, c-format
+msgid "Unable to create cache file"
+msgstr "Αδύνατη η δημιουργία αρχείου κρυφής μνήμης"
+
+#: ../src/camel/camel-ews-folder.c:451 ../src/camel/camel-ews-folder.c:531
+#, c-format
+msgid "Unable to create cache path"
+msgstr "Αδύνατη η δημιουργία διαδρομής κρυφής μνήμης"
+
+#: ../src/camel/camel-ews-folder.c:541
+#, c-format
+msgid "Failed to move message cache file"
+msgstr "Αποτυχία μετακίνησης μηνύματος αρχείου κρυφής μνήμης"
+
+#: ../src/camel/camel-ews-folder.c:1189
+#, c-format
+msgid "Could not load summary for %s"
+msgstr "Αδύνατη η φόρτωση περίληψης για το %s"
+
+#: ../src/camel/camel-ews-folder.c:1625
+#, c-format
+msgid "Cant perform actions on the folder while in offline mode"
+msgstr "Αδύνατη η εκτέλεση ενεργειών στον φάκελο όσο είναι εκτός σύνδεσης"
+
+#: ../src/camel/camel-ews-provider.c:48
+msgid "Checking for new mail"
+msgstr "Έλεγχος για νέα μηνύματα"
+
+#: ../src/camel/camel-ews-provider.c:50
+msgid "C_heck for new messages in all folders"
+msgstr "Έ_λεγχος για νέα μηνύματα σε όλους τους φακέλους"
+
+#: ../src/camel/camel-ews-provider.c:53
+msgid "Options"
+msgstr "Επιλογές"
+
+#: ../src/camel/camel-ews-provider.c:55
+msgid "_Apply filters to new messages in Inbox on this server"
+msgstr ""
+"_Εφαρμογή φίλτρων για νέα μηνύματα στα Εισερχόμενα σε αυτόν τον διακομιστή"
+
+#: ../src/camel/camel-ews-provider.c:57
+msgid "Check new messages for _Junk contents"
+msgstr "Έλεγχος νέων μηνυμάτων για _ανεπιθύμητα περιεχόμενα"
+
+#: ../src/camel/camel-ews-provider.c:59
+msgid "Only check for Junk messages in the IN_BOX folder"
+msgstr "Έλεγχος για ανεπιθύμητα μηνύματα μόνο στο φάκελο Εισερχο_μένων"
+
+#: ../src/camel/camel-ews-provider.c:61
+msgid "Automatically synchroni_ze remote mail locally"
+msgstr "Αυτόματος συγ_χρονισμός απομακρυσμένης αλληλογραφίας τοπικά"
+
+#: ../src/camel/camel-ews-provider.c:64
+msgid "Connection"
+msgstr "Σύνδεση"
+
+#. Translators: '%s' is preplaced with a widget, where "
+#. * user can select how long the timeout should be.
+#: ../src/camel/camel-ews-provider.c:68
+#, c-format
+msgid "Connection _timeout (in seconds) %s"
+msgstr "_Λήξη χρόνου σύνδεσης (σε δευτερόλεπτα) %s"
+
+#: ../src/camel/camel-ews-provider.c:76
+msgid "Exchange Web Services"
+msgstr "Υπηρεσίες ιστού Exchange"
+
+#: ../src/camel/camel-ews-provider.c:78
+msgid "For accessing Exchange servers using Web Services"
+msgstr "Για πρόσβαση εξυπηρετητών Exchange χρησιμοποιώντας υπηρεσίες ιστού"
+
+#: ../src/camel/camel-ews-provider.c:93
+msgid "NTLM"
+msgstr "NTLM"
+
+#: ../src/camel/camel-ews-provider.c:95
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with NTLM authentication."
+msgstr ""
+"Με αυτήν την επιλογή θα συνδεθείτε με τον διακομιστή Exchange "
+"χρησιμοποιώντας έναν κωδικό απλού κειμένου με πιστοποίηση NTLM."
+
+#: ../src/camel/camel-ews-provider.c:103
+msgid "Basic"
+msgstr "Βασικά"
+
+#: ../src/camel/camel-ews-provider.c:105
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with Basic authentication."
+msgstr ""
+"Με αυτήν την επιλογή θα συνδεθείτε με τον διακομιστή Exchange "
+"χρησιμοποιώντας έναν κωδικό απλού κειμένου με βασική πιστοποίηση."
+
+#: ../src/camel/camel-ews-store.c:192
+#, c-format
+msgid "Session has no storage path"
+msgstr "Η συνεδρία δεν έχει διαδρομή αποθήκευσης"
+
+#: ../src/camel/camel-ews-store.c:229
+#, c-format
+msgctxt "PublicFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:358
+#, c-format
+msgctxt "ForeignFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:696
+msgid "Updating foreign folder structure"
+msgstr "Ενημέρωση δομής ξένου φακέλου"
+
+#: ../src/camel/camel-ews-store.c:1138
+msgid "Query for authentication types is not supported"
+msgstr "Το ερώτημα για τύπους πιστοποίησης δεν υποστηρίζεται"
+
+#: ../src/camel/camel-ews-store.c:1190
+#, c-format
+msgid "No such folder: %s"
+msgstr "Δεν υπάρχει τέτοιος φάκελος: %s"
+
+#: ../src/camel/camel-ews-store.c:1502
+msgid "Cannot list EWS public folders in offline mode"
+msgstr "Αδύνατη η λίστα δημόσιων φακέλων EWS σε κατάσταση εκτός σύνδεσης"
+
+#: ../src/camel/camel-ews-store.c:1575
+msgid "Cannot find any EWS public folders"
+msgstr "Αδύνατη η εύρεση οποιωνδήποτε δημόσιων φακέλων"
+
+#: ../src/camel/camel-ews-store.c:1680
+#, c-format
+msgid "Cannot create folder '%s', folder already exists"
+msgstr "Αδύνατη η δημιουργία του φακέλου '%s', ο φάκελος υπάρχει ήδη"
+
+#: ../src/camel/camel-ews-store.c:1695
+#, c-format
+msgid "Parent folder %s does not exist"
+msgstr "Ο γονικός φάκελος %s δεν υπάρχει"
+
+#: ../src/camel/camel-ews-store.c:1705
+#, c-format
+msgid ""
+"Cannot create folder under '%s', it is used for folders of other users only"
+msgstr ""
+"Αδύνατη η δημιουργία φακέλου κάτω από τον '%s', χρησιμοποιείται μόνο για "
+"φακέλους άλλων χρηστών"
+
+#: ../src/camel/camel-ews-store.c:1715
+#, c-format
+msgid "Cannot create folder under '%s', it is used for public folders only"
+msgstr ""
+"Αδύνατη η δημιουργία φακέλου κάτω από τον '%s', χρησιμοποιείται μόνο για "
+"δημόσιους φακέλους"
+
+#: ../src/camel/camel-ews-store.c:1784
+#, c-format
+msgid "Folder does not exist"
+msgstr "Ο φάκελος δεν υπάρχει"
+
+#: ../src/camel/camel-ews-store.c:1793
+#, c-format
+msgid "Cannot remove folder '%s', it is used for folders of other users only"
+msgstr ""
+"Αδύνατη η αφαίρεση του φακέλου '%s', χρησιμοποιείται μόνο για φακέλους άλλων "
+"χρηστών"
+
+#: ../src/camel/camel-ews-store.c:1803
+#, c-format
+msgid "Cannot remove folder '%s', it is used for public folders only"
+msgstr ""
+"Αδύνατη η αφαίρεση του φακέλου '%s', χρησιμοποιείται μόνο για δημόσιους "
+"φακέλους"
+
+#: ../src/camel/camel-ews-store.c:1911
+#, c-format
+msgid "Folder %s does not exist"
+msgstr "Ο φάκελος %s δεν υπάρχει"
+
+#: ../src/camel/camel-ews-store.c:1921
+#, c-format
+msgid "No change key record for folder %s"
+msgstr "Καμία εγγραφή κλειδιού αλλαγής για τον φάκελο %s"
+
+#: ../src/camel/camel-ews-store.c:1963
+#, c-format
+msgid "Cannot both rename and move a folder at the same time"
+msgstr "Αδύνατη η ταυτόχρονη μετονομασία και μετακίνηση ενός φακέλου"
+
+#: ../src/camel/camel-ews-store.c:1999
+#, c-format
+msgid "Cannot find folder ID for parent folder %s"
+msgstr "Αδύνατη η εύρεση αναγνωριστικού φακέλου για τον γονικό φάκελο %s"
+
+#: ../src/camel/camel-ews-store.c:2049 ../src/camel/camel-ews-transport.c:69
+#, c-format
+msgid "Exchange server %s"
+msgstr "Εξυπηρετητής Exchange %s"
+
+#: ../src/camel/camel-ews-store.c:2052
+#, c-format
+msgid "Exchange service for %s on %s"
+msgstr "Υπηρεσία Exchange για τον %s σε %s"
+
+#: ../src/camel/camel-ews-store.c:2096
+#, c-format
+msgid "Could not locate Trash folder"
+msgstr "Αδύνατος ο εντοπισμός του φακέλου απορριμμάτων"
+
+#: ../src/camel/camel-ews-store.c:2156
+#, c-format
+msgid "Could not locate Junk folder"
+msgstr "Αδύνατος ο εντοπισμός του φακέλου ανεπιθύμητων"
+
+#: ../src/camel/camel-ews-store.c:2346
+msgid "Cannot subscribe EWS folders in offline mode"
+msgstr "Αδύνατη η εγγραφή σε φακέλους EWS σε λειτουργία χωρίς σύνδεση"
+
+#: ../src/camel/camel-ews-store.c:2369
+#, c-format
+msgid "Cannot subscribe folder '%s', no public folder available"
+msgstr ""
+"Αδύνατη η εγγραφή σε φάκελο '%s', δεν υπάρχει διαθέσιμος δημόσιος φάκελος"
+
+#: ../src/camel/camel-ews-store.c:2379
+#, c-format
+msgid "Cannot subscribe folder '%s', folder not found"
+msgstr "Αδύνατη η εγγραφή σε φάκελο '%s', ο φάκελος δεν βρέθηκε"
+
+#: ../src/camel/camel-ews-store.c:2470
+msgid "Cannot unsubscribe EWS folders in offline mode"
+msgstr "Αδύνατη η απεγγραφή φακέλων EWS σε κατάσταση χωρίς σύνδεση"
+
+#: ../src/camel/camel-ews-store.c:2587
+#, c-format
+msgid "You must be working online to complete this operation"
+msgstr ""
+"Πρέπει να είστε συνδεμένοι στο δίκτυο για να ολοκληρωθεί αυτή η διαδικασία"
+
+#: ../src/camel/camel-ews-transport.c:72
+#, c-format
+msgid "Exchange mail delivery via %s"
+msgstr "Παράδοση μηνυμάτων Exchange μέσω %s"
+
+#: ../src/camel/camel-ews-transport.c:119
+msgid "Cannot send message with no From address"
+msgstr "Αδύνατη η αποστολή μηνύματος χωρίς διεύθυνση αποστολέα"
+
+#: ../src/camel/camel-ews-transport.c:125
+msgid "Exchange server cannot send message with multiple From addresses"
+msgstr ""
+"Ο εξυπηρετητής Exchange δεν μπορεί να στείλει μήνυμα με πολλαπλές "
+"διευθύνσεις αποστολέα"
+
+#: ../src/camel/camel-ews-transport.c:136
+msgid "Failed to read From address"
+msgstr "Αποτυχία ανάγνωσης από τη διεύθυνση"
+
+#: ../src/camel/camel-ews-transport.c:148
+#, c-format
+msgid ""
+"Exchange server cannot send message as '%s', when the account was configured "
+"for address '%s'"
+msgstr ""
+"Ο εξυπηρετητής Exchange δεν μπορεί να στείλει μήνυμα ως '%s', όταν ο "
+"λογαριασμός ρυθμίστηκε για τη διεύθυνση'%s'"
+
+#: ../src/camel/camel-ews-transport.c:162
+#, c-format
+msgid "Service not connected"
+msgstr "Ασύνδετη υπηρεσία"
+
+#: ../src/collection/e-ews-backend.c:428
+#: ../src/configuration/e-mail-config-ews-gal.c:274
+msgid "Global Address List"
+msgstr "Καθολική λίστα διευθύνσεων"
+
+#: ../src/collection/e-ews-backend.c:813
+#, c-format
+msgid "Could not determine a suitable folder class for a new folder named '%s'"
+msgstr ""
+"Αδύνατος ο προσδιορισμός μιας κατάλληλης κλάσης φακέλου για έναν νέο φάκελο "
+"με όνομα '%s'"
+
+#: ../src/collection/e-ews-backend.c:902
+#, c-format
+msgid "Data source '%s' does not represent an Exchange Web Services folder"
+msgstr ""
+"Τα πηγαία δεδομένα '%s' δεν αντιπροσωπεύουν έναν φάκελο υπηρεσιών ιστού "
+"Exchange"
+
+#: ../src/configuration/e-ews-config-utils.c:516
+#, c-format
+msgid "Cannot edit permissions of folder '%s', choose other folder."
+msgstr "Αδύνατη η επεξεργασία αδειών του φακέλου '%s', επιλέξτε άλλον φάκελο."
+
+#: ../src/configuration/e-ews-config-utils.c:594
+msgid "Subscribe to folder of other user..."
+msgstr "Εγγραφείτε στον φάκελο του άλλου χρήστη..."
+
+#: ../src/configuration/e-ews-config-utils.c:603
+#: ../src/configuration/e-ews-config-utils.c:884
+#: ../src/configuration/e-ews-config-utils.c:915
+#: ../src/configuration/e-ews-config-utils.c:946
+#: ../src/configuration/e-ews-config-utils.c:977
+msgid "Permissions..."
+msgstr "Δικαιώματα..."
+
+#: ../src/configuration/e-ews-config-utils.c:605
+msgid "Edit EWS folder permissions"
+msgstr "Επεξεργασία των δικαιωμάτων φακέλου EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:886
+msgid "Edit EWS calendar permissions"
+msgstr "Επεξεργασία των δικαιωμάτων ημερολογίου EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:917
+msgid "Edit EWS tasks permissions"
+msgstr "Επεξεργασία των δικαιωμάτων εργασιών EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:948
+msgid "Edit EWS memos permissions"
+msgstr "Επεξεργασία των δικαιωμάτων υπενθυμίσεων EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:979
+msgid "Edit EWS contacts permissions"
+msgstr "Επεξεργασία των δικαιωμάτων επαφών EWS"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:87
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:499
+msgctxt "PermissionsLevel"
+msgid "None"
+msgstr "Κανένα"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:88
+msgctxt "PermissionsLevel"
+msgid "Owner"
+msgstr "Κάτοχος"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:98
+msgctxt "PermissionsLevel"
+msgid "Publishing Editor"
+msgstr "Επεξεργαστής δημοσιεύσεων"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:107
+msgctxt "PermissionsLevel"
+msgid "Editor"
+msgstr "Επεξεργαστής"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:115
+msgctxt "PermissionsLevel"
+msgid "Publishing Author"
+msgstr "Συντάκτης δημοσιεύσεων"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:122
+msgctxt "PermissionsLevel"
+msgid "Author"
+msgstr "Συγγραφέας"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:128
+msgctxt "PermissionsLevel"
+msgid "Nonediting Author"
+msgstr "Συντάκτης χωρίς δικαιώματα επεξεργασίας"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:133
+msgctxt "PermissionsLevel"
+msgid "Reviewer"
+msgstr "Αναθεωρητής"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:136
+msgctxt "PermissionsLevel"
+msgid "Contributor"
+msgstr "Συντελεστής"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:139
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time"
+msgstr "Διαθεσιμότητα"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:141
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time, subject, location"
+msgstr "Διαθεσιμότητα, θέμα, τοποθεσία"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:143
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:520
+msgctxt "PermissionsLevel"
+msgid "Custom"
+msgstr "Προσαρμοσμένο"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:267
+msgid "Writing folder permissions, please wait..."
+msgstr "Εγγραφή δικαιωμάτων φακέλου, παρακαλούμε περιμένετε..."
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:777
+msgctxt "User"
+msgid "Anonymous"
+msgstr "Ανώνυμος"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:780
+msgctxt "User"
+msgid "Default"
+msgstr "Προεπιλογή"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:786
+msgctxt "User"
+msgid "Unknown"
+msgstr "Άγνωστος"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:867
+#: ../src/configuration/e-ews-search-user.c:431
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1075
+msgid "Name"
+msgstr "Όνομα"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:873
+msgid "Permission level"
+msgstr "Επίπεδο δικαιωμάτων"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:925
+msgid "Edit EWS folder permissions..."
+msgstr "Επεξεργασία των δικαιωμάτων φακέλου EWS..."
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:950
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:635
+msgid "Account:"
+msgstr "Λογαριασμός:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:978
+msgid "Folder name:"
+msgstr "Όνομα φακέλου:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1001
+msgid "Folder ID:"
+msgstr "Αναγνωριστικό φακέλου:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1065
+msgid "Permissions"
+msgstr "Δικαιώματα"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1087
+msgid "Permi_ssion level:"
+msgstr "Ε_πίπεδο δικαιωμάτων:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1121
+msgctxt "Permissions"
+msgid "Read"
+msgstr "Αναγνωσμένα"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1133
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1200
+msgctxt "Permissions"
+msgid "None"
+msgstr "Κανένα"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1139
+msgctxt "Permissions"
+msgid "Free/Busy time"
+msgstr "Διαθεσιμότητα"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1144
+msgctxt "Permissions"
+msgid "Free/Busy time, subject, location"
+msgstr "Διαθεσιμότητα, θέμα, τοποθεσία"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1150
+msgctxt "Permissions"
+msgid "Full Details"
+msgstr "Πλήρεις λεπτομέρειες"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1156
+msgctxt "Permissions"
+msgid "Write"
+msgstr "Εγγραφή"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1168
+msgctxt "Permissions"
+msgid "Create items"
+msgstr "Δημιουργία στοιχείων"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1172
+msgctxt "Permissions"
+msgid "Create subfolders"
+msgstr "Δημιουργία υποφακέλων"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1176
+msgctxt "Permissions"
+msgid "Edit own"
+msgstr "Επεξεργασία ιδιοκτησιών"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1180
+msgctxt "Permissions"
+msgid "Edit all"
+msgstr "Επεξεργασία όλων"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1188
+msgctxt "Permissions"
+msgid "Delete items"
+msgstr "Διαγραφή στοιχείων"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1205
+msgctxt "Permissions"
+msgid "Own"
+msgstr "Ιδιοκτησία"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1210
+msgctxt "Permissions"
+msgid "All"
+msgstr "Όλα"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1216
+msgctxt "Permissions"
+msgid "Other"
+msgstr "Άλλο"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1228
+msgctxt "Permissions"
+msgid "Folder owner"
+msgstr "Ιδιοκτήτης φακέλου"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1232
+msgctxt "Permissions"
+msgid "Folder contact"
+msgstr "Επαφή φακέλου"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1236
+msgctxt "Permissions"
+msgid "Folder visible"
+msgstr "Ορατός φάκελος"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1309
+msgid "Reading folder permissions, please wait..."
+msgstr "Ανάγνωση δικαιωμάτων φακέλου, παρακαλούμε περιμένετε..."
+
+#: ../src/configuration/e-ews-search-user.c:208
+#, c-format
+msgid "No users found, only one contact"
+msgid_plural "No users found, only %d contacts"
+msgstr[0] "Δεν βρέθηκαν χρήστες, μόνο μία επαφή"
+msgstr[1] "Δεν βρέθηκαν χρήστες, μόνο %d επαφές"
+
+#: ../src/configuration/e-ews-search-user.c:213
+msgid "No users found"
+msgstr "Δε βρέθηκαν χρήστες"
+
+#: ../src/configuration/e-ews-search-user.c:217
+#, c-format
+msgid "Found one user"
+msgid_plural "Found %d users"
+msgstr[0] "Βρέθηκε ένας χρήστης"
+msgstr[1] "Βρέθηκαν %d χρήστες"
+
+#: ../src/configuration/e-ews-search-user.c:223
+#, c-format
+msgid "Found more than 100 users, but showing only first %d"
+msgid_plural "Found more than 100 users, but showing only first %d"
+msgstr[0] ""
+"Βρέθηκαν περισσότεροι από 100 χρήστες, αλλά εμφανίζονται μόνο οι πρώτοι %d"
+msgstr[1] ""
+"Βρέθηκαν περισσότεροι από 100 χρήστες, αλλά εμφανίζονται μόνο οι πρώτοι %d"
+
+#: ../src/configuration/e-ews-search-user.c:357
+#: ../src/configuration/e-ews-search-user.c:540
+msgid "Search for a user"
+msgstr "Αναζήτηση χρήστη"
+
+#: ../src/configuration/e-ews-search-user.c:437
+msgid "E-mail"
+msgstr "Ηλεκτρονικό ταχυδρομείο"
+
+#: ../src/configuration/e-ews-search-user.c:474
+msgid "Choose EWS user..."
+msgstr "Επιλέξτε χρήστη EWS..."
+
+#: ../src/configuration/e-ews-search-user.c:497
+msgid "_Search:"
+msgstr "Ανα_ζήτηση:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:97
+#: ../src/server/e-ews-folder.c:632
+#, c-format
+msgid "Cannot add folder, folder already exists as '%s'"
+msgstr "Αδύνατη η προσθήκη φακέλου, ο φάκελος υπάρχει ήδη ως '%s'"
+
+#. Translators: The '%s' is replaced with user name, to whom the foreign mailbox belongs.
+#. * Example result: "Mailbox - John Smith"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:107
+#, c-format
+msgctxt "ForeignFolder"
+msgid "Mailbox - %s"
+msgstr "Γραμματοκιβώτιο του - %s"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:272
+msgid "Cannot test foreign folder availability while in offline mode"
+msgstr ""
+"Αδύνατη η δοκιμή διαθεσιμότητας ξένου φακέλου όσο είναι σε κατάσταση χωρίς "
+"σύνδεση"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:297
+#, c-format
+msgid "User '%s' was not found on the server"
+msgstr "Ο χρήστης '%s' δεν βρέθηκε στον διακομιστή"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:333
+#, c-format
+msgid "User name '%s' is ambiguous, specify it more precisely, please"
+msgstr ""
+"Το όνομα χρήστη '%s' είναι ασαφές, ορίστε το με περισσότερη ακρίβεια, "
+"παρακαλούμε"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:355
+#, c-format
+msgid ""
+"Folder '%s' not found. Either it does not exist or you do not have "
+"permission to access it."
+msgstr ""
+"Ο φάκελος '%s' δεν βρέθηκε. Είτε δεν υπάρχει ή δεν έχετε το δικαίωμα "
+"πρόσβασης του."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:373
+msgid "Cannot add folder, cannot determine folder's type"
+msgstr ""
+"Αδύνατη η προσθήκη φακέλου, δεν μπορεί να προσδιοριστεί ο τύπος του φακέλου"
+
+#. Translators: This is used to name foreign folder.
+#. * The first '%s' is replaced with user name to whom the folder belongs,
+#. * the second '%s' is replaced with folder name.
+#. * Example result: "John Smith - Calendar"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:418
+#, c-format
+msgctxt "ForeignFolder"
+msgid "%s - %s"
+msgstr "%s - %s"
+
+#. convert well-known names to their non-localized form
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:512
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:720
+msgid "Inbox"
+msgstr "Εισερχόμενα"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:514
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:721
+msgid "Contacts"
+msgstr "Επαφές"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:516
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:722
+msgid "Calendar"
+msgstr "Ημερολόγιο"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:518
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:723
+msgid "Memos"
+msgstr "Υπενθυμίσεις"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:520
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:724
+msgid "Tasks"
+msgstr "Εργασίες"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:537
+#, c-format
+msgid "Testing availability of folder '%s' of user '%s', please wait..."
+msgstr ""
+"Έλεγχος διαθεσιμότητας του φακέλου '%s' του χρήστη '%s', παρακαλούμε "
+"περιμένετε..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:614
+msgid "Subscribe to folder of other EWS user..."
+msgstr "Εγγραφείτε στον φάκελο του άλλου χρήστη EWS..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:665
+msgid "User"
+msgstr "Χρήστης"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:672
+msgid "_User:"
+msgstr "_Χρήστης:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:687
+msgid "C_hoose..."
+msgstr "Επι_λογή..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:703
+msgid "_Folder name:"
+msgstr "Όνομα _φακέλου:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:733
+msgid "Include _subfolders"
+msgstr "_Να περιλαμβάνονται οι υποφάκελοι"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:140
+msgid "Querying Autodiscover service"
+msgstr "Ερώτημα υπηρεσίας αυτόματης ανακάλυψης"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:231
+msgid "Fetch _URL"
+msgstr "Προσκόμιση _URL"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:140
+msgid "Configuration"
+msgstr "Ρύθμιση"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:158
+msgid "User_name:"
+msgstr "Ό_νομα χρήστη:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:172
+msgid "_Host URL:"
+msgstr "URL _οικοδεσπότη:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:191
+msgid "OAB U_RL:"
+msgstr "U_RL OAB:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:205
+msgid "Open _Mailbox of other user"
+msgstr "Άνοιγμα _γραμματοκιβωτίου του άλλου χρήστη"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:239
+msgid "S_earch..."
+msgstr "Α_ναζήτηση..."
+
+#: ../src/configuration/e-mail-config-ews-backend.c:250
+msgid "Authentication"
+msgstr "Εξουσιοδότηση"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:500
+msgctxt "PermissionsLevel"
+msgid "Reviewer (can read items)"
+msgstr "Αναθεωρητής (μπορεί να διαβάσει στοιχεία)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:501
+msgctxt "PermissionsLevel"
+msgid "Author (can read and create items)"
+msgstr "Συντάκτης (μπορεί να διαβάσει και να δημιουργήσει στοιχεία)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:502
+msgctxt "PermissionsLevel"
+msgid "Editor (can read, create and modify items)"
+msgstr ""
+"Συντάκτης (μπορεί να διαβάσει, να δημιουργήσει και να τροποποιήσει στοιχεία)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:605
+msgid "Delegate permissions"
+msgstr "Δικαιώματα αντιπροσώπου"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:623
+msgid "C_alendar"
+msgstr "Η_μερολόγιο"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:626
+msgid "_Delegate receives copies of meeting-related messages sent to me"
+msgstr ""
+"Ο _αντιπρόσωπος δέχεται αντίγραφα της συγκέντρωσης - σχετικά μηνύματα "
+"στάλθηκαν σε μένα"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:631
+msgid "_Tasks"
+msgstr "_Εργασίες"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:634
+msgid "_Inbox"
+msgstr "Ε_ισερχόμενα"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:637
+msgid "C_ontacts"
+msgstr "Ε_παφές"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:640
+msgid "_Notes"
+msgstr "Σ_ημειώσεις"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:643
+msgid "_Journal"
+msgstr "Ημε_ρολόγιο"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:646
+#, c-format
+msgid "Delegate '%s' has the following permissions"
+msgstr "Ο αντιπρόσωπος '%s' έχει τα ακόλουθα δικαιώματα"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:664
+msgid "Delegate can see my _private items"
+msgstr "Ο αντιπρόσωπος μπορεί να δει τα _ιδιωτικά μου στοιχεία"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:987
+msgid "Retrieving current user permissions, please wait..."
+msgstr "Ανάκτηση τρεχόντων δικαιωμάτων χρήστη, παρακαλούμε περιμένετε..."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1108
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1638
+msgid "Delegates"
+msgstr "Αντιπρόσωποι"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1132
+msgid ""
+"Delegates can send items on your behalf, including creating and responding "
+"to meeting requests. If you want to grant folder permissions without giving "
+"send-on-behalf-of permissions, close this dialog box, right-click the "
+"folder, click Permissions and change the options there."
+msgstr ""
+"Οι αντιπρόσωποι μπορούν να στείλουν στοιχεία για λογαριασμό σας, "
+"συμπεριλαμβανόμενης της δημιουργίας και απάντησης σε αιτήματα συγκέντρωσης. "
+"Αν θέλετε να παραχωρήσετε δικαιώματα φακέλου χωρίς να δώσετε δικαιώματα "
+"αποστολής ως αντιπροσώπου, κλείστε αυτό το πλαίσιο διαλόγου, δεξιοπατήστε "
+"τον φάκελο, πατήστε δικαιώματα και αλλάξτε τις επιλογές εκεί."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1181
+msgid ""
+"Deliver meeting requests addressed to me and responses to meeting requests "
+"where I am the organizer to:"
+msgstr ""
+"Η παράδοση αιτημάτων συγκέντρωσης που απευθύνονται σε μένα και απαντήσεις σε "
+"αιτήματα συγκέντρωσης όπου είμαι ο οργανωτής:"
+
+#. new-line break, because GtkRadioButton doesn't allow wrapping of the inner label
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1190
+msgid ""
+"My delegates only, but _send a copy of meeting requests\n"
+"and responses to me (recommended)"
+msgstr ""
+"Οι αντιπρόσωποι μου μόνο, αλλά η _αποστολή ενός αντιγράφου αιτημάτων "
+"συγκέντρωσης\n"
+"και απαντήσεις σε μένα (συνιστάται)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1197
+msgid "My d_elegates only"
+msgstr "Μόνο οι α_ντιπρόσωποι μου"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1204
+msgid "My delegates a_nd me"
+msgstr "Οι αντιπρόσωποι μου _και εγώ"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1713
+msgid "Retrieving \"Delegates\" settings"
+msgstr "Ανάκτηση ρυθμίσεων \"Αντιπροσώπων\""
+
+#: ../src/configuration/e-mail-config-ews-gal.c:221
+msgid "Locating offline address books"
+msgstr "Εντοπισμός βιβλίων διευθύνσεων χωρίς σύνδεση"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:301
+msgid "Cache o_ffline address book"
+msgstr "Απόκρυψη βιβλίου διευθύνσεων _εκτός σύνδεσης"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:327
+msgid "Select ad_dress list:"
+msgstr "Επιλογή λίστας _διευθύνσεων:"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:351
+msgid "Fetch List"
+msgstr "Προσκόμιση λίστας"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:444
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:923
+msgid "Out of Office"
+msgstr "Εκτός γραφείου"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:460
+msgid ""
+"The messages specified below will be automatically sent to each internal and "
+"external person who sends a mail to you."
+msgstr ""
+"Τα παρακάτω συγκεκριμένα μηνύματα θα αποσταλούν αυτόματα σε κάθε εσωτερικό "
+"και εξωτερικό άτομο που στέλνει ένα μήνυμα σε σας."
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:468
+msgid "Do _not send Out of Office replies"
+msgstr "Μην _στέλνετε απαντήσεις εκτός γραφείου"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:476
+msgid "_Send Out of Office replies"
+msgstr "Να _στέλνετε απαντήσεις εκτός γραφείου"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:484
+msgid "Send Out of Office replies only _during this time period:"
+msgstr ""
+"Να στέλνετε απαντήσεις εκτός γραφείου μόνο κατά τη _διάρκεια αυτού του "
+"χρόνου:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:504
+msgid "_From:"
+msgstr "Α_πό:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:529
+msgid "_To:"
+msgstr "Πρ_ος:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:554
+msgid "I_nternal:"
+msgstr "Ε_σωτερικός:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:563
+msgid "Message to be sent within the organization"
+msgstr "Αποστολή μηνύματος μες τον οργανισμό"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:590
+msgid "E_xternal:"
+msgstr "Ε_ξωτερικός:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:598
+msgid "Message to be sent outside the organization"
+msgstr "Αποστολή μηνύματος έξω από τον οργανισμό"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:608
+msgid "Do not reply to senders outside the organization"
+msgstr "Χωρίς απαντήσεις για αποστολείς έξω από τον οργανισμό"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:611
+msgid "Reply only to known senders outside the organization"
+msgstr "Απάντηση μόνο σε γνωστούς αποστολείς έξω από τον οργανισμό"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:614
+msgid "Reply to any sender outside the organization"
+msgstr "Απάντηση σε οποιονδήποτε αποστολέα έξω από τον οργανισμό"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:999
+msgid "Retrieving \"Out of Office\" settings"
+msgstr "Ανάκτηση ρυθμίσεων \"Εκτός γραφείου\""
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:1
+msgid "Autodiscovery query failed."
+msgstr "Αποτυχία ερωτήματος αυτόματης ανακάλυψης."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:2
+msgid "The reported error was &quot;{0}&quot;."
+msgstr "Το σφάλμα που αναφέρθηκε ήταν &quot;{0}&quot;."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:3
+msgid "Failed to locate offline address books."
+msgstr "Αποτυχία εντοπισμού βιβλίων διευθύνσεων χωρίς σύνδεση."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:4
+msgid "Failed to retrieve &quot;Out of Office&quot; settings."
+msgstr "Αποτυχία ανάκτησης ρυθμίσεων &quot;Εκτός γραφείου&quot;."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:5
+msgid "Failed to retrieve &quot;Delegates&quot; settings."
+msgstr "Αποτυχία ανάκτησης ρυθμίσεων &quot;Αντιπροσώπων&quot;."
+
+#: ../src/server/e-ews-connection.c:494
+msgid "Operation Cancelled"
+msgstr "Ακύρωση λειτουργίας"
+
+#: ../src/server/e-ews-connection.c:563
+msgid "Authentication failed"
+msgstr "Αποτυχία πιστοποίησης"
+
+#: ../src/server/e-ews-connection.c:574
+#, c-format
+msgid "No response: %s"
+msgstr "Χωρίς απάντηση: %s"
+
+#: ../src/server/e-ews-connection.c:1912
+#, c-format
+msgid "Failed to parse autodiscover response XML"
+msgstr "Αποτυχία ανάλυσης απάντησης αυτόματης εύρεσης XML"
+
+#: ../src/server/e-ews-connection.c:1919
+#, c-format
+msgid "Failed to find <Autodiscover> element"
+msgstr "Αποτυχία εύρεσης στοιχείου <Autodiscover>"
+
+#: ../src/server/e-ews-connection.c:1930
+#, c-format
+msgid "Failed to find <Response> element"
+msgstr "Αποτυχία εύρεσης στοιχείου <Response>"
+
+#: ../src/server/e-ews-connection.c:1941
+#, c-format
+msgid "Failed to find <Account> element"
+msgstr "Αποτυχία εύρεσης στοιχείου <Account>"
+
+#: ../src/server/e-ews-connection.c:1960
+#, c-format
+msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
+msgstr "Αποτυχία εύρεσης <ASUrl> και <OABUrl> σε απόκριση αυτόματης εύρεσης"
+
+#: ../src/server/e-ews-connection.c:2042
+msgid "URL cannot be NULL"
+msgstr "Το URL δεν μπορεί να είναι κενό"
+
+#: ../src/server/e-ews-connection.c:2050
+#, c-format
+msgid "URL '%s' is not valid"
+msgstr "Το URL '%s' δεν είναι έγκυρο"
+
+#: ../src/server/e-ews-connection.c:2152
+msgid "Email address is missing a domain part"
+msgstr "Στη διεύθυνση αλληλογραφίας λείπει ένα τμήμα τομέα"
+
+#: ../src/server/e-ews-connection.c:2479
+msgid "Failed to parse oab XML"
+msgstr "Αποτυχία ανάλυσης oab XML"
+
+#: ../src/server/e-ews-connection.c:2487
+msgid "Failed to find <OAB> element\n"
+msgstr "Αποτυχία εύρεσης στοιχείου <OAB>\n"
+
+#: ../src/server/e-ews-connection.c:3673
+msgid "No items found"
+msgstr "Δε βρέθηκαν καταχωρίσεις"
+
+#: ../src/server/e-ews-folder.c:587
+msgid "Cannot add folder, unsupported folder type"
+msgstr "Αδύνατη η προσθήκη φακέλου, ανυποστήρικτος τύπος φακέλου"
+
+#: ../src/server/e-ews-folder.c:592
+msgid "Cannot add folder, master source not found"
+msgstr "Αδύνατη η προσθήκη φακέλου, η κύρια πηγή δεν βρέθηκε"
+
+#: ../src/utils/ews-camel-common.c:187
+#, c-format
+msgid "CreateItem call failed to return ID for new message"
+msgstr ""
+"Η κλήση CreateItem απέτυχε να επιστρέψει το αναγνωριστικό για νέο μήνυμα"
diff -up evolution-ews-gnome-3-0.gitcc16df2/po/LINGUAS.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/po/LINGUAS
--- evolution-ews-gnome-3-0.gitcc16df2/po/LINGUAS.sync-with-3.8.4	2013-07-24 07:30:27.236435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/po/LINGUAS	2013-07-24 07:30:27.316435567 +0200
@@ -2,6 +2,7 @@
 cs
 da
 de
+el
 en_GB
 es
 fr
@@ -17,4 +18,5 @@ sl
 sr
 sr@latin
 sv
+te
 zh_CN
diff -up evolution-ews-gnome-3-0.gitcc16df2/po/mr.po.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/po/mr.po
--- evolution-ews-gnome-3-0.gitcc16df2/po/mr.po.sync-with-3.8.4	2013-07-24 07:30:27.237435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/po/mr.po	2013-07-24 07:30:27.315435567 +0200
@@ -2,14 +2,14 @@
 # Copyright (C) 2012 evolution-ews's COPYRIGHT HOLDER
 # This file is distributed under the same license as the evolution-ews package.
 #
-# Sandeep Shedmake <sshedmak@redhat.com>, 2012.
+# Sandeep Shedmake <sshedmak@redhat.com>, 2012, 2013.
 msgid ""
 msgstr ""
 "Project-Id-Version: evolution-ews master\n"
 "Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
 "product=evolution-ews&keywords=I18N+L10N&component=general\n"
-"POT-Creation-Date: 2012-11-25 11:12+0000\n"
-"PO-Revision-Date: 2012-11-25 19:20+0530\n"
+"POT-Creation-Date: 2013-07-22 16:06+0000\n"
+"PO-Revision-Date: 2013-07-23 10:26+0530\n"
 "Last-Translator: Sandeep Shedmake <sshedmak@redhat.com>\n"
 "Language-Team: Marathi <maajhe-sanganak@freelists.org>\n"
 "Language: mr\n"
@@ -19,89 +19,81 @@ msgstr ""
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
 "X-Generator: Lokalize 1.5\n"
 
-#: ../src/addressbook/e-book-backend-ews.c:982
+#: ../src/addressbook/e-book-backend-ews.c:1038
 msgid "The backend does not support bulk additions"
 msgstr "बॅकएंड बल्क समाविष्टांकरीता समर्थन पुरवत नाही"
 
-#: ../src/addressbook/e-book-backend-ews.c:1266
+#: ../src/addressbook/e-book-backend-ews.c:1325
 msgid "The backend does not support bulk modifications"
 msgstr "बॅकएंड बल्क संपादनकरीता समर्थन पुरवत नाही"
 
-#: ../src/addressbook/e-book-backend-ews.c:1449
+#: ../src/addressbook/e-book-backend-ews.c:1513
 msgid "Wait till syncing is done"
 msgstr "सिंकिंग पूर्ण होईपर्यंत थांबा"
 
-#: ../src/addressbook/e-book-backend-ews.c:1787
+#: ../src/addressbook/e-book-backend-ews.c:1922
 #, c-format
 msgid "Downloading contacts in %s %d%% completed... "
 msgstr "%s %d%% मध्ये संपर्क डाउनोलड करणे पूर्ण झाले... "
 
-#: ../src/addressbook/e-book-backend-ews.c:2332
-#| msgid "Caching contact %d"
+#: ../src/addressbook/e-book-backend-ews.c:2535
 msgid "Syncing contacts..."
 msgstr "संपर्क सिंग करत आहे..."
 
-#: ../src/addressbook/e-book-backend-ews.c:2550
-#: ../src/configuration/e-ews-search-user.c:364
+#: ../src/addressbook/e-book-backend-ews.c:2757
+#: ../src/configuration/e-ews-search-user.c:365
 msgid "Searching..."
 msgstr "शोधत आहे..."
 
-#: ../src/calendar/e-cal-backend-ews.c:1022
-#| msgid "The backend does not support bulk modifications"
+#: ../src/calendar/e-cal-backend-ews.c:1112
 msgid "EWS does not support bulk removals"
 msgstr "EWS बल्क काढून टाकण्यास समर्थन पुरवत नाही"
 
-#: ../src/calendar/e-cal-backend-ews.c:1607
-#| msgid "The backend does not support bulk additions"
+#: ../src/calendar/e-cal-backend-ews.c:1755
 msgid "EWS does not support bulk additions"
 msgstr "EWS बल्क समावेषनकरीता समर्थन पुरवत नाही"
 
-#: ../src/calendar/e-cal-backend-ews.c:2109
-#| msgid "The backend does not support bulk modifications"
+#: ../src/calendar/e-cal-backend-ews.c:2338
 msgid "EWS does not support bulk modifications"
 msgstr "EWS बल्क् संपादनकरीता समर्थन पुरवत नाही"
 
-#: ../src/camel/camel-ews-folder.c:267
+#: ../src/camel/camel-ews-folder.c:268
 #, c-format
 msgid "Unable to open mimecontent temporary file!"
 msgstr "माइमकंटेंट टेम्पररि फाइल उघडण्यास अशक्य!"
 
-#: ../src/camel/camel-ews-folder.c:275
+#: ../src/camel/camel-ews-folder.c:276
 #, c-format
 msgid "Unable to generate parser from mimecontent!"
 msgstr "माइमकंटेंटपासून पार्सर निर्माण करण्यास अशक्य!"
 
-#: ../src/camel/camel-ews-folder.c:284
+#: ../src/camel/camel-ews-folder.c:285
 #, c-format
 msgid "Unable to parse meeting request mimecontent!"
 msgstr "सभा रिक्वेस्ट माइमटकंटेंट वाचण्यास अशक्य!"
 
-#: ../src/camel/camel-ews-folder.c:344
+#: ../src/camel/camel-ews-folder.c:346
 #, c-format
-#| msgid "Could not create cache file"
 msgid "Unable to create cache file"
 msgstr "कॅश फाइल निर्माण करण्यास अशक्य"
 
-#: ../src/camel/camel-ews-folder.c:449 ../src/camel/camel-ews-folder.c:529
+#: ../src/camel/camel-ews-folder.c:451 ../src/camel/camel-ews-folder.c:531
 #, c-format
-#| msgid "Could not create cache file"
 msgid "Unable to create cache path"
 msgstr "कॅश मार्ग निर्माण करण्यास अशक्य"
 
-#: ../src/camel/camel-ews-folder.c:539
+#: ../src/camel/camel-ews-folder.c:541
 #, c-format
-#| msgid "Failed to remove public folder"
 msgid "Failed to move message cache file"
 msgstr "संदेश कॅश फाइल हलवण्यास अपयशी"
 
-#: ../src/camel/camel-ews-folder.c:1140
+#: ../src/camel/camel-ews-folder.c:1189
 #, c-format
 msgid "Could not load summary for %s"
 msgstr "%s करीता सारांश लोड करणे अशक्य"
 
-#: ../src/camel/camel-ews-folder.c:1576
+#: ../src/camel/camel-ews-folder.c:1625
 #, c-format
-#| msgid "Cannot create MAPI folders in offline mode"
 msgid "Cant perform actions on the folder while in offline mode"
 msgstr "ऑफलाइन मोडमध्ये फोल्डरवरील कृती करण्यास अशक्य"
 
@@ -126,17 +118,14 @@ msgid "Check new messages for _Junk cont
 msgstr "जंक अंतर्भुत माहितीकरीता नवीन संदेशची तपासणी करा (_J)"
 
 #: ../src/camel/camel-ews-provider.c:59
-#| msgid "Only check for Junk messag_es in the Inbox folder"
 msgid "Only check for Junk messages in the IN_BOX folder"
 msgstr "INBOX फोल्डरमध्ये फक्त जंक संदेशकरीता तपासणी करा (_B)"
 
 #: ../src/camel/camel-ews-provider.c:61
-#| msgid "Automatically synchroni_ze account locally"
 msgid "Automatically synchroni_ze remote mail locally"
 msgstr "रिमोट मेल स्थानीयरित्या स्वयंरित्या समजुळणी करा (_z)"
 
 #: ../src/camel/camel-ews-provider.c:64
-#| msgid "Connecting to '%s'"
 msgid "Connection"
 msgstr "जोडणी"
 
@@ -148,7 +137,6 @@ msgid "Connection _timeout (in seconds) 
 msgstr "जोडणी वेळसमाप्ति (_t) (सेकंदात) %s"
 
 #: ../src/camel/camel-ews-provider.c:76
-#| msgid "Exchange MAPI server %s"
 msgid "Exchange Web Services"
 msgstr "एक्सचेंज वेब सर्व्हिसेस्"
 
@@ -162,9 +150,6 @@ msgid "NTLM"
 msgstr "NTLM"
 
 #: ../src/camel/camel-ews-provider.c:95
-#| msgid ""
-#| "This option will connect to the OpenChange server using a plaintext "
-#| "password."
 msgid ""
 "This option will connect to the Exchange server using a plaintext password "
 "with NTLM authentication."
@@ -177,9 +162,6 @@ msgid "Basic"
 msgstr "मूळ"
 
 #: ../src/camel/camel-ews-provider.c:105
-#| msgid ""
-#| "This option will connect to the OpenChange server using a plaintext "
-#| "password."
 msgid ""
 "This option will connect to the Exchange server using a plaintext password "
 "with Basic authentication."
@@ -187,162 +169,180 @@ msgstr ""
 "मूळ ओळखपटवासह प्लैनटेक्स्ट पासवर्डचा वापर करून हा पर्याय एक्सचेंज सर्व्हरशी "
 "जोडणी करेल."
 
-#: ../src/camel/camel-ews-store.c:185
+#: ../src/camel/camel-ews-store.c:192
 #, c-format
 msgid "Session has no storage path"
 msgstr "सत्रकडे स्टोरेज मार्ग नाही"
 
-#: ../src/camel/camel-ews-store.c:283
+#: ../src/camel/camel-ews-store.c:229
+#, c-format
+#| msgctxt "ForeignFolders"
+#| msgid "%s_%d"
+msgctxt "PublicFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:358
 #, c-format
 msgctxt "ForeignFolders"
 msgid "%s_%d"
 msgstr "%s_%d"
 
-#: ../src/camel/camel-ews-store.c:571
+#: ../src/camel/camel-ews-store.c:727
 msgid "Updating foreign folder structure"
 msgstr "फॉरैन फोल्डर मांडणी सुधारित करत आहे"
 
-#: ../src/camel/camel-ews-store.c:741
-msgid "Authentication password not available"
-msgstr "ओळखपटवण्यासाठी पासवर्ड अनुपलब्ध"
-
-#: ../src/camel/camel-ews-store.c:885
+#: ../src/camel/camel-ews-store.c:1169
 msgid "Query for authentication types is not supported"
 msgstr "ओळख पटवाकरीता चौकशी समर्थीत नाही"
 
-#: ../src/camel/camel-ews-store.c:937
+#: ../src/camel/camel-ews-store.c:1221
 #, c-format
-#| msgid "No public folder found"
 msgid "No such folder: %s"
 msgstr "अशा प्रकारचे फोल्डर नाही: %s"
 
-#: ../src/camel/camel-ews-store.c:1084
-msgid ""
-"Cannot list folders available for subscription of Exchange Web Services "
-"account, use 'Subscribe to folder of other user' context menu option above "
-"the account node in the folder tree instead."
-msgstr ""
-"एक्सचेंज वेब सर्व्हिसेस् खातेच्या सबस्क्रिप्शनकरीता उपलब्ध फोल्डर्सची सूची "
-"दाखवणे अशक्य, फोल्डर ट्री ऐवजी खाते नोडवरील 'इतर वापरकर्त्याच्या फोल्डरकरीता "
-"सबस्क्रिब व्हा' संदर्भ मेन्यु पर्यायचा वापर करा."
+#: ../src/camel/camel-ews-store.c:1533
+#| msgid "Cannot subscribe EWS folders in offline mode"
+msgid "Cannot list EWS public folders in offline mode"
+msgstr "ऑफलाइन मोडमध्ये EWS पब्लिक फोल्डर्स सूचीत दाखवणे अशक्य"
+
+#: ../src/camel/camel-ews-store.c:1606
+#| msgid "Cannot find folder '%s'"
+msgid "Cannot find any EWS public folders"
+msgstr "कोणतेही EWS पब्लिक फोल्डर्स शोधणे अशक्य"
 
-#: ../src/camel/camel-ews-store.c:1191
+#: ../src/camel/camel-ews-store.c:1711
 #, c-format
-#| msgid "Cannot add folder, folder already exists as '%s'"
 msgid "Cannot create folder '%s', folder already exists"
 msgstr "फोल्डर '%s' निर्माण करणे अशक्य, फोल्डर आधिपासूनच अस्तित्वात आहे"
 
-#: ../src/camel/camel-ews-store.c:1206
+#: ../src/camel/camel-ews-store.c:1726
 #, c-format
-#| msgid "Cannot rename MAPI folder '%s'. Folder does not exist"
 msgid "Parent folder %s does not exist"
 msgstr "पॅरेंट फोल्डर %s अस्तित्वात नाही"
 
-#: ../src/camel/camel-ews-store.c:1216
+#: ../src/camel/camel-ews-store.c:1736
 #, c-format
 msgid ""
 "Cannot create folder under '%s', it is used for folders of other users only"
 msgstr ""
 "'%s' अंतर्गत फोल्डर निर्माण करणे अशक्य, त्याचा वापर इतर वापरकर्त्यांच्या "
-"वापरसाठीचे केला जातो"
+"वापरसाठीचे केला "
+"जातो"
+
+#: ../src/camel/camel-ews-store.c:1746
+#, c-format
+#| msgid ""
+#| "Cannot create folder under '%s', it is used for folders of other users "
+#| "only"
+msgid "Cannot create folder under '%s', it is used for public folders only"
+msgstr ""
+"'%s' अंतर्गत फोल्डर निर्माण करणे अशक्य, त्याचा वापर इतर पब्लिक फोल्डर्सकरिताच "
+"होतो"
 
-#: ../src/camel/camel-ews-store.c:1285
+#: ../src/camel/camel-ews-store.c:1815
 #, c-format
-#| msgctxt "Permissions"
-#| msgid "Folder contact"
 msgid "Folder does not exist"
 msgstr "फोल्डर अस्तित्वात नाही"
 
-#: ../src/camel/camel-ews-store.c:1294
+#: ../src/camel/camel-ews-store.c:1824
 #, c-format
-#| msgid "Cannot rename MAPI folder '%s'. Folder does not exist"
 msgid "Cannot remove folder '%s', it is used for folders of other users only"
 msgstr ""
 "फोल्डर '%s' काढून टाकणे अशक्य, त्याचा वापर फक्त इतर वापरकर्त्यांकरीताच केला "
 "जातो"
 
-#: ../src/camel/camel-ews-store.c:1401
+#: ../src/camel/camel-ews-store.c:1834
+#, c-format
+#| msgid ""
+#| "Cannot remove folder '%s', it is used for folders of other users only"
+msgid "Cannot remove folder '%s', it is used for public folders only"
+msgstr ""
+"फोल्डर '%s' काढून टाकणे अशक्य, त्याचा वापर फक्त पब्लिक फोल्डर्सकरिताच होतो"
+
+#: ../src/camel/camel-ews-store.c:1942
 #, c-format
-#| msgid "Folder '%s' not found"
 msgid "Folder %s does not exist"
 msgstr "फोल्डर %s अस्तित्वात नाही"
 
-#: ../src/camel/camel-ews-store.c:1411
+#: ../src/camel/camel-ews-store.c:1952
 #, c-format
 msgid "No change key record for folder %s"
 msgstr "फोल्डर %s करीता कि रेकॉर्डमध्ये बदल आढळले नाही"
 
-#: ../src/camel/camel-ews-store.c:1453
+#: ../src/camel/camel-ews-store.c:1994
 #, c-format
 msgid "Cannot both rename and move a folder at the same time"
 msgstr "एकाच वेळी फोल्डरचे दोंही पुनःनामांकन व स्थानांतरन"
 
-#: ../src/camel/camel-ews-store.c:1489
+#: ../src/camel/camel-ews-store.c:2030
 #, c-format
-#| msgid "Cannot find folder in a local cache"
 msgid "Cannot find folder ID for parent folder %s"
 msgstr "मुख्य फोल्डर %s करीता फोल्डर ID शोधणे अशक्य"
 
-#: ../src/camel/camel-ews-store.c:1539 ../src/camel/camel-ews-transport.c:69
+#: ../src/camel/camel-ews-store.c:2080 ../src/camel/camel-ews-transport.c:69
 #, c-format
-#| msgid "Exchange MAPI server %s"
 msgid "Exchange server %s"
 msgstr "एक्चेंज सर्व्हर %s"
 
-#: ../src/camel/camel-ews-store.c:1542
+#: ../src/camel/camel-ews-store.c:2083
 #, c-format
-#| msgid "Exchange MAPI service for %s on %s"
 msgid "Exchange service for %s on %s"
 msgstr "%s करीता %s वरील एक्सचेंज सर्व्हिस"
 
-#: ../src/camel/camel-ews-store.c:1586
+#: ../src/camel/camel-ews-store.c:2127
 #, c-format
-#| msgid "Could not create cache file"
 msgid "Could not locate Trash folder"
 msgstr "ट्रॅश फोल्डर शोधणे अशक्य"
 
-#: ../src/camel/camel-ews-store.c:1621
+#: ../src/camel/camel-ews-store.c:2187
 #, c-format
-#| msgid "Could not create cache file"
 msgid "Could not locate Junk folder"
 msgstr "जंक फोल्डर शोधणे अशक्य"
 
-#: ../src/camel/camel-ews-store.c:1699
-#| msgid "Cannot subscribe MAPI folders in offline mode"
+#: ../src/camel/camel-ews-store.c:2377
 msgid "Cannot subscribe EWS folders in offline mode"
 msgstr "ऑफलाइन मोडमध्ये EWS फोल्डर्सशी सबस्क्राइब होणे अशक्य"
 
-#: ../src/camel/camel-ews-store.c:1721
-#| msgid "Cannot unsubscribe MAPI folders in offline mode"
+#: ../src/camel/camel-ews-store.c:2400
+#, c-format
+#| msgid "Cannot create folder '%s', folder already exists"
+msgid "Cannot subscribe folder '%s', no public folder available"
+msgstr "फोल्डर '%s' निर्माण करणे अशक्य, पब्लिक फोल्डर अनुपलब्ध"
+
+#: ../src/camel/camel-ews-store.c:2410
+#, c-format
+#| msgid "Cannot subscribe EWS folders in offline mode"
+msgid "Cannot subscribe folder '%s', folder not found"
+msgstr "फोल्डर '%s' करिता सबस्क्राइब अशक्य, फोल्डर आढळले नाही"
+
+#: ../src/camel/camel-ews-store.c:2501
 msgid "Cannot unsubscribe EWS folders in offline mode"
 msgstr "ऑफलाइन मोडमध्ये EWS फोल्डर्सला सबस्क्राइब करणे अशक्य"
 
-#: ../src/camel/camel-ews-store.c:1794
+#: ../src/camel/camel-ews-store.c:2618
 #, c-format
 msgid "You must be working online to complete this operation"
 msgstr "हे कार्य पूर्ण करण्यासाठी ऑनलाइन कार्य करणे आवश्यक"
 
 #: ../src/camel/camel-ews-transport.c:72
 #, c-format
-#| msgid "Exchange MAPI server %s"
 msgid "Exchange mail delivery via %s"
 msgstr "%s तर्फे मेल डिलिवरि अदलाबदल करा"
 
-#: ../src/camel/camel-ews-transport.c:120
-#| msgid "Cannot append message to folder '%s'"
+#: ../src/camel/camel-ews-transport.c:119
 msgid "Cannot send message with no From address"
 msgstr "विना प्रेषक पत्तासह संदेश पाठवणे अशक्य"
 
-#: ../src/camel/camel-ews-transport.c:126
+#: ../src/camel/camel-ews-transport.c:125
 msgid "Exchange server cannot send message with multiple From addresses"
 msgstr "एकापेक्षाजास्त प्रेषक पत्तासह एक्सचेंज सर्व्हर संदेश पाठवण्यास अशक्य"
 
-#: ../src/camel/camel-ews-transport.c:137
-#| msgid "Failed to create item on a server"
+#: ../src/camel/camel-ews-transport.c:136
 msgid "Failed to read From address"
 msgstr "पत्तापासून वाचण्यास अपयशी"
 
-#: ../src/camel/camel-ews-transport.c:149
+#: ../src/camel/camel-ews-transport.c:148
 #, c-format
 msgid ""
 "Exchange server cannot send message as '%s', when the account was configured "
@@ -351,71 +351,65 @@ msgstr ""
 "पत्ता '%2$s' करीता खाते संरचीत केल्यास, एक्सचेंज सर्व्हर '%1$s' प्रमाणे संदेश "
 "पाठवू शकत नाही"
 
-#: ../src/camel/camel-ews-transport.c:163
+#: ../src/camel/camel-ews-transport.c:162
 #, c-format
 msgid "Service not connected"
 msgstr "सर्व्हिस खंडीत आहे"
 
-#: ../src/collection/e-ews-backend.c:391
+#: ../src/collection/e-ews-backend.c:428
 #: ../src/configuration/e-mail-config-ews-gal.c:274
 msgid "Global Address List"
 msgstr "ग्लोबल पत्ता सूची"
 
-#: ../src/collection/e-ews-backend.c:776
+#: ../src/collection/e-ews-backend.c:813
 #, c-format
 msgid "Could not determine a suitable folder class for a new folder named '%s'"
 msgstr "'%s' नावाच्या नवीन फोल्डरकरीता योग्य फोल्डर क्लास ओळखणे अशक्य"
 
-#: ../src/collection/e-ews-backend.c:867
+#: ../src/collection/e-ews-backend.c:902
 #, c-format
-#| msgid "Data source '%s' does not represent a MAPI folder"
 msgid "Data source '%s' does not represent an Exchange Web Services folder"
 msgstr "डाटा सोअर्स् '%s' एक्सचेंज वेब सर्व्हिसेस् फोल्डर प्रस्तुत करत नाही"
 
-#: ../src/configuration/e-ews-config-utils.c:515
+#: ../src/configuration/e-ews-config-utils.c:516
 #, c-format
 msgid "Cannot edit permissions of folder '%s', choose other folder."
 msgstr "फोल्डर '%s' ची परवानगी संपादित करणे अशक्य, इतर फोल्डर नीवडा."
 
-#: ../src/configuration/e-ews-config-utils.c:593
+#: ../src/configuration/e-ews-config-utils.c:594
 msgid "Subscribe to folder of other user..."
 msgstr "इतर वापरकर्त्याच्या फोल्डरकरीता सबस्क्राइब व्हा..."
 
-#: ../src/configuration/e-ews-config-utils.c:602
-#: ../src/configuration/e-ews-config-utils.c:883
-#: ../src/configuration/e-ews-config-utils.c:914
-#: ../src/configuration/e-ews-config-utils.c:945
-#: ../src/configuration/e-ews-config-utils.c:976
+#: ../src/configuration/e-ews-config-utils.c:603
+#: ../src/configuration/e-ews-config-utils.c:884
+#: ../src/configuration/e-ews-config-utils.c:915
+#: ../src/configuration/e-ews-config-utils.c:946
+#: ../src/configuration/e-ews-config-utils.c:977
 msgid "Permissions..."
 msgstr "परवानगी..."
 
-#: ../src/configuration/e-ews-config-utils.c:604
-#| msgid "Edit MAPI folder permissions"
+#: ../src/configuration/e-ews-config-utils.c:605
 msgid "Edit EWS folder permissions"
 msgstr "EWS फोल्डर परवानगी संपादित करा"
 
-#: ../src/configuration/e-ews-config-utils.c:885
-#| msgid "Edit MAPI calendar permissions"
+#: ../src/configuration/e-ews-config-utils.c:886
 msgid "Edit EWS calendar permissions"
 msgstr "EWS दिनदर्शिका परवानगी संपादित करा"
 
-#: ../src/configuration/e-ews-config-utils.c:916
-#| msgid "Edit MAPI tasks permissions"
+#: ../src/configuration/e-ews-config-utils.c:917
 msgid "Edit EWS tasks permissions"
 msgstr "EWS कार्ये परवानगी संपादित करा"
 
-#: ../src/configuration/e-ews-config-utils.c:947
-#| msgid "Edit MAPI memos permissions"
+#: ../src/configuration/e-ews-config-utils.c:948
 msgid "Edit EWS memos permissions"
 msgstr "EWS मेमोज परवानगी संपादित करा"
 
-#: ../src/configuration/e-ews-config-utils.c:978
-#| msgid "Edit MAPI contacts permissions"
+#: ../src/configuration/e-ews-config-utils.c:979
 msgid "Edit EWS contacts permissions"
 msgstr "EWS संपर्क परवानगी संपादित करा"
 
 #: ../src/configuration/e-ews-edit-folder-permissions.c:87
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:504
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:499
 msgctxt "PermissionsLevel"
 msgid "None"
 msgstr "काहिच नाही"
@@ -471,7 +465,7 @@ msgid "Free/Busy time, subject, location
 msgstr "मोकळे/व्यस्त वेळ, विषय, ठिकाण"
 
 #: ../src/configuration/e-ews-edit-folder-permissions.c:143
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:525
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:520
 msgctxt "PermissionsLevel"
 msgid "Custom"
 msgstr "पसंतीचे"
@@ -480,152 +474,148 @@ msgstr "पसंतीचे"
 msgid "Writing folder permissions, please wait..."
 msgstr "फोल्डर परवानगी लिहित आहे, कृपया प्रतिक्षा करा..."
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:759
+#: ../src/configuration/e-ews-edit-folder-permissions.c:777
 msgctxt "User"
 msgid "Anonymous"
 msgstr "निनावी"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:762
+#: ../src/configuration/e-ews-edit-folder-permissions.c:780
 msgctxt "User"
 msgid "Default"
 msgstr "पूर्वनिर्धारित"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:768
+#: ../src/configuration/e-ews-edit-folder-permissions.c:786
 msgctxt "User"
 msgid "Unknown"
 msgstr "अपरिचीत"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:849
-#: ../src/configuration/e-ews-search-user.c:430
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:1080
+#: ../src/configuration/e-ews-edit-folder-permissions.c:867
+#: ../src/configuration/e-ews-search-user.c:431
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1075
 msgid "Name"
 msgstr "नाव"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:855
+#: ../src/configuration/e-ews-edit-folder-permissions.c:873
 msgid "Permission level"
 msgstr "परवानगी स्तर"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:907
-#| msgid "Edit MAPI folder permissions..."
+#: ../src/configuration/e-ews-edit-folder-permissions.c:925
 msgid "Edit EWS folder permissions..."
 msgstr "EWS फोल्डर परवानगी संपादित करा..."
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:932
+#: ../src/configuration/e-ews-edit-folder-permissions.c:950
 #: ../src/configuration/e-ews-subscribe-foreign-folder.c:635
 msgid "Account:"
 msgstr "खाते:"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:960
+#: ../src/configuration/e-ews-edit-folder-permissions.c:978
 msgid "Folder name:"
 msgstr "फोल्डर नाव:"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:983
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1001
 msgid "Folder ID:"
 msgstr "फोल्डर ID:"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1047
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1065
 msgid "Permissions"
 msgstr "परवानगी"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1069
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1087
 msgid "Permi_ssion level:"
 msgstr "परवानगी स्तर (_s):"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1103
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1121
 msgctxt "Permissions"
 msgid "Read"
 msgstr "वाचा"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1115
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1182
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1133
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1200
 msgctxt "Permissions"
 msgid "None"
 msgstr "काहिच नाही"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1121
-#| msgctxt "Permissions"
-#| msgid "Simple Free/Busy"
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1139
 msgctxt "Permissions"
 msgid "Free/Busy time"
 msgstr "मोकळे/व्यस्थ वेळ"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1126
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1144
 msgctxt "Permissions"
 msgid "Free/Busy time, subject, location"
 msgstr "मोकळे/व्यस्थ वेळ, विषय, ठिकाण"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1132
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1150
 msgctxt "Permissions"
 msgid "Full Details"
 msgstr "संपूर्ण तपशील"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1138
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1156
 msgctxt "Permissions"
 msgid "Write"
 msgstr "राइट"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1150
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1168
 msgctxt "Permissions"
 msgid "Create items"
 msgstr "घटक निर्माण करा"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1154
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1172
 msgctxt "Permissions"
 msgid "Create subfolders"
 msgstr "उपफोल्डर्स् निर्माण करा"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1158
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1176
 msgctxt "Permissions"
 msgid "Edit own"
 msgstr "स्वतः संपादित करा"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1162
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1180
 msgctxt "Permissions"
 msgid "Edit all"
 msgstr "सर्व संपादित करा"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1170
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1188
 msgctxt "Permissions"
 msgid "Delete items"
 msgstr "घटकांना नष्ट करा"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1187
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1205
 msgctxt "Permissions"
 msgid "Own"
 msgstr "स्वतः"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1192
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1210
 msgctxt "Permissions"
 msgid "All"
 msgstr "सर्व"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1198
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1216
 msgctxt "Permissions"
 msgid "Other"
 msgstr "इतर"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1210
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1228
 msgctxt "Permissions"
 msgid "Folder owner"
 msgstr "फोल्डरची मालकी"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1214
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1232
 msgctxt "Permissions"
 msgid "Folder contact"
 msgstr "फोल्डर संपर्क"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1218
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1236
 msgctxt "Permissions"
 msgid "Folder visible"
 msgstr "फोल्डर दृष्यास्पद"
 
-#: ../src/configuration/e-ews-edit-folder-permissions.c:1291
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1309
 msgid "Reading folder permissions, please wait..."
 msgstr "फोल्डर परवानगी लिहित आहे, कृपया प्रतिक्षा करा..."
 
 #: ../src/configuration/e-ews-search-user.c:208
 #, c-format
-#| msgid "No users found"
 msgid "No users found, only one contact"
 msgid_plural "No users found, only %d contacts"
 msgstr[0] "वापरकर्ते आढळले नाही, फक्त एक संपर्क आढळला"
@@ -644,8 +634,6 @@ msgstr[1] "%d वापरकर्त
 
 #: ../src/configuration/e-ews-search-user.c:223
 #, c-format
-#| msgid "Found %d user, but showing only first %d"
-#| msgid_plural "Found %d users, but showing only first %d"
 msgid "Found more than 100 users, but showing only first %d"
 msgid_plural "Found more than 100 users, but showing only first %d"
 msgstr[0] ""
@@ -653,26 +641,25 @@ msgstr[0] ""
 msgstr[1] ""
 "100 पेक्षा जास्त वापरकर्ते आढळले, परंतु फक्त सुरूवातीचे %d दाखवत आहे"
 
-#: ../src/configuration/e-ews-search-user.c:356
-#: ../src/configuration/e-ews-search-user.c:539
+#: ../src/configuration/e-ews-search-user.c:357
+#: ../src/configuration/e-ews-search-user.c:540
 msgid "Search for a user"
 msgstr "वापकर्ताकरीता शोधा"
 
-#: ../src/configuration/e-ews-search-user.c:436
+#: ../src/configuration/e-ews-search-user.c:437
 msgid "E-mail"
 msgstr "ईमेल"
 
-#: ../src/configuration/e-ews-search-user.c:473
-#| msgid "Choose MAPI user..."
+#: ../src/configuration/e-ews-search-user.c:474
 msgid "Choose EWS user..."
 msgstr "EWS वापरकर्ता पसंत करा..."
 
-#: ../src/configuration/e-ews-search-user.c:496
+#: ../src/configuration/e-ews-search-user.c:497
 msgid "_Search:"
 msgstr "शोध (_S):"
 
-#: ../src/configuration/e-ews-subscribe-foreign-folder.c:98
-#: ../src/server/e-ews-folder.c:600
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:97
+#: ../src/server/e-ews-folder.c:632
 #, c-format
 msgid "Cannot add folder, folder already exists as '%s'"
 msgstr ""
@@ -681,31 +668,28 @@ msgstr ""
 #. Translators: The '%s' is replaced with user name, to whom the foreign mailbox belongs.
 #. * Example result: "Mailbox - John Smith"
 #.
-#: ../src/configuration/e-ews-subscribe-foreign-folder.c:108
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:107
 #, c-format
 msgctxt "ForeignFolder"
 msgid "Mailbox - %s"
 msgstr "मेलबॉक्स् - %s"
 
-#: ../src/configuration/e-ews-subscribe-foreign-folder.c:273
-#| msgid "Folder list is not available in offline mode"
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:272
 msgid "Cannot test foreign folder availability while in offline mode"
 msgstr "ऑफलाइन मोडमध्ये असताना फॉरेंन फोल्डर उपलब्धता चाचणी अशक्य"
 
-#: ../src/configuration/e-ews-subscribe-foreign-folder.c:298
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:297
 #, c-format
-#| msgid "User name '%s' not found"
 msgid "User '%s' was not found on the server"
 msgstr "सर्व्हरवर वापरकर्ता '%s' आढळला नाही"
 
-#: ../src/configuration/e-ews-subscribe-foreign-folder.c:334
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:333
 #, c-format
-#| msgid "User name '%s' is ambiguous"
 msgid "User name '%s' is ambiguous, specify it more precisely, please"
 msgstr ""
 "वापरकर्ता नाव '%s' गोंधळास्पद आहे, त्यास कृपया, व्यवस्थीत निर्देशीत करा"
 
-#: ../src/configuration/e-ews-subscribe-foreign-folder.c:356
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:355
 #, c-format
 msgid ""
 "Folder '%s' not found. Either it does not exist or you do not have "
@@ -714,7 +698,7 @@ msgstr ""
 "फोल्डर '%s' आढळले नाही. एकतर अस्तित्वात नाही किंवा तुमच्याकडे प्रवेशकरीता "
 "परवानगी नाही."
 
-#: ../src/configuration/e-ews-subscribe-foreign-folder.c:374
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:373
 msgid "Cannot add folder, cannot determine folder's type"
 msgstr "फोल्डर समाविष्ट करणे अशक्य, फोल्डर प्रकार ओळखणे अशक्य"
 
@@ -723,39 +707,39 @@ msgstr "फोल्डर समाव
 #. * the second '%s' is replaced with folder name.
 #. * Example result: "John Smith - Calendar"
 #.
-#: ../src/configuration/e-ews-subscribe-foreign-folder.c:419
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:418
 #, c-format
 msgctxt "ForeignFolder"
 msgid "%s - %s"
 msgstr "%s - %s"
 
 #. convert well-known names to their non-localized form
-#: ../src/configuration/e-ews-subscribe-foreign-folder.c:513
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:512
 #: ../src/configuration/e-ews-subscribe-foreign-folder.c:720
 msgid "Inbox"
 msgstr "इंबॉक्स्"
 
-#: ../src/configuration/e-ews-subscribe-foreign-folder.c:515
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:514
 #: ../src/configuration/e-ews-subscribe-foreign-folder.c:721
 msgid "Contacts"
 msgstr "संपर्क"
 
-#: ../src/configuration/e-ews-subscribe-foreign-folder.c:517
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:516
 #: ../src/configuration/e-ews-subscribe-foreign-folder.c:722
 msgid "Calendar"
 msgstr "दिनदर्शिका"
 
-#: ../src/configuration/e-ews-subscribe-foreign-folder.c:519
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:518
 #: ../src/configuration/e-ews-subscribe-foreign-folder.c:723
 msgid "Memos"
 msgstr "मेमोज्"
 
-#: ../src/configuration/e-ews-subscribe-foreign-folder.c:521
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:520
 #: ../src/configuration/e-ews-subscribe-foreign-folder.c:724
 msgid "Tasks"
 msgstr "कार्ये"
 
-#: ../src/configuration/e-ews-subscribe-foreign-folder.c:538
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:537
 #, c-format
 msgid "Testing availability of folder '%s' of user '%s', please wait..."
 msgstr ""
@@ -763,7 +747,6 @@ msgstr ""
 "करा..."
 
 #: ../src/configuration/e-ews-subscribe-foreign-folder.c:614
-#| msgid "Subscribe to folder of other user..."
 msgid "Subscribe to folder of other EWS user..."
 msgstr "इतर EWS वापरकर्त्याच्या फोल्डरकरीता सबस्क्राइब व्हा..."
 
@@ -784,16 +767,14 @@ msgid "_Folder name:"
 msgstr "फोल्डर नाव (_F):"
 
 #: ../src/configuration/e-ews-subscribe-foreign-folder.c:733
-#| msgctxt "Permissions"
-#| msgid "Create subfolders"
 msgid "Include _subfolders"
 msgstr "सबफोल्डर्स् समाविष्ट करा (_s)"
 
-#: ../src/configuration/e-mail-config-ews-autodiscover.c:129
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:140
 msgid "Querying Autodiscover service"
 msgstr "स्वयंडिस्कवर सर्व्हिसची चौकशी करत आहे"
 
-#: ../src/configuration/e-mail-config-ews-autodiscover.c:212
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:231
 msgid "Fetch _URL"
 msgstr "फेच् URL (_U)"
 
@@ -818,89 +799,79 @@ msgid "Open _Mailbox of other user"
 msgstr "इतर वापरकर्त्याचा मेलबॉक्स उघडा (_M)"
 
 #: ../src/configuration/e-mail-config-ews-backend.c:239
-#| msgid "Searching..."
 msgid "S_earch..."
 msgstr "शोधा (_e)..."
 
 #: ../src/configuration/e-mail-config-ews-backend.c:250
-#| msgid "_Authenticate"
 msgid "Authentication"
 msgstr "ओळखपटवा"
 
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:505
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:500
 msgctxt "PermissionsLevel"
 msgid "Reviewer (can read items)"
 msgstr "पुनरावलोकनकर्ता (घटकांचे वाचन शक्य)"
 
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:506
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:501
 msgctxt "PermissionsLevel"
 msgid "Author (can read and create items)"
 msgstr "लेखक (घटकांचे वाचन व निर्माण शक्य)"
 
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:507
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:502
 msgctxt "PermissionsLevel"
 msgid "Editor (can read, create and modify items)"
 msgstr "संपादक (घटकांचे वाचन, निर्माण व संपादन शक्य)"
 
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:610
-#| msgid "Permissions"
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:605
 msgid "Delegate permissions"
 msgstr "परवानगी द्या"
 
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:628
-#| msgid "Calendar"
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:623
 msgid "C_alendar"
 msgstr "दिनदर्शिका (_a)"
 
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:631
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:626
 msgid "_Delegate receives copies of meeting-related messages sent to me"
 msgstr "डेलिगेटकडे मला पाठवलेले सभा-संदर्भात संदेश प्राप्त झाले (_D)"
 
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:636
-#| msgid "Tasks"
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:631
 msgid "_Tasks"
 msgstr "कार्ये (_T)"
 
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:639
-#| msgid "Inbox"
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:634
 msgid "_Inbox"
 msgstr "इंबॉक्स (_I)"
 
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:642
-#| msgid "Contacts"
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:637
 msgid "C_ontacts"
 msgstr "संपर्क (_o)"
 
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:645
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:640
 msgid "_Notes"
 msgstr "टिपण्णी (_N)"
 
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:648
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:643
 msgid "_Journal"
 msgstr "जर्नल (_J)"
 
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:651
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:646
 #, c-format
 msgid "Delegate '%s' has the following permissions"
 msgstr "डेलिगेट '%s' कडे खालील परवानगी आहे"
 
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:669
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:664
 msgid "Delegate can see my _private items"
 msgstr "डिलिगेट माझे व्यक्तिगत घटके पाहू शकतात (_p)"
 
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:992
-#| msgid "Writing folder permissions, please wait..."
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:987
 msgid "Retrieving current user permissions, please wait..."
 msgstr "सध्याची वापरकर्ता परवागनी प्राप्त करत आहे, कृपया थांबा..."
 
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:1113
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:1643
-#| msgctxt "Permissions"
-#| msgid "Delete items"
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1108
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1638
 msgid "Delegates"
 msgstr "डेलिगेट्स्"
 
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:1137
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1132
 msgid ""
 "Delegates can send items on your behalf, including creating and responding "
 "to meeting requests. If you want to grant folder permissions without giving "
@@ -908,11 +879,12 @@ msgid ""
 "folder, click Permissions and change the options there."
 msgstr ""
 "डेलिगेट्स् तुमच्याकरीता घटके पाठवू शकतात, ज्यामध्ये सभा विनंतीचे निर्माण व "
-"प्रतिसाद समाविष्टीत आहे. "
-"send-on-behalf-of परवानगीविना फोल्डर परवागनी द्यायची असल्यास, हे संवाद पटल "
-"बंद करा, फोल्डरवर उजवी-क्लिक द्या, परवानगी क्लिक करा व पर्याय बदला."
+"प्रतिसाद "
+"समाविष्टीत आहे. send-on-behalf-of परवानगीविना फोल्डर परवागनी द्यायची असल्यास, "
+"हे "
+"संवाद पटल बंद करा, फोल्डरवर उजवी-क्लिक द्या, परवानगी क्लिक करा व पर्याय बदला."
 
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:1186
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1181
 msgid ""
 "Deliver meeting requests addressed to me and responses to meeting requests "
 "where I am the organizer to:"
@@ -921,7 +893,7 @@ msgstr ""
 "where I am the organizer to:"
 
 #. new-line break, because GtkRadioButton doesn't allow wrapping of the inner label
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:1195
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1190
 msgid ""
 "My delegates only, but _send a copy of meeting requests\n"
 "and responses to me (recommended)"
@@ -929,15 +901,15 @@ msgstr ""
 "फक्त माझे डेलिगेट संदेश, परंतु सभा विनंती व प्रतिसादचे मला प्रत पाठवा\n"
 "(शिफारसीय) (_s)"
 
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:1202
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1197
 msgid "My d_elegates only"
 msgstr "फक्त माझे डेलिगेट्स् (_e)"
 
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:1209
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1204
 msgid "My delegates a_nd me"
 msgstr "माझे डेलिगेट्स् व मी (_n)"
 
-#: ../src/configuration/e-mail-config-ews-delegates-page.c:1718
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1713
 msgid "Retrieving \"Delegates\" settings"
 msgstr "\"डेलिगेट्स्\" सेटिंग्स् प्राप्त करत आहे"
 
@@ -950,7 +922,6 @@ msgid "Cache o_ffline address book"
 msgstr "कॅश ऑफलाइन पत्ता पुस्तिका (_f)"
 
 #: ../src/configuration/e-mail-config-ews-gal.c:327
-#| msgid "Global Address List"
 msgid "Select ad_dress list:"
 msgstr "पत्ता सूची पसंत करा (_d):"
 
@@ -958,68 +929,69 @@ msgstr "पत्ता सूची प
 msgid "Fetch List"
 msgstr "फेच् सूची"
 
-#: ../src/configuration/e-mail-config-ews-ooo-page.c:449
-#: ../src/configuration/e-mail-config-ews-ooo-page.c:928
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:444
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:923
 msgid "Out of Office"
 msgstr "ऑट ऑफ ऑफिस"
 
-#: ../src/configuration/e-mail-config-ews-ooo-page.c:465
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:460
 msgid ""
 "The messages specified below will be automatically sent to each internal and "
 "external person who sends a mail to you."
 msgstr ""
 "खालील निर्देशीत संदेश स्वयंरित्या आंतरिक व बाहेरिल व्यक्तिकरीता पाठवले जाईल, "
-"ज्याचे तुम्हाला मेल प्राप्त होते."
+"ज्याचे तुम्हाला "
+"मेल प्राप्त होते."
 
-#: ../src/configuration/e-mail-config-ews-ooo-page.c:473
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:468
 msgid "Do _not send Out of Office replies"
 msgstr "ऑट ऑफ ऑफिस प्रतिसाद पाठवू नका (_n)"
 
-#: ../src/configuration/e-mail-config-ews-ooo-page.c:481
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:476
 msgid "_Send Out of Office replies"
 msgstr "आउट ऑफ ऑफिस प्रतिसाद पाठवू नका (_S)"
 
-#: ../src/configuration/e-mail-config-ews-ooo-page.c:489
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:484
 msgid "Send Out of Office replies only _during this time period:"
 msgstr "फक्त ह्या कालावधीतच आउट ऑफ ऑफिस प्रतिसाद पाठवू नका (_d):"
 
-#: ../src/configuration/e-mail-config-ews-ooo-page.c:509
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:504
 msgid "_From:"
 msgstr "पासून (_F):"
 
-#: ../src/configuration/e-mail-config-ews-ooo-page.c:534
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:529
 msgid "_To:"
 msgstr "प्रति (_T):"
 
-#: ../src/configuration/e-mail-config-ews-ooo-page.c:559
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:554
 msgid "I_nternal:"
 msgstr "आंतरिक (_n):"
 
-#: ../src/configuration/e-mail-config-ews-ooo-page.c:568
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:563
 msgid "Message to be sent within the organization"
 msgstr "संस्था अंतर्गत संदेश पाठवा"
 
-#: ../src/configuration/e-mail-config-ews-ooo-page.c:595
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:590
 msgid "E_xternal:"
 msgstr "बाहेरिल (_x):"
 
-#: ../src/configuration/e-mail-config-ews-ooo-page.c:603
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:598
 msgid "Message to be sent outside the organization"
 msgstr "संस्थेच्या बाहेर पाठवण्याजोजी संदेश"
 
-#: ../src/configuration/e-mail-config-ews-ooo-page.c:613
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:608
 msgid "Do not reply to senders outside the organization"
 msgstr "संस्थेच्या बाहेरील प्रेषकांना प्रतिसाद पाठवू नका"
 
-#: ../src/configuration/e-mail-config-ews-ooo-page.c:616
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:611
 msgid "Reply only to known senders outside the organization"
 msgstr "फक्त संस्थेच्या बाहेरिल प्रेषकांनाच प्रतिसाद पाठवा"
 
-#: ../src/configuration/e-mail-config-ews-ooo-page.c:619
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:614
 msgid "Reply to any sender outside the organization"
 msgstr "संस्थेच्या बाहेरिल कोणत्याहि प्रेषकाला प्रतिसाद पाठवा"
 
-#: ../src/configuration/e-mail-config-ews-ooo-page.c:1004
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:999
 msgid "Retrieving \"Out of Office\" settings"
 msgstr "\"आउट ऑफ ऑफिस\" सेटिंग्स् प्राप्त करत आहे"
 
@@ -1032,7 +1004,6 @@ msgid "The reported error was &quot;{0}&
 msgstr "&quot;{0}&quot; त्रुटी कळवली."
 
 #: ../src/configuration/module-ews-configuration.error.xml.h:3
-#| msgid "Failed to close folder: %s"
 msgid "Failed to locate offline address books."
 msgstr "ऑफलाइन पत्ता पुस्तिका शोधण्यास अपयशी."
 
@@ -1044,86 +1015,94 @@ msgstr "&quot;आउट ऑफ ऑफि
 msgid "Failed to retrieve &quot;Delegates&quot; settings."
 msgstr "&quot;डेलिगेट्स्&quot; सेटिंग्स् प्राप्त करण्यास अपयशी."
 
-#: ../src/server/e-ews-connection.c:493
+#: ../src/server/e-ews-connection.c:494
 msgid "Operation Cancelled"
 msgstr "कार्य रद्द केले"
 
-#: ../src/server/e-ews-connection.c:562
+#: ../src/server/e-ews-connection.c:563
 msgid "Authentication failed"
 msgstr "ओळख पटवणे अपयशी"
 
-#: ../src/server/e-ews-connection.c:573
+#: ../src/server/e-ews-connection.c:574
 #, c-format
 msgid "No response: %s"
 msgstr "प्रतिसाद नाही: %s"
 
-#: ../src/server/e-ews-connection.c:1877
+#: ../src/server/e-ews-connection.c:1912
 #, c-format
 msgid "Failed to parse autodiscover response XML"
 msgstr "ऑटोडिस्कवर रेसपाँस् XML वाचण्यास अपयशी"
 
-#: ../src/server/e-ews-connection.c:1884
+#: ../src/server/e-ews-connection.c:1919
 #, c-format
 msgid "Failed to find <Autodiscover> element"
 msgstr "<Autodiscover> एलिमेंट शोधण्यास अपयशी"
 
-#: ../src/server/e-ews-connection.c:1895
+#: ../src/server/e-ews-connection.c:1930
 #, c-format
 msgid "Failed to find <Response> element"
 msgstr "<Response> एलिमेंट शोधण्यास अपयशी"
 
-#: ../src/server/e-ews-connection.c:1906
+#: ../src/server/e-ews-connection.c:1941
 #, c-format
-#| msgid "Failed to count server contacts"
 msgid "Failed to find <Account> element"
 msgstr "<Account> एलिमेंट शोधण्यास अपयशी"
 
-#: ../src/server/e-ews-connection.c:1925
+#: ../src/server/e-ews-connection.c:1960
 #, c-format
 msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
 msgstr "autodiscover प्रतिसादमध्ये <ASUrl> व <OABUrl> शोधण्यास अपयशी"
 
-#: ../src/server/e-ews-connection.c:2007
+#: ../src/server/e-ews-connection.c:2042
 msgid "URL cannot be NULL"
 msgstr "URL  NULL असणे अशक्य"
 
-#: ../src/server/e-ews-connection.c:2015
+#: ../src/server/e-ews-connection.c:2050
 #, c-format
 msgid "URL '%s' is not valid"
 msgstr "URL '%s' वैध नाही"
 
-#: ../src/server/e-ews-connection.c:2117
+#: ../src/server/e-ews-connection.c:2152
 msgid "Email address is missing a domain part"
 msgstr "ईमेल पत्तामध्ये डोमेन भाग आढळले नाही"
 
-#: ../src/server/e-ews-connection.c:2429
-#| msgid "Failed to transfer objects: %s"
+#: ../src/server/e-ews-connection.c:2479
 msgid "Failed to parse oab XML"
 msgstr "oab XML वाचण्यास अपयशी"
 
-#: ../src/server/e-ews-connection.c:2437
-#| msgid "Failed to fetch GAL entries"
+#: ../src/server/e-ews-connection.c:2487
 msgid "Failed to find <OAB> element\n"
 msgstr "<OAB> एलिमेंट शोधण्यास अपयशी\n"
 
-#: ../src/server/e-ews-connection.c:3594
-#| msgid "No users found"
+#: ../src/server/e-ews-connection.c:3673
 msgid "No items found"
 msgstr "घटके आढळले नाही"
 
-#: ../src/server/e-ews-folder.c:554
+#: ../src/server/e-ews-folder.c:587
 msgid "Cannot add folder, unsupported folder type"
 msgstr "फोल्डर समाविष्ट करणे अशक्य, असमर्थीत फोल्डर प्रकार"
 
-#: ../src/server/e-ews-folder.c:559
+#: ../src/server/e-ews-folder.c:592
 msgid "Cannot add folder, master source not found"
 msgstr "फोल्डर समाविष्ट करणे अशक्य, मास्टर सोअर्स् आढळले नाही"
 
-#: ../src/utils/ews-camel-common.c:176
+#: ../src/utils/ews-camel-common.c:221
 #, c-format
 msgid "CreateItem call failed to return ID for new message"
 msgstr "नवीन संदेशकरीता CreateItem कॉल रिटर्न ID पुरवण्यास अपयशी"
 
+#~ msgid "Authentication password not available"
+#~ msgstr "ओळखपटवण्यासाठी पासवर्ड अनुपलब्ध"
+
+#~ msgid ""
+#~ "Cannot list folders available for subscription of Exchange Web Services "
+#~ "account, use 'Subscribe to folder of other user' context menu option "
+#~ "above the account node in the folder tree instead."
+#~ msgstr ""
+#~ "एक्सचेंज वेब सर्व्हिसेस् खातेच्या सबस्क्रिप्शनकरीता उपलब्ध फोल्डर्सची सूची दाखवणे अशक्य, "
+#~ "फोल्डर ट्री ऐवजी खाते नोडवरील 'इतर वापरकर्त्याच्या फोल्डरकरीता सबस्क्रिब व्हा' संदर्भ "
+#~ "मेन्यु पर्यायचा वापर करा."
+
 #~ msgid "Searching"
 #~ msgstr "शोधत आहे"
 
@@ -1245,9 +1224,6 @@ msgstr "नवीन संदेशक
 #~ msgid "MAPI folders can be created only within mailbox of the logged user"
 #~ msgstr "प्रवेश केलेल्या वापरकर्त्याच्या मेलबॉक्समध्ये MAPI फोल्डर्सचे निर्माण करा"
 
-#~ msgid "Cannot find folder '%s'"
-#~ msgstr "फोल्डर '%s' शोधणे अशक्य"
-
 #~ msgid "Cannot create folder '%s': %s"
 #~ msgstr "'%s': %s निर्माण करणे अशक्य"
 
diff -up evolution-ews-gnome-3-0.gitcc16df2/po/te.po.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/po/te.po
--- evolution-ews-gnome-3-0.gitcc16df2/po/te.po.sync-with-3.8.4	2013-07-24 07:30:27.314435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/po/te.po	2013-07-24 07:30:27.314435567 +0200
@@ -0,0 +1,1079 @@
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+#
+# Krishnababu Krothapalli <kkrothap@redhat.com>, 2013.
+msgid ""
+msgstr ""
+"Project-Id-Version: \n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
+"product=evolution-ews&keywords=I18N+L10N&component=general\n"
+"POT-Creation-Date: 2013-07-02 15:42+0000\n"
+"PO-Revision-Date: 2013-07-12 15:32+0000\n"
+"Last-Translator: Krishnababu Krothapalli <kkrothap@redhat.com>\n"
+"Language-Team: American English <fedora-trans-te@redhat.com>\n"
+"Language: en_US\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+"X-Generator: Lokalize 1.5\n"
+
+#: ../src/addressbook/e-book-backend-ews.c:1038
+msgid "The backend does not support bulk additions"
+msgstr "బ్యాకెండ్ పెద్దమొత్తంలో చేర్పులకు తోడ్పాటునీయదు"
+
+#: ../src/addressbook/e-book-backend-ews.c:1325
+msgid "The backend does not support bulk modifications"
+msgstr "బ్యాకెండ్ పెద్దమొత్తంలో సవరణలకు తోడ్పాటునీయదు"
+
+#: ../src/addressbook/e-book-backend-ews.c:1513
+msgid "Wait till syncing is done"
+msgstr "సింకింగ్ పూర్తయ్యేవరకు వేచివుండు"
+
+#: ../src/addressbook/e-book-backend-ews.c:1922
+#, c-format
+msgid "Downloading contacts in %s %d%% completed... "
+msgstr "%s %d%% నందు పరిచయాలను దింపుకొనుట పూర్తైనది... "
+
+#: ../src/addressbook/e-book-backend-ews.c:2535
+msgid "Syncing contacts..."
+msgstr "పరిచయాలను సింక్ చేస్తోంది..."
+
+#: ../src/addressbook/e-book-backend-ews.c:2757
+#: ../src/configuration/e-ews-search-user.c:365
+msgid "Searching..."
+msgstr "అన్వేషిస్తోంది..."
+
+#: ../src/calendar/e-cal-backend-ews.c:1055
+msgid "EWS does not support bulk removals"
+msgstr "EWS అనునది పెద్దమొత్తంలో తీసివేతలను తోడ్పాటునీయదు"
+
+#: ../src/calendar/e-cal-backend-ews.c:1698
+msgid "EWS does not support bulk additions"
+msgstr "EWS పెద్దమొత్తంలో చేర్పులను తోడ్పాటునీయదు"
+
+#: ../src/calendar/e-cal-backend-ews.c:2281
+msgid "EWS does not support bulk modifications"
+msgstr "EWS పెద్దమొత్తంలో సవరణలను తోడ్పాటునీయదు"
+
+#: ../src/camel/camel-ews-folder.c:268
+#, c-format
+msgid "Unable to open mimecontent temporary file!"
+msgstr "మైమ్‌కాంటెంట్ తాత్కాలిక ఫైలును తెరువలేకపోయింది!"
+
+#: ../src/camel/camel-ews-folder.c:276
+#, c-format
+msgid "Unable to generate parser from mimecontent!"
+msgstr "మైమ్‌కాంటెంట్ నుండి పార్సర్ జనియింపచేయలేదు!"
+
+#: ../src/camel/camel-ews-folder.c:285
+#, c-format
+msgid "Unable to parse meeting request mimecontent!"
+msgstr "మీటింగ్ అభ్యర్ధన మైమ్‌కాంటెంట్‌ను పార్స్ చేయలేదు!"
+
+#: ../src/camel/camel-ews-folder.c:346
+#, c-format
+msgid "Unable to create cache file"
+msgstr "క్యాచీ ఫైలు సృష్టించ లేకపోయింది"
+
+#: ../src/camel/camel-ews-folder.c:451 ../src/camel/camel-ews-folder.c:531
+#, c-format
+msgid "Unable to create cache path"
+msgstr "క్యాచీ పాత్ సృష్టించ లేకపోయింది"
+
+#: ../src/camel/camel-ews-folder.c:541
+#, c-format
+msgid "Failed to move message cache file"
+msgstr "సందేశం క్యాచీ ఫైలు కదుల్చుటకు విఫలమైంది"
+
+#: ../src/camel/camel-ews-folder.c:1189
+#, c-format
+msgid "Could not load summary for %s"
+msgstr "%s కొరకు "
+
+#: ../src/camel/camel-ews-folder.c:1625
+#, c-format
+msgid "Cant perform actions on the folder while in offline mode"
+msgstr "ఆఫ్‌లైన్ రీతినందు సంచయంపై చర్యలను జరుపలేదు"
+
+#: ../src/camel/camel-ews-provider.c:48
+msgid "Checking for new mail"
+msgstr "కొత్త మెయిల్ కొరకు పరిశీలిస్తోంది"
+
+#: ../src/camel/camel-ews-provider.c:50
+msgid "C_heck for new messages in all folders"
+msgstr "అన్ని సంచయాలనందు కొత్త సందేశముల కొరకు పరిశీలించు (_h)"
+
+#: ../src/camel/camel-ews-provider.c:53
+msgid "Options"
+msgstr "ఐచ్చికాలు"
+
+#: ../src/camel/camel-ews-provider.c:55
+msgid "_Apply filters to new messages in Inbox on this server"
+msgstr "ఈ సేవికపై యిన్బాక్స్ నందు కొత్త సందేశాలకు వడపోతలను ఆపాదించు (_A)"
+
+#: ../src/camel/camel-ews-provider.c:57
+msgid "Check new messages for _Junk contents"
+msgstr "నిరర్ధక విషాయల కొత్త సందేశాలను పరిశీలించు (_J)"
+
+#: ../src/camel/camel-ews-provider.c:59
+msgid "Only check for Junk messages in the IN_BOX folder"
+msgstr "నిరర్ధక సందేశాల కొరకు ఇన్బాక్స్ నందు మాత్రమే పరిశీలించు (_B)"
+
+#: ../src/camel/camel-ews-provider.c:61
+msgid "Automatically synchroni_ze remote mail locally"
+msgstr "స్వయంచాలకంగా రిమోట్ సందేశంను స్థానికంగా సింక్‌చేయి (_z)"
+
+#: ../src/camel/camel-ews-provider.c:64
+msgid "Connection"
+msgstr "అనుసంధానం"
+
+#. Translators: '%s' is preplaced with a widget, where "
+#. * user can select how long the timeout should be.
+#: ../src/camel/camel-ews-provider.c:68
+#, c-format
+msgid "Connection _timeout (in seconds) %s"
+msgstr "అనుసంధానం కాలపరిమితి (క్షణాలలో) %s (_t)"
+
+#: ../src/camel/camel-ews-provider.c:76
+msgid "Exchange Web Services"
+msgstr "వినిమయ వెబ్ సేవలు"
+
+#: ../src/camel/camel-ews-provider.c:78
+msgid "For accessing Exchange servers using Web Services"
+msgstr "ఇచ్చిపుచ్చుకొనే సేవికలను వెబ్ సేవలను వుపయోగించి వాడుకొనుటకు"
+
+#: ../src/camel/camel-ews-provider.c:93
+msgid "NTLM"
+msgstr "NTLM"
+
+#: ../src/camel/camel-ews-provider.c:95
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with NTLM authentication."
+msgstr ""
+"NTLM ధృవీకణతో సాదాపాఠం సంకేతపదం వుపయోగిస్తూ యీ ఐచ్చికం అనునది వినిమయ సేవికకు "
+"అనుసంధానమగును."
+
+#: ../src/camel/camel-ews-provider.c:103
+msgid "Basic"
+msgstr "ప్రాధమిక"
+
+#: ../src/camel/camel-ews-provider.c:105
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with Basic authentication."
+msgstr ""
+"ప్రాధమిక ధృవీకణతో సాదాపాఠం సంకేతపదం వుపయోగిస్తూ యీ ఐచ్చికం అనునది వినిమయ "
+"సేవికకు అనుసంధానమగును."
+
+#: ../src/camel/camel-ews-store.c:192
+#, c-format
+msgid "Session has no storage path"
+msgstr "సెషన్ యెటువంటి నిల్వ పాత్ కలిగిలేదు"
+
+#: ../src/camel/camel-ews-store.c:229
+#, c-format
+msgctxt "PublicFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:358
+#, c-format
+msgctxt "ForeignFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:688
+msgid "Updating foreign folder structure"
+msgstr "ఫారెన్ ఫోల్డర్ స్ట్రక్చర్ నవీకరిస్తోంది"
+
+#: ../src/camel/camel-ews-store.c:973
+msgid "Authentication password not available"
+msgstr "ధృవీకరణ సంకేతపదం అందుబాటులో లేదు"
+
+#: ../src/camel/camel-ews-store.c:1138
+msgid "Query for authentication types is not supported"
+msgstr "ధృవీకరణ రకాల ప్రశ్నకు తోడ్పాటులేదు"
+
+#: ../src/camel/camel-ews-store.c:1190
+#, c-format
+msgid "No such folder: %s"
+msgstr "అటువంటి సంచయం లేదు: %s"
+
+#: ../src/camel/camel-ews-store.c:1502
+msgid "Cannot list EWS public folders in offline mode"
+msgstr "EWS పబ్లిక్ సంచయాలను ఆఫ్‌లైన్ రీతినందు జాబితా చేయలేదు"
+
+#: ../src/camel/camel-ews-store.c:1575
+msgid "Cannot find any EWS public folders"
+msgstr "ఏ EWS పబ్లిక్ సంచయాలను కనుగొనలేదు"
+
+#: ../src/camel/camel-ews-store.c:1680
+#, c-format
+msgid "Cannot create folder '%s', folder already exists"
+msgstr "సంచయం '%s' సృష్టించలేదు, సంచయం యిప్పటికే వుంది"
+
+#: ../src/camel/camel-ews-store.c:1695
+#, c-format
+msgid "Parent folder %s does not exist"
+msgstr "పేరెంట్ సంచయం %s లేదు"
+
+#: ../src/camel/camel-ews-store.c:1705
+#, c-format
+msgid ""
+"Cannot create folder under '%s', it is used for folders of other users only"
+msgstr ""
+"'%s' కిందన సంచయం సృష్టించలేదు, ఇది యితర వాడుకరుల సంచయాల కొరకు మాత్రమే "
+"వుపయోగించబడును"
+
+#: ../src/camel/camel-ews-store.c:1715
+#, c-format
+msgid "Cannot create folder under '%s', it is used for public folders only"
+msgstr ""
+"'%s' కిందన సంచయం సృష్టించలేదు, ఇది పబ్లిక్ సంచయాల కొరకు మాత్రమే వుపయోగించబడెను"
+
+#: ../src/camel/camel-ews-store.c:1784
+#, c-format
+msgid "Folder does not exist"
+msgstr "సంచయం లేదు"
+
+#: ../src/camel/camel-ews-store.c:1793
+#, c-format
+msgid "Cannot remove folder '%s', it is used for folders of other users only"
+msgstr ""
+"సంచయం '%s' తీసివేయలేదు, ఇది యితర వాడుకరుల సంచయాల కొరకు మాత్రమే వుపయోగించబడును"
+
+#: ../src/camel/camel-ews-store.c:1803
+#, c-format
+msgid "Cannot remove folder '%s', it is used for public folders only"
+msgstr ""
+"సంచయం '%s' తీసివేయలేము, ఇది పబ్లిక్ సంచయాల కొరకు మాత్రమే వుపయోగించబడెను"
+
+#: ../src/camel/camel-ews-store.c:1911
+#, c-format
+msgid "Folder %s does not exist"
+msgstr "సంచయం %s లేదు"
+
+#: ../src/camel/camel-ews-store.c:1921
+#, c-format
+msgid "No change key record for folder %s"
+msgstr "సంచయం %s కొరకు చేంజ్ కీ రికార్డు కాలేదు"
+
+#: ../src/camel/camel-ews-store.c:1963
+#, c-format
+msgid "Cannot both rename and move a folder at the same time"
+msgstr "ఒకేసారి సంచయం పేరు మార్చుట మరియు కదుల్చుట కుదరదు"
+
+#: ../src/camel/camel-ews-store.c:1999
+#, c-format
+msgid "Cannot find folder ID for parent folder %s"
+msgstr "పేరెంట్ సంచయం %s కొరకు సంచయం ఐడి కనుగొనలేదు"
+
+#: ../src/camel/camel-ews-store.c:2049 ../src/camel/camel-ews-transport.c:69
+#, c-format
+msgid "Exchange server %s"
+msgstr "వినిమయ సేవిక %s"
+
+#: ../src/camel/camel-ews-store.c:2052
+#, c-format
+msgid "Exchange service for %s on %s"
+msgstr "%s కొరకు %s పై వినిమయ సేవిక"
+
+#: ../src/camel/camel-ews-store.c:2096
+#, c-format
+msgid "Could not locate Trash folder"
+msgstr "చెత్త సంచయం కనపడలేదు"
+
+#: ../src/camel/camel-ews-store.c:2156
+#, c-format
+msgid "Could not locate Junk folder"
+msgstr "నిరర్ధక సంచయం కనపడలేదు"
+
+#: ../src/camel/camel-ews-store.c:2346
+msgid "Cannot subscribe EWS folders in offline mode"
+msgstr "ఆఫ్‌లైన్ రీతినందు EWS సంచయాలకు సబ్‌స్క్రైబ్ కాలేదు"
+
+#: ../src/camel/camel-ews-store.c:2369
+#, c-format
+msgid "Cannot subscribe folder '%s', no public folder available"
+msgstr "సంచయం '%s' కు సబ్‌స్క్రైబ్ కాలేదు, ఏ పబ్లిక్ సంచయం అందుబాటులో లేదు"
+
+#: ../src/camel/camel-ews-store.c:2379
+#, c-format
+msgid "Cannot subscribe folder '%s', folder not found"
+msgstr "సంచయం '%s' కు సబ్‌స్క్రైబ్ కాలేదు, సంచయం కనబడలేదు"
+
+#: ../src/camel/camel-ews-store.c:2470
+msgid "Cannot unsubscribe EWS folders in offline mode"
+msgstr "ఆఫ్‌లైన్ రీతినందు EWS సంచయాలను అన్‌సబ్‌స్క్రైబ్ చేయలేదు"
+
+#: ../src/camel/camel-ews-store.c:2587
+#, c-format
+msgid "You must be working online to complete this operation"
+msgstr "ఈ ఆపరేషన్ పూర్తిచేయుటకు మీరు ఆన్‌లైన్ నందు పనిచేస్తూవుండాలి"
+
+#: ../src/camel/camel-ews-transport.c:72
+#, c-format
+msgid "Exchange mail delivery via %s"
+msgstr "వినిమయ మెయిల్ డెలివరీ %s ద్వారా"
+
+#: ../src/camel/camel-ews-transport.c:119
+msgid "Cannot send message with no From address"
+msgstr "సందేశం పంపుతున్నవారి చిరునామా లేకుండా పంపలేము"
+
+#: ../src/camel/camel-ews-transport.c:125
+msgid "Exchange server cannot send message with multiple From addresses"
+msgstr "ఒకటికన్నా యెక్కువ చిరునామాలనుండి వినిమయ సేవిక సందేశం పంపలేదు"
+
+#: ../src/camel/camel-ews-transport.c:136
+msgid "Failed to read From address"
+msgstr "ఏ చిరునామా నుండి వస్తుందో చదువుటకు విఫలమైంది"
+
+#: ../src/camel/camel-ews-transport.c:148
+#, c-format
+msgid ""
+"Exchange server cannot send message as '%s', when the account was configured "
+"for address '%s'"
+msgstr ""
+"వినిమయ సేవిక '%s' వలె సందేశం పంపలేదు, చిరునామా '%s' కొరకు ఖాతా "
+"ఆకృతీకరించబడినప్పుడు."
+
+#: ../src/camel/camel-ews-transport.c:162
+#, c-format
+msgid "Service not connected"
+msgstr "సేవ అనుసంధానం కాలేదు"
+
+#: ../src/collection/e-ews-backend.c:428
+#: ../src/configuration/e-mail-config-ews-gal.c:274
+msgid "Global Address List"
+msgstr "గ్లోబల్ చిరునామా జాబితా"
+
+#: ../src/collection/e-ews-backend.c:813
+#, c-format
+msgid "Could not determine a suitable folder class for a new folder named '%s'"
+msgstr ""
+"'%s' పేరుతో వున్న కొత్త సంచయం కొరకు సరిపోయే సంచయం తరగతిని నిర్ణయించలేక పోయింది"
+
+#: ../src/collection/e-ews-backend.c:902
+#, c-format
+msgid "Data source '%s' does not represent an Exchange Web Services folder"
+msgstr "దత్తాంశ మూలం '%s' అనునది వినిమయ వెబ్ సేవల సంచయంను సూచించును"
+
+#: ../src/configuration/e-ews-config-utils.c:516
+#, c-format
+msgid "Cannot edit permissions of folder '%s', choose other folder."
+msgstr "'%s' సంచయం యొక్క అనుమతులను సరికూర్చలేదు, వేరే సంచయం యెంచుము."
+
+#: ../src/configuration/e-ews-config-utils.c:594
+msgid "Subscribe to folder of other user..."
+msgstr "వేరే వాడుకరి యొక్క సంచయంకు సబ్‌స్క్రైబ్ అవ్వు ..."
+
+#: ../src/configuration/e-ews-config-utils.c:603
+#: ../src/configuration/e-ews-config-utils.c:884
+#: ../src/configuration/e-ews-config-utils.c:915
+#: ../src/configuration/e-ews-config-utils.c:946
+#: ../src/configuration/e-ews-config-utils.c:977
+msgid "Permissions..."
+msgstr "అనుమతులు..."
+
+#: ../src/configuration/e-ews-config-utils.c:605
+msgid "Edit EWS folder permissions"
+msgstr "EWS సంచయం అనుమతులను సరికూర్చు"
+
+#: ../src/configuration/e-ews-config-utils.c:886
+msgid "Edit EWS calendar permissions"
+msgstr "EWS క్యాలెండర్ అనుమతులను సరికూర్చు"
+
+#: ../src/configuration/e-ews-config-utils.c:917
+msgid "Edit EWS tasks permissions"
+msgstr "EWS కర్తవ్యాల అనుమతులను సరికూర్చు"
+
+#: ../src/configuration/e-ews-config-utils.c:948
+msgid "Edit EWS memos permissions"
+msgstr "EWS మెమోల అనుమతులను సరికూర్చు"
+
+#: ../src/configuration/e-ews-config-utils.c:979
+msgid "Edit EWS contacts permissions"
+msgstr "EWS పరిచయాల అనుమతులను సరికూర్చు"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:87
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:499
+msgctxt "PermissionsLevel"
+msgid "None"
+msgstr "ఏదీకాదు"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:88
+msgctxt "PermissionsLevel"
+msgid "Owner"
+msgstr "యజమాని"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:98
+msgctxt "PermissionsLevel"
+msgid "Publishing Editor"
+msgstr "ప్రచురించు సరికూర్పరి"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:107
+msgctxt "PermissionsLevel"
+msgid "Editor"
+msgstr "సరికూర్పరి"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:115
+msgctxt "PermissionsLevel"
+msgid "Publishing Author"
+msgstr "ప్రచురించు మూలకర్త"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:122
+msgctxt "PermissionsLevel"
+msgid "Author"
+msgstr "మూలకర్త"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:128
+msgctxt "PermissionsLevel"
+msgid "Nonediting Author"
+msgstr "కూర్పుచేయని మూలకర్త"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:133
+msgctxt "PermissionsLevel"
+msgid "Reviewer"
+msgstr "పునఃపరిశీలించువారు"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:136
+msgctxt "PermissionsLevel"
+msgid "Contributor"
+msgstr "సహాయకులు"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:139
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time"
+msgstr "ఖాళీ/వత్తిడి సమయం"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:141
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time, subject, location"
+msgstr "ఖాళీ/వత్తిడి సమయం, సంగతి, స్థానం"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:143
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:520
+msgctxt "PermissionsLevel"
+msgid "Custom"
+msgstr "మలచిన"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:267
+msgid "Writing folder permissions, please wait..."
+msgstr "సంచయం అనుమతులను వ్రాయుచున్నది, దయచేసి వేచివుండు..."
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:777
+msgctxt "User"
+msgid "Anonymous"
+msgstr "పేరులేని"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:780
+msgctxt "User"
+msgid "Default"
+msgstr "అప్రమేయ"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:786
+msgctxt "User"
+msgid "Unknown"
+msgstr "తెలియని"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:867
+#: ../src/configuration/e-ews-search-user.c:431
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1075
+msgid "Name"
+msgstr "పేరు"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:873
+msgid "Permission level"
+msgstr "అనుమతి స్థాయి"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:925
+msgid "Edit EWS folder permissions..."
+msgstr "EWS సంచయం అనుమతులను సరిచేయి..."
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:950
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:635
+msgid "Account:"
+msgstr "ఖాతా:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:978
+msgid "Folder name:"
+msgstr "సంచయం పేరు:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1001
+msgid "Folder ID:"
+msgstr "సంచయం ఐడి:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1065
+msgid "Permissions"
+msgstr "అనుమతులు"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1087
+msgid "Permi_ssion level:"
+msgstr "అనుమతి స్థాయి (_s):"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1121
+msgctxt "Permissions"
+msgid "Read"
+msgstr "చదువు"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1133
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1200
+msgctxt "Permissions"
+msgid "None"
+msgstr "ఏదీకాదు"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1139
+msgctxt "Permissions"
+msgid "Free/Busy time"
+msgstr "ఖాళీ/వత్తిడి సమయం"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1144
+msgctxt "Permissions"
+msgid "Free/Busy time, subject, location"
+msgstr "ఖాళీ/వత్తిడి సమయం, సంగతి, స్థానం"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1150
+msgctxt "Permissions"
+msgid "Full Details"
+msgstr "పూర్తి వివరాలు"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1156
+msgctxt "Permissions"
+msgid "Write"
+msgstr "వ్రాయి"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1168
+msgctxt "Permissions"
+msgid "Create items"
+msgstr "అంశాలను సృష్టించు"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1172
+msgctxt "Permissions"
+msgid "Create subfolders"
+msgstr "ఉపసంచయాలను సృష్టించు"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1176
+msgctxt "Permissions"
+msgid "Edit own"
+msgstr "స్వంతవి సరిచేయి"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1180
+msgctxt "Permissions"
+msgid "Edit all"
+msgstr "అన్నిటినీ సరిచేయి"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1188
+msgctxt "Permissions"
+msgid "Delete items"
+msgstr "అంశాలను తొలగించు"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1205
+msgctxt "Permissions"
+msgid "Own"
+msgstr "స్వంత"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1210
+msgctxt "Permissions"
+msgid "All"
+msgstr "అన్నీ"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1216
+msgctxt "Permissions"
+msgid "Other"
+msgstr "ఇతర"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1228
+msgctxt "Permissions"
+msgid "Folder owner"
+msgstr "సంచయం యజమాని"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1232
+msgctxt "Permissions"
+msgid "Folder contact"
+msgstr "సంచయం పరిచయం"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1236
+msgctxt "Permissions"
+msgid "Folder visible"
+msgstr "సంచయం  దృశ్యనీయత"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1309
+msgid "Reading folder permissions, please wait..."
+msgstr "సంచయం అనుమతులను చదువుతోంది, దయచేసి వేచివుండు..."
+
+#: ../src/configuration/e-ews-search-user.c:208
+#, c-format
+msgid "No users found, only one contact"
+msgid_plural "No users found, only %d contacts"
+msgstr[0] "ఏ వాడుకరులు కనబడలేదు, ఒక పరిచయం మాత్రమే"
+msgstr[1] "ఏ వాడుకరులు కనబడలేదు, %d పరిచయాలు మాత్రమే"
+
+#: ../src/configuration/e-ews-search-user.c:213
+msgid "No users found"
+msgstr "ఏ వాడుకరులు కనబడలేదు"
+
+#: ../src/configuration/e-ews-search-user.c:217
+#, c-format
+msgid "Found one user"
+msgid_plural "Found %d users"
+msgstr[0] "ఒక వాడుకరి కనుగొన్నది"
+msgstr[1] "%d వాడుకరులు కనుగొన్నది"
+
+#: ../src/configuration/e-ews-search-user.c:223
+#, c-format
+msgid "Found more than 100 users, but showing only first %d"
+msgid_plural "Found more than 100 users, but showing only first %d"
+msgstr[0] ""
+"100 కన్నా యెక్కువ వాడుకరులు కనుగొన్నది, అయితే మొదటి %d మాత్రమే చూపుతోంది"
+msgstr[1] ""
+"100 కన్నా యెక్కువ వాడుకరులు కనుగొన్నది, అయితే మొదటి %d మాత్రమే చూపుతోంది"
+
+#: ../src/configuration/e-ews-search-user.c:357
+#: ../src/configuration/e-ews-search-user.c:540
+msgid "Search for a user"
+msgstr "వాడుకరి కొరకు అన్వేషించు"
+
+#: ../src/configuration/e-ews-search-user.c:437
+msgid "E-mail"
+msgstr "ఈ-మెయిల్"
+
+#: ../src/configuration/e-ews-search-user.c:474
+msgid "Choose EWS user..."
+msgstr "EWS వాడుకరి యెంచు..."
+
+#: ../src/configuration/e-ews-search-user.c:497
+msgid "_Search:"
+msgstr "అన్వేషించు (_S):"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:97
+#: ../src/server/e-ews-folder.c:632
+#, c-format
+msgid "Cannot add folder, folder already exists as '%s'"
+msgstr "సంచయం జతచేయలేదు, సంచయం యిప్పటికే '%s' వలె వుంది"
+
+#. Translators: The '%s' is replaced with user name, to whom the foreign mailbox belongs.
+#. * Example result: "Mailbox - John Smith"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:107
+#, c-format
+msgctxt "ForeignFolder"
+msgid "Mailbox - %s"
+msgstr "మెయిల్‌బాక్స్ - %s"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:272
+msgid "Cannot test foreign folder availability while in offline mode"
+msgstr "ఆఫ్‌లైన్ రీతినందు ఫారెన్ సంచయం అందుబాటును పరీక్షించలేదు"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:297
+#, c-format
+msgid "User '%s' was not found on the server"
+msgstr "వాడుకరి '%s' సేవికపై కనబడలేదు"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:333
+#, c-format
+msgid "User name '%s' is ambiguous, specify it more precisely, please"
+msgstr ""
+"వాడుకరి పేరు '%s' సందిగ్ధంగా వుంది, దాన్ని మరింత ఖచ్చితంగా తెలుపండి, దయచేసి"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:355
+#, c-format
+msgid ""
+"Folder '%s' not found. Either it does not exist or you do not have "
+"permission to access it."
+msgstr "సంచయం '%s' కనబడలేదు. అది లేదు లేదా దానిని వాడుకొనుటకు మీకు అనుమతిలేదు."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:373
+msgid "Cannot add folder, cannot determine folder's type"
+msgstr "సంచయం జతచేయలేము, సంచయం రకంను నిర్ణయించలేము"
+
+#. Translators: This is used to name foreign folder.
+#. * The first '%s' is replaced with user name to whom the folder belongs,
+#. * the second '%s' is replaced with folder name.
+#. * Example result: "John Smith - Calendar"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:418
+#, c-format
+msgctxt "ForeignFolder"
+msgid "%s - %s"
+msgstr "%s - %s"
+
+#. convert well-known names to their non-localized form
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:512
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:720
+msgid "Inbox"
+msgstr "ఇన్బాక్స్"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:514
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:721
+msgid "Contacts"
+msgstr "పరిచయాలు"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:516
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:722
+msgid "Calendar"
+msgstr "క్యాలెండర్"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:518
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:723
+msgid "Memos"
+msgstr "మెమోలు"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:520
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:724
+msgid "Tasks"
+msgstr "కర్తవ్యాలు"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:537
+#, c-format
+msgid "Testing availability of folder '%s' of user '%s', please wait..."
+msgstr ""
+"సంచయం '%s' వాడకరి '%s' ది అందుబాటులో వుందోలేదో పరిశీలిస్తోంది, దయచేసి "
+"వేచివుండు..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:614
+msgid "Subscribe to folder of other EWS user..."
+msgstr "ఇతర EWS వాడుకరి యొక్క సంచయంకు సబ్‌స్క్రైబ్ అవ్వు..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:665
+msgid "User"
+msgstr "వాడుకరి"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:672
+msgid "_User:"
+msgstr "వాడుకరి (_U):"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:687
+msgid "C_hoose..."
+msgstr "ఎంచు (h)..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:703
+msgid "_Folder name:"
+msgstr "సంచయం పేరు (_F):"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:733
+msgid "Include _subfolders"
+msgstr "ఉపసంచయాలను చేర్చు (s)"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:140
+msgid "Querying Autodiscover service"
+msgstr "స్వయంచాలకంగాకనుగొను సేవను ప్రశ్నించు"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:231
+msgid "Fetch _URL"
+msgstr "_URL వెతికితెమ్ము"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:140
+msgid "Configuration"
+msgstr "ఆకృతీకరణ"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:158
+msgid "User_name:"
+msgstr "వాడుకరి పేరు (_n):"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:172
+msgid "_Host URL:"
+msgstr "అతిధేయ URL (_H):"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:191
+msgid "OAB U_RL:"
+msgstr "OAB U_RL:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:205
+msgid "Open _Mailbox of other user"
+msgstr "వేరే వాడకరి యొక్క మెయిల్‌బాక్స్ తెరువు (_M)"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:239
+msgid "S_earch..."
+msgstr "అన్వేషించు (_e)..."
+
+#: ../src/configuration/e-mail-config-ews-backend.c:250
+msgid "Authentication"
+msgstr "ధృవీకరణ"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:500
+msgctxt "PermissionsLevel"
+msgid "Reviewer (can read items)"
+msgstr "పునఃపరిశీలించువారు (అంశాలను చదువగలరు)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:501
+msgctxt "PermissionsLevel"
+msgid "Author (can read and create items)"
+msgstr "మూలకర్త (అంశాలను చదువగలరు మరియు సృష్టించగలరు)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:502
+msgctxt "PermissionsLevel"
+msgid "Editor (can read, create and modify items)"
+msgstr "సరికూర్పరి (చదువుట, సృష్టించుట మరియు అంశాలను సవరించుట చేయగలదు)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:605
+msgid "Delegate permissions"
+msgstr "డెలిగేట్ అనుమతులు"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:623
+msgid "C_alendar"
+msgstr "క్యాలెండర్ (_a)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:626
+msgid "_Delegate receives copies of meeting-related messages sent to me"
+msgstr "నాకు పంపిన మీటింగ్-సంబందిత సందేశాల నకళ్ళను డెలిగేట్ స్వీకరించును (_D)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:631
+msgid "_Tasks"
+msgstr "కర్తవ్యాలు (_T)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:634
+msgid "_Inbox"
+msgstr "ఇన్బాక్స్ (_I)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:637
+msgid "C_ontacts"
+msgstr "పరిచయాలు (_o)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:640
+msgid "_Notes"
+msgstr "గమనికలు (_N)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:643
+msgid "_Journal"
+msgstr "జర్నల్ (_J)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:646
+#, c-format
+msgid "Delegate '%s' has the following permissions"
+msgstr "డెలిగేట్ '%s' కింది అనుమతులను కలిగివుంది"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:664
+msgid "Delegate can see my _private items"
+msgstr "డెలిగేట్ నా వ్యక్తిగత అంశాలను చూడగలదు (_p)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:987
+msgid "Retrieving current user permissions, please wait..."
+msgstr "ప్రస్తుత వాడుకరి అనుమతులను పొందుతోంది, దయచేసి వేచివుండు..."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1108
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1638
+msgid "Delegates"
+msgstr "డెలిగేట్లు"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1132
+msgid ""
+"Delegates can send items on your behalf, including creating and responding "
+"to meeting requests. If you want to grant folder permissions without giving "
+"send-on-behalf-of permissions, close this dialog box, right-click the "
+"folder, click Permissions and change the options there."
+msgstr ""
+"డెలిగేట్స్ మీ తరుపున మీటింగ్ అభ్యర్ధనలను సృష్టించగలరు మరియు స్పందించగలరు "
+"అంశాలను పంపగలరు. మీ-తరుపున-పంపే అనుమతులు ఇవ్వకుండా సంచయం అనుమతులను ఇవ్వాలంటే, "
+"ఈ డైలాగ్ బాక్స్ మూసి, సంచయంపై కుడి-నొక్కు నొక్కి, అనుమతులను నొక్కి ఐచ్చికాలను "
+"యిక్కడ మార్చండి."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1181
+msgid ""
+"Deliver meeting requests addressed to me and responses to meeting requests "
+"where I am the organizer to:"
+msgstr ""
+"నేను నిర్వాహకునిగా వున్నప్పుడు నాకు సంబందించిన మీటింగ్ అభ్యర్ధనలను పంపు మరియు "
+"మీటింగ్ అభ్యర్ధనలకు స్పందించు:"
+
+#. new-line break, because GtkRadioButton doesn't allow wrapping of the inner label
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1190
+msgid ""
+"My delegates only, but _send a copy of meeting requests\n"
+"and responses to me (recommended)"
+msgstr ""
+"నా డెలిగేట్స్ మాత్రమే, అయితే మీటింగ్ అభ్యర్ధనల మరియు స్పందనల\n"
+"నకలు నాకు పంపు (సిఫార్సుచేయబడినది)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1197
+msgid "My d_elegates only"
+msgstr "నా డెలిగేట్స్ మాత్రమే"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1204
+msgid "My delegates a_nd me"
+msgstr "నా డెలిగేట్లు మరియు నేను (_n)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1713
+msgid "Retrieving \"Delegates\" settings"
+msgstr "\"డెలిగేట్స్\" అమరికలను పొందుతోంది"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:221
+msgid "Locating offline address books"
+msgstr "ఆఫ్‌లైన్ చిరునామా పుస్తకాలను గుర్తించుతోంది"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:301
+msgid "Cache o_ffline address book"
+msgstr "ఆఫ్‌లైన్ చిరునామా పుస్తకం క్యాచీ"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:327
+msgid "Select ad_dress list:"
+msgstr "చిరునామా జాబితా యెంపికచేయి:"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:351
+msgid "Fetch List"
+msgstr "జాబితా వెతికితెమ్ము"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:444
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:923
+msgid "Out of Office"
+msgstr "కార్యాలయం బయట"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:460
+msgid ""
+"The messages specified below will be automatically sent to each internal and "
+"external person who sends a mail to you."
+msgstr ""
+"కింద తెలిపిన సందేశాలు అనునవి మీకు మెయిల్ పంపిన అంతర్గత మరియు బాహ్య వ్యక్తికి "
+"స్వయంచాలకంగా పంపబడును."
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:468
+msgid "Do _not send Out of Office replies"
+msgstr "కార్యాలయ ప్రత్యుత్తరములు బయటకి పంపవద్దు (_n)"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:476
+msgid "_Send Out of Office replies"
+msgstr "కార్యాలయ ప్రత్యుత్తరాలు బయటకు పంపు (_S)"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:484
+msgid "Send Out of Office replies only _during this time period:"
+msgstr "ఈ సమయం నందు మాత్రమే కార్యాలయ ప్రత్యుత్తరాలు బయటకు పంపు (_d):"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:504
+msgid "_From:"
+msgstr "నుండి (_F):"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:529
+msgid "_To:"
+msgstr "వీరికి (_T):"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:554
+msgid "I_nternal:"
+msgstr "అంతర్గత (_n):"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:563
+msgid "Message to be sent within the organization"
+msgstr "సంస్థ లోపలే సందేశం పంపాలి"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:590
+msgid "E_xternal:"
+msgstr "బాహ్య (_x):"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:598
+msgid "Message to be sent outside the organization"
+msgstr "సంస్థ బయటకి సందేశం పంపాలి"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:608
+msgid "Do not reply to senders outside the organization"
+msgstr "సంస్థ బయట నుండి స్పందించేవారికి ప్రత్యుత్తరం ఇవ్వొద్దు"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:611
+msgid "Reply only to known senders outside the organization"
+msgstr "సంస్థ బయట నుండి స్పందిచేవారిలో తెలిసినవారికే ప్రత్యుత్తరం యివ్వు"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:614
+msgid "Reply to any sender outside the organization"
+msgstr "సంస్థ బయటనుండి స్పందించిన యెవరికైనా ప్రత్యుత్తరం యివ్వు"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:999
+msgid "Retrieving \"Out of Office\" settings"
+msgstr "\"కార్యాలయం బయట\" అమరికలను పొందుతోంది"
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:1
+msgid "Autodiscovery query failed."
+msgstr "స్వయంచాలకంగాకనుగొను క్వరీ విఫలమైంది."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:2
+msgid "The reported error was &quot;{0}&quot;."
+msgstr "నివేదించిన దోషం &quot;{0}&quot;."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:3
+msgid "Failed to locate offline address books."
+msgstr "ఆఫ్‌లైన్ చిరునామా పుస్తకాలను గుర్తించుటలో విఫలమైంది."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:4
+msgid "Failed to retrieve &quot;Out of Office&quot; settings."
+msgstr "&quot;కార్యాలయం బయట&quot; అమరికలను పొందుటకు విఫలమైంది."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:5
+msgid "Failed to retrieve &quot;Delegates&quot; settings."
+msgstr "&quot;డెలిగేట్స్&quot; అమరికలను పొందుటలో విఫలమైంది."
+
+#: ../src/server/e-ews-connection.c:494
+msgid "Operation Cancelled"
+msgstr "ఆపరేషన్ రద్దైనది"
+
+#: ../src/server/e-ews-connection.c:563
+msgid "Authentication failed"
+msgstr "ధృవీకరణ విఫలమైంది"
+
+#: ../src/server/e-ews-connection.c:574
+#, c-format
+msgid "No response: %s"
+msgstr "స్పందన లేదు: %s"
+
+#: ../src/server/e-ews-connection.c:1912
+#, c-format
+msgid "Failed to parse autodiscover response XML"
+msgstr "స్వయంచాలకంగాకనుగొను స్పందన XML పార్స్ విఫలమైంది"
+
+#: ../src/server/e-ews-connection.c:1919
+#, c-format
+msgid "Failed to find <Autodiscover> element"
+msgstr "<స్వయంచాలకంగాకనుగొను> మూలకం కనుగొనుటలో విఫలమైంది"
+
+#: ../src/server/e-ews-connection.c:1930
+#, c-format
+msgid "Failed to find <Response> element"
+msgstr "<స్పందన> మూలకం కనుగొనుటలో విఫలమైంది"
+
+#: ../src/server/e-ews-connection.c:1941
+#, c-format
+msgid "Failed to find <Account> element"
+msgstr "<ఖాతా> మూలకం కనుగొనుటలో విఫలమైంది"
+
+#: ../src/server/e-ews-connection.c:1960
+#, c-format
+msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
+msgstr ""
+"స్వయంచాలకంగాకనుగొను స్పందనలో <ASUrl> మరియు <OABUrl> కనుగొనుటలో విఫలమైంది"
+
+#: ../src/server/e-ews-connection.c:2042
+msgid "URL cannot be NULL"
+msgstr "URL అనునది NULL కాలేదు"
+
+#: ../src/server/e-ews-connection.c:2050
+#, c-format
+msgid "URL '%s' is not valid"
+msgstr "URL '%s' చెల్లునది కాదు"
+
+#: ../src/server/e-ews-connection.c:2152
+msgid "Email address is missing a domain part"
+msgstr "ఈమెయిల్ చిరునామా నందు డొమైన్ బాగము లేదు"
+
+#: ../src/server/e-ews-connection.c:2479
+msgid "Failed to parse oab XML"
+msgstr "oab XML పార్సు చేయుట విఫలమైంది"
+
+#: ../src/server/e-ews-connection.c:2487
+msgid "Failed to find <OAB> element\n"
+msgstr "<OAB> మూలకం కనుగొనుటలో విఫలమైంది\n"
+
+#: ../src/server/e-ews-connection.c:3673
+msgid "No items found"
+msgstr "ఏ అంశాలు కనబడలేదు"
+
+#: ../src/server/e-ews-folder.c:587
+msgid "Cannot add folder, unsupported folder type"
+msgstr "సంచయం జతచేయలేదు, తోడ్పాటులేని సంచయం రకం"
+
+#: ../src/server/e-ews-folder.c:592
+msgid "Cannot add folder, master source not found"
+msgstr "సంచయం జతచేయ లేదు, మాస్టర్ మూలం కనబడలేదు"
+
+#: ../src/utils/ews-camel-common.c:187
+#, c-format
+msgid "CreateItem call failed to return ID for new message"
+msgstr "కొత్త సందేశం కొరకు ఐడి యిచ్చుటలో అంశముసృష్టించు కాల్ విఫలమైంది"
+
+
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/e-book-backend-ews.c.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/e-book-backend-ews.c
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/e-book-backend-ews.c.sync-with-3.8.4	2013-07-24 07:30:27.286435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/e-book-backend-ews.c	2013-07-24 07:30:27.304435567 +0200
@@ -53,8 +53,6 @@
 #include "e-book-backend-sqlitedb.h"
 #include "e-book-backend-ews-utils.h"
 
-#include "lzx/ews-oal-decompress.h"
-
 #include "server/e-ews-item-change.h"
 #include "server/e-ews-message.h"
 #include "server/e-ews-connection.h"
@@ -64,6 +62,7 @@
 
 #include "e-book-backend-ews.h"
 #include "ews-oab-decoder.h"
+#include "ews-oab-decompress.h"
 #include "libedata-book-compat.h"
 
 #include "server/e-ews-gnome-3-8-compat.h"
@@ -849,7 +848,7 @@ ebews_set_notes_changes (ESoapMessage *m
 
 	if (g_strcmp0 (old_notes, new_notes) != 0) {
 		convert_contact_property_to_updatexml (
-				message, "Body", new_notes ?: "", "item", "BodyType", "Text");
+				message, "Body", new_notes ? new_notes : "", "item", "BodyType", "Text");
 	}
 
 	g_free (old_notes);
@@ -916,7 +915,7 @@ static const struct field_element_mappin
 	{ E_CONTACT_IM_AIM, ELEMENT_TYPE_COMPLEX, "ImAddresses", NULL, ebews_populate_ims, ebews_set_ims, ebews_set_im_changes },
 	{ E_CONTACT_TITLE, ELEMENT_TYPE_SIMPLE, "JobTitle", e_ews_item_get_job_title},
 	{ E_CONTACT_MANAGER, ELEMENT_TYPE_SIMPLE, "Manager", e_ews_item_get_manager},
-	{ E_CONTACT_MANAGER, ELEMENT_TYPE_SIMPLE, "OfficeLocation", e_ews_item_get_office_location},
+	{ E_CONTACT_OFFICE, ELEMENT_TYPE_SIMPLE, "OfficeLocation", e_ews_item_get_office_location},
 	{ E_CONTACT_SPOUSE, ELEMENT_TYPE_SIMPLE, "Profession", e_ews_item_get_profession},
 	{ E_CONTACT_SPOUSE, ELEMENT_TYPE_SIMPLE, "SpouseName", e_ews_item_get_spouse_name},
 	{ E_CONTACT_FAMILY_NAME, ELEMENT_TYPE_SIMPLE, "Surname", e_ews_item_get_surname},
@@ -1159,7 +1158,7 @@ e_book_backend_ews_remove_contacts (EBoo
 		return;
 	}
 
-	for (l = (GSList *) id_list; l != NULL; l = g_slist_next (id_list))
+	for (l = (GSList *) id_list; l != NULL; l = g_slist_next (l))
 		copy = g_slist_prepend (copy, g_strdup ((gchar *) l->data));
 	copy = g_slist_reverse (copy);
 
@@ -1689,45 +1688,18 @@ e_book_backend_ews_build_restriction (co
 }
 
 /************* GAL sync ***********************/
-static gboolean
-ews_gal_needs_update (EBookBackendEws *cbews,
-                      EwsOALDetails *full,
-                      GError **error)
-{
-	EBookBackendEwsPrivate *priv = cbews->priv;
-	guint32 seq;
-	gboolean ret = FALSE;
-	gchar *tmp;
-
-	if (!priv->summary)
-		return FALSE;
-
-	tmp = e_book_backend_sqlitedb_get_key_value (priv->summary, priv->folder_id, "seq", error);
-	if (!tmp)
-		goto exit;
-
-	sscanf (tmp, "%"G_GUINT32_FORMAT, &seq);
-	if (seq < full->seq)
-		ret = TRUE;
-
-	d (printf ("Gal needs update: %d (local: %d, remote: %d)\n",
-		   ret, seq, full->seq);)
-exit:
-	g_free (tmp);
-	return ret;
-}
 
 static gchar *
-ews_download_full_gal (EBookBackendEws *cbews,
+ews_download_gal_file (EBookBackendEws *cbews,
                        EwsOALDetails *full,
                        GCancellable *cancellable,
                        GError **error)
 {
 	EBookBackendEwsPrivate *priv = cbews->priv;
 	EEwsConnection *oab_cnc;
-	gchar *full_url, *oab_url, *cache_file = NULL;
+	gchar *full_url, *oab_url;
 	const gchar *cache_dir, *timeout_str;
-	gchar *comp_cache_file = NULL, *uncompress_file = NULL;
+	gchar *download_path = NULL;
 	gchar *password;
 	ESource *esource = e_book_backend_get_source (E_BOOK_BACKEND (cbews));
 
@@ -1735,7 +1707,7 @@ ews_download_full_gal (EBookBackendEws *
 	oab_url = g_strndup (priv->oab_url, strlen (priv->oab_url) - 7);
 	full_url = g_strconcat (oab_url, full->filename, NULL);
 	cache_dir = e_book_backend_get_cache_dir (E_BOOK_BACKEND (cbews));
-	comp_cache_file = g_build_filename (cache_dir, full->filename, NULL);
+	download_path = g_build_filename (cache_dir, full->filename, NULL);
 	timeout_str = e_source_get_property (esource, "timeout");
 
 	oab_cnc = e_ews_connection_new (full_url, priv->username, priv->password,
@@ -1749,30 +1721,127 @@ ews_download_full_gal (EBookBackendEws *
 	e_ews_connection_set_password (oab_cnc, password);
 	g_free (password);
 
-	if (!e_ews_connection_download_oal_file_sync (
-		oab_cnc, comp_cache_file, NULL, NULL, cancellable, error))
-		goto exit;
-
-	cache_file = g_strdup_printf ("%s-%d.oab", priv->folder_name, full->seq);
-	uncompress_file = g_build_filename (cache_dir, cache_file, NULL);
-	if (!oal_decompress_v4_full_detail_file (comp_cache_file, uncompress_file, error)) {
-		g_free (uncompress_file);
-		uncompress_file = NULL;
+	if (!e_ews_connection_download_oal_file_sync (oab_cnc, download_path,
+						      NULL, NULL,
+						      cancellable, error)) {
+		g_free (download_path);
+		download_path = NULL;
 		goto exit;
 	}
 
-	d (g_print ("OAL file decompressed %s \n", uncompress_file);)
+	d (g_print ("OAL file downloaded %s\n", download_path);)
 
-exit:
-	if (comp_cache_file)
-		g_unlink (comp_cache_file);
+ exit:
 	g_object_unref (oab_cnc);
 	g_free (oab_url);
 	g_free (full_url);
-	g_free (comp_cache_file);
-	g_free (cache_file);
 
-	return uncompress_file;
+	return download_path;
+}
+
+static gchar *
+ews_download_full_gal (EBookBackendEws *cbews,
+                       EwsOALDetails *full,
+                       GCancellable *cancellable,
+                       GError **error)
+{
+	EBookBackendEwsPrivate *priv = cbews->priv;
+	const gchar *cache_dir;
+	gchar *lzx_path, *oab_file, *oab_path;
+
+	lzx_path = ews_download_gal_file (cbews, full, cancellable, error);
+	if (!lzx_path)
+		return NULL;
+
+	cache_dir = e_book_backend_get_cache_dir (E_BOOK_BACKEND (cbews));
+	oab_file = g_strdup_printf ("%s-%d.oab", priv->folder_name, full->seq);
+	oab_path = g_build_filename (cache_dir, oab_file, NULL);
+	if (!ews_oab_decompress_full (lzx_path, oab_path, error)) {
+		g_free (oab_path);
+		oab_path = NULL;
+		goto exit;
+	}
+
+	d (g_print ("OAL file decompressed %s \n", oab_path);)
+
+exit:
+	if (lzx_path) {
+		g_unlink (lzx_path);
+		g_free (lzx_path);
+	}
+	g_free (oab_file);
+	return oab_path;
+}
+
+static gchar *
+ews_download_gal (EBookBackendEws *cbews, EwsOALDetails *full, GSList *deltas, guint32 seq,
+		  GCancellable *cancellable, GError **error)
+{
+#ifdef USE_MSPACK
+	EBookBackendEwsPrivate *priv = cbews->priv;
+	GSList *p;
+	gchar *thisoab = NULL;
+	const gchar *cache_dir;
+
+	cache_dir = e_book_backend_get_cache_dir (E_BOOK_BACKEND (cbews));
+
+	thisoab = e_book_backend_sqlitedb_get_key_value (priv->summary, priv->folder_id,
+							 "oab-filename", NULL);
+	if (!thisoab)
+		goto full;
+
+	for (p = deltas; p; p = p->next) {
+		EwsOALDetails *det = p->data;
+		GError *local_error = NULL;
+		gchar *oab_file, *lzx_path, *nextoab;
+
+		seq++;
+		if (det->seq != seq)
+			break;
+
+		lzx_path = ews_download_gal_file (cbews, det, cancellable, NULL);
+		if (!lzx_path)
+			break;
+
+		oab_file = g_strdup_printf ("%s-%d.oab", priv->folder_name, seq);
+		nextoab = g_build_filename (cache_dir, oab_file, NULL);
+		g_free (oab_file);
+
+		ews_oab_decompress_patch (lzx_path, thisoab, nextoab, &local_error);
+
+		/* Free the LZX file */
+		g_unlink (lzx_path);
+		g_free (lzx_path);
+
+		/* Free the previous OAB file */
+		g_unlink (thisoab);
+		g_free (thisoab);
+
+		thisoab = nextoab;
+
+		/* For once we are *allowed* to use the error instead of having to
+		 * check the return value of the function. It's our *own* error. */
+		if (local_error) {
+			d (g_print ("Failed to apply incremental patch: %s\n",
+				    local_error->message));
+			g_error_free (local_error);
+			break;
+		}
+
+		d (g_print ("Created %s from delta\n", thisoab));
+
+		if (seq == full->seq)
+			return thisoab;
+	}
+
+	if (thisoab) {
+		g_unlink (thisoab);
+		g_free (thisoab);
+	}
+ full:
+#endif
+	d (printf ("Ewsgal: Downloading full gal \n"));
+	return ews_download_full_gal (cbews, full, cancellable, error);
 }
 
 static gboolean
@@ -1847,6 +1916,13 @@ ews_gal_store_contact (EContact *contact
 		e_book_backend_notify_complete (E_BOOK_BACKEND (data->cbews));
 }
 
+static gint det_sort_func (gconstpointer _a, gconstpointer _b)
+{
+	const EwsOALDetails *a = _a, *b = _b;
+
+	return a->seq - b->seq;
+}
+
 static gboolean
 ews_replace_gal_in_db (EBookBackendEws *cbews,
                        const gchar *filename,
@@ -1903,8 +1979,14 @@ ebews_start_gal_sync (gpointer data)
 	GError *error = NULL;
 	EEwsConnection *oab_cnc;
 	GSList *full_l = NULL;
+	GSList *deltas = NULL;
 	gboolean ret = TRUE;
+	gboolean is_populated;
 	gchar *uncompressed_filename = NULL;
+	gchar *old_etag = NULL, *etag = NULL;
+	gchar *seq;
+	guint32 old_seq = 0;
+	guint32 delta_size = 0;
 	const gchar *timeout_str;
 	ESource *esource;
 
@@ -1923,8 +2005,22 @@ ebews_start_gal_sync (gpointer data)
 
 	d (printf ("Ewsgal: Fetching oal full details file \n");)
 
+	is_populated = e_book_backend_sqlitedb_get_is_populated (priv->summary, priv->folder_id, NULL);
+	if (is_populated) {
+		gchar *tmp;
+		old_etag = e_book_backend_sqlitedb_get_key_value (
+			priv->summary, priv->folder_id, "etag", NULL);
+		tmp = e_book_backend_sqlitedb_get_key_value (
+			priv->summary, priv->folder_id, "seq", NULL);
+		if (tmp)
+			old_seq = strtoul(tmp, NULL, 10);
+		else
+			is_populated = FALSE;
+		g_free (tmp);
+	}
+
 	if (!e_ews_connection_get_oal_detail_sync (
-		oab_cnc, priv->folder_id, "Full", &full_l,
+		oab_cnc, priv->folder_id, NULL, old_etag, &full_l, &etag,
 		priv->cancellable, &error)) {
 		ret = FALSE;
 		goto exit;
@@ -1937,41 +2033,71 @@ ebews_start_gal_sync (gpointer data)
 	if (full_l == NULL)
 		goto exit;
 
-	full = (EwsOALDetails *) full_l->data;
-	/* TODO fetch differential updates if available instead of downloading the whole GAL */
-	if (!e_book_backend_sqlitedb_get_is_populated (priv->summary, priv->folder_id, NULL) || ews_gal_needs_update (cbews, full, &error)) {
-		gchar *seq;
+	while (full_l) {
+		EwsOALDetails *det = full_l->data;
 
-		d (printf ("Ewsgal: Downloading full gal \n");)
-		uncompressed_filename = ews_download_full_gal (cbews, full, priv->cancellable, &error);
-		if (error) {
-			ret = FALSE;
-			goto exit;
+		/* Throw away anything older than we already have */
+		if (det->seq <= old_seq) {
+			ews_oal_details_free (det);
+		} else if (!strcmp (det->type, "Full")) {
+			if (full)
+				ews_oal_details_free (full);
+			full = det;
+		} else if (is_populated && !strcmp (det->type, "Diff")) {
+			delta_size += det->size;
+			deltas = g_slist_insert_sorted (deltas, det, det_sort_func);
+		} else {
+			ews_oal_details_free (det);
 		}
+		full_l = g_slist_remove (full_l, det);
+	}
 
-		d (printf ("Ewsgal: Removing old gal \n");)
-		/* remove old_gal_file */
-		ret = ews_remove_old_gal_file (cbews, &error);
-		if (!ret) {
-			goto exit;
-		}
+	if (!full)
+		goto exit;
 
-		d (printf ("Ewsgal: Replacing old gal with new gal contents in db \n");)
-		ret = ews_replace_gal_in_db (cbews, uncompressed_filename, priv->cancellable, &error);
-		if (!ret)
-			goto exit;
+	/* If the deltas would be bigger, just download the new full file */
+	if (delta_size > full->size) {
+		g_slist_free_full (deltas, (GDestroyNotify) ews_oal_details_free);
+		deltas = NULL;
+	}
 
-		seq = g_strdup_printf ("%"G_GUINT32_FORMAT, full->seq);
-		ret = e_book_backend_sqlitedb_set_key_value (priv->summary, priv->folder_id, "seq", seq, &error);
-		g_free (seq);
+	uncompressed_filename = ews_download_gal (cbews, full, deltas, old_seq, priv->cancellable, &error);
+	if (!uncompressed_filename) {
+		ret = FALSE;
+		goto exit;
+	}
 
-		if (!ret) {
-			e_book_backend_sqlitedb_delete_addressbook (priv->summary, priv->folder_id, &error);
-			goto exit;
-		}
+	d (printf ("Ewsgal: Removing old gal \n");)
+	/* remove old_gal_file */
+	ret = ews_remove_old_gal_file (cbews, &error);
+	if (!ret) {
+		goto exit;
+	}
+
+	d (printf ("Ewsgal: Replacing old gal with new gal contents in db \n");)
+	ret = ews_replace_gal_in_db (cbews, uncompressed_filename, priv->cancellable, &error);
+	if (!ret)
+		goto exit;
+
+	e_book_backend_sqlitedb_set_key_value (priv->summary, priv->folder_id, "etag", etag ? etag : "", NULL);
+	if (e_book_backend_sqlitedb_set_key_value (priv->summary, priv->folder_id,
+						   "oab-filename", uncompressed_filename,
+						   NULL)) {
+		/* Don't let it get deleted */
+		g_free (uncompressed_filename);
+		uncompressed_filename = NULL;
 	}
 
-	d (printf ("Ews gal: sync successfull complete \n");)
+	seq = g_strdup_printf ("%"G_GUINT32_FORMAT, full->seq);
+	ret = e_book_backend_sqlitedb_set_key_value (priv->summary, priv->folder_id, "seq", seq, &error);
+	g_free (seq);
+
+	if (!ret) {
+		e_book_backend_sqlitedb_delete_addressbook (priv->summary, priv->folder_id, &error);
+		goto exit;
+	}
+
+	d (printf ("Ews gal: sync successful complete \n");)
 
 exit:
 	if (error) {
@@ -1979,18 +2105,21 @@ exit:
 		g_clear_error (&error);
 	}
 
+	g_free (old_etag);
+	g_free (etag);
+
 	/* preserve  the oab file once we are able to decode the differential updates */
 	if (uncompressed_filename) {
 		g_unlink (uncompressed_filename);
 		g_free (uncompressed_filename);
 	}
 
-	if (full_l) {
-		g_free (full->sha);
-		g_free (full->filename);
-		g_free (full);
-		g_slist_free (full_l);
-	}
+	if (full)
+		ews_oal_details_free (full);
+	if (deltas)
+		g_slist_free_full (deltas, (GDestroyNotify) ews_oal_details_free);
+	if (full_l)
+		g_slist_free_full (full_l, (GDestroyNotify) ews_oal_details_free);
 
 	g_object_unref (oab_cnc);
 	return ret;
@@ -2909,23 +3036,23 @@ e_book_backend_ews_get_supported_fields 
 
 	for (i = 0; i < G_N_ELEMENTS (mappings); i++)
 		if (mappings[i].element_type == ELEMENT_TYPE_SIMPLE)
-			fields = g_list_append (fields, g_strdup (e_contact_field_name (mappings[i].field_id)));
+			fields = g_list_append (fields, (gpointer) e_contact_field_name (mappings[i].field_id));
 
 	for (i = 0; i < G_N_ELEMENTS (phone_field_map); i++)
-		fields = g_list_append (fields, g_strdup (e_contact_field_name (phone_field_map[i].field)));
+		fields = g_list_append (fields, (gpointer) e_contact_field_name (phone_field_map[i].field));
 
-	fields = g_list_append (fields, g_strdup (e_contact_field_name (E_CONTACT_FULL_NAME)));
-	fields = g_list_append (fields, g_strdup (e_contact_field_name (E_CONTACT_NICKNAME)));
-	fields = g_list_append (fields, g_strdup (e_contact_field_name (E_CONTACT_FAMILY_NAME)));
-	fields = g_list_append (fields, g_strdup (e_contact_field_name (E_CONTACT_EMAIL_1)));
-	fields = g_list_append (fields, g_strdup (e_contact_field_name (E_CONTACT_EMAIL_2)));
-	fields = g_list_append (fields, g_strdup (e_contact_field_name (E_CONTACT_EMAIL_3)));
-	fields = g_list_append (fields, g_strdup (e_contact_field_name (E_CONTACT_ADDRESS_WORK)));
-	fields = g_list_append (fields, g_strdup (e_contact_field_name (E_CONTACT_ADDRESS_HOME)));
-	fields = g_list_append (fields, g_strdup (e_contact_field_name (E_CONTACT_ADDRESS_OTHER)));
-	fields = g_list_append (fields, g_strdup (e_contact_field_name (E_CONTACT_BIRTH_DATE)));
+	fields = g_list_append (fields, (gpointer) e_contact_field_name (E_CONTACT_FULL_NAME));
+	fields = g_list_append (fields, (gpointer) e_contact_field_name (E_CONTACT_NICKNAME));
+	fields = g_list_append (fields, (gpointer) e_contact_field_name (E_CONTACT_FAMILY_NAME));
+	fields = g_list_append (fields, (gpointer) e_contact_field_name (E_CONTACT_EMAIL_1));
+	fields = g_list_append (fields, (gpointer) e_contact_field_name (E_CONTACT_EMAIL_2));
+	fields = g_list_append (fields, (gpointer) e_contact_field_name (E_CONTACT_EMAIL_3));
+	fields = g_list_append (fields, (gpointer) e_contact_field_name (E_CONTACT_ADDRESS_WORK));
+	fields = g_list_append (fields, (gpointer) e_contact_field_name (E_CONTACT_ADDRESS_HOME));
+	fields = g_list_append (fields, (gpointer) e_contact_field_name (E_CONTACT_ADDRESS_OTHER));
+	fields = g_list_append (fields, (gpointer) e_contact_field_name (E_CONTACT_BIRTH_DATE));
 
-	fields = g_list_append (fields, g_strdup (e_contact_field_name (E_CONTACT_NOTE)));
+	fields = g_list_append (fields, (gpointer) e_contact_field_name (E_CONTACT_NOTE));
 
 	e_data_book_respond_get_supported_fields (book, opid, EDB_ERROR (SUCCESS), fields);
 
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/ews-oab-decoder.c.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/ews-oab-decoder.c
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/ews-oab-decoder.c.sync-with-3.8.4	2013-07-24 07:30:27.253435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/ews-oab-decoder.c	2013-07-24 07:30:27.298435567 +0200
@@ -33,6 +33,8 @@
 #include "ews-oab-decoder.h"
 #include "ews-oab-props.h"
 
+#include "server/e-ews-gnome-3-8-compat.h"
+
 G_DEFINE_TYPE (EwsOabDecoder, ews_oab_decoder, G_TYPE_OBJECT)
 
 #define d(x)
@@ -142,6 +144,22 @@ ews_populate_string_list (EContact *cont
 }
 
 static void
+ews_populate_cert (EContact *contact,
+                    EContactField field,
+                    gpointer value,
+                    gpointer user_data)
+{
+	GSList *list = value;
+	GBytes *bytes = list->data;
+	EContactCert cert;
+
+	cert.data = (gpointer) g_bytes_get_data (bytes, &cert.length);
+	cert.length = g_bytes_get_size (bytes);
+
+	e_contact_set (contact, E_CONTACT_X509_CERT, &cert);
+}
+
+static void
 ews_populate_photo (EContact *contact,
                     EContactField field,
                     gpointer value,
@@ -214,7 +232,10 @@ static const struct prop_field_mapping {
 	{EWS_PT_PAGER_NUMBER, E_CONTACT_PHONE_PAGER, ews_populate_simple_string},
 	{EWS_PT_COMMENT, E_CONTACT_NOTE, ews_populate_simple_string},
 	{EWS_PT_DL_MEMBERS, E_CONTACT_EMAIL, ews_populate_string_list},
-	{EWS_PT_THUMBNAIL_PHOTO, E_CONTACT_PHOTO, ews_populate_photo}
+	{EWS_PT_THUMBNAIL_PHOTO, E_CONTACT_PHOTO, ews_populate_photo},
+	{EWS_PT_OFFICE_LOCATION, E_CONTACT_OFFICE, ews_populate_simple_string},
+	{EWS_PT_X509_CERT, E_CONTACT_X509_CERT, ews_populate_cert},
+	{EWS_PT_SEND_RICH_INFO, E_CONTACT_WANTS_HTML, ews_populate_simple_string},
 };
 
 static void
@@ -382,14 +403,16 @@ ews_oab_read_upto (GInputStream *is,
 	GString *str;
 
 	str = g_string_sized_new (size);
-	do {
+	while (1) {
 		gsize len;
 		gsize bytes_read;
 		gchar *c = g_malloc0 (size);
 
-		g_input_stream_read_all (is, c, size, &bytes_read, cancellable, error);
-		if (*error)
+		if (!g_input_stream_read_all (is, c, size, &bytes_read,
+					      cancellable, error)) {
+			g_free (c);
 			break;
+		}
 
 		if (bytes_read != size)
 			size = bytes_read;
@@ -398,6 +421,8 @@ ews_oab_read_upto (GInputStream *is,
 		if (len)
 			str = g_string_append_len (str, c, len);
 
+		g_free (c);
+
 		if (len == 0 || len < size) {
 			goffset seek = (goffset) len + 1 - (goffset) size;
 
@@ -407,8 +432,7 @@ ews_oab_read_upto (GInputStream *is,
 		}
 
 		size *= 2;
-		g_free (c);
-	} while (!*error);
+	}
 
 	return g_string_free (str, FALSE);
 }
@@ -592,35 +616,31 @@ ews_decode_uint32 (EwsOabDecoder *eod,
 	return ret;
 }
 
-static gchar *
+static GBytes *
 ews_decode_binary (EwsOabDecoder *eod,
                    GCancellable *cancellable,
                    GError **error)
 {
 	EwsOabDecoderPrivate *priv = GET_PRIVATE (eod);
 	guint32 len;
-	gchar *binary, *filename = NULL;
-	gint fd = 0;
+	gchar *binary;
+	GBytes *val = NULL;
 
 	len = ews_decode_uint32 (eod, cancellable, error);
 	if (*error)
 		return NULL;
-
 	binary = g_malloc (len);
 	g_input_stream_read (G_INPUT_STREAM (priv->fis), binary, len, cancellable, error);
-	if (*error)
+	if (*error) {
+		g_free (binary);
 		goto exit;
+	}
 
-	filename = g_build_filename (priv->cache_dir, "XXXXXX", NULL);
-	fd = g_mkstemp (filename);
-	g_file_set_contents (filename, binary, len, error);
+	val = g_bytes_new_take (binary, len);
+	binary = NULL;
 
 exit:
-	if (binary)
-		g_free (binary);
-	close (fd);
-
-	return filename;
+	return val;
 }
 
 static gpointer
@@ -671,7 +691,7 @@ ews_decode_oab_prop (EwsOabDecoder *eod,
 		case EWS_PTYP_BINARY:
 		{
 			ret_val = ews_decode_binary (eod, cancellable, error);
-			d (g_print ("prop id %X prop type: binary value %s \n", prop_id, (gchar *) ret_val);)
+			d (g_print ("prop id %X prop type: binary size %zd \n", prop_id, g_bytes_get_size ((GBytes *)ret_val)));
 			break;
 		}
 		case EWS_PTYP_MULTIPLEINTEGER32:
@@ -702,23 +722,35 @@ ews_decode_oab_prop (EwsOabDecoder *eod,
 						g_slist_free (list);
 						return NULL;
 					}
-				} else {
-					gchar *val;
+				} else if (prop_type == EWS_PTYP_MULTIPLEBINARY) {
+					GBytes *val;
 
-					if (prop_type == EWS_PTYP_MULTIPLEBINARY) {
-						val = ews_decode_binary (eod, cancellable, error);
-					} else {
-						val = ews_oab_read_upto (G_INPUT_STREAM (priv->fis), '\0', cancellable, error);
+					val = ews_decode_binary (eod, cancellable, error);
+					if (!val) {
+						g_slist_foreach (list, (GFunc) g_bytes_unref, NULL);
+						g_slist_free (list);
+						return NULL;
 					}
 
-					if (*error) {
+					d (g_print ("prop id %X prop type: multi-bin size %zd\n", prop_id, g_bytes_get_size (val)));
+
+					list = g_slist_prepend (list, val);
+				} else {
+					gchar *val;
+
+					val = ews_oab_read_upto (G_INPUT_STREAM (priv->fis), '\0', cancellable, error);
+					if (!val) {
 						g_slist_foreach (list, (GFunc) g_free, NULL);
 						g_slist_free (list);
 						return NULL;
 					}
+
+					d (g_print ("prop id %X prop type: multi-str '%s'\n", prop_id, val));
+					list = g_slist_prepend (list, val);
 				}
 
 			}
+			ret_val = list;
 
 			break;
 		}
@@ -731,9 +763,7 @@ ews_decode_oab_prop (EwsOabDecoder *eod,
 }
 
 static void
-ews_destroy_oab_prop (guint32 prop_id,
-                      gpointer val,
-                      gboolean delete_files)
+ews_destroy_oab_prop (guint32 prop_id, gpointer val)
 {
 	guint32 prop_type;
 
@@ -743,14 +773,17 @@ ews_destroy_oab_prop (guint32 prop_id,
 		case EWS_PTYP_INTEGER32:
 		case EWS_PTYP_BOOLEAN:
 			break;
+		case EWS_PTYP_BINARY:
+			g_bytes_unref(val);
+			break;
 		case EWS_PTYP_STRING8:
 		case EWS_PTYP_STRING:
-		case EWS_PTYP_BINARY:
 			g_free ((gchar *) val);
 			break;
 		case EWS_PTYP_MULTIPLEBINARY:
-			if (delete_files)
-				g_slist_foreach ((GSList *) val, (GFunc) g_unlink, NULL);
+			g_slist_foreach ((GSList *) val, (GFunc) g_bytes_unref, NULL);
+			g_slist_free ((GSList *) val);
+			break;
 		case EWS_PTYP_MULTIPLESTRING8:
 		case EWS_PTYP_MULTIPLESTRING:
 			g_slist_foreach ((GSList *) val, (GFunc) g_free, NULL);
@@ -821,10 +854,7 @@ ews_decode_addressbook_record (EwsOabDec
 			else
 				prop_map[i - 1].defered_populate_function (dset, prop_id, val);
 		}
-
-		/* delete the binary file if we do not have the property in the index or if there
-		 * was an error */
-		ews_destroy_oab_prop (prop_id, val, (*error || !index) ? TRUE : FALSE);
+		ews_destroy_oab_prop (prop_id, val);
 		if (*error)
 			goto exit;
 	}
@@ -1064,78 +1094,3 @@ ews_oab_decoder_get_contact_from_offset 
 	return contact;
 }
 
-#ifdef TEST_BUILD
-
-struct _db_data {
-	GSList *contact_collector;
-	guint collected_length;
-	EBookBackendSqliteDB *summary;
-	const gchar *folderid;
-};
-
-static void
-ews_test_store_contact (EContact *contact,
-                        goffset offset,
-                        guint percent,
-                        gpointer user_data,
-                        GError **error)
-{
-	struct _db_data *data = (struct _db_data *) user_data;
-
-	data->contact_collector = g_slist_prepend (data->contact_collector, g_object_ref (contact));
-	data->collected_length += 1;
-
-	if (data->collected_length == 1000 || percent >= 100) {
-		data->contact_collector = g_slist_reverse (data->contact_collector);
-		e_book_backend_sqlitedb_add_contacts (data->summary, data->folderid, data->contact_collector, FALSE, error);
-		g_print ("percent complete %d \n", percent);
-
-		g_slist_foreach (data->contact_collector, (GFunc) g_object_unref, NULL);
-		g_slist_free (data->contact_collector);
-		data->contact_collector = NULL;
-		data->collected_length = 0;
-	}
-}
-
-gint
-main (gint argc,
-      gchar *argv[])
-{
-	EBookBackendSqliteDB *summary;
-	EwsOabDecoder *eod;
-	GError *err = NULL;
-	GTimer *timer;
-	struct _db_data data;
-
-	g_type_init ();
-
-	if (argc != 3) {
-		g_print ("Pass the oab filename  and cache dir as argument \n");
-		return -1;
-	}
-
-	summary = e_book_backend_sqlitedb_new (argv[2], "dum", "de", "dum", TRUE, NULL);
-	eod = ews_oab_decoder_new (argv[1], argv[2], &err);
-
-	data.contact_collector = NULL;
-	data.collected_length = 0;
-	data.summary = summary;
-	data.folderid = "de";
-
-	timer = g_timer_new ();
-	g_timer_start (timer);
-	if (!ews_oab_decoder_decode (eod, ews_test_store_contact, &data, NULL, &err)) {
-		g_print ("Unable to decode %s \n", err->message);
-	}
-	g_timer_stop (timer);
-	g_print ("Time elapsed %lf \n", g_timer_elapsed (timer, NULL));
-
-	if (err)
-		g_clear_error (&err);
-
-	g_object_unref (eod);
-	g_object_unref (summary);
-
-	return 0;
-}
-#endif /* TEST_BUILD */
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/ews-oab-decompress.c.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/ews-oab-decompress.c
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/ews-oab-decompress.c.sync-with-3.8.4	2013-07-24 07:30:27.297435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/ews-oab-decompress.c	2013-07-24 07:30:27.297435567 +0200
@@ -0,0 +1,84 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/* e-book-backend-ews.h - Ews contact backend.
+ *
+ * Copyright (C) 1999-2008 Novell, Inc. (www.novell.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU Lesser General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <glib.h>
+#include "ews-oab-decompress.h"
+#include <mspack.h>
+
+/* This contains the minimal implementation of these functions, for use with
+   a sufficiently up-to-date version of libmspack. For the full implementation
+   for use without libmspack, see the lzx/ directory. */
+
+gboolean
+ews_oab_decompress_full (const gchar *filename, const gchar *output_filename,
+			 GError **error)
+{
+	struct msoab_decompressor *msoab;
+	int ret;
+
+	msoab = mspack_create_oab_decompressor (NULL);
+	if (!msoab) {
+		g_set_error_literal (error, g_quark_from_string ("lzx"), 1,
+				     "Unable to create msoab decompressor");
+		return FALSE;
+	}
+	ret = msoab->decompress (msoab, filename, output_filename);
+	mspack_destroy_oab_decompressor (msoab);
+	if (ret != MSPACK_ERR_OK) {
+		g_set_error (error, g_quark_from_string ("lzx"), 1,
+			     "Failed to decompress LZX file: %d", ret);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+
+gboolean
+ews_oab_decompress_patch (const gchar *filename, const gchar *orig_filename,
+			  const gchar *output_filename, GError **error)
+{
+	struct msoab_decompressor *msoab;
+	int ret;
+
+	msoab = mspack_create_oab_decompressor (NULL);
+	if (!msoab) {
+		g_set_error_literal (error, g_quark_from_string ("lzx"), 1,
+				     "Unable to create msoab decompressor");
+		return FALSE;
+	}
+	ret = msoab->decompress_incremental (msoab, filename,
+					     orig_filename, output_filename);
+	mspack_destroy_oab_decompressor (msoab);
+	if (ret != MSPACK_ERR_OK) {
+		g_set_error (error, g_quark_from_string ("lzx"), 1,
+			     "Failed to apply LZX patch file: %d", ret);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/ews-oab-decompress.h.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/ews-oab-decompress.h
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/ews-oab-decompress.h.sync-with-3.8.4	2013-07-24 07:30:27.298435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/ews-oab-decompress.h	2013-07-24 07:30:27.298435567 +0200
@@ -0,0 +1,36 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/* ews-oal-decompress.h - Ews contact backend.
+ *
+ * Copyright (C) 1999-2008 Novell, Inc. (www.novell.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU Lesser General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#ifndef __EWS_OAB_DECOMPRESS_H__
+#define __EWS_OAB_DECOMPRESS_H__
+
+#include <glib.h>
+
+gboolean ews_oab_decompress_full (const gchar *filename,
+				  const gchar *output_filename,
+				  GError **error);
+gboolean ews_oab_decompress_patch (const gchar *filename,
+				   const gchar *orig_filename,
+				   const gchar *output_filename,
+				   GError **error);
+
+#endif
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/ews-oab-props.h.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/ews-oab-props.h
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/ews-oab-props.h.sync-with-3.8.4	2013-07-24 07:30:27.253435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/ews-oab-props.h	2013-07-24 07:30:27.298435567 +0200
@@ -74,5 +74,7 @@
 #define EWS_PT_MEMBER_OF_DLS		0x8008101E
 #define EWS_PT_TRUNCATED_PROPS		0x68051003
 #define EWS_PT_THUMBNAIL_PHOTO		0x8C9E0102
+#define EWS_PT_X509_CERT		0x8c6a1102
+#define EWS_PT_SEND_RICH_INFO		0x3a40000b
 
 #endif /* _EWS_OAB_PROPS */
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/gal-lzx-decompress-test.c.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/gal-lzx-decompress-test.c
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/gal-lzx-decompress-test.c.sync-with-3.8.4	2013-07-24 07:30:27.308435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/gal-lzx-decompress-test.c	2013-07-24 07:30:27.308435567 +0200
@@ -0,0 +1,31 @@
+
+#include "ews-oab-decompress.h"
+#include <glib.h>
+
+gint
+main (gint argc, gchar *argv[])
+{
+	GError *error = NULL;
+
+	if (argc != 3 && argc != 4) {
+		g_print ("Pass an lzx file and an output filename as argument \n");
+		return -1;
+	}
+
+	if (argc == 4) {
+		g_print("Applying binary patch %s to %s to create %s\n",
+			argv[1], argv[2], argv[3]);
+		if (ews_oab_decompress_patch (argv[1], argv[2], argv[3], &error))
+			g_print("Successfully applied\n");
+		else
+			g_print("apply failed: %s\n", error->message);
+	} else
+
+
+	if (ews_oab_decompress_full (argv[1], argv[2], &error))
+		g_print ("Successfully decompressed \n");
+	else
+		g_print ("decompression failed: %s\n", error->message);
+
+	return 0;
+}
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/ews-oal-decompress.c.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/ews-oal-decompress.c
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/ews-oal-decompress.c.sync-with-3.8.4	2013-07-24 07:30:27.287435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/ews-oal-decompress.c	2013-07-24 07:30:27.303435567 +0200
@@ -1,263 +1 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
 
-/* e-book-backend-ews.h - Ews contact backend.
- *
- * Copyright (C) 1999-2008 Novell, Inc. (www.novell.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of version 2 of the GNU Lesser General Public
- * License as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this program; if not, write to the
- * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301, USA.
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <sys/types.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <math.h>
-#include <unistd.h>
-#include <glib.h>
-#include <glib/gstdio.h>
-#include "lzx.h"
-#include "ews-oal-decompress.h"
-
-/* endian-neutral reading of little-endian data */
-#define __egi32(a,n) ( ((((unsigned char *) a)[n+3]) << 24) | \
-                       ((((guchar *) a)[n + 2]) << 16) | \
-                       ((((guchar *) a)[n + 1]) <<  8) | \
-                       ((((guchar *) a)[n + 0])))
-#define EndGetI64(a) ((((unsigned long long int) __egi32(a,4)) << 32) | \
-                      ((guint) __egi32 (a,0)))
-#define EndGetI32(a) __egi32(a,0)
-#define EndGetI16(a) ((((a)[1])<<8)|((a)[0]))
-
-typedef struct {
-	guint32 h_version;
-	guint32 l_version;
-	guint32 max_block_size;
-	guint32 target_size;
-} LzxHeader;
-
-typedef struct {
-	guint32 flags;
-	guint32 comp_size;
-	guint32 ucomp_size;
-	guint32 crc;
-} LzxBlockHeader;
-
-static gboolean
-read_uint32 (FILE *input,
-             guint32 *val)
-{
-	gchar buf[4];
-
-	if (fread (buf, 1, 4, input) == 4) {
-		*val = EndGetI32 (buf);
-		return TRUE;
-	} else
-		return FALSE;
-}
-
-static LzxHeader *
-read_headers (FILE *input,
-              GError **error)
-{
-	LzxHeader *lzx_h;
-	gboolean success;
-
-	lzx_h = g_new0 (LzxHeader, 1);
-
-	success = read_uint32 (input, &lzx_h->h_version);
-	if (!success)
-		goto exit;
-	success = read_uint32 (input, &lzx_h->l_version);
-	if (!success)
-		goto exit;
-
-	if (lzx_h->h_version !=  0x00000003 || lzx_h->l_version != 0x00000001) {
-		g_free (lzx_h);
-		/* set the right domain later */
-		g_set_error_literal (error, g_quark_from_string ("lzx"), 1, "wrong version header");
-		return NULL;
-	}
-
-	success = read_uint32 (input, &lzx_h->max_block_size);
-	if (!success)
-		goto exit;
-	success = read_uint32 (input, &lzx_h->target_size);
-	if (!success)
-		goto exit;
-
-exit:
-	if (!success) {
-		/* set the right domain later */
-		g_set_error_literal (error, g_quark_from_string ("lzx"), 1, "Unable to read lzx main header");
-
-		g_free (lzx_h);
-		lzx_h = NULL;
-	}
-
-	return lzx_h;
-}
-
-static LzxBlockHeader *
-read_block_header (FILE *input,
-                   GError **error)
-{
-	LzxBlockHeader *lzx_b;
-	gboolean success;
-
-	lzx_b = g_new0 (LzxBlockHeader, 1);
-
-	success = read_uint32 (input, &lzx_b->flags);
-	if (!success)
-		goto exit;
-
-	success = read_uint32 (input, &lzx_b->comp_size);
-	if (!success)
-		goto exit;
-
-	success = read_uint32 (input, &lzx_b->ucomp_size);
-	if (!success)
-		goto exit;
-
-	success = read_uint32 (input, &lzx_b->crc);
-
-exit:
-	if (!success) {
-		/* set the right domain later */
-		g_set_error_literal (error, g_quark_from_string ("lzx"), 1, "Unable to read lzx block header");
-
-		g_free (lzx_b);
-		lzx_b = NULL;
-	}
-
-	return	lzx_b;
-}
-
-gboolean
-oal_decompress_v4_full_detail_file (const gchar *filename,
-                                    const gchar *output_filename,
-                                    GError **error)
-{
-	LzxHeader *lzx_h = NULL;
-	guint total_decomp_size = 0;
-	FILE *input, *output = NULL;
-	gboolean ret = TRUE;
-	GError *err = NULL;
-
-	input = fopen (filename, "rb");
-	if (!input) {
-		g_set_error_literal (&err, g_quark_from_string ("lzx"), 1, "unable to open the input file");
-		ret = FALSE;
-		goto exit;
-	}
-
-	output = fopen (output_filename, "wb");
-	if (!input) {
-		g_set_error_literal (&err, g_quark_from_string ("lzx"), 1, "unable to open the output file");
-		ret = FALSE;
-		goto exit;
-	}
-
-	lzx_h = read_headers (input, &err);
-	if (!lzx_h) {
-		ret = FALSE;
-		goto exit;
-	}
-
-	/* TODO decompressing multiple lzx_blocks has not been tested yet. Will need to get a setup and test it. */
-	do {
-		LzxBlockHeader *lzx_b;
-		struct lzxd_stream *lzs;
-		goffset offset;
-
-		lzx_b = read_block_header (input, &err);
-		if (err) {
-			ret = FALSE;
-			goto exit;
-		}
-
-		/* note the file offset */
-		offset = ftell (input);
-
-		/* lzx_b points to 1, write it directly to file */
-		if (lzx_b->flags == 0) {
-			gchar *buffer = g_malloc0 (lzx_b->ucomp_size);
-
-			if (!(fread (buffer, 1, lzx_b->ucomp_size, input) == lzx_b->ucomp_size &&
-				fwrite (buffer, 1, lzx_b->ucomp_size, output) == lzx_b->ucomp_size)) {
-				g_set_error_literal (&err, g_quark_from_string ("lzx"), 1, "failed to write data in output file");
-				g_free (buffer);
-				ret = FALSE;
-				goto exit;
-			}
-			g_free (buffer);
-		} else {
-			/* The window size should be the smallest power of two between 2^17 and 2^25 that is
-			   greater than or equal to the sum of the size of the reference data rounded up to
-			   a multiple of 32768 and the size of the subject data. Since we have no reference
-			   data, forget that and the rounding. Just the smallest power of two which is large
-			   enough to cover the subject data (lzx_b->ucomp_size). */
-
-			guint window_bits = g_bit_nth_msf(lzx_b->ucomp_size - 1, -1) + 1;
-
-			if (window_bits < 17)
-				window_bits = 17;
-			else if (window_bits > 25)
-				window_bits = 25;
-
-			lzs = lzxd_init (input, output, window_bits,
-					 0, 16, lzx_b->ucomp_size, 1);
-			if (!lzs) {
-				g_set_error_literal (&err, g_quark_from_string ("lzx"), 1, "decompression failed (lzxd_init)");
-				ret = FALSE;
-				goto exit;
-			}
-
-			if (lzxd_decompress (lzs, lzs->length) != LZX_ERR_OK) {
-				g_set_error_literal (&err, g_quark_from_string ("lzx"), 1, "decompression failed (lzxd_decompress)");
-				ret = FALSE;
-				goto exit;
-			}
-		}
-
-		/* Set the fp to beggining of next block. This is a HACK, looks like decompress reads beyond the block.
-		 * Since we can identify the next block start from block header, we just reset the offset */
-		offset += lzx_b->comp_size;
-		fseek (input, offset, SEEK_SET);
-
-		total_decomp_size += lzx_b->ucomp_size;
-		g_free (lzx_b);
-	} while (total_decomp_size < lzx_h->target_size);
-
-exit:
-	if (input)
-		fclose (input);
-
-	if (output)
-		fclose (output);
-
-	if (err) {
-		ret = FALSE;
-		g_propagate_error (error, err);
-		g_unlink (output_filename);
-	}
-
-	g_free (lzx_h);
-
-	return ret;
-}
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/ews-oal-decompress.h.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/ews-oal-decompress.h
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/ews-oal-decompress.h.sync-with-3.8.4	2013-05-17 14:36:16.000000000 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/ews-oal-decompress.h	2013-07-24 07:30:27.299435567 +0200
@@ -1,31 +1 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
 
-/* ews-oal-decompress.h - Ews contact backend.
- *
- * Copyright (C) 1999-2008 Novell, Inc. (www.novell.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of version 2 of the GNU Lesser General Public
- * License as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this program; if not, write to the
- * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301, USA.
- *
- */
-
-#ifndef __EWS_OAL_DECOMPRESS_H__
-#define __EWS_OAL_DECOMPRESS_H__
-
-#include <glib.h>
-
-gboolean
-oal_decompress_v4_full_detail_file (const gchar *filename, const gchar *output_filename, GError **error);
-
-#endif
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/lzxd.c.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/lzxd.c
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/lzxd.c.sync-with-3.8.4	2013-07-24 07:30:27.287435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/lzxd.c	2013-07-24 07:30:27.300435567 +0200
@@ -1,886 +1 @@
-/* This file is part of libmspack.
- * (C) 2003-2013 Stuart Caie.
- *
- * The LZX method was created by Jonathan Forbes and Tomi Poutanen, adapted
- * by Microsoft Corporation.
- *
- * libmspack is free software; you can redistribute it and/or modify it under
- * the terms of the GNU Lesser General Public License (LGPL) version 2.1
- *
- * For further details, see the file COPYING.LIB distributed with libmspack
- */
 
-/* LZX decompression implementation */
-
-#include "lzx.h"
-
-/* Microsoft's LZX document (in cab-sdk.exe) and their implementation
- * of the com.ms.util.cab Java package do not concur.
- *
- * In the LZX document, there is a table showing the correlation between
- * window size and the number of position slots. It states that the 1MB
- * window = 40 slots and the 2MB window = 42 slots. In the implementation,
- * 1MB = 42 slots, 2MB = 50 slots. The actual calculation is 'find the
- * first slot whose position base is equal to or more than the required
- * window size'. This would explain why other tables in the document refer
- * to 50 slots rather than 42.
- *
- * The constant NUM_PRIMARY_LENGTHS used in the decompression pseudocode
- * is not defined in the specification.
- *
- * The LZX document does not state the uncompressed block has an
- * uncompressed length field. Where does this length field come from, so
- * we can know how large the block is? The implementation has it as the 24
- * bits following after the 3 blocktype bits, before the alignment
- * padding.
- *
- * The LZX document states that aligned offset blocks have their aligned
- * offset huffman tree AFTER the main and length trees. The implementation
- * suggests that the aligned offset tree is BEFORE the main and length
- * trees.
- *
- * The LZX document decoding algorithm states that, in an aligned offset
- * block, if an extra_bits value is 1, 2 or 3, then that number of bits
- * should be read and the result added to the match offset. This is
- * correct for 1 and 2, but not 3, where just a huffman symbol (using the
- * aligned tree) should be read.
- *
- * Regarding the E8 preprocessing, the LZX document states 'No translation
- * may be performed on the last 6 bytes of the input block'. This is
- * correct.  However, the pseudocode provided checks for the *E8 leader*
- * up to the last 6 bytes. If the leader appears between -10 and -7 bytes
- * from the end, this would cause the next four bytes to be modified, at
- * least one of which would be in the last 6 bytes, which is not allowed
- * according to the spec.
- *
- * The specification states that the huffman trees must always contain at
- * least one element. However, many CAB files contain blocks where the
- * length tree is completely empty (because there are no matches), and
- * this is expected to succeed.
- *
- * The errors in LZX documentation appear have been corrected in the
- * new documentation for the LZX DELTA format.
- *
- *     http://msdn.microsoft.com/en-us/library/cc483133.aspx
- *
- * However, this is a different format, an extension of regular LZX.
- * I have noticed the following differences, there may be more:
- *
- * The maximum window size has increased from 2MB to 32MB. This also
- * increases the maximum number of position slots, etc.
- *
- * If the match length is 257 (the maximum possible), this signals
- * a further length decoding step, that allows for matches up to
- * 33024 bytes long.
- *
- * The format now allows for "reference data", supplied by the caller.
- * If match offsets go further back than the number of bytes
- * decompressed so far, that is them accessing the reference data.
- */
-
-/* import bit-reading macros and code */
-#define BITS_TYPE struct lzxd_stream
-#define BITS_VAR lzx
-#define BITS_ORDER_MSB
-#define READ_BYTES do {			\
-    unsigned char b0, b1;		\
-    READ_IF_NEEDED; b0 = *i_ptr++;	\
-    READ_IF_NEEDED; b1 = *i_ptr++;	\
-    INJECT_BITS((b1 << 8) | b0, 16);	\
-} while (0)
-#include "readbits.h"
-
-/* import huffman-reading macros and code */
-#define TABLEBITS(tbl)      LZX_##tbl##_TABLEBITS
-#define MAXSYMBOLS(tbl)     LZX_##tbl##_MAXSYMBOLS
-#define HUFF_TABLE(tbl,idx) lzx->tbl##_table[idx]
-#define HUFF_LEN(tbl,idx)   lzx->tbl##_len[idx]
-#define HUFF_ERROR          return lzx->error = LZX_ERR_DECRUNCH
-#include "readhuff.h"
-
-/* BUILD_TABLE(tbl) builds a huffman lookup table from code lengths */
-#define BUILD_TABLE(tbl)						\
-    if (make_decode_table(MAXSYMBOLS(tbl), TABLEBITS(tbl),		\
-			  &HUFF_LEN(tbl,0), &HUFF_TABLE(tbl,0)))	\
-    {									\
-        D(("failed to build %s table", #tbl))				\
-	return lzx->error = LZX_ERR_DECRUNCH;			\
-    }
-
-#define BUILD_TABLE_MAYBE_EMPTY(tbl) do {				\
-    lzx->tbl##_empty = 0;						\
-    if (make_decode_table(MAXSYMBOLS(tbl), TABLEBITS(tbl),		\
-                          &HUFF_LEN(tbl,0), &HUFF_TABLE(tbl,0)))	\
-    {									\
-	for (i = 0; i < MAXSYMBOLS(tbl); i++) {				\
-	    if (HUFF_LEN(tbl, i) > 0) {					\
-		D(("failed to build %s table", #tbl))			\
-		return lzx->error = LZX_ERR_DECRUNCH;		\
-	    }								\
-	}								\
-	/* empty tree - allow it, but don't decode symbols with it */	\
-	lzx->tbl##_empty = 1;						\
-    }									\
-} while (0)
-
-/* READ_LENGTHS(tablename, first, last) reads in code lengths for symbols
- * first to last in the given table. The code lengths are stored in their
- * own special LZX way.
- */
-#define READ_LENGTHS(tbl, first, last) do {		\
-  STORE_BITS;						\
-  if (lzxd_read_lens(lzx, &HUFF_LEN(tbl, 0), (first),	\
-    (unsigned int)(last))) return lzx->error;		\
-  RESTORE_BITS;						\
-} while (0)
-
-static int lzxd_read_lens(struct lzxd_stream *lzx, unsigned char *lens,
-			  unsigned int first, unsigned int last)
-{
-  /* bit buffer and huffman symbol decode variables */
-  register unsigned int bit_buffer;
-  register int bits_left, i;
-  register unsigned short sym;
-  unsigned char *i_ptr, *i_end;
-
-  unsigned int x, y;
-  int z;
-
-  RESTORE_BITS;
-  
-  /* read lengths for pretree (20 symbols, lengths stored in fixed 4 bits) */
-  for (x = 0; x < 20; x++) {
-    READ_BITS(y, 4);
-    lzx->PRETREE_len[x] = y;
-  }
-  BUILD_TABLE(PRETREE);
-
-  for (x = first; x < last; ) {
-    READ_HUFFSYM(PRETREE, z);
-    if (z == 17) {
-      /* code = 17, run of ([read 4 bits]+4) zeros */
-      READ_BITS(y, 4); y += 4;
-      while (y--) lens[x++] = 0;
-    }
-    else if (z == 18) {
-      /* code = 18, run of ([read 5 bits]+20) zeros */
-      READ_BITS(y, 5); y += 20;
-      while (y--) lens[x++] = 0;
-    }
-    else if (z == 19) {
-      /* code = 19, run of ([read 1 bit]+4) [read huffman symbol] */
-      READ_BITS(y, 1); y += 4;
-      READ_HUFFSYM(PRETREE, z);
-      z = lens[x] - z; if (z < 0) z += 17;
-      while (y--) lens[x++] = z;
-    }
-    else {
-      /* code = 0 to 16, delta current length entry */
-      z = lens[x] - z; if (z < 0) z += 17;
-      lens[x++] = z;
-    }
-  }
-
-  STORE_BITS;
-
-  return LZX_ERR_OK;
-}
-
-/* LZX static data tables:
- *
- * LZX uses 'position slots' to represent match offsets.  For every match,
- * a small 'position slot' number and a small offset from that slot are
- * encoded instead of one large offset.
- *
- * The number of slots is decided by how many are needed to encode the
- * largest offset for a given window size. This is easy when the gap between
- * slots is less than 128Kb, it's a linear relationship. But when extra_bits
- * reaches its limit of 17 (because LZX can only ensure reading 17 bits of
- * data at a time), we can only jump 128Kb at a time and have to start
- * using more and more position slots as each window size doubles.
- *
- * position_base[] is an index to the position slot bases
- *
- * extra_bits[] states how many bits of offset-from-base data is needed.
- *
- * They are calculated as follows:
- * extra_bits[i] = 0 where i < 4
- * extra_bits[i] = floor(i/2)-1 where i >= 4 && i < 36
- * extra_bits[i] = 17 where i >= 36
- * position_base[0] = 0
- * position_base[i] = position_base[i-1] + (1 << extra_bits[i-1])
- */
-static const unsigned int position_slots[11] = {
-    30, 32, 34, 36, 38, 42, 50, 66, 98, 162, 290
-};
-static const unsigned char extra_bits[36] = {
-    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8,
-    9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16
-};
-static const unsigned int position_base[290] = {
-    0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512,
-    768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576, 32768,
-    49152, 65536, 98304, 131072, 196608, 262144, 393216, 524288, 655360,
-    786432, 917504, 1048576, 1179648, 1310720, 1441792, 1572864, 1703936,
-    1835008, 1966080, 2097152, 2228224, 2359296, 2490368, 2621440, 2752512,
-    2883584, 3014656, 3145728, 3276800, 3407872, 3538944, 3670016, 3801088,
-    3932160, 4063232, 4194304, 4325376, 4456448, 4587520, 4718592, 4849664,
-    4980736, 5111808, 5242880, 5373952, 5505024, 5636096, 5767168, 5898240,
-    6029312, 6160384, 6291456, 6422528, 6553600, 6684672, 6815744, 6946816,
-    7077888, 7208960, 7340032, 7471104, 7602176, 7733248, 7864320, 7995392,
-    8126464, 8257536, 8388608, 8519680, 8650752, 8781824, 8912896, 9043968,
-    9175040, 9306112, 9437184, 9568256, 9699328, 9830400, 9961472, 10092544,
-    10223616, 10354688, 10485760, 10616832, 10747904, 10878976, 11010048,
-    11141120, 11272192, 11403264, 11534336, 11665408, 11796480, 11927552,
-    12058624, 12189696, 12320768, 12451840, 12582912, 12713984, 12845056,
-    12976128, 13107200, 13238272, 13369344, 13500416, 13631488, 13762560,
-    13893632, 14024704, 14155776, 14286848, 14417920, 14548992, 14680064,
-    14811136, 14942208, 15073280, 15204352, 15335424, 15466496, 15597568,
-    15728640, 15859712, 15990784, 16121856, 16252928, 16384000, 16515072,
-    16646144, 16777216, 16908288, 17039360, 17170432, 17301504, 17432576,
-    17563648, 17694720, 17825792, 17956864, 18087936, 18219008, 18350080,
-    18481152, 18612224, 18743296, 18874368, 19005440, 19136512, 19267584,
-    19398656, 19529728, 19660800, 19791872, 19922944, 20054016, 20185088,
-    20316160, 20447232, 20578304, 20709376, 20840448, 20971520, 21102592,
-    21233664, 21364736, 21495808, 21626880, 21757952, 21889024, 22020096,
-    22151168, 22282240, 22413312, 22544384, 22675456, 22806528, 22937600,
-    23068672, 23199744, 23330816, 23461888, 23592960, 23724032, 23855104,
-    23986176, 24117248, 24248320, 24379392, 24510464, 24641536, 24772608,
-    24903680, 25034752, 25165824, 25296896, 25427968, 25559040, 25690112,
-    25821184, 25952256, 26083328, 26214400, 26345472, 26476544, 26607616,
-    26738688, 26869760, 27000832, 27131904, 27262976, 27394048, 27525120,
-    27656192, 27787264, 27918336, 28049408, 28180480, 28311552, 28442624,
-    28573696, 28704768, 28835840, 28966912, 29097984, 29229056, 29360128,
-    29491200, 29622272, 29753344, 29884416, 30015488, 30146560, 30277632,
-    30408704, 30539776, 30670848, 30801920, 30932992, 31064064, 31195136,
-    31326208, 31457280, 31588352, 31719424, 31850496, 31981568, 32112640,
-    32243712, 32374784, 32505856, 32636928, 32768000, 32899072, 33030144,
-    33161216, 33292288, 33423360
-};
-
-static void lzxd_reset_state(struct lzxd_stream *lzx) {
-  int i;
-
-  lzx->R0              = 1;
-  lzx->R1              = 1;
-  lzx->R2              = 1;
-  lzx->header_read     = 0;
-  lzx->block_remaining = 0;
-  lzx->block_type      = LZX_BLOCKTYPE_INVALID;
-
-  /* initialise tables to 0 (because deltas will be applied to them) */
-  for (i = 0; i < LZX_MAINTREE_MAXSYMBOLS; i++) lzx->MAINTREE_len[i] = 0;
-  for (i = 0; i < LZX_LENGTH_MAXSYMBOLS; i++)   lzx->LENGTH_len[i]   = 0;
-}
-
-/*-------- main LZX code --------*/
-
-struct lzxd_stream *lzxd_init(FILE *input,
-			      FILE *output,
-			      int window_bits,
-			      int reset_interval,
-			      int input_buffer_size,
-			      off_t output_length,
-			      char is_delta)
-{
-  unsigned int window_size = 1 << window_bits;
-  struct lzxd_stream *lzx;
-
-  /* LZX DELTA window sizes are between 2^17 (128KiB) and 2^25 (32MiB),
-   * regular LZX windows are between 2^15 (32KiB) and 2^21 (2MiB)
-   */
-  if (is_delta) {
-      if (window_bits < 17 || window_bits > 25) return NULL;
-  }
-  else {
-      if (window_bits < 15 || window_bits > 21) return NULL;
-  }
-
-  input_buffer_size = (input_buffer_size + 1) & -2;
-  if (!input_buffer_size) return NULL;
-
-  /* allocate decompression state */
-  if (!(lzx = (struct lzxd_stream *) malloc(sizeof(struct lzxd_stream)))) {
-    return NULL;
-  }
-
-  /* allocate decompression window and input buffer */
-  lzx->window = (unsigned char *) malloc((size_t) window_size);
-  lzx->inbuf  = (unsigned char *) malloc((size_t) input_buffer_size);
-  if (!lzx->window || !lzx->inbuf) {
-    free(lzx->window);
-    free(lzx->inbuf);
-    free(lzx);
-    return NULL;
-  }
-
-  /* initialise decompression state */
-  lzx->input           = input;
-  lzx->output          = output;
-  lzx->offset          = 0;
-  lzx->length          = output_length;
-
-  lzx->inbuf_size      = input_buffer_size;
-  lzx->window_size     = 1 << window_bits;
-  lzx->ref_data_size   = 0;
-  lzx->window_posn     = 0;
-  lzx->frame_posn      = 0;
-  lzx->frame           = 0;
-  lzx->reset_interval  = reset_interval;
-  lzx->intel_filesize  = 0;
-  lzx->intel_curpos    = 0;
-  lzx->intel_started   = 0;
-  lzx->error           = LZX_ERR_OK;
-  lzx->num_offsets     = position_slots[window_bits - 15] << 3;
-  lzx->is_delta        = is_delta;
-
-  lzx->o_ptr = lzx->o_end = &lzx->e8_buf[0];
-  lzxd_reset_state(lzx);
-  INIT_BITS;
-  return lzx;
-}
-
-int lzxd_set_reference_data(struct lzxd_stream *lzx,
-			    FILE *input,
-			    unsigned int length)
-{
-    if (!lzx) return LZX_ERR_ARGS;
-
-    if (!lzx->is_delta) {
-        D(("only LZX DELTA streams support reference data"))
-        return LZX_ERR_ARGS;
-    }
-    if (lzx->offset) {
-	D(("too late to set reference data after decoding starts"))
-	return LZX_ERR_ARGS;
-    }
-    if (length > lzx->window_size) {
-	D(("reference length (%u) is longer than the window", length))
-	return LZX_ERR_ARGS;
-    }
-    if (length > 0 && (!input)) {
-        D(("length > 0 but no input"))
-        return LZX_ERR_ARGS;
-    }
-
-    lzx->ref_data_size = length;
-    if (length > 0) {
-        /* copy reference data */
-        unsigned char *pos = &lzx->window[lzx->window_size - length];
-	int bytes = fread(pos, 1, length, input);
-	if (bytes < length) return LZX_ERR_READ;
-    }
-    lzx->ref_data_size = length;
-    return LZX_ERR_OK;
-}
-
-void lzxd_set_output_length(struct lzxd_stream *lzx, off_t out_bytes) {
-  if (lzx) lzx->length = out_bytes;
-}
-
-int lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes) {
-  /* bitstream and huffman reading variables */
-  register unsigned int bit_buffer;
-  register int bits_left, i=0;
-  unsigned char *i_ptr, *i_end;
-  register unsigned short sym;
-
-  int match_length, length_footer, extra, verbatim_bits, bytes_todo;
-  int this_run, main_element, aligned_bits, j;
-  unsigned char *window, *runsrc, *rundest, buf[12];
-  unsigned int frame_size=0, end_frame, match_offset, window_posn;
-  unsigned int R0, R1, R2;
-
-  /* easy answers */
-  if (!lzx || (out_bytes < 0)) return LZX_ERR_ARGS;
-  if (lzx->error) return lzx->error;
-
-  /* flush out any stored-up bytes before we begin */
-  i = lzx->o_end - lzx->o_ptr;
-  if ((off_t) i > out_bytes) i = (int) out_bytes;
-  if (i) {
-    if (fwrite(lzx->o_ptr, 1, i, lzx->output) != i) {
-      return lzx->error = LZX_ERR_WRITE;
-    }
-    lzx->o_ptr  += i;
-    lzx->offset += i;
-    out_bytes   -= i;
-  }
-  if (out_bytes == 0) return LZX_ERR_OK;
-
-  /* restore local state */
-  RESTORE_BITS;
-  window = lzx->window;
-  window_posn = lzx->window_posn;
-  R0 = lzx->R0;
-  R1 = lzx->R1;
-  R2 = lzx->R2;
-
-  end_frame = (unsigned int)((lzx->offset + out_bytes) / LZX_FRAME_SIZE) + 1;
-
-  while (lzx->frame < end_frame) {
-    /* have we reached the reset interval? (if there is one?) */
-    if (lzx->reset_interval && ((lzx->frame % lzx->reset_interval) == 0)) {
-      if (lzx->block_remaining) {
-	D(("%d bytes remaining at reset interval", lzx->block_remaining))
-	return lzx->error = LZX_ERR_DECRUNCH;
-      }
-
-      /* re-read the intel header and reset the huffman lengths */
-      lzxd_reset_state(lzx);
-      R0 = lzx->R0;
-      R1 = lzx->R1;
-      R2 = lzx->R2;
-    }
-
-    /* LZX DELTA format has chunk_size, not present in LZX format */
-    if (lzx->is_delta) {
-      ENSURE_BITS(16);
-      REMOVE_BITS(16);
-    }
-
-    /* read header if necessary */
-    if (!lzx->header_read) {
-      /* read 1 bit. if bit=0, intel filesize = 0.
-       * if bit=1, read intel filesize (32 bits) */
-      j = 0; READ_BITS(i, 1); if (i) { READ_BITS(i, 16); READ_BITS(j, 16); }
-      lzx->intel_filesize = (i << 16) | j;
-      lzx->header_read = 1;
-    } 
-
-    /* calculate size of frame: all frames are 32k except the final frame
-     * which is 32kb or less. this can only be calculated when lzx->length
-     * has been filled in. */
-    frame_size = LZX_FRAME_SIZE;
-    if (lzx->length && (lzx->length - lzx->offset) < (off_t)frame_size) {
-      frame_size = lzx->length - lzx->offset;
-    }
-
-    /* decode until one more frame is available */
-    bytes_todo = lzx->frame_posn + frame_size - window_posn;
-    while (bytes_todo > 0) {
-      /* initialise new block, if one is needed */
-      if (lzx->block_remaining == 0) {
-	/* realign if previous block was an odd-sized UNCOMPRESSED block */
-	if ((lzx->block_type == LZX_BLOCKTYPE_UNCOMPRESSED) &&
-	    (lzx->block_length & 1))
-	{
-	  READ_IF_NEEDED;
-	  i_ptr++;
-	}
-
-	/* read block type (3 bits) and block length (24 bits) */
-	READ_BITS(lzx->block_type, 3);
-	READ_BITS(i, 16); READ_BITS(j, 8);
-	lzx->block_remaining = lzx->block_length = (i << 8) | j;
-	/*D(("new block t%d len %u", lzx->block_type, lzx->block_length))*/
-
-	/* read individual block headers */
-	switch (lzx->block_type) {
-	case LZX_BLOCKTYPE_ALIGNED:
-	  /* read lengths of and build aligned huffman decoding tree */
-	  for (i = 0; i < 8; i++) { READ_BITS(j, 3); lzx->ALIGNED_len[i] = j; }
-	  BUILD_TABLE(ALIGNED);
-	  /* no break -- rest of aligned header is same as verbatim */
-	case LZX_BLOCKTYPE_VERBATIM:
-	  /* read lengths of and build main huffman decoding tree */
-	  READ_LENGTHS(MAINTREE, 0, 256);
-	  READ_LENGTHS(MAINTREE, 256, LZX_NUM_CHARS + lzx->num_offsets);
-	  BUILD_TABLE(MAINTREE);
-	  /* if the literal 0xE8 is anywhere in the block... */
-	  if (lzx->MAINTREE_len[0xE8] != 0) lzx->intel_started = 1;
-	  /* read lengths of and build lengths huffman decoding tree */
-	  READ_LENGTHS(LENGTH, 0, LZX_NUM_SECONDARY_LENGTHS);
-	  BUILD_TABLE_MAYBE_EMPTY(LENGTH);
-	  break;
-
-	case LZX_BLOCKTYPE_UNCOMPRESSED:
-	  /* because we can't assume otherwise */
-	  lzx->intel_started = 1;
-
-	  /* read 1-16 (not 0-15) bits to align to bytes */
-	  ENSURE_BITS(16);
-	  if (bits_left > 16) i_ptr -= 2;
-	  bits_left = 0; bit_buffer = 0;
-
-	  /* read 12 bytes of stored R0 / R1 / R2 values */
-	  for (rundest = &buf[0], i = 0; i < 12; i++) {
-	    READ_IF_NEEDED;
-	    *rundest++ = *i_ptr++;
-	  }
-	  R0 = buf[0] | (buf[1] << 8) | (buf[2]  << 16) | (buf[3]  << 24);
-	  R1 = buf[4] | (buf[5] << 8) | (buf[6]  << 16) | (buf[7]  << 24);
-	  R2 = buf[8] | (buf[9] << 8) | (buf[10] << 16) | (buf[11] << 24);
-	  break;
-
-	default:
-	  D(("bad block type"))
-	  return lzx->error = LZX_ERR_DECRUNCH;
-	}
-      }
-
-      /* decode more of the block:
-       * run = min(what's available, what's needed) */
-      this_run = lzx->block_remaining;
-      if (this_run > bytes_todo) this_run = bytes_todo;
-
-      /* assume we decode exactly this_run bytes, for now */
-      bytes_todo           -= this_run;
-      lzx->block_remaining -= this_run;
-
-      /* decode at least this_run bytes */
-      switch (lzx->block_type) {
-      case LZX_BLOCKTYPE_VERBATIM:
-	while (this_run > 0) {
-	  READ_HUFFSYM(MAINTREE, main_element);
-	  if (main_element < LZX_NUM_CHARS) {
-	    /* literal: 0 to LZX_NUM_CHARS-1 */
-	    window[window_posn++] = main_element;
-	    this_run--;
-	  }
-	  else {
-	    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */
-	    main_element -= LZX_NUM_CHARS;
-
-	    /* get match length */
-	    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;
-	    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {
-	      if (lzx->LENGTH_empty) {
-                D(("LENGTH symbol needed but tree is empty"))
-                return lzx->error = LZX_ERR_DECRUNCH;
-              }
-	      READ_HUFFSYM(LENGTH, length_footer);
-	      match_length += length_footer;
-	    }
-	    match_length += LZX_MIN_MATCH;
-
-	    /* get match offset */
-	    switch ((match_offset = (main_element >> 3))) {
-	    case 0: match_offset = R0;                                  break;
-	    case 1: match_offset = R1; R1=R0;        R0 = match_offset; break;
-	    case 2: match_offset = R2; R2=R0;        R0 = match_offset; break;
-	    case 3: match_offset = 1;  R2=R1; R1=R0; R0 = match_offset; break;
-	    default:
-	      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];
-	      READ_BITS(verbatim_bits, extra);
-	      match_offset = position_base[match_offset] - 2 + verbatim_bits;
-	      R2 = R1; R1 = R0; R0 = match_offset;
-	    }
-
-	    /* LZX DELTA uses max match length to signal even longer match */
-	    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {
-		int extra_len = 0;
-		ENSURE_BITS(3); /* 4 entry huffman tree */
-		if (PEEK_BITS(1) == 0) {
-		    REMOVE_BITS(1); /* '0' -> 8 extra length bits */
-		    READ_BITS(extra_len, 8);
-		}
-		else if (PEEK_BITS(2) == 2) {
-		    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */
-		    READ_BITS(extra_len, 10);
-		    extra_len += 0x100;
-		}
-		else if (PEEK_BITS(3) == 6) {
-		    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */
-		    READ_BITS(extra_len, 12);
-		    extra_len += 0x500;
-		}
-		else {
-		    REMOVE_BITS(3); /* '111' -> 15 extra length bits */
-		    READ_BITS(extra_len, 15);
-		}
-		match_length += extra_len;
-	    }
-
-	    if ((window_posn + match_length) > lzx->window_size) {
-	      D(("match ran over window wrap"))
-	      return lzx->error = LZX_ERR_DECRUNCH;
-	    }
-	    
-	    /* copy match */
-	    rundest = &window[window_posn];
-	    i = match_length;
-	    /* does match offset wrap the window? */
-	    if (match_offset > window_posn) {
-	      if (match_offset > lzx->offset &&
-		  (match_offset - window_posn) > lzx->ref_data_size)
-	      {
-		D(("match offset beyond LZX stream"))
-		return lzx->error = LZX_ERR_DECRUNCH;
-	      }
-	      /* j = length from match offset to end of window */
-	      j = match_offset - window_posn;
-	      if (j > (int) lzx->window_size) {
-		D(("match offset beyond window boundaries"))
-		return lzx->error = LZX_ERR_DECRUNCH;
-	      }
-	      runsrc = &window[lzx->window_size - j];
-	      if (j < i) {
-		/* if match goes over the window edge, do two copy runs */
-		i -= j; while (j-- > 0) *rundest++ = *runsrc++;
-		runsrc = window;
-	      }
-	      while (i-- > 0) *rundest++ = *runsrc++;
-	    }
-	    else {
-	      runsrc = rundest - match_offset;
-	      while (i-- > 0) *rundest++ = *runsrc++;
-	    }
-
-	    this_run    -= match_length;
-	    window_posn += match_length;
-	  }
-	} /* while (this_run > 0) */
-	break;
-
-      case LZX_BLOCKTYPE_ALIGNED:
-	while (this_run > 0) {
-	  READ_HUFFSYM(MAINTREE, main_element);
-	  if (main_element < LZX_NUM_CHARS) {
-	    /* literal: 0 to LZX_NUM_CHARS-1 */
-	    window[window_posn++] = main_element;
-	    this_run--;
-	  }
-	  else {
-	    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */
-	    main_element -= LZX_NUM_CHARS;
-
-	    /* get match length */
-	    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;
-	    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {
-              if (lzx->LENGTH_empty) {
-                D(("LENGTH symbol needed but tree is empty"))
-                return lzx->error = LZX_ERR_DECRUNCH;
-              } 
-	      READ_HUFFSYM(LENGTH, length_footer);
-	      match_length += length_footer;
-	    }
-	    match_length += LZX_MIN_MATCH;
-
-	    /* get match offset */
-	    switch ((match_offset = (main_element >> 3))) {
-	    case 0: match_offset = R0;                             break;
-	    case 1: match_offset = R1; R1 = R0; R0 = match_offset; break;
-	    case 2: match_offset = R2; R2 = R0; R0 = match_offset; break;
-	    default:
-	      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];
-	      match_offset = position_base[match_offset] - 2;
-	      if (extra > 3) {
-		/* verbatim and aligned bits */
-		extra -= 3;
-		READ_BITS(verbatim_bits, extra);
-		match_offset += (verbatim_bits << 3);
-		READ_HUFFSYM(ALIGNED, aligned_bits);
-		match_offset += aligned_bits;
-	      }
-	      else if (extra == 3) {
-		/* aligned bits only */
-		READ_HUFFSYM(ALIGNED, aligned_bits);
-		match_offset += aligned_bits;
-	      }
-	      else if (extra > 0) { /* extra==1, extra==2 */
-		/* verbatim bits only */
-		READ_BITS(verbatim_bits, extra);
-		match_offset += verbatim_bits;
-	      }
-	      else /* extra == 0 */ {
-		/* ??? not defined in LZX specification! */
-		match_offset = 1;
-	      }
-	      /* update repeated offset LRU queue */
-	      R2 = R1; R1 = R0; R0 = match_offset;
-	    }
-
-	    /* LZX DELTA uses max match length to signal even longer match */
-	    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {
-		int extra_len = 0;
-		ENSURE_BITS(3); /* 4 entry huffman tree */
-		if (PEEK_BITS(1) == 0) {
-		    REMOVE_BITS(1); /* '0' -> 8 extra length bits */
-		    READ_BITS(extra_len, 8);
-		}
-		else if (PEEK_BITS(2) == 2) {
-		    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */
-		    READ_BITS(extra_len, 10);
-		    extra_len += 0x100;
-		}
-		else if (PEEK_BITS(3) == 6) {
-		    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */
-		    READ_BITS(extra_len, 12);
-		    extra_len += 0x500;
-		}
-		else {
-		    REMOVE_BITS(3); /* '111' -> 15 extra length bits */
-		    READ_BITS(extra_len, 15);
-		}
-		match_length += extra_len;
-	    }
-
-	    if ((window_posn + match_length) > lzx->window_size) {
-	      D(("match ran over window wrap"))
-	      return lzx->error = LZX_ERR_DECRUNCH;
-	    }
-
-	    /* copy match */
-	    rundest = &window[window_posn];
-	    i = match_length;
-	    /* does match offset wrap the window? */
-	    if (match_offset > window_posn) {
-	      if (match_offset > lzx->offset &&
-		  (match_offset - window_posn) > lzx->ref_data_size)
-	      {
-		D(("match offset beyond LZX stream"))
-		return lzx->error = LZX_ERR_DECRUNCH;
-	      }
-	      /* j = length from match offset to end of window */
-	      j = match_offset - window_posn;
-	      if (j > (int) lzx->window_size) {
-		D(("match offset beyond window boundaries"))
-		return lzx->error = LZX_ERR_DECRUNCH;
-	      }
-	      runsrc = &window[lzx->window_size - j];
-	      if (j < i) {
-		/* if match goes over the window edge, do two copy runs */
-		i -= j; while (j-- > 0) *rundest++ = *runsrc++;
-		runsrc = window;
-	      }
-	      while (i-- > 0) *rundest++ = *runsrc++;
-	    }
-	    else {
-	      runsrc = rundest - match_offset;
-	      while (i-- > 0) *rundest++ = *runsrc++;
-	    }
-
-	    this_run    -= match_length;
-	    window_posn += match_length;
-	  }
-	} /* while (this_run > 0) */
-	break;
-
-      case LZX_BLOCKTYPE_UNCOMPRESSED:
-	/* as this_run is limited not to wrap a frame, this also means it
-	 * won't wrap the window (as the window is a multiple of 32k) */
-	rundest = &window[window_posn];
-	window_posn += this_run;
-	while (this_run > 0) {
-	  if ((i = i_end - i_ptr) == 0) {
-	    READ_IF_NEEDED;
-	  }
-	  else {
-	    if (i > this_run) i = this_run;
-	    memcpy(rundest, i_ptr, (size_t) i);
-	    rundest  += i;
-	    i_ptr    += i;
-	    this_run -= i;
-	  }
-	}
-	break;
-
-      default:
-	return lzx->error = LZX_ERR_DECRUNCH; /* might as well */
-      }
-
-      /* did the final match overrun our desired this_run length? */
-      if (this_run < 0) {
-	if ((unsigned int)(-this_run) > lzx->block_remaining) {
-	  D(("overrun went past end of block by %d (%d remaining)",
-	     -this_run, lzx->block_remaining ))
-	  return lzx->error = LZX_ERR_DECRUNCH;
-	}
-	lzx->block_remaining -= -this_run;
-      }
-    } /* while (bytes_todo > 0) */
-
-    /* streams don't extend over frame boundaries */
-    if ((window_posn - lzx->frame_posn) != frame_size) {
-      D(("decode beyond output frame limits! %d != %d",
-	 window_posn - lzx->frame_posn, frame_size))
-      return lzx->error = LZX_ERR_DECRUNCH;
-    }
-
-    /* re-align input bitstream */
-    if (bits_left > 0) ENSURE_BITS(16);
-    if (bits_left & 15) REMOVE_BITS(bits_left & 15);
-
-    /* check that we've used all of the previous frame first */
-    if (lzx->o_ptr != lzx->o_end) {
-      D(("%ld avail bytes, new %d frame", lzx->o_end-lzx->o_ptr, frame_size))
-      return lzx->error = LZX_ERR_DECRUNCH;
-    }
-
-    /* does this intel block _really_ need decoding? */
-    if (lzx->intel_started && lzx->intel_filesize &&
-	(lzx->frame <= 32768) && (frame_size > 10))
-    {
-      unsigned char *data    = &lzx->e8_buf[0];
-      unsigned char *dataend = &lzx->e8_buf[frame_size - 10];
-      signed int curpos      = lzx->intel_curpos;
-      signed int filesize    = lzx->intel_filesize;
-      signed int abs_off, rel_off;
-
-      /* copy e8 block to the e8 buffer and tweak if needed */
-      lzx->o_ptr = data;
-      memcpy(data, &lzx->window[lzx->frame_posn], frame_size);
-
-      while (data < dataend) {
-	if (*data++ != 0xE8) { curpos++; continue; }
-	abs_off = data[0] | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);
-	if ((abs_off >= -curpos) && (abs_off < filesize)) {
-	  rel_off = (abs_off >= 0) ? abs_off - curpos : abs_off + filesize;
-	  data[0] = (unsigned char) rel_off;
-	  data[1] = (unsigned char) (rel_off >> 8);
-	  data[2] = (unsigned char) (rel_off >> 16);
-	  data[3] = (unsigned char) (rel_off >> 24);
-	}
-	data += 4;
-	curpos += 5;
-      }
-      lzx->intel_curpos += frame_size;
-    }
-    else {
-      lzx->o_ptr = &lzx->window[lzx->frame_posn];
-      if (lzx->intel_filesize) lzx->intel_curpos += frame_size;
-    }
-    lzx->o_end = &lzx->o_ptr[frame_size];
-
-    /* write a frame */
-    i = (out_bytes < (off_t)frame_size) ? (unsigned int)out_bytes : frame_size;
-    if (fwrite(lzx->o_ptr, 1, i, lzx->output) != i) {
-      return lzx->error = LZX_ERR_WRITE;
-    }
-    lzx->o_ptr  += i;
-    lzx->offset += i;
-    out_bytes   -= i;
-
-    /* advance frame start position */
-    lzx->frame_posn += frame_size;
-    lzx->frame++;
-
-    /* wrap window / frame position pointers */
-    if (window_posn == lzx->window_size)     window_posn = 0;
-    if (lzx->frame_posn == lzx->window_size) lzx->frame_posn = 0;
-
-  } /* while (lzx->frame < end_frame) */
-
-  if (out_bytes) {
-    D(("bytes left to output"))
-    return lzx->error = LZX_ERR_DECRUNCH;
-  }
-
-  /* store local state */
-  STORE_BITS;
-  lzx->window_posn = window_posn;
-  lzx->R0 = R0;
-  lzx->R1 = R1;
-  lzx->R2 = R2;
-
-  return LZX_ERR_OK;
-}
-
-void lzxd_free(struct lzxd_stream *lzx) {
-  if (lzx) {
-    free(lzx->inbuf);
-    free(lzx->window);
-    free(lzx);
-  }
-}
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/lzx.h.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/lzx.h
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/lzx.h.sync-with-3.8.4	2013-07-24 07:30:27.288435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/lzx.h	2013-07-24 07:30:27.302435567 +0200
@@ -1,239 +1 @@
-/* This file is part of libmspack.
- * (C) 2003-2013 Stuart Caie.
- *
- * The LZX method was created by Jonathan Forbes and Tomi Poutanen, adapted
- * by Microsoft Corporation.
- *
- * libmspack is free software; you can redistribute it and/or modify it under
- * the terms of the GNU Lesser General Public License (LGPL) version 2.1
- *
- * For further details, see the file COPYING.LIB distributed with libmspack
- */
 
-#ifndef LZX_H
-#define LZX_H 1
-
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#define D(x) do { printf("%s:%d (%s) \n",__FILE__, __LINE__, __func__); \
-                   printf x ; fputc('\n', stdout); fflush(stdout);} while (0);
-
-/* LZX compression / decompression definitions */
-
-/* some constants defined by the LZX specification */
-#define LZX_MIN_MATCH                (2)
-#define LZX_MAX_MATCH                (257)
-#define LZX_NUM_CHARS                (256)
-#define LZX_BLOCKTYPE_INVALID        (0)   /* also blocktypes 4-7 invalid */
-#define LZX_BLOCKTYPE_VERBATIM       (1)
-#define LZX_BLOCKTYPE_ALIGNED        (2)
-#define LZX_BLOCKTYPE_UNCOMPRESSED   (3)
-#define LZX_PRETREE_NUM_ELEMENTS     (20)
-#define LZX_ALIGNED_NUM_ELEMENTS     (8)   /* aligned offset tree #elements */
-#define LZX_NUM_PRIMARY_LENGTHS      (7)   /* this one missing from spec! */
-#define LZX_NUM_SECONDARY_LENGTHS    (249) /* length tree #elements */
-
-/* LZX huffman defines: tweak tablebits as desired */
-#define LZX_PRETREE_MAXSYMBOLS  (LZX_PRETREE_NUM_ELEMENTS)
-#define LZX_PRETREE_TABLEBITS   (6)
-#define LZX_MAINTREE_MAXSYMBOLS (LZX_NUM_CHARS + 290*8)
-#define LZX_MAINTREE_TABLEBITS  (12)
-#define LZX_LENGTH_MAXSYMBOLS   (LZX_NUM_SECONDARY_LENGTHS+1)
-#define LZX_LENGTH_TABLEBITS    (12)
-#define LZX_ALIGNED_MAXSYMBOLS  (LZX_ALIGNED_NUM_ELEMENTS)
-#define LZX_ALIGNED_TABLEBITS   (7)
-#define LZX_LENTABLE_SAFETY (64)  /* table decoding overruns are allowed */
-
-#define LZX_FRAME_SIZE (32768) /* the size of a frame in LZX */
-
-/* --- error codes --------------------------------------------------------- */
-
-/** Error code: no error */
-#define LZX_ERR_OK          (0)
-/** Error code: bad arguments to method */
-#define LZX_ERR_ARGS        (1)
-/** Error code: error opening file */
-#define LZX_ERR_OPEN        (2)
-/** Error code: error reading file */
-#define LZX_ERR_READ        (3)
-/** Error code: error writing file */
-#define LZX_ERR_WRITE       (4)
-/** Error code: seek error */
-#define LZX_ERR_SEEK        (5)
-/** Error code: out of memory */
-#define LZX_ERR_NOMEMORY    (6)
-/** Error code: bad "magic id" in file */
-#define LZX_ERR_SIGNATURE   (7)
-/** Error code: bad or corrupt file format */
-#define LZX_ERR_DATAFORMAT  (8)
-/** Error code: bad checksum or CRC */
-#define LZX_ERR_CHECKSUM    (9)
-/** Error code: error during compression */
-#define LZX_ERR_CRUNCH      (10)
-/** Error code: error during decompression */
-#define LZX_ERR_DECRUNCH    (11)
-
-struct lzxd_stream {
-  FILE   *input;		  /* input file handle                       */
-  FILE  *output;		  /* output file handle                      */
-
-  off_t   offset;                 /* number of bytes actually output         */
-  off_t   length;                 /* overall decompressed length of stream   */
-
-  unsigned char *window;          /* decoding window                         */
-  unsigned int   window_size;     /* window size                             */
-  unsigned int   ref_data_size;   /* LZX DELTA reference data size           */
-  unsigned int   num_offsets;     /* number of match_offset entries in table */
-  unsigned int   window_posn;     /* decompression offset within window      */
-  unsigned int   frame_posn;      /* current frame offset within in window   */
-  unsigned int   frame;           /* the number of 32kb frames processed     */
-  unsigned int   reset_interval;  /* which frame do we reset the compressor? */
-
-  unsigned int   R0, R1, R2;      /* for the LRU offset system               */
-  unsigned int   block_length;    /* uncompressed length of this LZX block   */
-  unsigned int   block_remaining; /* uncompressed bytes still left to decode */
-
-  signed int     intel_filesize;  /* magic header value used for transform   */
-  signed int     intel_curpos;    /* current offset in transform space       */
-
-  unsigned char  intel_started;   /* has intel E8 decoding started?          */
-  unsigned char  block_type;      /* type of the current block               */
-  unsigned char  header_read;     /* have we started decoding at all yet?    */
-  unsigned char  input_end;       /* have we reached the end of input?       */
-  unsigned char  is_delta;        /* does stream follow LZX DELTA spec?      */
-
-  int error;
-
-  /* I/O buffering */
-  unsigned char *inbuf, *i_ptr, *i_end, *o_ptr, *o_end;
-  unsigned int  bit_buffer, bits_left, inbuf_size;
-
-  /* huffman code lengths */
-  unsigned char PRETREE_len  [LZX_PRETREE_MAXSYMBOLS  + LZX_LENTABLE_SAFETY];
-  unsigned char MAINTREE_len [LZX_MAINTREE_MAXSYMBOLS + LZX_LENTABLE_SAFETY];
-  unsigned char LENGTH_len   [LZX_LENGTH_MAXSYMBOLS   + LZX_LENTABLE_SAFETY];
-  unsigned char ALIGNED_len  [LZX_ALIGNED_MAXSYMBOLS  + LZX_LENTABLE_SAFETY];
-
-  /* huffman decoding tables */
-  unsigned short PRETREE_table [(1 << LZX_PRETREE_TABLEBITS) +
-				(LZX_PRETREE_MAXSYMBOLS * 2)];
-  unsigned short MAINTREE_table[(1 << LZX_MAINTREE_TABLEBITS) +
-				(LZX_MAINTREE_MAXSYMBOLS * 2)];
-  unsigned short LENGTH_table  [(1 << LZX_LENGTH_TABLEBITS) +
-				(LZX_LENGTH_MAXSYMBOLS * 2)];
-  unsigned short ALIGNED_table [(1 << LZX_ALIGNED_TABLEBITS) +
-				(LZX_ALIGNED_MAXSYMBOLS * 2)];
-  unsigned char LENGTH_empty;
-
-  /* this is used purely for doing the intel E8 transform */
-  unsigned char  e8_buf[LZX_FRAME_SIZE];
-};
-
-/**
- * Allocates and initialises LZX decompression state for decoding an LZX
- * stream.
- *
- * This routine uses malloc() to allocate memory. If memory
- * allocation fails, or the parameters to this function are invalid,
- * NULL is returned.
- *
- * @param input              an input stream with the LZX data.
- * @param output             an output stream to write the decoded data to.
- * @param window_bits        the size of the decoding window, which must be
- *                           between 15 and 21 inclusive for regular LZX
- *                           data, or between 17 and 25 inclusive for
- *                           LZX DELTA data.
- * @param reset_interval     the interval at which the LZX bitstream is
- *                           reset, in multiples of LZX frames (32678
- *                           bytes), e.g. a value of 2 indicates the input
- *                           stream resets after every 65536 output bytes.
- *                           A value of 0 indicates that the bitstream never
- *                           resets, such as in CAB LZX streams.
- * @param input_buffer_size  the number of bytes to use as an input
- *                           bitstream buffer.
- * @param output_length      the length in bytes of the entirely
- *                           decompressed output stream, if known in
- *                           advance. It is used to correctly perform the
- *                           Intel E8 transformation, which must stop 6
- *                           bytes before the very end of the
- *                           decompressed stream. It is not otherwise used
- *                           or adhered to. If the full decompressed
- *                           length is known in advance, set it here.
- *                           If it is NOT known, use the value 0, and call
- *                           lzxd_set_output_length() once it is
- *                           known. If never set, 4 of the final 6 bytes
- *                           of the output stream may be incorrect.
- * @param is_delta           should be zero for all regular LZX data,
- *                           non-zero for LZX DELTA encoded data.
- * @return a pointer to an initialised lzxd_stream structure, or NULL if
- * there was not enough memory or parameters to the function were wrong.
- */
-extern struct lzxd_stream *lzxd_init(FILE *input,
-				     FILE *output,
-				     int window_bits,
-				     int reset_interval,
-				     int input_buffer_size,
-				     off_t output_length,
-                                     char is_delta);
-
-/* see description of output_length in lzxd_init() */
-extern void lzxd_set_output_length(struct lzxd_stream *lzx,
-				   off_t output_length);
-
-/**
- * Reads LZX DELTA reference data into the window and allows
- * lzxd_decompress() to reference it.
- *
- * Call this before the first call to lzxd_decompress().
-
- * @param lzx    the LZX stream to apply this reference data to
- * @param input  an input file handle to read reference data
- * @param length the length of the reference data. Cannot be longer
- *               than the LZX window size.
- * @return an error code, or LZX_ERR_OK if successful
- */
-extern int lzxd_set_reference_data(struct lzxd_stream *lzx,
-                                   FILE *input,
-                                   unsigned int length);
-
-/**
- * Decompresses entire or partial LZX streams.
- *
- * The number of bytes of data that should be decompressed is given as the
- * out_bytes parameter. If more bytes are decoded than are needed, they
- * will be kept over for a later invocation.
- *
- * The output bytes will be passed to the write() function given in
- * lzxd_init(), using the output file handle given in lzxd_init(). More than
- * one call may be made to write().
-
- * Input bytes will be read in as necessary using the read()
- * function given in lzxd_init(), using the input file handle given in
- * lzxd_init().  This will continue until read() returns 0 bytes,
- * or an error. Errors will be passed out of the function as
- * LZX_ERR_READ errors.  Input streams should convey an "end of input
- * stream" by refusing to supply all the bytes that LZX asks for when they
- * reach the end of the stream, rather than return an error code.
- *
- * If any error code other than LZX_ERR_OK is returned, the stream
- * should be considered unusable and lzxd_decompress() should not be
- * called again on this stream.
- *
- * @param lzx       LZX decompression state, as allocated by lzxd_init().
- * @param out_bytes the number of bytes of data to decompress.
- * @return an error code, or LZX_ERR_OK if successful
- */
-extern int lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes);
-
-/**
- * Frees all state associated with an LZX data stream. This will call
- * free() using the system pointer given in lzxd_init().
- *
- * @param lzx LZX decompression state to free.
- */
-void lzxd_free(struct lzxd_stream *lzx);
-
-#endif
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/Makefile.am.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/Makefile.am
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/Makefile.am.sync-with-3.8.4	2013-07-24 07:30:27.254435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/Makefile.am	2013-07-24 07:30:27.302435567 +0200
@@ -1,26 +0,0 @@
-NULL =
-
-lib_LTLIBRARIES = liblzx.la
-
-liblzx_la_CPPFLAGS = \
-	$(AM_CPPFLAGS) \
-	$(GNOME_PLATFORM_CFLAGS) \
-	$(NULL)
-
-liblzx_la_SOURCES = \
-	lzx.h \
-	ews-oal-decompress.h \
-	lzxd.c \
-	ews-oal-decompress.c \
-	readbits.h \
-	readhuff.h \
-	$(NULL)
-
-liblzx_la_LDFLAGS = $(NO_UNDEFINED)
-
-liblzx_la_LIBADD = \
-	$(GNOME_PLATFORM_LIBS) \
-	$(LIBM) \
-	$(NULL)
-
--include $(top_srcdir)/git.mk
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/readbits.h.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/readbits.h
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/readbits.h.sync-with-3.8.4	2013-07-24 07:30:27.288435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/readbits.h	2013-07-24 07:30:27.301435567 +0200
@@ -1,202 +1 @@
-/* This file is part of libmspack.
- * (C) 2003-2010 Stuart Caie.
- *
- * libmspack is free software; you can redistribute it and/or modify it under
- * the terms of the GNU Lesser General Public License (LGPL) version 2.1
- *
- * For further details, see the file COPYING.LIB distributed with libmspack
- */
 
-#ifndef READBITS_H
-#define READBITS_H 1
-
-/* this header defines macros that read data streams by
- * the individual bits
- *
- * INIT_BITS         initialises bitstream state in state structure
- * STORE_BITS        stores bitstream state in state structure
- * RESTORE_BITS      restores bitstream state from state structure
- * ENSURE_BITS(n)    ensure there are at least N bits in the bit buffer
- * READ_BITS(var,n)  takes N bits from the buffer and puts them in var
- * PEEK_BITS(n)      extracts without removing N bits from the bit buffer
- * REMOVE_BITS(n)    removes N bits from the bit buffer
- *
- * READ_BITS simply calls ENSURE_BITS, PEEK_BITS and REMOVE_BITS,
- * which means it's limited to reading the number of bits you can
- * ensure at any one time. It also fails if asked to read zero bits.
- * If you need to read zero bits, or more bits than can be ensured in
- * one go, use READ_MANY_BITS instead.
- *
- * These macros have variable names baked into them, so to use them
- * you have to define some macros:
- * - BITS_TYPE: the type name of your state structure
- * - BITS_VAR: the variable that points to your state structure
- * - define BITS_ORDER_MSB if bits are read from the MSB, or
- *   define BITS_ORDER_LSB if bits are read from the LSB
- * - READ_BYTES: some code that reads more data into the bit buffer,
- *   it should use READ_IF_NEEDED (calls read_input if the byte buffer
- *   is empty), then INJECT_BITS(data,n) to put data from the byte
- *   buffer into the bit buffer.
- *
- * You also need to define some variables and structure members:
- * - unsigned char *i_ptr;    // current position in the byte buffer
- * - unsigned char *i_end;    // end of the byte buffer
- * - unsigned int bit_buffer; // the bit buffer itself
- * - unsigned int bits_left;  // number of bits remaining
- *
- * If you use read_input() and READ_IF_NEEDED, they also expect these
- * structure members:
- * - unsigned int error;         // to record/return read errors
- * - unsigned char input_end;    // to mark reaching the EOF
- * - unsigned char *inbuf;       // the input byte buffer
- * - unsigned int inbuf_size;    // the size of the input byte buffer
- *
- * Your READ_BYTES implementation should read data from *i_ptr and
- * put them in the bit buffer. READ_IF_NEEDED will call read_input()
- * if i_ptr reaches i_end, and will fill up inbuf and set i_ptr to
- * the start of inbuf and i_end to the end of inbuf.
- *
- * If you're reading in MSB order, the routines work by using the area
- * beyond the MSB and the LSB of the bit buffer as a free source of
- * zeroes when shifting. This avoids having to mask any bits. So we
- * have to know the bit width of the bit buffer variable. We use
- * <limits.h> and CHAR_BIT to find the size of the bit buffer in bits.
- *
- * If you are reading in LSB order, bits need to be masked. Normally
- * this is done by computing the mask: N bits are masked by the value
- * (1<<N)-1). However, you can define BITS_LSB_TABLE to use a lookup
- * table instead of computing this. This adds two new macros,
- * PEEK_BITS_T and READ_BITS_T which work the same way as PEEK_BITS
- * and READ_BITS, except they use this lookup table. This is useful if
- * you need to look up a number of bits that are only known at
- * runtime, so the bit mask can't be turned into a constant by the
- * compiler.
-
- * The bit buffer datatype should be at least 32 bits wide: it must be
- * possible to ENSURE_BITS(17), so it must be possible to add 16 new bits
- * to the bit buffer when the bit buffer already has 1 to 15 bits left.
- */
-
-#ifndef BITS_VAR
-# error "define BITS_VAR as the state structure poiner variable name"
-#endif
-#ifndef BITS_TYPE
-# error "define BITS_TYPE as the state structure type"
-#endif
-#if defined(BITS_ORDER_MSB) && defined(BITS_ORDER_LSB)
-# error "you must define either BITS_ORDER_MSB or BITS_ORDER_LSB"
-#else
-# if !(defined(BITS_ORDER_MSB) || defined(BITS_ORDER_LSB))
-#  error "you must define BITS_ORDER_MSB or BITS_ORDER_LSB"
-# endif
-#endif
-
-# include <limits.h>
-
-#define BITBUF_WIDTH (sizeof(bit_buffer) * CHAR_BIT)
-
-#define INIT_BITS do {				\
-    BITS_VAR->i_ptr      = &BITS_VAR->inbuf[0];	\
-    BITS_VAR->i_end      = &BITS_VAR->inbuf[0];	\
-    BITS_VAR->bit_buffer = 0;			\
-    BITS_VAR->bits_left  = 0;			\
-    BITS_VAR->input_end  = 0;			\
-} while (0)
-
-#define STORE_BITS do {			\
-    BITS_VAR->i_ptr      = i_ptr;	\
-    BITS_VAR->i_end      = i_end;	\
-    BITS_VAR->bit_buffer = bit_buffer;	\
-    BITS_VAR->bits_left  = bits_left;	\
-} while (0)
-
-#define RESTORE_BITS do {		\
-    i_ptr      = BITS_VAR->i_ptr;	\
-    i_end      = BITS_VAR->i_end;	\
-    bit_buffer = BITS_VAR->bit_buffer;	\
-    bits_left  = BITS_VAR->bits_left;	\
-} while (0)
-
-#define ENSURE_BITS(nbits) do {			\
-    while (bits_left < (nbits)) READ_BYTES;	\
-} while (0)
-
-#define READ_BITS(val, nbits) do {		\
-    ENSURE_BITS(nbits);				\
-    (val) = PEEK_BITS(nbits);			\
-    REMOVE_BITS(nbits);				\
-} while (0)
-
-#define READ_MANY_BITS(val, bits) do {				\
-    unsigned char needed = (bits), bitrun;			\
-    (val) = 0;							\
-    while (needed > 0) {					\
-	if (bits_left <= (BITBUF_WIDTH - 16)) READ_BYTES;	\
-	bitrun = (bits_left < needed) ? bits_left : needed;	\
-	(val) = ((val) << bitrun) | PEEK_BITS(bitrun);		\
-	REMOVE_BITS(bitrun);					\
-	needed -= bitrun;					\
-    }								\
-} while (0)
-
-#ifdef BITS_ORDER_MSB
-# define PEEK_BITS(nbits)   (bit_buffer >> (BITBUF_WIDTH - (nbits)))
-# define REMOVE_BITS(nbits) ((bit_buffer <<= (nbits)), (bits_left -= (nbits)))
-# define INJECT_BITS(bitdata,nbits) ((bit_buffer |= \
-    (bitdata) << (BITBUF_WIDTH - (nbits) - bits_left)), (bits_left += (nbits)))
-#else /* BITS_ORDER_LSB */
-# define PEEK_BITS(nbits)   (bit_buffer & ((1 << (nbits))-1))
-# define REMOVE_BITS(nbits) ((bit_buffer >>= (nbits)), (bits_left -= (nbits)))
-# define INJECT_BITS(bitdata,nbits) ((bit_buffer |= \
-    (bitdata) << bits_left), (bits_left += (nbits)))
-#endif
-
-#ifdef BITS_LSB_TABLE
-/* lsb_bit_mask[n] = (1 << n) - 1 */
-static const unsigned short lsb_bit_mask[17] = {
-    0x0000, 0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
-    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
-};
-# define PEEK_BITS_T(nbits) (bit_buffer & lsb_bit_mask[(nbits)])
-# define READ_BITS_T(val, nbits) do {	\
-    ENSURE_BITS(nbits);			\
-    (val) = PEEK_BITS_T(nbits);		\
-    REMOVE_BITS(nbits);			\
-} while (0)
-#endif
-
-#ifndef BITS_NO_READ_INPUT
-# define READ_IF_NEEDED do {		\
-    if (i_ptr >= i_end) {		\
-	if (read_input(BITS_VAR))	\
-	    return BITS_VAR->error;	\
-	i_ptr = BITS_VAR->i_ptr;	\
-	i_end = BITS_VAR->i_end;	\
-    }					\
-} while (0)
-
-static int read_input(BITS_TYPE *p) {
-    int read = fread(p->inbuf, 1, (int)p->inbuf_size, p->input);
-    if (read < 0) return p->error = LZX_ERR_READ;
-
-    /* we might overrun the input stream by asking for bits we don't use,
-     * so fake 2 more bytes at the end of input */
-    if (read == 0) {
-	if (p->input_end) {
-	    D(("out of input bytes"))
-	    return p->error = LZX_ERR_READ;
-	}
-	else {
-	    read = 2;
-	    p->inbuf[0] = p->inbuf[1] = 0;
-	    p->input_end = 1;
-	}
-    }
-
-    /* update i_ptr and i_end */
-    p->i_ptr = &p->inbuf[0];
-    p->i_end = &p->inbuf[read];
-    return LZX_ERR_OK;
-}
-#endif
-#endif
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/readhuff.h.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/readhuff.h
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/readhuff.h.sync-with-3.8.4	2013-07-24 07:30:27.288435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/lzx/readhuff.h	2013-07-24 07:30:27.303435567 +0200
@@ -1,173 +1 @@
-/* This file is part of libmspack.
- * (C) 2003-2010 Stuart Caie.
- *
- * libmspack is free software; you can redistribute it and/or modify it under
- * the terms of the GNU Lesser General Public License (LGPL) version 2.1
- *
- * For further details, see the file COPYING.LIB distributed with libmspack
- */
 
-#ifndef MSPACK_READHUFF_H
-#define MSPACK_READHUFF_H 1
-
-/* This implements a fast Huffman tree decoding system.
- */
-
-#if !(defined(BITS_ORDER_MSB) || defined(BITS_ORDER_LSB))
-# error "readhuff.h is used in conjunction with readbits.h, include that first"
-#endif
-#if !(defined(TABLEBITS) && defined(MAXSYMBOLS))
-# error "define TABLEBITS(tbl) and MAXSYMBOLS(tbl) before using readhuff.h"
-#endif
-#if !(defined(HUFF_TABLE) && defined(HUFF_LEN))
-# error "define HUFF_TABLE(tbl) and HUFF_LEN(tbl) before using readhuff.h"
-#endif
-#ifndef HUFF_ERROR
-# error "define HUFF_ERROR before using readhuff.h"
-#endif
-#ifndef HUFF_MAXBITS
-# define HUFF_MAXBITS 16
-#endif
-
-/* Decodes the next huffman symbol from the input bitstream into var.
- * Do not use this macro on a table unless build_decode_table() succeeded.
- */
-#define READ_HUFFSYM(tbl, var) do {			\
-    ENSURE_BITS(HUFF_MAXBITS);				\
-    sym = HUFF_TABLE(tbl, PEEK_BITS(TABLEBITS(tbl)));	\
-    if (sym >= MAXSYMBOLS(tbl))	HUFF_TRAVERSE(tbl);	\
-    (var) = sym;					\
-    i = HUFF_LEN(tbl, sym);				\
-    REMOVE_BITS(i);					\
-} while (0)
-
-#ifdef BITS_ORDER_LSB
-# define HUFF_TRAVERSE(tbl) do {			\
-    i = TABLEBITS(tbl) - 1;				\
-    do {						\
-	if (i++ > HUFF_MAXBITS) HUFF_ERROR;		\
-	sym = HUFF_TABLE(tbl,				\
-            (sym << 1) | ((bit_buffer >> i) & 1));	\
-    } while (sym >= MAXSYMBOLS(tbl));			\
-} while (0)
-#else
-#define HUFF_TRAVERSE(tbl) do {				\
-    i = 1 << (BITBUF_WIDTH - TABLEBITS(tbl));		\
-    do {						\
-	if ((i >>= 1) == 0) HUFF_ERROR;			\
-	sym = HUFF_TABLE(tbl,				\
-	    (sym << 1) | ((bit_buffer & i) ? 1 : 0));	\
-    } while (sym >= MAXSYMBOLS(tbl));			\
-} while (0)
-#endif
-
-/* make_decode_table(nsyms, nbits, length[], table[])
- *
- * This function was originally coded by David Tritscher.
- * It builds a fast huffman decoding table from
- * a canonical huffman code lengths table.
- *
- * nsyms  = total number of symbols in this huffman tree.
- * nbits  = any symbols with a code length of nbits or less can be decoded
- *          in one lookup of the table.
- * length = A table to get code lengths from [0 to nsyms-1]
- * table  = The table to fill up with decoded symbols and pointers.
- *          Should be ((1<<nbits) + (nsyms*2)) in length.
- *
- * Returns 0 for OK or 1 for error
- */
-static int make_decode_table(unsigned int nsyms, unsigned int nbits,
-			     unsigned char *length, unsigned short *table)
-{
-    register unsigned short sym, next_symbol;
-    register unsigned int leaf, fill;
-#ifdef BITS_ORDER_LSB
-    register unsigned int reverse;
-#endif
-    register unsigned char bit_num;
-    unsigned int pos         = 0; /* the current position in the decode table */
-    unsigned int table_mask  = 1 << nbits;
-    unsigned int bit_mask    = table_mask >> 1; /* don't do 0 length codes */
-
-    /* fill entries for codes short enough for a direct mapping */
-    for (bit_num = 1; bit_num <= nbits; bit_num++) {
-	for (sym = 0; sym < nsyms; sym++) {
-	    if (length[sym] != bit_num) continue;
-#ifdef BITS_ORDER_MSB
-	    leaf = pos;
-#else
-	    /* reverse the significant bits */
-	    fill = length[sym]; reverse = pos >> (nbits - fill); leaf = 0;
-	    do {leaf <<= 1; leaf |= reverse & 1; reverse >>= 1;} while (--fill);
-#endif
-
-	    if((pos += bit_mask) > table_mask) return 1; /* table overrun */
-
-	    /* fill all possible lookups of this symbol with the symbol itself */
-#ifdef BITS_ORDER_MSB
-	    for (fill = bit_mask; fill-- > 0;) table[leaf++] = sym;
-#else
-	    fill = bit_mask; next_symbol = 1 << bit_num;
-	    do { table[leaf] = sym; leaf += next_symbol; } while (--fill);
-#endif
-	}
-	bit_mask >>= 1;
-    }
-
-    /* exit with success if table is now complete */
-    if (pos == table_mask) return 0;
-
-    /* mark all remaining table entries as unused */
-    for (sym = pos; sym < table_mask; sym++) {
-#ifdef BITS_ORDER_MSB
-	table[sym] = 0xFFFF;
-#else
-	reverse = sym; leaf = 0; fill = nbits;
-	do { leaf <<= 1; leaf |= reverse & 1; reverse >>= 1; } while (--fill);
-	table[leaf] = 0xFFFF;
-#endif
-    }
-
-    /* next_symbol = base of allocation for long codes */
-    next_symbol = ((table_mask >> 1) < nsyms) ? nsyms : (table_mask >> 1);
-
-    /* give ourselves room for codes to grow by up to 16 more bits.
-     * codes now start at bit nbits+16 and end at (nbits+16-codelength) */
-    pos <<= 16;
-    table_mask <<= 16;
-    bit_mask = 1 << 15;
-
-    for (bit_num = nbits+1; bit_num <= HUFF_MAXBITS; bit_num++) {
-	for (sym = 0; sym < nsyms; sym++) {
-	    if (length[sym] != bit_num) continue;
-
-#ifdef BITS_ORDER_MSB
-	    leaf = pos >> 16;
-#else
-	    /* leaf = the first nbits of the code, reversed */
-	    reverse = pos >> 16; leaf = 0; fill = nbits;
-	    do {leaf <<= 1; leaf |= reverse & 1; reverse >>= 1;} while (--fill);
-#endif
-	    for (fill = 0; fill < (bit_num - nbits); fill++) {
-		/* if this path hasn't been taken yet, 'allocate' two entries */
-		if (table[leaf] == 0xFFFF) {
-		    table[(next_symbol << 1)     ] = 0xFFFF;
-		    table[(next_symbol << 1) + 1 ] = 0xFFFF;
-		    table[leaf] = next_symbol++;
-		}
-
-		/* follow the path and select either left or right for next bit */
-		leaf = table[leaf] << 1;
-		if ((pos >> (15-fill)) & 1) leaf++;
-	    }
-	    table[leaf] = sym;
-
-	    if ((pos += bit_mask) > table_mask) return 1; /* table overflow */
-	}
-	bit_mask >>= 1;
-    }
-
-    /* full table? */
-    return (pos == table_mask) ? 0 : 1;
-}
-#endif
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/Makefile.am.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/Makefile.am
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/Makefile.am.sync-with-3.8.4	2013-07-24 07:30:27.254435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/Makefile.am	2013-07-24 07:30:27.299435567 +0200
@@ -1,11 +1,17 @@
-SUBDIRS = lzx .
-
 if ENABLE_GTK3
 ebook_backend_LTLIBRARIES = libebookbackendews.la
 else
 extension_LTLIBRARIES = libebookbackendews.la
 endif
 
+if HAVE_MSPACK
+USE_MSPACK_CFLAGS = $(MSPACK_CFLAGS)
+USE_MSPACK_LIBS = $(MSPACK_LIBS)
+MSPACK_SRCS = ews-oab-decompress.c
+else
+MSPACK_SRCS = mspack/lzx.h mspack/lzxd.c mspack/readbits.h mspack/readhuff.h mspack/oab-decompress.c
+endif
+
 libebookbackendews_la_CPPFLAGS = \
 	$(AM_CPPFLAGS)					\
 	-DG_LOG_DOMAIN=\"libebookbackend\"		\
@@ -13,6 +19,7 @@ libebookbackendews_la_CPPFLAGS = \
 	-I$(top_srcdir)/src/addressbook			\
 	-I$(top_srcdir)/src/server	                \
 	-I$(top_srcdir)/src/utils	                \
+	$(USE_MSPACK_CFLAGS)				\
 	$(LIBEBACKEND_CFLAGS)				\
 	$(LIBEDATASERVER_CFLAGS)			\
 	$(LIBEBOOK_CFLAGS)				\
@@ -32,14 +39,16 @@ libebookbackendews_la_SOURCES =			\
 	ews-oab-props.h				\
 	ews-oab-decoder.c			\
 	ews-oab-decoder.h			\
+	ews-oab-decompress.h			\
 	e-book-backend-ews.c			\
 	e-book-backend-ews.h			\
-	e-book-backend-ews-factory.c
+	e-book-backend-ews-factory.c		\
+	$(MSPACK_SRCS)
 
 libebookbackendews_la_LIBADD =					\
 	$(top_builddir)/src/server/libeews-1.2.la		\
 	$(top_builddir)/src/utils/libewsutils.la		\
-	$(top_builddir)/src/addressbook/lzx/liblzx.la		\
+	$(USE_MSPACK_LIBS)					\
 	$(LIBEBACKEND_LIBS)					\
 	$(LIBEDATASERVER_LIBS)					\
 	$(LIBEDATABOOK_LIBS) \
@@ -63,4 +72,40 @@ e_book_backend_sqlitedb_test_SOURCES = e
 e_book_backend_sqlitedb_test_LDADD = 					\
 	$(libebookbackendews_la_LIBADD)
 
+noinst_PROGRAMS = gal-lzx-decompress-test oab-decode-test
+
+oab-decode-test$(EXEEXT): libebookbackendews.la
+
+oab_decode_test_CPPFLAGS = \
+	$(AM_CPPFLAGS) \
+	$(LIBEBOOK_CFLAGS) \
+	$(LIBEDATABOOK_CFLAGS)  \
+	$(GNOME_PLATFORM_CFLAGS) \
+	$(NULL)
+
+oab_decode_test_SOURCES = \
+	oab-decode-test.c
+
+oab_decode_test_LDADD = \
+	$(GNOME_PLATFORM_LIBS) \
+	$(LIBEBOOK_LIBS) \
+	$(LIBEDATABOOK_LIBS)  \
+	$(top_builddir)/src/addressbook/libebookbackendews.la
+	$(NULL)
+
+gal_lzx_decompress_test_CPPFLAGS = \
+	$(AM_CPPFLAGS) \
+	$(GNOME_PLATFORM_CFLAGS) \
+	$(USE_MSPACK_CFLAGS) \
+	$(NULL)
+
+gal_lzx_decompress_test_SOURCES = \
+	gal-lzx-decompress-test.c \
+	$(MSPACK_SRCS)
+
+gal_lzx_decompress_test_LDADD = \
+	$(GNOME_PLATFORM_LIBS) \
+	$(USE_MSPACK_LIBS) \
+	$(NULL)
+
 -include $(top_srcdir)/git.mk
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/lzxd.c.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/lzxd.c
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/lzxd.c.sync-with-3.8.4	2013-07-24 07:30:27.306435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/lzxd.c	2013-07-24 07:30:27.306435567 +0200
@@ -0,0 +1,886 @@
+/* This file is part of libmspack.
+ * (C) 2003-2013 Stuart Caie.
+ *
+ * The LZX method was created by Jonathan Forbes and Tomi Poutanen, adapted
+ * by Microsoft Corporation.
+ *
+ * libmspack is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License (LGPL) version 2.1
+ *
+ * For further details, see the file COPYING.LIB distributed with libmspack
+ */
+
+/* LZX decompression implementation */
+
+#include "lzx.h"
+
+/* Microsoft's LZX document (in cab-sdk.exe) and their implementation
+ * of the com.ms.util.cab Java package do not concur.
+ *
+ * In the LZX document, there is a table showing the correlation between
+ * window size and the number of position slots. It states that the 1MB
+ * window = 40 slots and the 2MB window = 42 slots. In the implementation,
+ * 1MB = 42 slots, 2MB = 50 slots. The actual calculation is 'find the
+ * first slot whose position base is equal to or more than the required
+ * window size'. This would explain why other tables in the document refer
+ * to 50 slots rather than 42.
+ *
+ * The constant NUM_PRIMARY_LENGTHS used in the decompression pseudocode
+ * is not defined in the specification.
+ *
+ * The LZX document does not state the uncompressed block has an
+ * uncompressed length field. Where does this length field come from, so
+ * we can know how large the block is? The implementation has it as the 24
+ * bits following after the 3 blocktype bits, before the alignment
+ * padding.
+ *
+ * The LZX document states that aligned offset blocks have their aligned
+ * offset huffman tree AFTER the main and length trees. The implementation
+ * suggests that the aligned offset tree is BEFORE the main and length
+ * trees.
+ *
+ * The LZX document decoding algorithm states that, in an aligned offset
+ * block, if an extra_bits value is 1, 2 or 3, then that number of bits
+ * should be read and the result added to the match offset. This is
+ * correct for 1 and 2, but not 3, where just a huffman symbol (using the
+ * aligned tree) should be read.
+ *
+ * Regarding the E8 preprocessing, the LZX document states 'No translation
+ * may be performed on the last 6 bytes of the input block'. This is
+ * correct.  However, the pseudocode provided checks for the *E8 leader*
+ * up to the last 6 bytes. If the leader appears between -10 and -7 bytes
+ * from the end, this would cause the next four bytes to be modified, at
+ * least one of which would be in the last 6 bytes, which is not allowed
+ * according to the spec.
+ *
+ * The specification states that the huffman trees must always contain at
+ * least one element. However, many CAB files contain blocks where the
+ * length tree is completely empty (because there are no matches), and
+ * this is expected to succeed.
+ *
+ * The errors in LZX documentation appear have been corrected in the
+ * new documentation for the LZX DELTA format.
+ *
+ *     http://msdn.microsoft.com/en-us/library/cc483133.aspx
+ *
+ * However, this is a different format, an extension of regular LZX.
+ * I have noticed the following differences, there may be more:
+ *
+ * The maximum window size has increased from 2MB to 32MB. This also
+ * increases the maximum number of position slots, etc.
+ *
+ * If the match length is 257 (the maximum possible), this signals
+ * a further length decoding step, that allows for matches up to
+ * 33024 bytes long.
+ *
+ * The format now allows for "reference data", supplied by the caller.
+ * If match offsets go further back than the number of bytes
+ * decompressed so far, that is them accessing the reference data.
+ */
+
+/* import bit-reading macros and code */
+#define BITS_TYPE struct lzxd_stream
+#define BITS_VAR lzx
+#define BITS_ORDER_MSB
+#define READ_BYTES do {			\
+    unsigned char b0, b1;		\
+    READ_IF_NEEDED; b0 = *i_ptr++;	\
+    READ_IF_NEEDED; b1 = *i_ptr++;	\
+    INJECT_BITS((b1 << 8) | b0, 16);	\
+} while (0)
+#include "readbits.h"
+
+/* import huffman-reading macros and code */
+#define TABLEBITS(tbl)      LZX_##tbl##_TABLEBITS
+#define MAXSYMBOLS(tbl)     LZX_##tbl##_MAXSYMBOLS
+#define HUFF_TABLE(tbl,idx) lzx->tbl##_table[idx]
+#define HUFF_LEN(tbl,idx)   lzx->tbl##_len[idx]
+#define HUFF_ERROR          return lzx->error = LZX_ERR_DECRUNCH
+#include "readhuff.h"
+
+/* BUILD_TABLE(tbl) builds a huffman lookup table from code lengths */
+#define BUILD_TABLE(tbl)						\
+    if (make_decode_table(MAXSYMBOLS(tbl), TABLEBITS(tbl),		\
+			  &HUFF_LEN(tbl,0), &HUFF_TABLE(tbl,0)))	\
+    {									\
+        D(("failed to build %s table", #tbl))				\
+	return lzx->error = LZX_ERR_DECRUNCH;			\
+    }
+
+#define BUILD_TABLE_MAYBE_EMPTY(tbl) do {				\
+    lzx->tbl##_empty = 0;						\
+    if (make_decode_table(MAXSYMBOLS(tbl), TABLEBITS(tbl),		\
+                          &HUFF_LEN(tbl,0), &HUFF_TABLE(tbl,0)))	\
+    {									\
+	for (i = 0; i < MAXSYMBOLS(tbl); i++) {				\
+	    if (HUFF_LEN(tbl, i) > 0) {					\
+		D(("failed to build %s table", #tbl))			\
+		return lzx->error = LZX_ERR_DECRUNCH;		\
+	    }								\
+	}								\
+	/* empty tree - allow it, but don't decode symbols with it */	\
+	lzx->tbl##_empty = 1;						\
+    }									\
+} while (0)
+
+/* READ_LENGTHS(tablename, first, last) reads in code lengths for symbols
+ * first to last in the given table. The code lengths are stored in their
+ * own special LZX way.
+ */
+#define READ_LENGTHS(tbl, first, last) do {		\
+  STORE_BITS;						\
+  if (lzxd_read_lens(lzx, &HUFF_LEN(tbl, 0), (first),	\
+    (unsigned int)(last))) return lzx->error;		\
+  RESTORE_BITS;						\
+} while (0)
+
+static int lzxd_read_lens(struct lzxd_stream *lzx, unsigned char *lens,
+			  unsigned int first, unsigned int last)
+{
+  /* bit buffer and huffman symbol decode variables */
+  register unsigned int bit_buffer;
+  register int bits_left, i;
+  register unsigned short sym;
+  unsigned char *i_ptr, *i_end;
+
+  unsigned int x, y;
+  int z;
+
+  RESTORE_BITS;
+  
+  /* read lengths for pretree (20 symbols, lengths stored in fixed 4 bits) */
+  for (x = 0; x < 20; x++) {
+    READ_BITS(y, 4);
+    lzx->PRETREE_len[x] = y;
+  }
+  BUILD_TABLE(PRETREE);
+
+  for (x = first; x < last; ) {
+    READ_HUFFSYM(PRETREE, z);
+    if (z == 17) {
+      /* code = 17, run of ([read 4 bits]+4) zeros */
+      READ_BITS(y, 4); y += 4;
+      while (y--) lens[x++] = 0;
+    }
+    else if (z == 18) {
+      /* code = 18, run of ([read 5 bits]+20) zeros */
+      READ_BITS(y, 5); y += 20;
+      while (y--) lens[x++] = 0;
+    }
+    else if (z == 19) {
+      /* code = 19, run of ([read 1 bit]+4) [read huffman symbol] */
+      READ_BITS(y, 1); y += 4;
+      READ_HUFFSYM(PRETREE, z);
+      z = lens[x] - z; if (z < 0) z += 17;
+      while (y--) lens[x++] = z;
+    }
+    else {
+      /* code = 0 to 16, delta current length entry */
+      z = lens[x] - z; if (z < 0) z += 17;
+      lens[x++] = z;
+    }
+  }
+
+  STORE_BITS;
+
+  return LZX_ERR_OK;
+}
+
+/* LZX static data tables:
+ *
+ * LZX uses 'position slots' to represent match offsets.  For every match,
+ * a small 'position slot' number and a small offset from that slot are
+ * encoded instead of one large offset.
+ *
+ * The number of slots is decided by how many are needed to encode the
+ * largest offset for a given window size. This is easy when the gap between
+ * slots is less than 128Kb, it's a linear relationship. But when extra_bits
+ * reaches its limit of 17 (because LZX can only ensure reading 17 bits of
+ * data at a time), we can only jump 128Kb at a time and have to start
+ * using more and more position slots as each window size doubles.
+ *
+ * position_base[] is an index to the position slot bases
+ *
+ * extra_bits[] states how many bits of offset-from-base data is needed.
+ *
+ * They are calculated as follows:
+ * extra_bits[i] = 0 where i < 4
+ * extra_bits[i] = floor(i/2)-1 where i >= 4 && i < 36
+ * extra_bits[i] = 17 where i >= 36
+ * position_base[0] = 0
+ * position_base[i] = position_base[i-1] + (1 << extra_bits[i-1])
+ */
+static const unsigned int position_slots[11] = {
+    30, 32, 34, 36, 38, 42, 50, 66, 98, 162, 290
+};
+static const unsigned char extra_bits[36] = {
+    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8,
+    9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16
+};
+static const unsigned int position_base[290] = {
+    0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512,
+    768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576, 32768,
+    49152, 65536, 98304, 131072, 196608, 262144, 393216, 524288, 655360,
+    786432, 917504, 1048576, 1179648, 1310720, 1441792, 1572864, 1703936,
+    1835008, 1966080, 2097152, 2228224, 2359296, 2490368, 2621440, 2752512,
+    2883584, 3014656, 3145728, 3276800, 3407872, 3538944, 3670016, 3801088,
+    3932160, 4063232, 4194304, 4325376, 4456448, 4587520, 4718592, 4849664,
+    4980736, 5111808, 5242880, 5373952, 5505024, 5636096, 5767168, 5898240,
+    6029312, 6160384, 6291456, 6422528, 6553600, 6684672, 6815744, 6946816,
+    7077888, 7208960, 7340032, 7471104, 7602176, 7733248, 7864320, 7995392,
+    8126464, 8257536, 8388608, 8519680, 8650752, 8781824, 8912896, 9043968,
+    9175040, 9306112, 9437184, 9568256, 9699328, 9830400, 9961472, 10092544,
+    10223616, 10354688, 10485760, 10616832, 10747904, 10878976, 11010048,
+    11141120, 11272192, 11403264, 11534336, 11665408, 11796480, 11927552,
+    12058624, 12189696, 12320768, 12451840, 12582912, 12713984, 12845056,
+    12976128, 13107200, 13238272, 13369344, 13500416, 13631488, 13762560,
+    13893632, 14024704, 14155776, 14286848, 14417920, 14548992, 14680064,
+    14811136, 14942208, 15073280, 15204352, 15335424, 15466496, 15597568,
+    15728640, 15859712, 15990784, 16121856, 16252928, 16384000, 16515072,
+    16646144, 16777216, 16908288, 17039360, 17170432, 17301504, 17432576,
+    17563648, 17694720, 17825792, 17956864, 18087936, 18219008, 18350080,
+    18481152, 18612224, 18743296, 18874368, 19005440, 19136512, 19267584,
+    19398656, 19529728, 19660800, 19791872, 19922944, 20054016, 20185088,
+    20316160, 20447232, 20578304, 20709376, 20840448, 20971520, 21102592,
+    21233664, 21364736, 21495808, 21626880, 21757952, 21889024, 22020096,
+    22151168, 22282240, 22413312, 22544384, 22675456, 22806528, 22937600,
+    23068672, 23199744, 23330816, 23461888, 23592960, 23724032, 23855104,
+    23986176, 24117248, 24248320, 24379392, 24510464, 24641536, 24772608,
+    24903680, 25034752, 25165824, 25296896, 25427968, 25559040, 25690112,
+    25821184, 25952256, 26083328, 26214400, 26345472, 26476544, 26607616,
+    26738688, 26869760, 27000832, 27131904, 27262976, 27394048, 27525120,
+    27656192, 27787264, 27918336, 28049408, 28180480, 28311552, 28442624,
+    28573696, 28704768, 28835840, 28966912, 29097984, 29229056, 29360128,
+    29491200, 29622272, 29753344, 29884416, 30015488, 30146560, 30277632,
+    30408704, 30539776, 30670848, 30801920, 30932992, 31064064, 31195136,
+    31326208, 31457280, 31588352, 31719424, 31850496, 31981568, 32112640,
+    32243712, 32374784, 32505856, 32636928, 32768000, 32899072, 33030144,
+    33161216, 33292288, 33423360
+};
+
+static void lzxd_reset_state(struct lzxd_stream *lzx) {
+  int i;
+
+  lzx->R0              = 1;
+  lzx->R1              = 1;
+  lzx->R2              = 1;
+  lzx->header_read     = 0;
+  lzx->block_remaining = 0;
+  lzx->block_type      = LZX_BLOCKTYPE_INVALID;
+
+  /* initialise tables to 0 (because deltas will be applied to them) */
+  for (i = 0; i < LZX_MAINTREE_MAXSYMBOLS; i++) lzx->MAINTREE_len[i] = 0;
+  for (i = 0; i < LZX_LENGTH_MAXSYMBOLS; i++)   lzx->LENGTH_len[i]   = 0;
+}
+
+/*-------- main LZX code --------*/
+
+struct lzxd_stream *ews_lzxd_init(FILE *input,
+			      FILE *output,
+			      int window_bits,
+			      int reset_interval,
+			      int input_buffer_size,
+			      off_t output_length,
+			      char is_delta)
+{
+  unsigned int window_size = 1 << window_bits;
+  struct lzxd_stream *lzx;
+
+  /* LZX DELTA window sizes are between 2^17 (128KiB) and 2^25 (32MiB),
+   * regular LZX windows are between 2^15 (32KiB) and 2^21 (2MiB)
+   */
+  if (is_delta) {
+      if (window_bits < 17 || window_bits > 25) return NULL;
+  }
+  else {
+      if (window_bits < 15 || window_bits > 21) return NULL;
+  }
+
+  input_buffer_size = (input_buffer_size + 1) & -2;
+  if (!input_buffer_size) return NULL;
+
+  /* allocate decompression state */
+  if (!(lzx = (struct lzxd_stream *) malloc(sizeof(struct lzxd_stream)))) {
+    return NULL;
+  }
+
+  /* allocate decompression window and input buffer */
+  lzx->window = (unsigned char *) malloc((size_t) window_size);
+  lzx->inbuf  = (unsigned char *) malloc((size_t) input_buffer_size);
+  if (!lzx->window || !lzx->inbuf) {
+    free(lzx->window);
+    free(lzx->inbuf);
+    free(lzx);
+    return NULL;
+  }
+
+  /* initialise decompression state */
+  lzx->input           = input;
+  lzx->output          = output;
+  lzx->offset          = 0;
+  lzx->length          = output_length;
+
+  lzx->inbuf_size      = input_buffer_size;
+  lzx->window_size     = 1 << window_bits;
+  lzx->ref_data_size   = 0;
+  lzx->window_posn     = 0;
+  lzx->frame_posn      = 0;
+  lzx->frame           = 0;
+  lzx->reset_interval  = reset_interval;
+  lzx->intel_filesize  = 0;
+  lzx->intel_curpos    = 0;
+  lzx->intel_started   = 0;
+  lzx->error           = LZX_ERR_OK;
+  lzx->num_offsets     = position_slots[window_bits - 15] << 3;
+  lzx->is_delta        = is_delta;
+
+  lzx->o_ptr = lzx->o_end = &lzx->e8_buf[0];
+  lzxd_reset_state(lzx);
+  INIT_BITS;
+  return lzx;
+}
+
+int ews_lzxd_set_reference_data(struct lzxd_stream *lzx,
+			    FILE *input,
+			    unsigned int length)
+{
+    if (!lzx) return LZX_ERR_ARGS;
+
+    if (!lzx->is_delta) {
+        D(("only LZX DELTA streams support reference data"))
+        return LZX_ERR_ARGS;
+    }
+    if (lzx->offset) {
+	D(("too late to set reference data after decoding starts"))
+	return LZX_ERR_ARGS;
+    }
+    if (length > lzx->window_size) {
+	D(("reference length (%u) is longer than the window", length))
+	return LZX_ERR_ARGS;
+    }
+    if (length > 0 && (!input)) {
+        D(("length > 0 but no input"))
+        return LZX_ERR_ARGS;
+    }
+
+    lzx->ref_data_size = length;
+    if (length > 0) {
+        /* copy reference data */
+        unsigned char *pos = &lzx->window[lzx->window_size - length];
+	int bytes = fread(pos, 1, length, input);
+	if (bytes < length) return LZX_ERR_READ;
+    }
+    lzx->ref_data_size = length;
+    return LZX_ERR_OK;
+}
+
+void ews_lzxd_set_output_length(struct lzxd_stream *lzx, off_t out_bytes) {
+  if (lzx) lzx->length = out_bytes;
+}
+
+int ews_lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes) {
+  /* bitstream and huffman reading variables */
+  register unsigned int bit_buffer;
+  register int bits_left, i=0;
+  unsigned char *i_ptr, *i_end;
+  register unsigned short sym;
+
+  int match_length, length_footer, extra, verbatim_bits, bytes_todo;
+  int this_run, main_element, aligned_bits, j;
+  unsigned char *window, *runsrc, *rundest, buf[12];
+  unsigned int frame_size=0, end_frame, match_offset, window_posn;
+  unsigned int R0, R1, R2;
+
+  /* easy answers */
+  if (!lzx || (out_bytes < 0)) return LZX_ERR_ARGS;
+  if (lzx->error) return lzx->error;
+
+  /* flush out any stored-up bytes before we begin */
+  i = lzx->o_end - lzx->o_ptr;
+  if ((off_t) i > out_bytes) i = (int) out_bytes;
+  if (i) {
+    if (fwrite(lzx->o_ptr, 1, i, lzx->output) != i) {
+      return lzx->error = LZX_ERR_WRITE;
+    }
+    lzx->o_ptr  += i;
+    lzx->offset += i;
+    out_bytes   -= i;
+  }
+  if (out_bytes == 0) return LZX_ERR_OK;
+
+  /* restore local state */
+  RESTORE_BITS;
+  window = lzx->window;
+  window_posn = lzx->window_posn;
+  R0 = lzx->R0;
+  R1 = lzx->R1;
+  R2 = lzx->R2;
+
+  end_frame = (unsigned int)((lzx->offset + out_bytes) / LZX_FRAME_SIZE) + 1;
+
+  while (lzx->frame < end_frame) {
+    /* have we reached the reset interval? (if there is one?) */
+    if (lzx->reset_interval && ((lzx->frame % lzx->reset_interval) == 0)) {
+      if (lzx->block_remaining) {
+	D(("%d bytes remaining at reset interval", lzx->block_remaining))
+	return lzx->error = LZX_ERR_DECRUNCH;
+      }
+
+      /* re-read the intel header and reset the huffman lengths */
+      lzxd_reset_state(lzx);
+      R0 = lzx->R0;
+      R1 = lzx->R1;
+      R2 = lzx->R2;
+    }
+
+    /* LZX DELTA format has chunk_size, not present in LZX format */
+    if (lzx->is_delta) {
+      ENSURE_BITS(16);
+      REMOVE_BITS(16);
+    }
+
+    /* read header if necessary */
+    if (!lzx->header_read) {
+      /* read 1 bit. if bit=0, intel filesize = 0.
+       * if bit=1, read intel filesize (32 bits) */
+      j = 0; READ_BITS(i, 1); if (i) { READ_BITS(i, 16); READ_BITS(j, 16); }
+      lzx->intel_filesize = (i << 16) | j;
+      lzx->header_read = 1;
+    } 
+
+    /* calculate size of frame: all frames are 32k except the final frame
+     * which is 32kb or less. this can only be calculated when lzx->length
+     * has been filled in. */
+    frame_size = LZX_FRAME_SIZE;
+    if (lzx->length && (lzx->length - lzx->offset) < (off_t)frame_size) {
+      frame_size = lzx->length - lzx->offset;
+    }
+
+    /* decode until one more frame is available */
+    bytes_todo = lzx->frame_posn + frame_size - window_posn;
+    while (bytes_todo > 0) {
+      /* initialise new block, if one is needed */
+      if (lzx->block_remaining == 0) {
+	/* realign if previous block was an odd-sized UNCOMPRESSED block */
+	if ((lzx->block_type == LZX_BLOCKTYPE_UNCOMPRESSED) &&
+	    (lzx->block_length & 1))
+	{
+	  READ_IF_NEEDED;
+	  i_ptr++;
+	}
+
+	/* read block type (3 bits) and block length (24 bits) */
+	READ_BITS(lzx->block_type, 3);
+	READ_BITS(i, 16); READ_BITS(j, 8);
+	lzx->block_remaining = lzx->block_length = (i << 8) | j;
+	/*D(("new block t%d len %u", lzx->block_type, lzx->block_length))*/
+
+	/* read individual block headers */
+	switch (lzx->block_type) {
+	case LZX_BLOCKTYPE_ALIGNED:
+	  /* read lengths of and build aligned huffman decoding tree */
+	  for (i = 0; i < 8; i++) { READ_BITS(j, 3); lzx->ALIGNED_len[i] = j; }
+	  BUILD_TABLE(ALIGNED);
+	  /* no break -- rest of aligned header is same as verbatim */
+	case LZX_BLOCKTYPE_VERBATIM:
+	  /* read lengths of and build main huffman decoding tree */
+	  READ_LENGTHS(MAINTREE, 0, 256);
+	  READ_LENGTHS(MAINTREE, 256, LZX_NUM_CHARS + lzx->num_offsets);
+	  BUILD_TABLE(MAINTREE);
+	  /* if the literal 0xE8 is anywhere in the block... */
+	  if (lzx->MAINTREE_len[0xE8] != 0) lzx->intel_started = 1;
+	  /* read lengths of and build lengths huffman decoding tree */
+	  READ_LENGTHS(LENGTH, 0, LZX_NUM_SECONDARY_LENGTHS);
+	  BUILD_TABLE_MAYBE_EMPTY(LENGTH);
+	  break;
+
+	case LZX_BLOCKTYPE_UNCOMPRESSED:
+	  /* because we can't assume otherwise */
+	  lzx->intel_started = 1;
+
+	  /* read 1-16 (not 0-15) bits to align to bytes */
+	  ENSURE_BITS(16);
+	  if (bits_left > 16) i_ptr -= 2;
+	  bits_left = 0; bit_buffer = 0;
+
+	  /* read 12 bytes of stored R0 / R1 / R2 values */
+	  for (rundest = &buf[0], i = 0; i < 12; i++) {
+	    READ_IF_NEEDED;
+	    *rundest++ = *i_ptr++;
+	  }
+	  R0 = buf[0] | (buf[1] << 8) | (buf[2]  << 16) | (buf[3]  << 24);
+	  R1 = buf[4] | (buf[5] << 8) | (buf[6]  << 16) | (buf[7]  << 24);
+	  R2 = buf[8] | (buf[9] << 8) | (buf[10] << 16) | (buf[11] << 24);
+	  break;
+
+	default:
+	  D(("bad block type"))
+	  return lzx->error = LZX_ERR_DECRUNCH;
+	}
+      }
+
+      /* decode more of the block:
+       * run = min(what's available, what's needed) */
+      this_run = lzx->block_remaining;
+      if (this_run > bytes_todo) this_run = bytes_todo;
+
+      /* assume we decode exactly this_run bytes, for now */
+      bytes_todo           -= this_run;
+      lzx->block_remaining -= this_run;
+
+      /* decode at least this_run bytes */
+      switch (lzx->block_type) {
+      case LZX_BLOCKTYPE_VERBATIM:
+	while (this_run > 0) {
+	  READ_HUFFSYM(MAINTREE, main_element);
+	  if (main_element < LZX_NUM_CHARS) {
+	    /* literal: 0 to LZX_NUM_CHARS-1 */
+	    window[window_posn++] = main_element;
+	    this_run--;
+	  }
+	  else {
+	    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */
+	    main_element -= LZX_NUM_CHARS;
+
+	    /* get match length */
+	    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;
+	    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {
+	      if (lzx->LENGTH_empty) {
+                D(("LENGTH symbol needed but tree is empty"))
+                return lzx->error = LZX_ERR_DECRUNCH;
+              }
+	      READ_HUFFSYM(LENGTH, length_footer);
+	      match_length += length_footer;
+	    }
+	    match_length += LZX_MIN_MATCH;
+
+	    /* get match offset */
+	    switch ((match_offset = (main_element >> 3))) {
+	    case 0: match_offset = R0;                                  break;
+	    case 1: match_offset = R1; R1=R0;        R0 = match_offset; break;
+	    case 2: match_offset = R2; R2=R0;        R0 = match_offset; break;
+	    case 3: match_offset = 1;  R2=R1; R1=R0; R0 = match_offset; break;
+	    default:
+	      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];
+	      READ_BITS(verbatim_bits, extra);
+	      match_offset = position_base[match_offset] - 2 + verbatim_bits;
+	      R2 = R1; R1 = R0; R0 = match_offset;
+	    }
+
+	    /* LZX DELTA uses max match length to signal even longer match */
+	    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {
+		int extra_len = 0;
+		ENSURE_BITS(3); /* 4 entry huffman tree */
+		if (PEEK_BITS(1) == 0) {
+		    REMOVE_BITS(1); /* '0' -> 8 extra length bits */
+		    READ_BITS(extra_len, 8);
+		}
+		else if (PEEK_BITS(2) == 2) {
+		    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */
+		    READ_BITS(extra_len, 10);
+		    extra_len += 0x100;
+		}
+		else if (PEEK_BITS(3) == 6) {
+		    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */
+		    READ_BITS(extra_len, 12);
+		    extra_len += 0x500;
+		}
+		else {
+		    REMOVE_BITS(3); /* '111' -> 15 extra length bits */
+		    READ_BITS(extra_len, 15);
+		}
+		match_length += extra_len;
+	    }
+
+	    if ((window_posn + match_length) > lzx->window_size) {
+	      D(("match ran over window wrap"))
+	      return lzx->error = LZX_ERR_DECRUNCH;
+	    }
+	    
+	    /* copy match */
+	    rundest = &window[window_posn];
+	    i = match_length;
+	    /* does match offset wrap the window? */
+	    if (match_offset > window_posn) {
+	      if (match_offset > lzx->offset &&
+		  (match_offset - window_posn) > lzx->ref_data_size)
+	      {
+		D(("match offset beyond LZX stream"))
+		return lzx->error = LZX_ERR_DECRUNCH;
+	      }
+	      /* j = length from match offset to end of window */
+	      j = match_offset - window_posn;
+	      if (j > (int) lzx->window_size) {
+		D(("match offset beyond window boundaries"))
+		return lzx->error = LZX_ERR_DECRUNCH;
+	      }
+	      runsrc = &window[lzx->window_size - j];
+	      if (j < i) {
+		/* if match goes over the window edge, do two copy runs */
+		i -= j; while (j-- > 0) *rundest++ = *runsrc++;
+		runsrc = window;
+	      }
+	      while (i-- > 0) *rundest++ = *runsrc++;
+	    }
+	    else {
+	      runsrc = rundest - match_offset;
+	      while (i-- > 0) *rundest++ = *runsrc++;
+	    }
+
+	    this_run    -= match_length;
+	    window_posn += match_length;
+	  }
+	} /* while (this_run > 0) */
+	break;
+
+      case LZX_BLOCKTYPE_ALIGNED:
+	while (this_run > 0) {
+	  READ_HUFFSYM(MAINTREE, main_element);
+	  if (main_element < LZX_NUM_CHARS) {
+	    /* literal: 0 to LZX_NUM_CHARS-1 */
+	    window[window_posn++] = main_element;
+	    this_run--;
+	  }
+	  else {
+	    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */
+	    main_element -= LZX_NUM_CHARS;
+
+	    /* get match length */
+	    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;
+	    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {
+              if (lzx->LENGTH_empty) {
+                D(("LENGTH symbol needed but tree is empty"))
+                return lzx->error = LZX_ERR_DECRUNCH;
+              } 
+	      READ_HUFFSYM(LENGTH, length_footer);
+	      match_length += length_footer;
+	    }
+	    match_length += LZX_MIN_MATCH;
+
+	    /* get match offset */
+	    switch ((match_offset = (main_element >> 3))) {
+	    case 0: match_offset = R0;                             break;
+	    case 1: match_offset = R1; R1 = R0; R0 = match_offset; break;
+	    case 2: match_offset = R2; R2 = R0; R0 = match_offset; break;
+	    default:
+	      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];
+	      match_offset = position_base[match_offset] - 2;
+	      if (extra > 3) {
+		/* verbatim and aligned bits */
+		extra -= 3;
+		READ_BITS(verbatim_bits, extra);
+		match_offset += (verbatim_bits << 3);
+		READ_HUFFSYM(ALIGNED, aligned_bits);
+		match_offset += aligned_bits;
+	      }
+	      else if (extra == 3) {
+		/* aligned bits only */
+		READ_HUFFSYM(ALIGNED, aligned_bits);
+		match_offset += aligned_bits;
+	      }
+	      else if (extra > 0) { /* extra==1, extra==2 */
+		/* verbatim bits only */
+		READ_BITS(verbatim_bits, extra);
+		match_offset += verbatim_bits;
+	      }
+	      else /* extra == 0 */ {
+		/* ??? not defined in LZX specification! */
+		match_offset = 1;
+	      }
+	      /* update repeated offset LRU queue */
+	      R2 = R1; R1 = R0; R0 = match_offset;
+	    }
+
+	    /* LZX DELTA uses max match length to signal even longer match */
+	    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {
+		int extra_len = 0;
+		ENSURE_BITS(3); /* 4 entry huffman tree */
+		if (PEEK_BITS(1) == 0) {
+		    REMOVE_BITS(1); /* '0' -> 8 extra length bits */
+		    READ_BITS(extra_len, 8);
+		}
+		else if (PEEK_BITS(2) == 2) {
+		    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */
+		    READ_BITS(extra_len, 10);
+		    extra_len += 0x100;
+		}
+		else if (PEEK_BITS(3) == 6) {
+		    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */
+		    READ_BITS(extra_len, 12);
+		    extra_len += 0x500;
+		}
+		else {
+		    REMOVE_BITS(3); /* '111' -> 15 extra length bits */
+		    READ_BITS(extra_len, 15);
+		}
+		match_length += extra_len;
+	    }
+
+	    if ((window_posn + match_length) > lzx->window_size) {
+	      D(("match ran over window wrap"))
+	      return lzx->error = LZX_ERR_DECRUNCH;
+	    }
+
+	    /* copy match */
+	    rundest = &window[window_posn];
+	    i = match_length;
+	    /* does match offset wrap the window? */
+	    if (match_offset > window_posn) {
+	      if (match_offset > lzx->offset &&
+		  (match_offset - window_posn) > lzx->ref_data_size)
+	      {
+		D(("match offset beyond LZX stream"))
+		return lzx->error = LZX_ERR_DECRUNCH;
+	      }
+	      /* j = length from match offset to end of window */
+	      j = match_offset - window_posn;
+	      if (j > (int) lzx->window_size) {
+		D(("match offset beyond window boundaries"))
+		return lzx->error = LZX_ERR_DECRUNCH;
+	      }
+	      runsrc = &window[lzx->window_size - j];
+	      if (j < i) {
+		/* if match goes over the window edge, do two copy runs */
+		i -= j; while (j-- > 0) *rundest++ = *runsrc++;
+		runsrc = window;
+	      }
+	      while (i-- > 0) *rundest++ = *runsrc++;
+	    }
+	    else {
+	      runsrc = rundest - match_offset;
+	      while (i-- > 0) *rundest++ = *runsrc++;
+	    }
+
+	    this_run    -= match_length;
+	    window_posn += match_length;
+	  }
+	} /* while (this_run > 0) */
+	break;
+
+      case LZX_BLOCKTYPE_UNCOMPRESSED:
+	/* as this_run is limited not to wrap a frame, this also means it
+	 * won't wrap the window (as the window is a multiple of 32k) */
+	rundest = &window[window_posn];
+	window_posn += this_run;
+	while (this_run > 0) {
+	  if ((i = i_end - i_ptr) == 0) {
+	    READ_IF_NEEDED;
+	  }
+	  else {
+	    if (i > this_run) i = this_run;
+	    memcpy(rundest, i_ptr, (size_t) i);
+	    rundest  += i;
+	    i_ptr    += i;
+	    this_run -= i;
+	  }
+	}
+	break;
+
+      default:
+	return lzx->error = LZX_ERR_DECRUNCH; /* might as well */
+      }
+
+      /* did the final match overrun our desired this_run length? */
+      if (this_run < 0) {
+	if ((unsigned int)(-this_run) > lzx->block_remaining) {
+	  D(("overrun went past end of block by %d (%d remaining)",
+	     -this_run, lzx->block_remaining ))
+	  return lzx->error = LZX_ERR_DECRUNCH;
+	}
+	lzx->block_remaining -= -this_run;
+      }
+    } /* while (bytes_todo > 0) */
+
+    /* streams don't extend over frame boundaries */
+    if ((window_posn - lzx->frame_posn) != frame_size) {
+      D(("decode beyond output frame limits! %d != %d",
+	 window_posn - lzx->frame_posn, frame_size))
+      return lzx->error = LZX_ERR_DECRUNCH;
+    }
+
+    /* re-align input bitstream */
+    if (bits_left > 0) ENSURE_BITS(16);
+    if (bits_left & 15) REMOVE_BITS(bits_left & 15);
+
+    /* check that we've used all of the previous frame first */
+    if (lzx->o_ptr != lzx->o_end) {
+      D(("%ld avail bytes, new %d frame", lzx->o_end-lzx->o_ptr, frame_size))
+      return lzx->error = LZX_ERR_DECRUNCH;
+    }
+
+    /* does this intel block _really_ need decoding? */
+    if (lzx->intel_started && lzx->intel_filesize &&
+	(lzx->frame <= 32768) && (frame_size > 10))
+    {
+      unsigned char *data    = &lzx->e8_buf[0];
+      unsigned char *dataend = &lzx->e8_buf[frame_size - 10];
+      signed int curpos      = lzx->intel_curpos;
+      signed int filesize    = lzx->intel_filesize;
+      signed int abs_off, rel_off;
+
+      /* copy e8 block to the e8 buffer and tweak if needed */
+      lzx->o_ptr = data;
+      memcpy(data, &lzx->window[lzx->frame_posn], frame_size);
+
+      while (data < dataend) {
+	if (*data++ != 0xE8) { curpos++; continue; }
+	abs_off = data[0] | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);
+	if ((abs_off >= -curpos) && (abs_off < filesize)) {
+	  rel_off = (abs_off >= 0) ? abs_off - curpos : abs_off + filesize;
+	  data[0] = (unsigned char) rel_off;
+	  data[1] = (unsigned char) (rel_off >> 8);
+	  data[2] = (unsigned char) (rel_off >> 16);
+	  data[3] = (unsigned char) (rel_off >> 24);
+	}
+	data += 4;
+	curpos += 5;
+      }
+      lzx->intel_curpos += frame_size;
+    }
+    else {
+      lzx->o_ptr = &lzx->window[lzx->frame_posn];
+      if (lzx->intel_filesize) lzx->intel_curpos += frame_size;
+    }
+    lzx->o_end = &lzx->o_ptr[frame_size];
+
+    /* write a frame */
+    i = (out_bytes < (off_t)frame_size) ? (unsigned int)out_bytes : frame_size;
+    if (fwrite(lzx->o_ptr, 1, i, lzx->output) != i) {
+      return lzx->error = LZX_ERR_WRITE;
+    }
+    lzx->o_ptr  += i;
+    lzx->offset += i;
+    out_bytes   -= i;
+
+    /* advance frame start position */
+    lzx->frame_posn += frame_size;
+    lzx->frame++;
+
+    /* wrap window / frame position pointers */
+    if (window_posn == lzx->window_size)     window_posn = 0;
+    if (lzx->frame_posn == lzx->window_size) lzx->frame_posn = 0;
+
+  } /* while (lzx->frame < end_frame) */
+
+  if (out_bytes) {
+    D(("bytes left to output"))
+    return lzx->error = LZX_ERR_DECRUNCH;
+  }
+
+  /* store local state */
+  STORE_BITS;
+  lzx->window_posn = window_posn;
+  lzx->R0 = R0;
+  lzx->R1 = R1;
+  lzx->R2 = R2;
+
+  return LZX_ERR_OK;
+}
+
+void ews_lzxd_free(struct lzxd_stream *lzx) {
+  if (lzx) {
+    free(lzx->inbuf);
+    free(lzx->window);
+    free(lzx);
+  }
+}
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/lzx.h.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/lzx.h
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/lzx.h.sync-with-3.8.4	2013-07-24 07:30:27.307435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/lzx.h	2013-07-24 07:30:27.307435567 +0200
@@ -0,0 +1,239 @@
+/* This file is part of libmspack.
+ * (C) 2003-2013 Stuart Caie.
+ *
+ * The LZX method was created by Jonathan Forbes and Tomi Poutanen, adapted
+ * by Microsoft Corporation.
+ *
+ * libmspack is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License (LGPL) version 2.1
+ *
+ * For further details, see the file COPYING.LIB distributed with libmspack
+ */
+
+#ifndef LZX_H
+#define LZX_H 1
+
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define D(x) do { printf("%s:%d (%s) \n",__FILE__, __LINE__, __func__); \
+                   printf x ; fputc('\n', stdout); fflush(stdout);} while (0);
+
+/* LZX compression / decompression definitions */
+
+/* some constants defined by the LZX specification */
+#define LZX_MIN_MATCH                (2)
+#define LZX_MAX_MATCH                (257)
+#define LZX_NUM_CHARS                (256)
+#define LZX_BLOCKTYPE_INVALID        (0)   /* also blocktypes 4-7 invalid */
+#define LZX_BLOCKTYPE_VERBATIM       (1)
+#define LZX_BLOCKTYPE_ALIGNED        (2)
+#define LZX_BLOCKTYPE_UNCOMPRESSED   (3)
+#define LZX_PRETREE_NUM_ELEMENTS     (20)
+#define LZX_ALIGNED_NUM_ELEMENTS     (8)   /* aligned offset tree #elements */
+#define LZX_NUM_PRIMARY_LENGTHS      (7)   /* this one missing from spec! */
+#define LZX_NUM_SECONDARY_LENGTHS    (249) /* length tree #elements */
+
+/* LZX huffman defines: tweak tablebits as desired */
+#define LZX_PRETREE_MAXSYMBOLS  (LZX_PRETREE_NUM_ELEMENTS)
+#define LZX_PRETREE_TABLEBITS   (6)
+#define LZX_MAINTREE_MAXSYMBOLS (LZX_NUM_CHARS + 290*8)
+#define LZX_MAINTREE_TABLEBITS  (12)
+#define LZX_LENGTH_MAXSYMBOLS   (LZX_NUM_SECONDARY_LENGTHS+1)
+#define LZX_LENGTH_TABLEBITS    (12)
+#define LZX_ALIGNED_MAXSYMBOLS  (LZX_ALIGNED_NUM_ELEMENTS)
+#define LZX_ALIGNED_TABLEBITS   (7)
+#define LZX_LENTABLE_SAFETY (64)  /* table decoding overruns are allowed */
+
+#define LZX_FRAME_SIZE (32768) /* the size of a frame in LZX */
+
+/* --- error codes --------------------------------------------------------- */
+
+/** Error code: no error */
+#define LZX_ERR_OK          (0)
+/** Error code: bad arguments to method */
+#define LZX_ERR_ARGS        (1)
+/** Error code: error opening file */
+#define LZX_ERR_OPEN        (2)
+/** Error code: error reading file */
+#define LZX_ERR_READ        (3)
+/** Error code: error writing file */
+#define LZX_ERR_WRITE       (4)
+/** Error code: seek error */
+#define LZX_ERR_SEEK        (5)
+/** Error code: out of memory */
+#define LZX_ERR_NOMEMORY    (6)
+/** Error code: bad "magic id" in file */
+#define LZX_ERR_SIGNATURE   (7)
+/** Error code: bad or corrupt file format */
+#define LZX_ERR_DATAFORMAT  (8)
+/** Error code: bad checksum or CRC */
+#define LZX_ERR_CHECKSUM    (9)
+/** Error code: error during compression */
+#define LZX_ERR_CRUNCH      (10)
+/** Error code: error during decompression */
+#define LZX_ERR_DECRUNCH    (11)
+
+struct lzxd_stream {
+  FILE   *input;		  /* input file handle                       */
+  FILE  *output;		  /* output file handle                      */
+
+  off_t   offset;                 /* number of bytes actually output         */
+  off_t   length;                 /* overall decompressed length of stream   */
+
+  unsigned char *window;          /* decoding window                         */
+  unsigned int   window_size;     /* window size                             */
+  unsigned int   ref_data_size;   /* LZX DELTA reference data size           */
+  unsigned int   num_offsets;     /* number of match_offset entries in table */
+  unsigned int   window_posn;     /* decompression offset within window      */
+  unsigned int   frame_posn;      /* current frame offset within in window   */
+  unsigned int   frame;           /* the number of 32kb frames processed     */
+  unsigned int   reset_interval;  /* which frame do we reset the compressor? */
+
+  unsigned int   R0, R1, R2;      /* for the LRU offset system               */
+  unsigned int   block_length;    /* uncompressed length of this LZX block   */
+  unsigned int   block_remaining; /* uncompressed bytes still left to decode */
+
+  signed int     intel_filesize;  /* magic header value used for transform   */
+  signed int     intel_curpos;    /* current offset in transform space       */
+
+  unsigned char  intel_started;   /* has intel E8 decoding started?          */
+  unsigned char  block_type;      /* type of the current block               */
+  unsigned char  header_read;     /* have we started decoding at all yet?    */
+  unsigned char  input_end;       /* have we reached the end of input?       */
+  unsigned char  is_delta;        /* does stream follow LZX DELTA spec?      */
+
+  int error;
+
+  /* I/O buffering */
+  unsigned char *inbuf, *i_ptr, *i_end, *o_ptr, *o_end;
+  unsigned int  bit_buffer, bits_left, inbuf_size;
+
+  /* huffman code lengths */
+  unsigned char PRETREE_len  [LZX_PRETREE_MAXSYMBOLS  + LZX_LENTABLE_SAFETY];
+  unsigned char MAINTREE_len [LZX_MAINTREE_MAXSYMBOLS + LZX_LENTABLE_SAFETY];
+  unsigned char LENGTH_len   [LZX_LENGTH_MAXSYMBOLS   + LZX_LENTABLE_SAFETY];
+  unsigned char ALIGNED_len  [LZX_ALIGNED_MAXSYMBOLS  + LZX_LENTABLE_SAFETY];
+
+  /* huffman decoding tables */
+  unsigned short PRETREE_table [(1 << LZX_PRETREE_TABLEBITS) +
+				(LZX_PRETREE_MAXSYMBOLS * 2)];
+  unsigned short MAINTREE_table[(1 << LZX_MAINTREE_TABLEBITS) +
+				(LZX_MAINTREE_MAXSYMBOLS * 2)];
+  unsigned short LENGTH_table  [(1 << LZX_LENGTH_TABLEBITS) +
+				(LZX_LENGTH_MAXSYMBOLS * 2)];
+  unsigned short ALIGNED_table [(1 << LZX_ALIGNED_TABLEBITS) +
+				(LZX_ALIGNED_MAXSYMBOLS * 2)];
+  unsigned char LENGTH_empty;
+
+  /* this is used purely for doing the intel E8 transform */
+  unsigned char  e8_buf[LZX_FRAME_SIZE];
+};
+
+/**
+ * Allocates and initialises LZX decompression state for decoding an LZX
+ * stream.
+ *
+ * This routine uses malloc() to allocate memory. If memory
+ * allocation fails, or the parameters to this function are invalid,
+ * NULL is returned.
+ *
+ * @param input              an input stream with the LZX data.
+ * @param output             an output stream to write the decoded data to.
+ * @param window_bits        the size of the decoding window, which must be
+ *                           between 15 and 21 inclusive for regular LZX
+ *                           data, or between 17 and 25 inclusive for
+ *                           LZX DELTA data.
+ * @param reset_interval     the interval at which the LZX bitstream is
+ *                           reset, in multiples of LZX frames (32678
+ *                           bytes), e.g. a value of 2 indicates the input
+ *                           stream resets after every 65536 output bytes.
+ *                           A value of 0 indicates that the bitstream never
+ *                           resets, such as in CAB LZX streams.
+ * @param input_buffer_size  the number of bytes to use as an input
+ *                           bitstream buffer.
+ * @param output_length      the length in bytes of the entirely
+ *                           decompressed output stream, if known in
+ *                           advance. It is used to correctly perform the
+ *                           Intel E8 transformation, which must stop 6
+ *                           bytes before the very end of the
+ *                           decompressed stream. It is not otherwise used
+ *                           or adhered to. If the full decompressed
+ *                           length is known in advance, set it here.
+ *                           If it is NOT known, use the value 0, and call
+ *                           lzxd_set_output_length() once it is
+ *                           known. If never set, 4 of the final 6 bytes
+ *                           of the output stream may be incorrect.
+ * @param is_delta           should be zero for all regular LZX data,
+ *                           non-zero for LZX DELTA encoded data.
+ * @return a pointer to an initialised lzxd_stream structure, or NULL if
+ * there was not enough memory or parameters to the function were wrong.
+ */
+extern struct lzxd_stream *ews_lzxd_init(FILE *input,
+				     FILE *output,
+				     int window_bits,
+				     int reset_interval,
+				     int input_buffer_size,
+				     off_t output_length,
+                                     char is_delta);
+
+/* see description of output_length in lzxd_init() */
+extern void ews_lzxd_set_output_length(struct lzxd_stream *lzx,
+				   off_t output_length);
+
+/**
+ * Reads LZX DELTA reference data into the window and allows
+ * lzxd_decompress() to reference it.
+ *
+ * Call this before the first call to lzxd_decompress().
+
+ * @param lzx    the LZX stream to apply this reference data to
+ * @param input  an input file handle to read reference data
+ * @param length the length of the reference data. Cannot be longer
+ *               than the LZX window size.
+ * @return an error code, or LZX_ERR_OK if successful
+ */
+extern int ews_lzxd_set_reference_data(struct lzxd_stream *lzx,
+                                   FILE *input,
+                                   unsigned int length);
+
+/**
+ * Decompresses entire or partial LZX streams.
+ *
+ * The number of bytes of data that should be decompressed is given as the
+ * out_bytes parameter. If more bytes are decoded than are needed, they
+ * will be kept over for a later invocation.
+ *
+ * The output bytes will be passed to the write() function given in
+ * lzxd_init(), using the output file handle given in lzxd_init(). More than
+ * one call may be made to write().
+
+ * Input bytes will be read in as necessary using the read()
+ * function given in lzxd_init(), using the input file handle given in
+ * lzxd_init().  This will continue until read() returns 0 bytes,
+ * or an error. Errors will be passed out of the function as
+ * LZX_ERR_READ errors.  Input streams should convey an "end of input
+ * stream" by refusing to supply all the bytes that LZX asks for when they
+ * reach the end of the stream, rather than return an error code.
+ *
+ * If any error code other than LZX_ERR_OK is returned, the stream
+ * should be considered unusable and lzxd_decompress() should not be
+ * called again on this stream.
+ *
+ * @param lzx       LZX decompression state, as allocated by lzxd_init().
+ * @param out_bytes the number of bytes of data to decompress.
+ * @return an error code, or LZX_ERR_OK if successful
+ */
+extern int ews_lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes);
+
+/**
+ * Frees all state associated with an LZX data stream. This will call
+ * free() using the system pointer given in lzxd_init().
+ *
+ * @param lzx LZX decompression state to free.
+ */
+void ews_lzxd_free(struct lzxd_stream *lzx);
+
+#endif
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/oab-decompress.c.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/oab-decompress.c
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/oab-decompress.c.sync-with-3.8.4	2013-07-24 07:30:27.308435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/oab-decompress.c	2013-07-24 07:30:27.308435567 +0200
@@ -0,0 +1,481 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/* e-book-backend-ews.h - Ews contact backend.
+ *
+ * Copyright (C) 1999-2008 Novell, Inc. (www.novell.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU Lesser General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <sys/types.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <math.h>
+#include <unistd.h>
+#include <glib.h>
+#include <glib/gstdio.h>
+#include "lzx.h"
+#include "../ews-oab-decompress.h"
+
+/* endian-neutral reading of little-endian data */
+#define __egi32(a,n) ( ((((unsigned char *) a)[n+3]) << 24) | \
+                       ((((guchar *) a)[n + 2]) << 16) | \
+                       ((((guchar *) a)[n + 1]) <<  8) | \
+                       ((((guchar *) a)[n + 0])))
+#define EndGetI64(a) ((((unsigned long long int) __egi32(a,4)) << 32) | \
+                      ((guint) __egi32 (a,0)))
+#define EndGetI32(a) __egi32(a,0)
+#define EndGetI16(a) ((((a)[1])<<8)|((a)[0]))
+
+typedef struct {
+	guint32 h_version;
+	guint32 l_version;
+	guint32 max_block_size;
+	guint32 target_size;
+} LzxHeader;
+
+typedef struct {
+	guint32 flags;
+	guint32 comp_size;
+	guint32 ucomp_size;
+	guint32 crc;
+} LzxBlockHeader;
+
+static gboolean
+read_uint32 (FILE *input,
+             guint32 *val)
+{
+	gchar buf[4];
+
+	if (fread (buf, 1, 4, input) == 4) {
+		*val = EndGetI32 (buf);
+		return TRUE;
+	} else
+		return FALSE;
+}
+
+static LzxHeader *
+read_headers (FILE *input,
+              GError **error)
+{
+	LzxHeader *lzx_h;
+	gboolean success;
+
+	lzx_h = g_new0 (LzxHeader, 1);
+
+	success = read_uint32 (input, &lzx_h->h_version);
+	if (!success)
+		goto exit;
+	success = read_uint32 (input, &lzx_h->l_version);
+	if (!success)
+		goto exit;
+
+	if (lzx_h->h_version !=  0x00000003 || lzx_h->l_version != 0x00000001) {
+		g_free (lzx_h);
+		/* set the right domain later */
+		g_set_error_literal (error, g_quark_from_string ("lzx"), 1, "wrong version header");
+		return NULL;
+	}
+
+	success = read_uint32 (input, &lzx_h->max_block_size);
+	if (!success)
+		goto exit;
+	success = read_uint32 (input, &lzx_h->target_size);
+	if (!success)
+		goto exit;
+
+exit:
+	if (!success) {
+		/* set the right domain later */
+		g_set_error_literal (error, g_quark_from_string ("lzx"), 1, "Unable to read lzx main header");
+
+		g_free (lzx_h);
+		lzx_h = NULL;
+	}
+
+	return lzx_h;
+}
+
+static LzxBlockHeader *
+read_block_header (FILE *input,
+                   GError **error)
+{
+	LzxBlockHeader *lzx_b;
+	gboolean success;
+
+	lzx_b = g_new0 (LzxBlockHeader, 1);
+
+	success = read_uint32 (input, &lzx_b->flags);
+	if (!success)
+		goto exit;
+
+	success = read_uint32 (input, &lzx_b->comp_size);
+	if (!success)
+		goto exit;
+
+	success = read_uint32 (input, &lzx_b->ucomp_size);
+	if (!success)
+		goto exit;
+
+	success = read_uint32 (input, &lzx_b->crc);
+
+exit:
+	if (!success) {
+		/* set the right domain later */
+		g_set_error_literal (error, g_quark_from_string ("lzx"), 1, "Unable to read lzx block header");
+
+		g_free (lzx_b);
+		lzx_b = NULL;
+	}
+
+	return	lzx_b;
+}
+
+gboolean
+ews_oab_decompress_full (const gchar *filename, const gchar *output_filename,
+			 GError **error)
+{
+	LzxHeader *lzx_h = NULL;
+	guint total_decomp_size = 0;
+	FILE *input, *output = NULL;
+	gboolean ret = TRUE;
+	GError *err = NULL;
+
+	input = fopen (filename, "rb");
+	if (!input) {
+		g_set_error_literal (&err, g_quark_from_string ("lzx"), 1, "unable to open the input file");
+		ret = FALSE;
+		goto exit;
+	}
+
+	output = fopen (output_filename, "wb");
+	if (!output) {
+		g_set_error_literal (&err, g_quark_from_string ("lzx"), 1, "unable to open the output file");
+		ret = FALSE;
+		goto exit;
+	}
+
+	lzx_h = read_headers (input, &err);
+	if (!lzx_h) {
+		ret = FALSE;
+		goto exit;
+	}
+
+	/* TODO decompressing multiple lzx_blocks has not been tested yet. Will need to get a setup and test it. */
+	do {
+		LzxBlockHeader *lzx_b;
+		struct lzxd_stream *lzs;
+		goffset offset;
+
+		lzx_b = read_block_header (input, &err);
+		if (err) {
+			ret = FALSE;
+			goto exit;
+		}
+
+		/* note the file offset */
+		offset = ftell (input);
+
+		/* lzx_b points to 1, write it directly to file */
+		if (lzx_b->flags == 0) {
+			gchar *buffer = g_malloc0 (lzx_b->ucomp_size);
+
+			if (!(fread (buffer, 1, lzx_b->ucomp_size, input) == lzx_b->ucomp_size &&
+				fwrite (buffer, 1, lzx_b->ucomp_size, output) == lzx_b->ucomp_size)) {
+				g_set_error_literal (&err, g_quark_from_string ("lzx"), 1, "failed to write data in output file");
+				g_free (buffer);
+				ret = FALSE;
+				goto exit;
+			}
+			g_free (buffer);
+		} else {
+			/* The window size should be the smallest power of two between 2^17 and 2^25 that is
+			   greater than or equal to the sum of the size of the reference data rounded up to
+			   a multiple of 32768 and the size of the subject data. Since we have no reference
+			   data, forget that and the rounding. Just the smallest power of two which is large
+			   enough to cover the subject data (lzx_b->ucomp_size). */
+
+			guint window_bits = g_bit_nth_msf(lzx_b->ucomp_size - 1, -1) + 1;
+
+			if (window_bits < 17)
+				window_bits = 17;
+			else if (window_bits > 25)
+				window_bits = 25;
+
+			lzs = ews_lzxd_init (input, output, window_bits,
+					 0, 4096, lzx_b->ucomp_size, 1);
+			if (!lzs) {
+				g_set_error_literal (&err, g_quark_from_string ("lzx"), 1, "decompression failed (lzxd_init)");
+				ret = FALSE;
+				goto exit;
+			}
+			if (ews_lzxd_decompress (lzs, lzx_b->ucomp_size) != LZX_ERR_OK) {
+				g_set_error_literal (&err, g_quark_from_string ("lzx"), 1, "decompression failed (lzxd_decompress)");
+				ret = FALSE;
+				goto exit;
+			}
+		}
+
+		/* Set the fp to beggining of next block. This is a HACK, looks like decompress reads beyond the block.
+		 * Since we can identify the next block start from block header, we just reset the offset */
+		offset += lzx_b->comp_size;
+		fseek (input, offset, SEEK_SET);
+
+		total_decomp_size += lzx_b->ucomp_size;
+		g_free (lzx_b);
+	} while (total_decomp_size < lzx_h->target_size);
+
+exit:
+	if (input)
+		fclose (input);
+
+	if (output)
+		fclose (output);
+
+	if (err) {
+		ret = FALSE;
+		g_propagate_error (error, err);
+		g_unlink (output_filename);
+	}
+
+	g_free (lzx_h);
+
+	return ret;
+}
+
+typedef struct {
+	guint32 h_version;
+	guint32 l_version;
+	guint32 max_block_size;
+	guint32 source_size;
+	guint32 target_size;
+	guint32 source_crc;
+	guint32 target_crc;
+} LzxPatchHeader;
+
+typedef struct {
+	guint32 patch_size;
+	guint32 target_size;
+	guint32 source_size;
+	guint32 crc;
+} LzxPatchBlockHeader;
+
+
+static LzxPatchHeader *
+read_patch_headers (FILE *input,
+              GError **error)
+{
+	LzxPatchHeader *lzx_h;
+	gboolean success;
+
+	lzx_h = g_new0 (LzxPatchHeader, 1);
+
+	success = read_uint32 (input, &lzx_h->h_version);
+	if (!success)
+		goto exit;
+	success = read_uint32 (input, &lzx_h->l_version);
+	if (!success)
+		goto exit;
+
+	if (lzx_h->h_version !=  0x00000003 || lzx_h->l_version != 0x00000002) {
+		g_free (lzx_h);
+		/* set the right domain later */
+		g_set_error_literal (error, g_quark_from_string ("lzx"), 1, "wrong version header");
+		return NULL;
+	}
+
+	success = read_uint32 (input, &lzx_h->max_block_size);
+	if (!success)
+		goto exit;
+	success = read_uint32 (input, &lzx_h->source_size);
+	if (!success)
+		goto exit;
+	success = read_uint32 (input, &lzx_h->target_size);
+	if (!success)
+		goto exit;
+	success = read_uint32 (input, &lzx_h->source_crc);
+	if (!success)
+		goto exit;
+	success = read_uint32 (input, &lzx_h->target_crc);
+	if (!success)
+		goto exit;
+
+exit:
+	if (!success) {
+		/* set the right domain later */
+		g_set_error_literal (error, g_quark_from_string ("lzx"), 1, "Unable to read lzx main header");
+
+		g_free (lzx_h);
+		lzx_h = NULL;
+	}
+
+	return lzx_h;
+}
+
+static LzxPatchBlockHeader *
+read_patch_block_header (FILE *input,
+			 GError **error)
+{
+	LzxPatchBlockHeader *lzx_b;
+	gboolean success;
+
+	lzx_b = g_new0 (LzxPatchBlockHeader, 1);
+
+	success = read_uint32 (input, &lzx_b->patch_size);
+	if (!success)
+		goto exit;
+
+	success = read_uint32 (input, &lzx_b->target_size);
+	if (!success)
+		goto exit;
+
+	success = read_uint32 (input, &lzx_b->source_size);
+	if (!success)
+		goto exit;
+
+	success = read_uint32 (input, &lzx_b->crc);
+
+exit:
+	if (!success) {
+		/* set the right domain later */
+		g_set_error_literal (error, g_quark_from_string ("lzx"), 1, "Unable to read lzx block header");
+
+		g_free (lzx_b);
+		lzx_b = NULL;
+	}
+
+	return	lzx_b;
+}
+
+gboolean
+ews_oab_decompress_patch (const gchar *filename, const gchar *orig_filename,
+			  const gchar *output_filename, GError **error)
+{
+	LzxPatchHeader *lzx_h = NULL;
+	guint total_decomp_size = 0;
+	FILE *input = NULL, *output = NULL, *orig_input = NULL;
+	gboolean ret = TRUE;
+	GError *err = NULL;
+
+	input = fopen (filename, "rb");
+	if (!input) {
+		g_set_error_literal (&err, g_quark_from_string ("lzx"), 1, "unable to open the input file");
+		ret = FALSE;
+		goto exit;
+	}
+
+	orig_input = fopen (orig_filename, "rb");
+	if (!orig_input) {
+		g_set_error_literal (&err, g_quark_from_string ("lzx"), 1, "unable to open the reference input file");
+		ret = FALSE;
+		goto exit;
+	}
+
+	output = fopen (output_filename, "wb");
+	if (!output) {
+		g_set_error_literal (&err, g_quark_from_string ("lzx"), 1, "unable to open the output file");
+		ret = FALSE;
+		goto exit;
+	}
+
+	lzx_h = read_patch_headers (input, &err);
+	if (!lzx_h) {
+		ret = FALSE;
+		goto exit;
+	}
+
+	/* TODO decompressing multiple lzx_blocks has not been tested yet. Will need to get a setup and test it. */
+	do {
+		LzxPatchBlockHeader *lzx_b;
+		struct lzxd_stream *lzs;
+		goffset offset;
+		guint ref_size, window_bits;
+
+		lzx_b = read_patch_block_header (input, &err);
+		if (err) {
+			printf("err block header\n");
+			ret = FALSE;
+			goto exit;
+		}
+
+		/* note the file offset */
+		offset = ftell(input);
+
+		/* The window size should be the smallest power of two
+		   between 2^17 and 2^25 that is greater than or equal
+		   to the sum of the size of the reference data
+		   rounded up to a multiple of 32768 and the size of
+		   the subject data. */
+		ref_size = (lzx_b->source_size + 32767) & ~32767;
+		window_bits = g_bit_nth_msf(ref_size + lzx_b->target_size - 1, -1) + 1;
+
+		if (window_bits < 17)
+			window_bits = 17;
+		else if (window_bits > 25)
+			window_bits = 25;
+
+		lzs = ews_lzxd_init (input, output, window_bits,
+				 0, 4096, lzx_b->target_size, 1);
+		if (!lzs) {
+			g_set_error_literal (&err, g_quark_from_string ("lzx"), 1, "decompression failed (lzxd_init)");
+			ret = FALSE;
+			goto exit;
+		}
+		if (ews_lzxd_set_reference_data(lzs, orig_input, lzx_b->source_size)) {
+			g_set_error_literal (&err, g_quark_from_string ("lzx"), 1, "decompression failed (lzxd_set_reference_data)");
+			ret = FALSE;
+			goto exit;
+		}
+		if (ews_lzxd_decompress (lzs, lzs->length) != LZX_ERR_OK) {
+			g_set_error_literal (&err, g_quark_from_string ("lzx"), 1, "decompression failed (lzxd_decompress)");
+			ret = FALSE;
+			goto exit;
+		}
+
+		/* Set the fp to beggining of next block. This is a HACK, looks like decompress reads beyond the block.
+		 * Since we can identify the next block start from block header, we just reset the offset */
+		offset += lzx_b->patch_size;
+		fseek (input, offset, SEEK_SET);
+
+		total_decomp_size += lzx_b->target_size;
+		g_free (lzx_b);
+	} while (total_decomp_size < lzx_h->target_size);
+
+exit:
+	if (input)
+		fclose (input);
+
+	if (orig_input)
+		fclose (orig_input);
+
+	if (output)
+		fclose (output);
+
+	if (err) {
+		ret = FALSE;
+		g_propagate_error (error, err);
+		g_unlink (output_filename);
+	}
+
+	g_free (lzx_h);
+
+	return ret;
+}
+
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/readbits.h.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/readbits.h
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/readbits.h.sync-with-3.8.4	2013-07-24 07:30:27.307435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/readbits.h	2013-07-24 07:30:27.307435567 +0200
@@ -0,0 +1,202 @@
+/* This file is part of libmspack.
+ * (C) 2003-2010 Stuart Caie.
+ *
+ * libmspack is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License (LGPL) version 2.1
+ *
+ * For further details, see the file COPYING.LIB distributed with libmspack
+ */
+
+#ifndef READBITS_H
+#define READBITS_H 1
+
+/* this header defines macros that read data streams by
+ * the individual bits
+ *
+ * INIT_BITS         initialises bitstream state in state structure
+ * STORE_BITS        stores bitstream state in state structure
+ * RESTORE_BITS      restores bitstream state from state structure
+ * ENSURE_BITS(n)    ensure there are at least N bits in the bit buffer
+ * READ_BITS(var,n)  takes N bits from the buffer and puts them in var
+ * PEEK_BITS(n)      extracts without removing N bits from the bit buffer
+ * REMOVE_BITS(n)    removes N bits from the bit buffer
+ *
+ * READ_BITS simply calls ENSURE_BITS, PEEK_BITS and REMOVE_BITS,
+ * which means it's limited to reading the number of bits you can
+ * ensure at any one time. It also fails if asked to read zero bits.
+ * If you need to read zero bits, or more bits than can be ensured in
+ * one go, use READ_MANY_BITS instead.
+ *
+ * These macros have variable names baked into them, so to use them
+ * you have to define some macros:
+ * - BITS_TYPE: the type name of your state structure
+ * - BITS_VAR: the variable that points to your state structure
+ * - define BITS_ORDER_MSB if bits are read from the MSB, or
+ *   define BITS_ORDER_LSB if bits are read from the LSB
+ * - READ_BYTES: some code that reads more data into the bit buffer,
+ *   it should use READ_IF_NEEDED (calls read_input if the byte buffer
+ *   is empty), then INJECT_BITS(data,n) to put data from the byte
+ *   buffer into the bit buffer.
+ *
+ * You also need to define some variables and structure members:
+ * - unsigned char *i_ptr;    // current position in the byte buffer
+ * - unsigned char *i_end;    // end of the byte buffer
+ * - unsigned int bit_buffer; // the bit buffer itself
+ * - unsigned int bits_left;  // number of bits remaining
+ *
+ * If you use read_input() and READ_IF_NEEDED, they also expect these
+ * structure members:
+ * - unsigned int error;         // to record/return read errors
+ * - unsigned char input_end;    // to mark reaching the EOF
+ * - unsigned char *inbuf;       // the input byte buffer
+ * - unsigned int inbuf_size;    // the size of the input byte buffer
+ *
+ * Your READ_BYTES implementation should read data from *i_ptr and
+ * put them in the bit buffer. READ_IF_NEEDED will call read_input()
+ * if i_ptr reaches i_end, and will fill up inbuf and set i_ptr to
+ * the start of inbuf and i_end to the end of inbuf.
+ *
+ * If you're reading in MSB order, the routines work by using the area
+ * beyond the MSB and the LSB of the bit buffer as a free source of
+ * zeroes when shifting. This avoids having to mask any bits. So we
+ * have to know the bit width of the bit buffer variable. We use
+ * <limits.h> and CHAR_BIT to find the size of the bit buffer in bits.
+ *
+ * If you are reading in LSB order, bits need to be masked. Normally
+ * this is done by computing the mask: N bits are masked by the value
+ * (1<<N)-1). However, you can define BITS_LSB_TABLE to use a lookup
+ * table instead of computing this. This adds two new macros,
+ * PEEK_BITS_T and READ_BITS_T which work the same way as PEEK_BITS
+ * and READ_BITS, except they use this lookup table. This is useful if
+ * you need to look up a number of bits that are only known at
+ * runtime, so the bit mask can't be turned into a constant by the
+ * compiler.
+
+ * The bit buffer datatype should be at least 32 bits wide: it must be
+ * possible to ENSURE_BITS(17), so it must be possible to add 16 new bits
+ * to the bit buffer when the bit buffer already has 1 to 15 bits left.
+ */
+
+#ifndef BITS_VAR
+# error "define BITS_VAR as the state structure poiner variable name"
+#endif
+#ifndef BITS_TYPE
+# error "define BITS_TYPE as the state structure type"
+#endif
+#if defined(BITS_ORDER_MSB) && defined(BITS_ORDER_LSB)
+# error "you must define either BITS_ORDER_MSB or BITS_ORDER_LSB"
+#else
+# if !(defined(BITS_ORDER_MSB) || defined(BITS_ORDER_LSB))
+#  error "you must define BITS_ORDER_MSB or BITS_ORDER_LSB"
+# endif
+#endif
+
+# include <limits.h>
+
+#define BITBUF_WIDTH (sizeof(bit_buffer) * CHAR_BIT)
+
+#define INIT_BITS do {				\
+    BITS_VAR->i_ptr      = &BITS_VAR->inbuf[0];	\
+    BITS_VAR->i_end      = &BITS_VAR->inbuf[0];	\
+    BITS_VAR->bit_buffer = 0;			\
+    BITS_VAR->bits_left  = 0;			\
+    BITS_VAR->input_end  = 0;			\
+} while (0)
+
+#define STORE_BITS do {			\
+    BITS_VAR->i_ptr      = i_ptr;	\
+    BITS_VAR->i_end      = i_end;	\
+    BITS_VAR->bit_buffer = bit_buffer;	\
+    BITS_VAR->bits_left  = bits_left;	\
+} while (0)
+
+#define RESTORE_BITS do {		\
+    i_ptr      = BITS_VAR->i_ptr;	\
+    i_end      = BITS_VAR->i_end;	\
+    bit_buffer = BITS_VAR->bit_buffer;	\
+    bits_left  = BITS_VAR->bits_left;	\
+} while (0)
+
+#define ENSURE_BITS(nbits) do {			\
+    while (bits_left < (nbits)) READ_BYTES;	\
+} while (0)
+
+#define READ_BITS(val, nbits) do {		\
+    ENSURE_BITS(nbits);				\
+    (val) = PEEK_BITS(nbits);			\
+    REMOVE_BITS(nbits);				\
+} while (0)
+
+#define READ_MANY_BITS(val, bits) do {				\
+    unsigned char needed = (bits), bitrun;			\
+    (val) = 0;							\
+    while (needed > 0) {					\
+	if (bits_left <= (BITBUF_WIDTH - 16)) READ_BYTES;	\
+	bitrun = (bits_left < needed) ? bits_left : needed;	\
+	(val) = ((val) << bitrun) | PEEK_BITS(bitrun);		\
+	REMOVE_BITS(bitrun);					\
+	needed -= bitrun;					\
+    }								\
+} while (0)
+
+#ifdef BITS_ORDER_MSB
+# define PEEK_BITS(nbits)   (bit_buffer >> (BITBUF_WIDTH - (nbits)))
+# define REMOVE_BITS(nbits) ((bit_buffer <<= (nbits)), (bits_left -= (nbits)))
+# define INJECT_BITS(bitdata,nbits) ((bit_buffer |= \
+    (bitdata) << (BITBUF_WIDTH - (nbits) - bits_left)), (bits_left += (nbits)))
+#else /* BITS_ORDER_LSB */
+# define PEEK_BITS(nbits)   (bit_buffer & ((1 << (nbits))-1))
+# define REMOVE_BITS(nbits) ((bit_buffer >>= (nbits)), (bits_left -= (nbits)))
+# define INJECT_BITS(bitdata,nbits) ((bit_buffer |= \
+    (bitdata) << bits_left), (bits_left += (nbits)))
+#endif
+
+#ifdef BITS_LSB_TABLE
+/* lsb_bit_mask[n] = (1 << n) - 1 */
+static const unsigned short lsb_bit_mask[17] = {
+    0x0000, 0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
+    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
+};
+# define PEEK_BITS_T(nbits) (bit_buffer & lsb_bit_mask[(nbits)])
+# define READ_BITS_T(val, nbits) do {	\
+    ENSURE_BITS(nbits);			\
+    (val) = PEEK_BITS_T(nbits);		\
+    REMOVE_BITS(nbits);			\
+} while (0)
+#endif
+
+#ifndef BITS_NO_READ_INPUT
+# define READ_IF_NEEDED do {		\
+    if (i_ptr >= i_end) {		\
+	if (read_input(BITS_VAR))	\
+	    return BITS_VAR->error;	\
+	i_ptr = BITS_VAR->i_ptr;	\
+	i_end = BITS_VAR->i_end;	\
+    }					\
+} while (0)
+
+static int read_input(BITS_TYPE *p) {
+    int read = fread(p->inbuf, 1, (int)p->inbuf_size, p->input);
+    if (read < 0) return p->error = LZX_ERR_READ;
+
+    /* we might overrun the input stream by asking for bits we don't use,
+     * so fake 2 more bytes at the end of input */
+    if (read == 0) {
+	if (p->input_end) {
+	    D(("out of input bytes"))
+	    return p->error = LZX_ERR_READ;
+	}
+	else {
+	    read = 2;
+	    p->inbuf[0] = p->inbuf[1] = 0;
+	    p->input_end = 1;
+	}
+    }
+
+    /* update i_ptr and i_end */
+    p->i_ptr = &p->inbuf[0];
+    p->i_end = &p->inbuf[read];
+    return LZX_ERR_OK;
+}
+#endif
+#endif
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/readhuff.h.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/readhuff.h
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/readhuff.h.sync-with-3.8.4	2013-07-24 07:30:27.308435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/readhuff.h	2013-07-24 07:30:27.308435567 +0200
@@ -0,0 +1,173 @@
+/* This file is part of libmspack.
+ * (C) 2003-2010 Stuart Caie.
+ *
+ * libmspack is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License (LGPL) version 2.1
+ *
+ * For further details, see the file COPYING.LIB distributed with libmspack
+ */
+
+#ifndef MSPACK_READHUFF_H
+#define MSPACK_READHUFF_H 1
+
+/* This implements a fast Huffman tree decoding system.
+ */
+
+#if !(defined(BITS_ORDER_MSB) || defined(BITS_ORDER_LSB))
+# error "readhuff.h is used in conjunction with readbits.h, include that first"
+#endif
+#if !(defined(TABLEBITS) && defined(MAXSYMBOLS))
+# error "define TABLEBITS(tbl) and MAXSYMBOLS(tbl) before using readhuff.h"
+#endif
+#if !(defined(HUFF_TABLE) && defined(HUFF_LEN))
+# error "define HUFF_TABLE(tbl) and HUFF_LEN(tbl) before using readhuff.h"
+#endif
+#ifndef HUFF_ERROR
+# error "define HUFF_ERROR before using readhuff.h"
+#endif
+#ifndef HUFF_MAXBITS
+# define HUFF_MAXBITS 16
+#endif
+
+/* Decodes the next huffman symbol from the input bitstream into var.
+ * Do not use this macro on a table unless build_decode_table() succeeded.
+ */
+#define READ_HUFFSYM(tbl, var) do {			\
+    ENSURE_BITS(HUFF_MAXBITS);				\
+    sym = HUFF_TABLE(tbl, PEEK_BITS(TABLEBITS(tbl)));	\
+    if (sym >= MAXSYMBOLS(tbl))	HUFF_TRAVERSE(tbl);	\
+    (var) = sym;					\
+    i = HUFF_LEN(tbl, sym);				\
+    REMOVE_BITS(i);					\
+} while (0)
+
+#ifdef BITS_ORDER_LSB
+# define HUFF_TRAVERSE(tbl) do {			\
+    i = TABLEBITS(tbl) - 1;				\
+    do {						\
+	if (i++ > HUFF_MAXBITS) HUFF_ERROR;		\
+	sym = HUFF_TABLE(tbl,				\
+            (sym << 1) | ((bit_buffer >> i) & 1));	\
+    } while (sym >= MAXSYMBOLS(tbl));			\
+} while (0)
+#else
+#define HUFF_TRAVERSE(tbl) do {				\
+    i = 1 << (BITBUF_WIDTH - TABLEBITS(tbl));		\
+    do {						\
+	if ((i >>= 1) == 0) HUFF_ERROR;			\
+	sym = HUFF_TABLE(tbl,				\
+	    (sym << 1) | ((bit_buffer & i) ? 1 : 0));	\
+    } while (sym >= MAXSYMBOLS(tbl));			\
+} while (0)
+#endif
+
+/* make_decode_table(nsyms, nbits, length[], table[])
+ *
+ * This function was originally coded by David Tritscher.
+ * It builds a fast huffman decoding table from
+ * a canonical huffman code lengths table.
+ *
+ * nsyms  = total number of symbols in this huffman tree.
+ * nbits  = any symbols with a code length of nbits or less can be decoded
+ *          in one lookup of the table.
+ * length = A table to get code lengths from [0 to nsyms-1]
+ * table  = The table to fill up with decoded symbols and pointers.
+ *          Should be ((1<<nbits) + (nsyms*2)) in length.
+ *
+ * Returns 0 for OK or 1 for error
+ */
+static int make_decode_table(unsigned int nsyms, unsigned int nbits,
+			     unsigned char *length, unsigned short *table)
+{
+    register unsigned short sym, next_symbol;
+    register unsigned int leaf, fill;
+#ifdef BITS_ORDER_LSB
+    register unsigned int reverse;
+#endif
+    register unsigned char bit_num;
+    unsigned int pos         = 0; /* the current position in the decode table */
+    unsigned int table_mask  = 1 << nbits;
+    unsigned int bit_mask    = table_mask >> 1; /* don't do 0 length codes */
+
+    /* fill entries for codes short enough for a direct mapping */
+    for (bit_num = 1; bit_num <= nbits; bit_num++) {
+	for (sym = 0; sym < nsyms; sym++) {
+	    if (length[sym] != bit_num) continue;
+#ifdef BITS_ORDER_MSB
+	    leaf = pos;
+#else
+	    /* reverse the significant bits */
+	    fill = length[sym]; reverse = pos >> (nbits - fill); leaf = 0;
+	    do {leaf <<= 1; leaf |= reverse & 1; reverse >>= 1;} while (--fill);
+#endif
+
+	    if((pos += bit_mask) > table_mask) return 1; /* table overrun */
+
+	    /* fill all possible lookups of this symbol with the symbol itself */
+#ifdef BITS_ORDER_MSB
+	    for (fill = bit_mask; fill-- > 0;) table[leaf++] = sym;
+#else
+	    fill = bit_mask; next_symbol = 1 << bit_num;
+	    do { table[leaf] = sym; leaf += next_symbol; } while (--fill);
+#endif
+	}
+	bit_mask >>= 1;
+    }
+
+    /* exit with success if table is now complete */
+    if (pos == table_mask) return 0;
+
+    /* mark all remaining table entries as unused */
+    for (sym = pos; sym < table_mask; sym++) {
+#ifdef BITS_ORDER_MSB
+	table[sym] = 0xFFFF;
+#else
+	reverse = sym; leaf = 0; fill = nbits;
+	do { leaf <<= 1; leaf |= reverse & 1; reverse >>= 1; } while (--fill);
+	table[leaf] = 0xFFFF;
+#endif
+    }
+
+    /* next_symbol = base of allocation for long codes */
+    next_symbol = ((table_mask >> 1) < nsyms) ? nsyms : (table_mask >> 1);
+
+    /* give ourselves room for codes to grow by up to 16 more bits.
+     * codes now start at bit nbits+16 and end at (nbits+16-codelength) */
+    pos <<= 16;
+    table_mask <<= 16;
+    bit_mask = 1 << 15;
+
+    for (bit_num = nbits+1; bit_num <= HUFF_MAXBITS; bit_num++) {
+	for (sym = 0; sym < nsyms; sym++) {
+	    if (length[sym] != bit_num) continue;
+
+#ifdef BITS_ORDER_MSB
+	    leaf = pos >> 16;
+#else
+	    /* leaf = the first nbits of the code, reversed */
+	    reverse = pos >> 16; leaf = 0; fill = nbits;
+	    do {leaf <<= 1; leaf |= reverse & 1; reverse >>= 1;} while (--fill);
+#endif
+	    for (fill = 0; fill < (bit_num - nbits); fill++) {
+		/* if this path hasn't been taken yet, 'allocate' two entries */
+		if (table[leaf] == 0xFFFF) {
+		    table[(next_symbol << 1)     ] = 0xFFFF;
+		    table[(next_symbol << 1) + 1 ] = 0xFFFF;
+		    table[leaf] = next_symbol++;
+		}
+
+		/* follow the path and select either left or right for next bit */
+		leaf = table[leaf] << 1;
+		if ((pos >> (15-fill)) & 1) leaf++;
+	    }
+	    table[leaf] = sym;
+
+	    if ((pos += bit_mask) > table_mask) return 1; /* table overflow */
+	}
+	bit_mask >>= 1;
+    }
+
+    /* full table? */
+    return (pos == table_mask) ? 0 : 1;
+}
+#endif
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/README.mspack.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/README.mspack
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/README.mspack.sync-with-3.8.4	2013-07-24 07:30:27.308435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/mspack/README.mspack	2013-07-24 07:30:27.308435567 +0200
@@ -0,0 +1,15 @@
+
+This contains a local copy of parts of libmspack.
+
+Parts (lzxd.c and various header files) were originally lifted from
+libmspack and modified to support the LZX DELTA format.
+
+The "file format" support in oab-decompress.c was developed as part of
+Evolution-EWS, and a mostly rewritten version was later submitted for
+inclusion in libmspack upstream.
+
+If you have a sufficiently recent version of libmspack, none of the
+code in this directory will be used. Instead ews-oab-decompressor.c
+in the parent directory will invoke the decompressor in libmspack.
+
+
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/oab-decode-test.c.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/oab-decode-test.c
--- evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/oab-decode-test.c.sync-with-3.8.4	2013-07-24 07:30:27.297435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/addressbook/oab-decode-test.c	2013-07-24 07:30:27.297435567 +0200
@@ -0,0 +1,86 @@
+#undef EDS_DISABLE_DEPRECATED
+
+#include <math.h>
+#include <stdlib.h>
+#include <string.h>
+#include <glib/gstdio.h>
+
+#include <libebook/libebook.h>
+#include <libedata-book/libedata-book.h>
+
+#include "ews-oab-decoder.h"
+#include "ews-oab-props.h"
+
+struct _db_data {
+	GSList *contact_collector;
+	guint collected_length;
+	EBookBackendSqliteDB *summary;
+	const gchar *folderid;
+};
+
+static void
+ews_test_store_contact (EContact *contact,
+                        goffset offset,
+                        guint percent,
+                        gpointer user_data,
+                        GError **error)
+{
+	struct _db_data *data = (struct _db_data *) user_data;
+
+	data->contact_collector = g_slist_prepend (data->contact_collector, g_object_ref (contact));
+	data->collected_length += 1;
+
+	if (data->collected_length == 1000 || percent >= 100) {
+		data->contact_collector = g_slist_reverse (data->contact_collector);
+		e_book_backend_sqlitedb_add_contacts (data->summary, data->folderid, data->contact_collector, FALSE, error);
+		g_print ("percent complete %d \n", percent);
+
+		g_slist_foreach (data->contact_collector, (GFunc) g_object_unref, NULL);
+		g_slist_free (data->contact_collector);
+		data->contact_collector = NULL;
+		data->collected_length = 0;
+	}
+}
+
+gint
+main (gint argc,
+      gchar *argv[])
+{
+	EBookBackendSqliteDB *summary;
+	EwsOabDecoder *eod;
+	GError *err = NULL;
+	GTimer *timer;
+	struct _db_data data;
+
+	g_type_init ();
+
+	if (argc != 3) {
+		g_print ("Pass the oab filename  and cache dir as argument \n");
+		return -1;
+	}
+
+	summary = e_book_backend_sqlitedb_new (argv[2], "dum", "de", "dum", TRUE, NULL);
+	eod = ews_oab_decoder_new (argv[1], argv[2], &err);
+
+	data.contact_collector = NULL;
+	data.collected_length = 0;
+	data.summary = summary;
+	data.folderid = "de";
+
+	timer = g_timer_new ();
+	g_timer_start (timer);
+	if (!ews_oab_decoder_decode (eod, ews_test_store_contact, &data, NULL, &err)) {
+		g_print ("Unable to decode %s \n", err->message);
+	}
+	g_timer_stop (timer);
+	g_print ("Time elapsed %lf \n", g_timer_elapsed (timer, NULL));
+
+	if (err)
+		g_clear_error (&err);
+
+	g_object_unref (eod);
+	g_object_unref (summary);
+
+	return 0;
+}
+
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/calendar/e-cal-backend-ews.c.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/calendar/e-cal-backend-ews.c
--- evolution-ews-gnome-3-0.gitcc16df2/src/calendar/e-cal-backend-ews.c.sync-with-3.8.4	2013-07-24 07:30:27.257435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/calendar/e-cal-backend-ews.c	2013-07-24 07:30:27.313435567 +0200
@@ -958,6 +958,48 @@ e_cal_backend_ews_remove (ECalBackend *b
 	e_data_cal_respond_remove (cal, context, NULL);
 }
 
+/* to not depend on added function in 3.8.4 */
+static gchar *
+e_ews_cal_backend_store_get_components_by_uid_as_ical_string (ECalBackendStore *store,
+							      const gchar *uid)
+{
+	GSList *comps;
+	gchar *ical_string = NULL;
+
+	g_return_val_if_fail (E_IS_CAL_BACKEND_STORE (store), NULL);
+	g_return_val_if_fail (uid != NULL, NULL);
+
+	comps = e_cal_backend_store_get_components_by_uid (store, uid);
+	if (!comps)
+		return NULL;
+
+	if (!comps->next) {
+		ical_string = e_cal_component_get_as_string (comps->data);
+	} else {
+		GSList *citer;
+		icalcomponent *icalcomp;
+
+		/* if we have detached recurrences, return a VCALENDAR */
+		icalcomp = e_cal_util_new_top_level ();
+
+		for (citer = comps; citer; citer = g_slist_next (citer)) {
+			ECalComponent *comp = citer->data;
+
+			icalcomponent_add_component (
+				icalcomp,
+				icalcomponent_new_clone (e_cal_component_get_icalcomponent (comp)));
+		}
+
+		ical_string = icalcomponent_as_ical_string_r (icalcomp);
+
+		icalcomponent_free (icalcomp);
+	}
+
+	g_slist_free_full (comps, g_object_unref);
+
+	return ical_string;
+}
+
 static void
 e_cal_backend_ews_get_object (ECalBackend *backend,
                               EDataCal *cal,
@@ -966,7 +1008,6 @@ e_cal_backend_ews_get_object (ECalBacken
                               const gchar *uid,
                               const gchar *rid)
 {
-	ECalComponent *comp;
 	ECalBackendEwsPrivate *priv;
 	ECalBackendEws *cbews = (ECalBackendEws *) backend;
 	gchar *object = NULL;
@@ -988,32 +1029,52 @@ e_cal_backend_ews_get_object (ECalBacken
 	}
 
 	/* search the object in the cache */
-	comp = e_cal_backend_store_get_component (priv->store, uid, rid);
-	if (!comp && e_cal_backend_ews_get_online (E_CAL_BACKEND_EWS (backend))) {
-		/* maybe a meeting invitation, for which the calendar item is not downloaded yet,
-		 * thus synchronize local cache first */
-		ews_start_sync (cbews);
-
-		PRIV_UNLOCK (priv);
-		e_flag_wait (priv->refreshing_done);
-		PRIV_LOCK (priv);
+	if (rid && *rid) {
+		ECalComponent *comp;
 
 		comp = e_cal_backend_store_get_component (priv->store, uid, rid);
-	}
+		if (!comp && e_cal_backend_ews_get_online (E_CAL_BACKEND_EWS (backend))) {
+			/* maybe a meeting invitation, for which the calendar item is not downloaded yet,
+			 * thus synchronize local cache first */
+			ews_start_sync (cbews);
 
-	if (comp) {
-		if (e_cal_backend_get_kind (backend) ==
-		    icalcomponent_isa (e_cal_component_get_icalcomponent (comp)))
-			object = e_cal_component_get_as_string (comp);
-		else
-			object = NULL;
+			PRIV_UNLOCK (priv);
+			e_flag_wait (priv->refreshing_done);
+			PRIV_LOCK (priv);
 
-		g_object_unref (comp);
+			comp = e_cal_backend_store_get_component (priv->store, uid, rid);
+		}
 
-		if (!object)
+		if (comp) {
+			if (e_cal_backend_get_kind (backend) ==
+			    icalcomponent_isa (e_cal_component_get_icalcomponent (comp)))
+				object = e_cal_component_get_as_string (comp);
+			else
+				object = NULL;
+
+			g_object_unref (comp);
+
+			if (!object)
+				g_propagate_error (&error, EDC_ERROR (ObjectNotFound));
+		} else {
 			g_propagate_error (&error, EDC_ERROR (ObjectNotFound));
+		}
 	} else {
-		g_propagate_error (&error, EDC_ERROR (ObjectNotFound));
+		object = e_ews_cal_backend_store_get_components_by_uid_as_ical_string (priv->store, uid);
+		if (!object && e_cal_backend_ews_get_online (E_CAL_BACKEND_EWS (backend))) {
+			/* maybe a meeting invitation, for which the calendar item is not downloaded yet,
+			 * thus synchronize local cache first */
+			ews_start_sync (cbews);
+
+			PRIV_UNLOCK (priv);
+			e_flag_wait (priv->refreshing_done);
+			PRIV_LOCK (priv);
+
+			object = e_ews_cal_backend_store_get_components_by_uid_as_ical_string (priv->store, uid);
+		}
+
+		if (!object)
+			g_propagate_error (&error, EDC_ERROR (ObjectNotFound));
 	}
 
 	PRIV_UNLOCK (priv);
@@ -3561,7 +3622,6 @@ add_item_to_cache (ECalBackendEws *cbews
 		const EwsId *item_id;
 		ECalComponentId *id;
 		const GSList *l = NULL;
-		const gchar *org_email_address = e_ews_collect_organizer (icalcomp);
 		const gchar *uid = e_ews_item_get_uid (item);
 
 		item_id = e_ews_item_get_id (item);
@@ -3579,11 +3639,6 @@ add_item_to_cache (ECalBackendEws *cbews
 			if (g_strcmp0 (attendee->mailbox->routing_type, "EX") == 0)
 				email = e_ews_item_util_strip_ex_address (attendee->mailbox->email);
 
-			/*remove organizer for attendees list*/
-			if (g_ascii_strcasecmp (org_email_address, email ? email : attendee->mailbox->email) == 0) {
-				continue;
-			}
-
 			mailtoname = g_strdup_printf ("mailto:%s", email ? email : attendee->mailbox->email);
 			icalprop = icalproperty_new_attendee (mailtoname);
 			g_free (mailtoname);
@@ -3702,6 +3757,29 @@ add_item_to_cache (ECalBackendEws *cbews
 		comp = e_cal_component_new ();
 		e_cal_component_set_icalcomponent (comp, icalcomponent_new_clone (icalcomp));
 
+		/*
+		 * There is no API to set/get alarm description on the server side.
+		 * However, for some reason, the alarm description has been set to "REMINDER"
+		 * automatically (and with no i18n). Instead of show it to the user, let's
+		 * set the summary as the alarm description.
+		 */
+		if (e_cal_component_has_alarms (comp)) {
+			GList *alarm_uids, *l;
+
+			alarm_uids = e_cal_component_get_alarm_uids (comp);
+			for (l = alarm_uids; l != NULL; l = l->next) {
+				ECalComponentAlarm *alarm;
+				ECalComponentText text;
+
+				alarm = e_cal_component_get_alarm (comp, l->data);
+				e_cal_component_get_summary (comp, &text);
+				e_cal_component_alarm_set_description (alarm, &text);
+
+				e_cal_component_alarm_free (alarm);
+			}
+			cal_obj_uid_list_free (alarm_uids);
+		}
+
 		id = e_cal_component_get_id (comp);
 		cache_comp = e_cal_backend_store_get_component (priv->store, id->uid, id->rid);
 		e_cal_component_free_id (id);
@@ -4357,7 +4435,11 @@ e_cal_backend_ews_get_backend_property	(
 					 CAL_STATIC_CAPABILITY_NO_CONV_TO_ASSIGN_TASK ","
 				//	 CAL_STATIC_CAPABILITY_NO_CONV_TO_RECUR ","
 					 CAL_STATIC_CAPABILITY_NO_TASK_ASSIGNMENT ","
-					 CAL_STATIC_CAPABILITY_SAVE_SCHEDULES);
+					 CAL_STATIC_CAPABILITY_SAVE_SCHEDULES ","
+					/*
+					 * This capability was added after the 3.8.0 release
+					 */
+					"no-alarm-after-start");
 	} else if (g_str_equal (prop_name, CAL_BACKEND_PROPERTY_CAL_EMAIL_ADDRESS)) {
 		/* return email address of the person who opened the calendar */
 		ECalBackendEws *cbews;
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/calendar/e-cal-backend-ews-utils.c.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/calendar/e-cal-backend-ews-utils.c
--- evolution-ews-gnome-3-0.gitcc16df2/src/calendar/e-cal-backend-ews-utils.c.sync-with-3.8.4	2013-07-24 07:30:27.258435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/calendar/e-cal-backend-ews-utils.c	2013-07-24 07:30:27.312435567 +0200
@@ -94,6 +94,9 @@ e_ews_collect_attendees (icalcomponent *
 			break;
 		}
 	}
+
+	if (*required == NULL && *optional == NULL && *resource == NULL && org_email_address != NULL)
+		*required = g_slist_prepend (*required, (gpointer) org_email_address);
 }
 
 gint
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/camel/camel-ews-folder.c.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/camel/camel-ews-folder.c
--- evolution-ews-gnome-3-0.gitcc16df2/src/camel/camel-ews-folder.c.sync-with-3.8.4	2013-07-24 07:30:27.260435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/camel/camel-ews-folder.c	2013-07-24 07:30:27.309435567 +0200
@@ -1846,12 +1846,25 @@ ews_folder_dispose (GObject *object)
 		ews_folder->search = NULL;
 	}
 
+	/* Chain up to parent's dispose() method. */
+	G_OBJECT_CLASS (camel_ews_folder_parent_class)->dispose (object);
+}
+
+static void
+ews_folder_finalize (GObject *object)
+{
+	CamelEwsFolder *ews_folder;
+
+	ews_folder = CAMEL_EWS_FOLDER (object);
+
 	g_mutex_free (ews_folder->priv->search_lock);
+	g_mutex_free (ews_folder->priv->state_lock);
+	g_static_rec_mutex_free (&ews_folder->priv->cache_lock);
 	g_hash_table_destroy (ews_folder->priv->uid_eflags);
 	g_cond_free (ews_folder->priv->fetch_cond);
 
-	/* Chain up to parent's dispose() method. */
-	G_OBJECT_CLASS (camel_ews_folder_parent_class)->dispose (object);
+	/* Chain up to parent's finalize() method. */
+	G_OBJECT_CLASS (camel_ews_folder_parent_class)->finalize (object);
 }
 
 static void
@@ -1884,6 +1897,7 @@ camel_ews_folder_class_init (CamelEwsFol
 
 	object_class = G_OBJECT_CLASS (class);
 	object_class->dispose = ews_folder_dispose;
+	object_class->finalize = ews_folder_finalize;
 	object_class->constructed = ews_folder_constructed;
 
 	folder_class = CAMEL_FOLDER_CLASS (class);
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/camel/camel-ews-utils.c.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/camel/camel-ews-utils.c
--- evolution-ews-gnome-3-0.gitcc16df2/src/camel/camel-ews-utils.c.sync-with-3.8.4	2013-07-24 07:30:27.265435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/camel/camel-ews-utils.c	2013-07-24 07:30:27.309435567 +0200
@@ -139,6 +139,10 @@ camel_ews_utils_build_folder_info (Camel
 }
 
 static void
+add_folder_to_summary (CamelEwsStore *store,
+                       EEwsFolder *folder);
+
+static void
 sync_deleted_folders (CamelEwsStore *store,
                       GSList *deleted_folders)
 {
@@ -222,6 +226,13 @@ sync_updated_folders (CamelEwsStore *sto
 		folder_name = camel_ews_store_summary_get_folder_full_name (
 			ews_summary, fid->id, NULL);
 
+		if (!folder_name) {
+			/* in case the folder is not in the local store summary,
+			   just add it as a new folder */
+			add_folder_to_summary (store, ews_folder);
+			continue;
+		}
+
 		pfid = e_ews_folder_get_parent_id (ews_folder);
 		display_name = g_strdup (e_ews_folder_get_name (ews_folder));
 
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/server/e-ews-connection.c.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/server/e-ews-connection.c
--- evolution-ews-gnome-3-0.gitcc16df2/src/server/e-ews-connection.c.sync-with-3.8.4	2013-07-24 07:30:27.290435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/server/e-ews-connection.c	2013-07-24 07:30:27.311435567 +0200
@@ -1403,6 +1403,7 @@ void
 ews_oal_details_free (EwsOALDetails *details)
 {
 	if (details != NULL) {
+		g_free (details->type);
 		g_free (details->sha);
 		g_free (details->filename);
 		g_free (details);
@@ -2172,6 +2173,7 @@ struct _oal_req_data {
 
 	GSList *oals;
 	GSList *elements;
+	gchar *etag;
 
 	GCancellable *cancellable;
 	gulong cancel_id;
@@ -2193,6 +2195,7 @@ oal_req_data_free (struct _oal_req_data 
 
 	g_free (data->oal_id);
 	g_free (data->oal_element);
+	g_free (data->etag);
 
 	g_slist_free_full (data->oals, (GDestroyNotify) ews_oal_free);
 	g_slist_free_full (data->elements, (GDestroyNotify) ews_oal_details_free);
@@ -2256,20 +2259,27 @@ parse_oal_full_details (xmlNode *node,
 	GSList *elements = NULL;
 
 	for (node = node->children; node; node = node->next) {
-		if (node->type == XML_ELEMENT_NODE && !strcmp ((gchar *) node->name, element)) {
-			EwsOALDetails *det = g_new0 (EwsOALDetails, 1);
+		EwsOALDetails *det;
+		if (node->type != XML_ELEMENT_NODE)
+			continue;
+		if (element && strcmp ((gchar *) node->name, element))
+			continue;
+		if (!element && strcmp ((gchar *) node->name, "Full") &&
+		    strcmp((gchar *) node->name, "Diff"))
+			continue;
 
-			det->seq = get_property_as_uint32 (node, "seq");
-			det->ver = get_property_as_uint32 (node, "ver");
-			det->size = get_property_as_uint32 (node, "size");
-			det->uncompressed_size = get_property_as_uint32 (node, "uncompressedsize");
-			det->sha = get_property (node, "uncompressedsize");
-			det->filename = g_strstrip (get_content (node));
+		det = g_new0 (EwsOALDetails, 1);
+		det->type = g_strdup((gchar *) node->name);
+		det->seq = get_property_as_uint32 (node, "seq");
+		det->ver = get_property_as_uint32 (node, "ver");
+		det->size = get_property_as_uint32 (node, "size");
+		det->uncompressed_size = get_property_as_uint32 (node, "uncompressedsize");
+		det->sha = get_property (node, "uncompressedsize");
+		det->filename = g_strstrip (get_content (node));
 
-			elements = g_slist_prepend (elements, det);
-			if (!strcmp (element, "Full"))
-				break;
-		}
+		elements = g_slist_prepend (elements, det);
+		if (element && !strcmp (element, "Full"))
+			break;
 	}
 
 	return elements;
@@ -2283,6 +2293,7 @@ oal_response_cb (SoupSession *soup_sessi
 {
 	GSimpleAsyncResult *simple;
 	struct _oal_req_data *data;
+	const gchar *etag;
 	xmlDoc *doc;
 	xmlNode *node;
 
@@ -2299,6 +2310,11 @@ oal_response_cb (SoupSession *soup_sessi
 		goto exit;
 	}
 
+	etag = soup_message_headers_get_one(soup_message->response_headers,
+					    "ETag");
+	if (etag)
+		data->etag = g_strdup(etag);
+
 	ews_dump_raw_soup_response (soup_message);
 
 	doc = xmlReadMemory (
@@ -2317,7 +2333,7 @@ oal_response_cb (SoupSession *soup_sessi
 		g_simple_async_result_set_error (
 			simple, EWS_CONNECTION_ERROR, -1,
 			"%s", _("Failed to find <OAB> element\n"));
-		goto exit;
+		goto exit_doc;
 	}
 
 	for (node = node->children; node; node = node->next) {
@@ -2348,7 +2364,9 @@ oal_response_cb (SoupSession *soup_sessi
 
 	data->oals = g_slist_reverse (data->oals);
 
-exit:
+ exit_doc:
+	xmlFreeDoc (doc);
+ exit:
 	g_simple_async_result_complete_in_idle (simple);
 	/* This is run in cnc->priv->soup_thread, and the cnc is held by simple, thus
 	 * for cases when the complete_in_idle is finished before the unref call, when
@@ -2480,7 +2498,9 @@ gboolean
 e_ews_connection_get_oal_detail_sync (EEwsConnection *cnc,
                                       const gchar *oal_id,
                                       const gchar *oal_element,
+				      const gchar *old_etag,
                                       GSList **elements,
+				      gchar **etag,
                                       GCancellable *cancellable,
                                       GError **error)
 {
@@ -2493,13 +2513,13 @@ e_ews_connection_get_oal_detail_sync (EE
 	closure = e_async_closure_new ();
 
 	e_ews_connection_get_oal_detail (
-		cnc, oal_id, oal_element, cancellable,
-		e_async_closure_callback, closure);
+		cnc, oal_id, oal_element, old_etag,
+		cancellable, e_async_closure_callback, closure);
 
 	result = e_async_closure_wait (closure);
 
 	success = e_ews_connection_get_oal_detail_finish (
-		cnc, result, elements, error);
+		cnc, result, elements, etag, error);
 
 	e_async_closure_free (closure);
 
@@ -2510,6 +2530,7 @@ void
 e_ews_connection_get_oal_detail (EEwsConnection *cnc,
                                  const gchar *oal_id,
                                  const gchar *oal_element,
+				 const gchar *etag,
                                  GCancellable *cancellable,
                                  GAsyncReadyCallback callback,
                                  gpointer user_data)
@@ -2534,6 +2555,10 @@ e_ews_connection_get_oal_detail (EEwsCon
 		return;
 	}
 
+	if (etag && *etag)
+		soup_message_headers_append (soup_message->request_headers,
+					     "If-None-Match", etag);
+
 	data = g_slice_new0 (struct _oal_req_data);
 	data->cnc = g_object_ref (cnc);
 	data->soup_message = soup_message;  /* the session owns this */
@@ -2563,6 +2588,7 @@ gboolean
 e_ews_connection_get_oal_detail_finish (EEwsConnection *cnc,
                                         GAsyncResult *result,
                                         GSList **elements,
+					gchar **etag,
                                         GError **error)
 {
 	GSimpleAsyncResult *simple;
@@ -2584,6 +2610,10 @@ e_ews_connection_get_oal_detail_finish (
 		*elements = data->elements;
 		data->elements = NULL;
 	}
+	if (etag != NULL) {
+		*etag = data->etag;
+		data->etag = NULL;
+	}
 
 	return TRUE;
 
@@ -4910,7 +4940,7 @@ e_ews_connection_create_folder (EEwsConn
 	if (is_distinguished_id || !parent_folder_id) {
 		e_soap_message_start_element (msg, "DistinguishedFolderId", NULL, NULL);
 		e_soap_message_add_attribute (
-				msg, "Id", parent_folder_id ?: "msgfolderroot", NULL, NULL);
+				msg, "Id", parent_folder_id ? parent_folder_id : "msgfolderroot", NULL, NULL);
 		if (is_distinguished_id && cnc->priv->email) {
 			e_soap_message_start_element (msg, "Mailbox", NULL, NULL);
 			e_ews_message_write_string_parameter(
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/server/e-ews-connection.h.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/server/e-ews-connection.h
--- evolution-ews-gnome-3-0.gitcc16df2/src/server/e-ews-connection.h.sync-with-3.8.4	2013-07-24 07:30:27.271435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/server/e-ews-connection.h	2013-07-24 07:30:27.312435567 +0200
@@ -117,6 +117,7 @@ typedef struct {
 } EwsOAL;
 
 typedef struct {
+	gchar *type;
 	guint32 seq;
 	guint32 ver;
 	guint32 size;
@@ -769,12 +770,15 @@ gboolean	e_ews_connection_get_oal_detail
 						(EEwsConnection *cnc,
 						 const gchar *oal_id,
 						 const gchar *oal_element,
+						 const gchar *old_etag,
 						 GSList **elements,
+						 gchar **etag,
 						 GCancellable *cancellable,
 						 GError **error);
 void		e_ews_connection_get_oal_detail	(EEwsConnection *cnc,
 						 const gchar *oal_id,
 						 const gchar *oal_element,
+						 const gchar *etag,
 						 GCancellable *cancellable,
 						 GAsyncReadyCallback callback,
 						 gpointer user_data);
@@ -782,6 +786,7 @@ gboolean	e_ews_connection_get_oal_detail
 						(EEwsConnection *cnc,
 						 GAsyncResult *result,
 						 GSList **elements,
+						 gchar **etag,
 						 GError **error);
 
 void		e_ews_connection_get_free_busy	(EEwsConnection *cnc,
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/server/e-ews-gnome-3-8-compat.c.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/server/e-ews-gnome-3-8-compat.c
--- evolution-ews-gnome-3-0.gitcc16df2/src/server/e-ews-gnome-3-8-compat.c.sync-with-3.8.4	2013-07-24 07:30:27.273435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/server/e-ews-gnome-3-8-compat.c	2013-07-24 07:30:27.310435567 +0200
@@ -26,6 +26,7 @@
 
 #include <libedataserver/e-data-server-util.h>
 #include <errno.h>
+#include <string.h>
 
 #include "e-ews-gnome-3-8-compat.h"
 
@@ -486,3 +487,427 @@ camel_session_submit_job (CamelSession *
 		session_start_job_cb,
 		job_data, (GDestroyNotify) NULL);
 }
+
+/* copy from GLib - begin */
+/**
+ * GBytes:
+ *
+ * A simple refcounted data type representing an immutable byte sequence
+ * from an unspecified origin.
+ *
+ * The purpose of a #GBytes is to keep the memory region that it holds
+ * alive for as long as anyone holds a reference to the bytes.  When
+ * the last reference count is dropped, the memory is released. Multiple
+ * unrelated callers can use byte data in the #GBytes without coordinating
+ * their activities, resting assured that the byte data will not change or
+ * move while they hold a reference.
+ *
+ * A #GBytes can come from many different origins that may have
+ * different procedures for freeing the memory region.  Examples are
+ * memory from g_malloc(), from memory slices, from a #GMappedFile or
+ * memory from other allocators.
+ *
+ * #GBytes work well as keys in #GHashTable. Use g_bytes_equal() and
+ * g_bytes_hash() as parameters to g_hash_table_new() or g_hash_table_new_full().
+ * #GBytes can also be used as keys in a #GTree by passing the g_bytes_compare()
+ * function to g_tree_new().
+ *
+ * The data pointed to by this bytes must not be modified. For a mutable
+ * array of bytes see #GByteArray. Use g_bytes_unref_to_array() to create a
+ * mutable array for a #GBytes sequence. To create an immutable #GBytes from
+ * a mutable #GByteArray, use the g_byte_array_free_to_bytes() function.
+ *
+ * Since: 2.32
+ **/
+
+struct _GBytes
+{
+  gconstpointer data;
+  gsize size;
+  gint ref_count;
+  GDestroyNotify free_func;
+  gpointer user_data;
+};
+
+/**
+ * g_bytes_new:
+ * @data: (transfer none) (array length=size) (element-type guint8):
+ *        the data to be used for the bytes
+ * @size: the size of @data
+ *
+ * Creates a new #GBytes from @data.
+ *
+ * @data is copied.
+ *
+ * Returns: (transfer full): a new #GBytes
+ *
+ * Since: 2.32
+ */
+GBytes *
+g_bytes_new (gconstpointer data,
+             gsize         size)
+{
+  return g_bytes_new_take (g_memdup (data, size), size);
+}
+
+/**
+ * g_bytes_new_take:
+ * @data: (transfer full) (array length=size) (element-type guint8):
+          the data to be used for the bytes
+ * @size: the size of @data
+ *
+ * Creates a new #GBytes from @data.
+ *
+ * After this call, @data belongs to the bytes and may no longer be
+ * modified by the caller.  g_free() will be called on @data when the
+ * bytes is no longer in use. Because of this @data must have been created by
+ * a call to g_malloc(), g_malloc0() or g_realloc() or by one of the many
+ * functions that wrap these calls (such as g_new(), g_strdup(), etc).
+ *
+ * For creating #GBytes with memory from other allocators, see
+ * g_bytes_new_with_free_func().
+ *
+ * Returns: (transfer full): a new #GBytes
+ *
+ * Since: 2.32
+ */
+GBytes *
+g_bytes_new_take (gpointer data,
+                  gsize    size)
+{
+  return g_bytes_new_with_free_func (data, size, g_free, data);
+}
+
+
+/**
+ * g_bytes_new_static: (skip)
+ * @data: (transfer full) (array length=size) (element-type guint8):
+          the data to be used for the bytes
+ * @size: the size of @data
+ *
+ * Creates a new #GBytes from static data.
+ *
+ * @data must be static (ie: never modified or freed).
+ *
+ * Returns: (transfer full): a new #GBytes
+ *
+ * Since: 2.32
+ */
+GBytes *
+g_bytes_new_static (gconstpointer data,
+                    gsize         size)
+{
+  return g_bytes_new_with_free_func (data, size, NULL, NULL);
+}
+
+/**
+ * g_bytes_new_with_free_func:
+ * @data: (array length=size): the data to be used for the bytes
+ * @size: the size of @data
+ * @free_func: the function to call to release the data
+ * @user_data: data to pass to @free_func
+ *
+ * Creates a #GBytes from @data.
+ *
+ * When the last reference is dropped, @free_func will be called with the
+ * @user_data argument.
+ *
+ * @data must not be modified after this call is made until @free_func has
+ * been called to indicate that the bytes is no longer in use.
+ *
+ * Returns: (transfer full): a new #GBytes
+ *
+ * Since: 2.32
+ */
+GBytes *
+g_bytes_new_with_free_func (gconstpointer  data,
+                            gsize          size,
+                            GDestroyNotify free_func,
+                            gpointer       user_data)
+{
+  GBytes *bytes;
+
+  bytes = g_slice_new (GBytes);
+  bytes->data = data;
+  bytes->size = size;
+  bytes->free_func = free_func;
+  bytes->user_data = user_data;
+  bytes->ref_count = 1;
+
+  return (GBytes *)bytes;
+}
+
+/**
+ * g_bytes_new_from_bytes:
+ * @bytes: a #GBytes
+ * @offset: offset which subsection starts at
+ * @length: length of subsection
+ *
+ * Creates a #GBytes which is a subsection of another #GBytes. The @offset +
+ * @length may not be longer than the size of @bytes.
+ *
+ * A reference to @bytes will be held by the newly created #GBytes until
+ * the byte data is no longer needed.
+ *
+ * Returns: (transfer full): a new #GBytes
+ *
+ * Since: 2.32
+ */
+GBytes *
+g_bytes_new_from_bytes (GBytes  *bytes,
+                        gsize    offset,
+                        gsize    length)
+{
+  g_return_val_if_fail (bytes != NULL, NULL);
+  g_return_val_if_fail (offset <= bytes->size, NULL);
+  g_return_val_if_fail (offset + length <= bytes->size, NULL);
+
+  return g_bytes_new_with_free_func ((gchar *)bytes->data + offset, length,
+                                     (GDestroyNotify)g_bytes_unref, g_bytes_ref (bytes));
+}
+
+/**
+ * g_bytes_get_data:
+ * @bytes: a #GBytes
+ * @size: (out) (allow-none): location to return size of byte data
+ *
+ * Get the byte data in the #GBytes. This data should not be modified.
+ *
+ * This function will always return the same pointer for a given #GBytes.
+ *
+ * Returns: (transfer none) (array length=size) (type guint8): a pointer to the
+ *          byte data
+ *
+ * Since: 2.32
+ */
+gconstpointer
+g_bytes_get_data (GBytes *bytes,
+                  gsize *size)
+{
+  g_return_val_if_fail (bytes != NULL, NULL);
+  if (size)
+    *size = bytes->size;
+  return bytes->data;
+}
+
+/**
+ * g_bytes_get_size:
+ * @bytes: a #GBytes
+ *
+ * Get the size of the byte data in the #GBytes.
+ *
+ * This function will always return the same value for a given #GBytes.
+ *
+ * Returns: the size
+ *
+ * Since: 2.32
+ */
+gsize
+g_bytes_get_size (GBytes *bytes)
+{
+  g_return_val_if_fail (bytes != NULL, 0);
+  return bytes->size;
+}
+
+
+/**
+ * g_bytes_ref:
+ * @bytes: a #GBytes
+ *
+ * Increase the reference count on @bytes.
+ *
+ * Returns: the #GBytes
+ *
+ * Since: 2.32
+ */
+GBytes *
+g_bytes_ref (GBytes *bytes)
+{
+  g_return_val_if_fail (bytes != NULL, NULL);
+
+  g_atomic_int_inc (&bytes->ref_count);
+
+  return bytes;
+}
+
+/**
+ * g_bytes_unref:
+ * @bytes: (allow-none): a #GBytes
+ *
+ * Releases a reference on @bytes.  This may result in the bytes being
+ * freed.
+ *
+ * Since: 2.32
+ */
+void
+g_bytes_unref (GBytes *bytes)
+{
+  if (bytes == NULL)
+    return;
+
+  if (g_atomic_int_dec_and_test (&bytes->ref_count))
+    {
+      if (bytes->free_func != NULL)
+        bytes->free_func (bytes->user_data);
+      g_slice_free (GBytes, bytes);
+    }
+}
+
+/**
+ * g_bytes_equal:
+ * @bytes1: (type GLib.Bytes): a pointer to a #GBytes
+ * @bytes2: (type GLib.Bytes): a pointer to a #GBytes to compare with @bytes1
+ *
+ * Compares the two #GBytes values being pointed to and returns
+ * %TRUE if they are equal.
+ *
+ * This function can be passed to g_hash_table_new() as the @key_equal_func
+ * parameter, when using non-%NULL #GBytes pointers as keys in a #GHashTable.
+ *
+ * Returns: %TRUE if the two keys match.
+ *
+ * Since: 2.32
+ */
+gboolean
+g_bytes_equal (gconstpointer bytes1,
+               gconstpointer bytes2)
+{
+  const GBytes *b1 = bytes1;
+  const GBytes *b2 = bytes2;
+
+  g_return_val_if_fail (bytes1 != NULL, FALSE);
+  g_return_val_if_fail (bytes2 != NULL, FALSE);
+
+  return b1->size == b2->size &&
+         memcmp (b1->data, b2->data, b1->size) == 0;
+}
+
+/**
+ * g_bytes_hash:
+ * @bytes: (type GLib.Bytes): a pointer to a #GBytes key
+ *
+ * Creates an integer hash code for the byte data in the #GBytes.
+ *
+ * This function can be passed to g_hash_table_new() as the @key_equal_func
+ * parameter, when using non-%NULL #GBytes pointers as keys in a #GHashTable.
+ *
+ * Returns: a hash value corresponding to the key.
+ *
+ * Since: 2.32
+ */
+guint
+g_bytes_hash (gconstpointer bytes)
+{
+  const GBytes *a = bytes;
+  const signed char *p, *e;
+  guint32 h = 5381;
+
+  g_return_val_if_fail (bytes != NULL, 0);
+
+  for (p = (signed char *)a->data, e = (signed char *)a->data + a->size; p != e; p++)
+    h = (h << 5) + h + *p;
+
+  return h;
+}
+
+/**
+ * g_bytes_compare:
+ * @bytes1: (type GLib.Bytes): a pointer to a #GBytes
+ * @bytes2: (type GLib.Bytes): a pointer to a #GBytes to compare with @bytes1
+ *
+ * Compares the two #GBytes values.
+ *
+ * This function can be used to sort GBytes instances in lexographical order.
+ *
+ * Returns: a negative value if bytes2 is lesser, a positive value if bytes2 is
+ *          greater, and zero if bytes2 is equal to bytes1
+ *
+ * Since: 2.32
+ */
+gint
+g_bytes_compare (gconstpointer bytes1,
+                 gconstpointer bytes2)
+{
+  const GBytes *b1 = bytes1;
+  const GBytes *b2 = bytes2;
+  gint ret;
+
+  g_return_val_if_fail (bytes1 != NULL, 0);
+  g_return_val_if_fail (bytes2 != NULL, 0);
+
+  ret = memcmp (b1->data, b2->data, MIN (b1->size, b2->size));
+  if (ret == 0 && b1->size != b2->size)
+      ret = b1->size < b2->size ? -1 : 1;
+  return ret;
+}
+
+static gpointer
+try_steal_and_unref (GBytes         *bytes,
+                     GDestroyNotify  free_func,
+                     gsize          *size)
+{
+  gpointer result;
+
+  if (bytes->free_func != free_func || bytes->data == NULL)
+    return NULL;
+
+  /* Are we the only reference? */
+  if (g_atomic_int_get (&bytes->ref_count) == 1)
+    {
+      *size = bytes->size;
+      result = (gpointer)bytes->data;
+      g_slice_free (GBytes, bytes);
+      return result;
+    }
+
+  return NULL;
+}
+
+
+/**
+ * g_bytes_unref_to_data:
+ * @bytes: (transfer full): a #GBytes
+ * @size: location to place the length of the returned data
+ *
+ * Unreferences the bytes, and returns a pointer the same byte data
+ * contents.
+ *
+ * As an optimization, the byte data is returned without copying if this was
+ * the last reference to bytes and bytes was created with g_bytes_new(),
+ * g_bytes_new_take() or g_byte_array_free_to_bytes(). In all other cases the
+ * data is copied.
+ *
+ * Returns: (transfer full): a pointer to the same byte data, which should
+ *          be freed with g_free()
+ *
+ * Since: 2.32
+ */
+gpointer
+g_bytes_unref_to_data (GBytes *bytes,
+                       gsize  *size)
+{
+  gpointer result;
+
+  g_return_val_if_fail (bytes != NULL, NULL);
+  g_return_val_if_fail (size != NULL, NULL);
+
+  /*
+   * Optimal path: if this is was the last reference, then we can return
+   * the data from this GBytes without copying.
+   */
+
+  result = try_steal_and_unref (bytes, g_free, size);
+  if (result == NULL)
+    {
+      /*
+       * Copy: Non g_malloc (or compatible) allocator, or static memory,
+       * so we have to copy, and then unref.
+       */
+      result = g_memdup (bytes->data, bytes->size);
+      *size = bytes->size;
+      g_bytes_unref (bytes);
+    }
+
+  return result;
+}
+/* copy from GLib - end */
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/server/e-ews-gnome-3-8-compat.h.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/server/e-ews-gnome-3-8-compat.h
--- evolution-ews-gnome-3-0.gitcc16df2/src/server/e-ews-gnome-3-8-compat.h.sync-with-3.8.4	2013-07-24 07:30:27.273435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/server/e-ews-gnome-3-8-compat.h	2013-07-24 07:30:27.311435567 +0200
@@ -104,4 +104,48 @@ void		camel_session_submit_job	(CamelSes
 						 gpointer user_data,
 						 GDestroyNotify notify);
 
+/* copy from GLib - begin */
+typedef struct _GBytes          GBytes;
+
+GBytes *        g_bytes_new                     (gconstpointer   data,
+                                                 gsize           size);
+
+GBytes *        g_bytes_new_take                (gpointer        data,
+                                                 gsize           size);
+
+GBytes *        g_bytes_new_static              (gconstpointer   data,
+                                                 gsize           size);
+
+GBytes *        g_bytes_new_with_free_func      (gconstpointer   data,
+                                                 gsize           size,
+                                                 GDestroyNotify  free_func,
+                                                 gpointer        user_data);
+
+GBytes *        g_bytes_new_from_bytes          (GBytes         *bytes,
+                                                 gsize           offset,
+                                                 gsize           length);
+
+gconstpointer   g_bytes_get_data                (GBytes         *bytes,
+                                                 gsize          *size);
+
+gsize           g_bytes_get_size                (GBytes         *bytes);
+
+GBytes *        g_bytes_ref                     (GBytes         *bytes);
+
+void            g_bytes_unref                   (GBytes         *bytes);
+
+gpointer        g_bytes_unref_to_data           (GBytes         *bytes,
+                                                 gsize          *size);
+
+GByteArray *    g_bytes_unref_to_array          (GBytes         *bytes);
+
+guint           g_bytes_hash                    (gconstpointer   bytes);
+
+gboolean        g_bytes_equal                   (gconstpointer   bytes1,
+                                                 gconstpointer   bytes2);
+
+gint            g_bytes_compare                 (gconstpointer   bytes1,
+                                                 gconstpointer   bytes2);
+/* copy from GLib - end */
+
 #endif /* E_EWS_GNOME_3_8_COMPAT_H */
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/server/e-ews-oof-settings.c.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/server/e-ews-oof-settings.c
--- evolution-ews-gnome-3-0.gitcc16df2/src/server/e-ews-oof-settings.c.sync-with-3.8.4	2013-07-24 07:30:27.277435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/server/e-ews-oof-settings.c	2013-07-24 07:30:27.309435567 +0200
@@ -148,6 +148,7 @@ ews_oof_settings_get_response_cb (ESoapR
 	ESoapParameter *subsubparam;
 	GDateTime *date_time;
 	gchar *string;
+	gchar *text;
 	GError *error = NULL;
 
 	param = e_soap_response_get_first_parameter_by_name (
@@ -239,24 +240,34 @@ ews_oof_settings_get_response_cb (ESoapR
 	subsubparam = e_soap_parameter_get_first_child_by_name (
 		subparam, "Message");
 	string = e_soap_parameter_get_string_value (subsubparam);
-	if (g_strrstr (string, "</body>") != NULL)
-		string = ews_oof_settings_text_from_html (string);
+	if (string == NULL)
+		text = NULL;
+	else if (g_strrstr (string, "</body>") != NULL)
+		text = ews_oof_settings_text_from_html (string);
 	else if (g_strrstr (string, "BodyFragment") != NULL)
-		string = ews_oof_settings_text_from_html (string);
-	e_ews_oof_settings_set_internal_reply (settings, string);
+		text = ews_oof_settings_text_from_html (string);
+	else
+		text = NULL;
+	e_ews_oof_settings_set_internal_reply (settings, text ? text : "");
 	g_free (string);
+	g_free (text);
 
 	subparam = e_soap_parameter_get_first_child_by_name (
 		param, "ExternalReply");
 	subsubparam = e_soap_parameter_get_first_child_by_name (
 		subparam, "Message");
 	string = e_soap_parameter_get_string_value (subsubparam);
-	if (g_strrstr (string, "</body>") != NULL)
-		string = ews_oof_settings_text_from_html (string);
+	if (string == NULL)
+		text = NULL;
+	else if (g_strrstr (string, "</body>") != NULL)
+		text = ews_oof_settings_text_from_html (string);
 	else if (g_strrstr (string, "BodyFragment") != NULL)
-		string = ews_oof_settings_text_from_html (string);
-	e_ews_oof_settings_set_external_reply (settings, string);
+		text = ews_oof_settings_text_from_html (string);
+	else
+		text = NULL;
+	e_ews_oof_settings_set_external_reply (settings, text ? text : "");
 	g_free (string);
+	g_free (text);
 
 	g_object_unref (source_object);
 }
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/server/tests/Makefile.in.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/server/tests/Makefile.in
--- evolution-ews-gnome-3-0.gitcc16df2/src/server/tests/Makefile.in.sync-with-3.8.4	2013-05-28 08:55:12.000000000 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/server/tests/Makefile.in	2013-07-24 07:30:27.312435567 +0200
@@ -42,8 +42,11 @@ check_PROGRAMS = testews$(EXEEXT)
 subdir = src/server/tests
 DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
-	$(top_srcdir)/configure.ac
+am__aclocal_m4_deps = $(top_srcdir)/m4/gtk-doc.m4 \
+	$(top_srcdir)/m4/intltool.m4 $(top_srcdir)/m4/libtool.m4 \
+	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
+	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
+	$(top_srcdir)/acinclude.m4 $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
@@ -151,8 +154,6 @@ GNOME_PLATFORM_LIBS = @GNOME_PLATFORM_LI
 GOBJECT_QUERY = @GOBJECT_QUERY@
 GREP = @GREP@
 GTKDOC_CHECK = @GTKDOC_CHECK@
-GTKDOC_MKPDF = @GTKDOC_MKPDF@
-GTKDOC_REBASE = @GTKDOC_REBASE@
 GTK_MODULE = @GTK_MODULE@
 HTML_DIR = @HTML_DIR@
 INSTALL = @INSTALL@
@@ -198,6 +199,8 @@ MKINSTALLDIRS = @MKINSTALLDIRS@
 MSGFMT = @MSGFMT@
 MSGFMT_OPTS = @MSGFMT_OPTS@
 MSGMERGE = @MSGMERGE@
+MSPACK_CFLAGS = @MSPACK_CFLAGS@
+MSPACK_LIBS = @MSPACK_LIBS@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NO_UNDEFINED = @NO_UNDEFINED@
@@ -257,6 +260,7 @@ dvidir = @dvidir@
 ebook_backenddir = @ebook_backenddir@
 ecal_backenddir = @ecal_backenddir@
 edataserver_privincludedir = @edataserver_privincludedir@
+evo_moduledir = @evo_moduledir@
 exec_prefix = @exec_prefix@
 extensiondir = @extensiondir@
 host = @host@
diff -up evolution-ews-gnome-3-0.gitcc16df2/src/utils/ews-camel-common.c.sync-with-3.8.4 evolution-ews-gnome-3-0.gitcc16df2/src/utils/ews-camel-common.c
--- evolution-ews-gnome-3-0.gitcc16df2/src/utils/ews-camel-common.c.sync-with-3.8.4	2013-07-24 07:30:27.282435567 +0200
+++ evolution-ews-gnome-3-0.gitcc16df2/src/utils/ews-camel-common.c	2013-07-24 07:30:27.296435567 +0200
@@ -99,13 +99,21 @@ create_mime_message_cb (ESoapMessage *ms
 		e_soap_message_end_element (msg); /* ItemClass */
 	}
 
+	e_ews_message_write_string_parameter_with_attribute (
+			msg,
+			"Importance",
+			NULL,
+			(create_data->message_camel_flags & CAMEL_MESSAGE_FLAGGED) != 0 ? "High" : "Normal",
+			NULL,
+			NULL);
+
 	/* more MAPI crap.  You can't just set the IsDraft property
 	 * here you have to use the MAPI MSGFLAG_UNSENT extended
 	 * property Further crap is that Exchange 2007 assumes when it
 	 * sees this property that you're setting the value to 0
 	 * ... it never checks */
 	msgflag  = MAPI_MSGFLAG_READ; /* draft or sent is always read */
-	if (create_data->message_camel_flags & CAMEL_MESSAGE_DRAFT)
+	if ((create_data->message_camel_flags & CAMEL_MESSAGE_DRAFT) != 0)
 		msgflag |= MAPI_MSGFLAG_UNSENT;
 
 	e_soap_message_start_element (msg, "ExtendedProperty", NULL, NULL);
@@ -117,6 +125,32 @@ create_mime_message_cb (ESoapMessage *ms
 	e_ews_message_write_int_parameter (msg, "Value", NULL, msgflag);
 
 	e_soap_message_end_element (msg); /* ExtendedProperty */
+
+	if ((create_data->message_camel_flags & (CAMEL_MESSAGE_FORWARDED | CAMEL_MESSAGE_ANSWERED)) != 0) {
+		gint icon;
+
+		icon = (create_data->message_camel_flags & CAMEL_MESSAGE_ANSWERED) != 0 ? 0x105 : 0x106;
+
+		e_soap_message_start_element (msg, "ExtendedProperty", NULL, NULL);
+
+		e_soap_message_start_element (msg, "ExtendedFieldURI", NULL, NULL);
+		e_soap_message_add_attribute (msg, "PropertyTag", "0x1080", NULL, NULL);
+		e_soap_message_add_attribute (msg, "PropertyType", "Integer", NULL, NULL);
+		e_soap_message_end_element (msg); /* ExtendedFieldURI */
+
+		e_ews_message_write_int_parameter (msg, "Value", NULL, icon);
+
+		e_soap_message_end_element (msg); /* ExtendedProperty */
+	}
+
+	e_ews_message_write_string_parameter_with_attribute (
+			msg,
+			"IsRead",
+			NULL,
+			(create_data->message_camel_flags & CAMEL_MESSAGE_SEEN) != 0 ? "true" : "false",
+			NULL,
+			NULL);
+
 	e_soap_message_end_element (msg); /* Message */
 
 	g_free (create_data);
