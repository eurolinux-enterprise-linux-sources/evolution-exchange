diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/configure.ac evolution-ews.sync-with-3.8.2/configure.ac
--- evolution-ews.git-gnome-3-0/configure.ac	2013-05-28 08:54:15.570837489 +0200
+++ evolution-ews.sync-with-3.8.2/configure.ac	2013-05-28 12:49:52.680712376 +0200
@@ -1,11 +1,12 @@
 AC_PREREQ(2.58)
 AC_INIT([evolution-ews], [0.31.0], [http://bugzilla.gnome.org/browse.cgi?product=evolution-ews])
 AM_INIT_AUTOMAKE([gnu 1.9])
+AC_CONFIG_MACRO_DIR([m4])
 AC_CONFIG_SRCDIR(README)
 AC_CONFIG_HEADERS(config.h)
 
-BASE_VERSION=3.0
-m4_define([base_version], [3.0])
+BASE_VERSION=2.32
+m4_define([base_version], [2.32])
 AC_SUBST(BASE_VERSION)
 
 dnl ****************************
@@ -27,7 +28,7 @@ m4_define([eds_minimum_version], [2.31.1
 m4_define([evo_minimum_version], [2.31.1])
 m4_define([glib_minimum_version], [2.16.1])
 m4_define([gconf_minimum_version], [2.0.0])
-m4_define([libsoup_minimum_version], [2.30])
+m4_define([libsoup_minimum_version], [2.28])
 
 
 dnl ***********************************
@@ -91,7 +92,7 @@ AS_COMPILER_FLAGS(WARNING_FLAGS,
 	-Wformat-nonliteral -Wformat-security -Winit-self
 	-Wmissing-declarations -Wmissing-include-dirs
 	-Wmissing-noreturn -Wnested-externs -Wpointer-arith
-	-Wundef -Wwrite-strings -Werror")
+	-Wundef -Wwrite-strings")
 AC_SUBST(WARNING_FLAGS)
 
 dnl Other useful compiler warnings for test builds only.
@@ -241,10 +242,10 @@ AC_SUBST(camel_providerdir) 
 privdatadir='${datadir}'/evolution-data-server-$BASE_VERSION
 AC_SUBST(privdatadir)
 
-privincludedir='${includedir}'/evolution-data-server-$BASE_VERSION
+privincludedir='${includedir}'/evolution-data-server-$EDS_PACKAGE
 AC_SUBST(privincludedir)
 
-privlibdir='${libdir}'/evolution-data-server-$BASE_VERSION
+privlibdir='${libdir}'/evolution-data-server-$EDS_PACKAGE
 AC_SUBST(privlibdir)
 
 imagesdir='${datadir}'/pixmaps/evolution-data-server
@@ -256,6 +257,9 @@ AC_SUBST(uidir)
 edataserver_privincludedir=`$PKG_CONFIG --variable=privincludedir libedataserver-$EDS_PACKAGE`
 AC_SUBST(edataserver_privincludedir)
 
+evo_moduledir=`$PKG_CONFIG --variable=moduledir evolution-shell`
+AC_SUBST(evo_moduledir)
+
 dnl *************
 dnl Gtk Doc stuff
 dnl *************
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/cs.po evolution-ews.sync-with-3.8.2/po/cs.po
--- evolution-ews.git-gnome-3-0/po/cs.po	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/po/cs.po	2013-05-29 08:46:45.648863785 +0200
@@ -0,0 +1,1081 @@
+# Czech translation for evolution-ews.
+# Copyright (C) 2011 evolution-ews's COPYRIGHT HOLDER
+# This file is distributed under the same license as the evolution-ews package.
+#
+# Marek Černocký <marek@manet.cz>, 2011, 2012, 2013.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: evolution-ews master\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
+"product=evolution-ews&keywords=I18N+L10N&component=general\n"
+"POT-Creation-Date: 2013-01-17 11:11+0000\n"
+"PO-Revision-Date: 2013-01-22 08:09+0100\n"
+"Last-Translator: Marek Černocký <marek@manet.cz>\n"
+"Language-Team: čeština <gnome-cs-list@gnome.org>\n"
+"Language: cs\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=3; plural=(n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2;\n"
+"X-Generator: Gtranslator 2.91.6\n"
+
+#: ../src/addressbook/e-book-backend-ews.c:969
+msgid "The backend does not support bulk additions"
+msgstr "Serverová část nepodporuje hromadné přidávání"
+
+#: ../src/addressbook/e-book-backend-ews.c:1253
+msgid "The backend does not support bulk modifications"
+msgstr "Serverová část nepodporuje hromadné změny"
+
+#: ../src/addressbook/e-book-backend-ews.c:1436
+msgid "Wait till syncing is done"
+msgstr "Vyčkejte, než se dokončí synchronizace"
+
+#: ../src/addressbook/e-book-backend-ews.c:1775
+#, c-format
+msgid "Downloading contacts in %s %d%% completed... "
+msgstr "Stahování kontaktů v %s %d%% dokončeno…"
+
+#: ../src/addressbook/e-book-backend-ews.c:2324
+msgid "Syncing contacts..."
+msgstr "Synchronizují se kontakty…"
+
+#: ../src/addressbook/e-book-backend-ews.c:2548
+#: ../src/configuration/e-ews-search-user.c:364
+msgid "Searching..."
+msgstr "Vyhledává se…"
+
+#: ../src/calendar/e-cal-backend-ews.c:1001
+msgid "EWS does not support bulk removals"
+msgstr "EWS nepodporuje hromadné odstraňování"
+
+#: ../src/calendar/e-cal-backend-ews.c:1644
+msgid "EWS does not support bulk additions"
+msgstr "EWS nepodporuje hromadné přidávání"
+
+#: ../src/calendar/e-cal-backend-ews.c:2223
+msgid "EWS does not support bulk modifications"
+msgstr "EWS nepodporuje hromadné změny"
+
+#: ../src/camel/camel-ews-folder.c:267
+#, c-format
+msgid "Unable to open mimecontent temporary file!"
+msgstr "Nelze otevřít dočasný soubor s obsahem MIME!"
+
+#: ../src/camel/camel-ews-folder.c:275
+#, c-format
+msgid "Unable to generate parser from mimecontent!"
+msgstr "Nelze vygenerovat analyzátor z obsahu MIME!"
+
+#: ../src/camel/camel-ews-folder.c:284
+#, c-format
+msgid "Unable to parse meeting request mimecontent!"
+msgstr "Nelze analyzovat uvítací požadavek z obsahu MIME!"
+
+#: ../src/camel/camel-ews-folder.c:344
+#, c-format
+msgid "Unable to create cache file"
+msgstr "Nelze vytvořit soubor pro mezipaměť"
+
+#: ../src/camel/camel-ews-folder.c:449 ../src/camel/camel-ews-folder.c:529
+#, c-format
+msgid "Unable to create cache path"
+msgstr "Nelze vytvořit cestu pro mezipaměť"
+
+#: ../src/camel/camel-ews-folder.c:539
+#, c-format
+msgid "Failed to move message cache file"
+msgstr "Nelze přesunout soubor s mezipamětí zpráv"
+
+#: ../src/camel/camel-ews-folder.c:1186
+#, c-format
+msgid "Could not load summary for %s"
+msgstr "Nelze získat přehled pro složku %s"
+
+#: ../src/camel/camel-ews-folder.c:1622
+#, c-format
+msgid "Cant perform actions on the folder while in offline mode"
+msgstr "Akci na složce nelze provádět v režimu off-line"
+
+#: ../src/camel/camel-ews-provider.c:48
+msgid "Checking for new mail"
+msgstr "Kontrola nové pošty"
+
+#: ../src/camel/camel-ews-provider.c:50
+msgid "C_heck for new messages in all folders"
+msgstr "Kontrolovat _nové zprávy ve všech složkách"
+
+#: ../src/camel/camel-ews-provider.c:53
+msgid "Options"
+msgstr "Volby"
+
+#: ../src/camel/camel-ews-provider.c:55
+msgid "_Apply filters to new messages in Inbox on this server"
+msgstr "Pro nové zprávy na tomto serveru použív_at filtry"
+
+#: ../src/camel/camel-ews-provider.c:57
+msgid "Check new messages for _Junk contents"
+msgstr "Kontrolovat nové zprávy, zda ne_jsou nevyžádané"
+
+#: ../src/camel/camel-ews-provider.c:59
+msgid "Only check for Junk messages in the IN_BOX folder"
+msgstr "Nevyžádané zprávy kontrolovat pouze v doručené poště (IN_BOX)"
+
+#: ../src/camel/camel-ews-provider.c:61
+msgid "Automatically synchroni_ze remote mail locally"
+msgstr "Automaticky synchronizovat vzdálenou poštu na místní počítač"
+
+#: ../src/camel/camel-ews-provider.c:64
+msgid "Connection"
+msgstr "Připojení"
+
+#. Translators: '%s' is preplaced with a widget, where "
+#. * user can select how long the timeout should be.
+#: ../src/camel/camel-ews-provider.c:68
+#, c-format
+msgid "Connection _timeout (in seconds) %s"
+msgstr "Časový limi_t připojení (v sekundách) pro %s"
+
+#: ../src/camel/camel-ews-provider.c:76
+msgid "Exchange Web Services"
+msgstr "Webové služby Exchange"
+
+#: ../src/camel/camel-ews-provider.c:78
+msgid "For accessing Exchange servers using Web Services"
+msgstr "Pro přístup k serverům Exchange pomocí webových služeb"
+
+#: ../src/camel/camel-ews-provider.c:93
+msgid "NTLM"
+msgstr "NTLM"
+
+#: ../src/camel/camel-ews-provider.c:95
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with NTLM authentication."
+msgstr ""
+"Tato volba způsobí připojování k serveru Exchange pomocí hesla v textové "
+"podobě a autentizací NTLM"
+
+#: ../src/camel/camel-ews-provider.c:103
+msgid "Basic"
+msgstr "Základní"
+
+#: ../src/camel/camel-ews-provider.c:105
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with Basic authentication."
+msgstr ""
+"Tato volba způsobí připojování k serveru Exchange pomocí hesla v textové "
+"podobě se základní autentizací."
+
+#: ../src/camel/camel-ews-store.c:189
+#, c-format
+msgid "Session has no storage path"
+msgstr "Sezení nemá žádnou cestu pro ukládání"
+
+#: ../src/camel/camel-ews-store.c:226
+#, c-format
+msgctxt "PublicFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:355
+#, c-format
+msgctxt "ForeignFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:678
+msgid "Updating foreign folder structure"
+msgstr "Aktualizuje se struktura vzdálených složek"
+
+#: ../src/camel/camel-ews-store.c:957
+msgid "Authentication password not available"
+msgstr "Autentizační heslo není k dispozici"
+
+#: ../src/camel/camel-ews-store.c:1109
+msgid "Query for authentication types is not supported"
+msgstr "Dotaz na typy autentizace není podporován"
+
+#: ../src/camel/camel-ews-store.c:1161
+#, c-format
+msgid "No such folder: %s"
+msgstr "Taková složka neexistuje: %s"
+
+#: ../src/camel/camel-ews-store.c:1472
+msgid "Cannot list EWS public folders in offline mode"
+msgstr "V režimu off-line nelze vypsat žádné veřejné složky EWS"
+
+#: ../src/camel/camel-ews-store.c:1545
+msgid "Cannot find any EWS public folders"
+msgstr "Nelze najít žádné veřejné složky EWS"
+
+#: ../src/camel/camel-ews-store.c:1650
+#, c-format
+msgid "Cannot create folder '%s', folder already exists"
+msgstr "Nelze vytvořit složku „%s“, složka již existuje"
+
+#: ../src/camel/camel-ews-store.c:1665
+#, c-format
+msgid "Parent folder %s does not exist"
+msgstr "Rodičovská složka %s neexistuje"
+
+#: ../src/camel/camel-ews-store.c:1675
+#, c-format
+msgid ""
+"Cannot create folder under '%s', it is used for folders of other users only"
+msgstr ""
+"Nelze vytvořit složku pod složkou „%s“, která se používá pouze pro složky "
+"ostatních uživatelů"
+
+#: ../src/camel/camel-ews-store.c:1685
+#, c-format
+msgid "Cannot create folder under '%s', it is used for public folders only"
+msgstr ""
+"Nelze vytvořit složku pod složkou „%s“, která se používá pouze pro veřejné "
+"složky"
+
+#: ../src/camel/camel-ews-store.c:1754
+#, c-format
+msgid "Folder does not exist"
+msgstr "Složka neexistuje"
+
+#: ../src/camel/camel-ews-store.c:1763
+#, c-format
+msgid "Cannot remove folder '%s', it is used for folders of other users only"
+msgstr ""
+"Nelze odstranit složku „%s“, která se používá pouze pro složky ostatních "
+"uživatelů"
+
+#: ../src/camel/camel-ews-store.c:1773
+#, c-format
+msgid "Cannot remove folder '%s', it is used for public folders only"
+msgstr "Nelze odstranit složku „%s“, která se používá pouze pro veřejné složky"
+
+#: ../src/camel/camel-ews-store.c:1881
+#, c-format
+msgid "Folder %s does not exist"
+msgstr "Složka %s neexistuje"
+
+#: ../src/camel/camel-ews-store.c:1891
+#, c-format
+msgid "No change key record for folder %s"
+msgstr "Neexistuje záznam s klíčem o změně (ChangeKey) pro složku %s"
+
+#: ../src/camel/camel-ews-store.c:1933
+#, c-format
+msgid "Cannot both rename and move a folder at the same time"
+msgstr "Složku nelze naráz přejmenovat i přesunout"
+
+#: ../src/camel/camel-ews-store.c:1969
+#, c-format
+msgid "Cannot find folder ID for parent folder %s"
+msgstr "Nelze najít ID složky pro rodičovskou složku %s"
+
+#: ../src/camel/camel-ews-store.c:2019 ../src/camel/camel-ews-transport.c:69
+#, c-format
+msgid "Exchange server %s"
+msgstr "Server Exchange %s"
+
+#: ../src/camel/camel-ews-store.c:2022
+#, c-format
+msgid "Exchange service for %s on %s"
+msgstr "Služba Exchange pro uživatele %s na počítači %s"
+
+#: ../src/camel/camel-ews-store.c:2066
+#, c-format
+msgid "Could not locate Trash folder"
+msgstr "Nelze vyhledat složku Koš"
+
+#: ../src/camel/camel-ews-store.c:2101
+#, c-format
+msgid "Could not locate Junk folder"
+msgstr "Nelze vyhledat složku Nevyžádaná pošta"
+
+#: ../src/camel/camel-ews-store.c:2291
+msgid "Cannot subscribe EWS folders in offline mode"
+msgstr "K odběru složek EWS se nelze přihlásit v režimu off-line"
+
+#: ../src/camel/camel-ews-store.c:2309
+#, c-format
+msgid "Cannot subscribe folder '%s', no public folder available"
+msgstr ""
+"Nelze se přihlásit k odběru složky  „%s“, není dostupná žádná veřejná složka"
+
+#: ../src/camel/camel-ews-store.c:2319
+#, c-format
+msgid "Cannot subscribe folder '%s', folder not found"
+msgstr "Nelze se přihlásit k odběru složky „%s“, složka nebyla nalezena"
+
+#: ../src/camel/camel-ews-store.c:2409
+msgid "Cannot unsubscribe EWS folders in offline mode"
+msgstr "Z odběru složek EWS se nelze odhlásit v režimu off-line"
+
+#: ../src/camel/camel-ews-store.c:2525
+#, c-format
+msgid "You must be working online to complete this operation"
+msgstr "K dokončení této operace je nutné, abyste pracovali on-line"
+
+#: ../src/camel/camel-ews-transport.c:72
+#, c-format
+msgid "Exchange mail delivery via %s"
+msgstr "Doručování pošty Exchange přes server %s"
+
+#: ../src/camel/camel-ews-transport.c:119
+msgid "Cannot send message with no From address"
+msgstr "Nelze odeslat zprávu, která nemá uvedenu adresu „Od“"
+
+#: ../src/camel/camel-ews-transport.c:125
+msgid "Exchange server cannot send message with multiple From addresses"
+msgstr "Server Exchange nemůže odeslat zprávu s více adresami „Od“"
+
+#: ../src/camel/camel-ews-transport.c:136
+msgid "Failed to read From address"
+msgstr "Selhalo čtení adresy „Od“"
+
+#: ../src/camel/camel-ews-transport.c:148
+#, c-format
+msgid ""
+"Exchange server cannot send message as '%s', when the account was configured "
+"for address '%s'"
+msgstr ""
+"Server Exchange nemůže odeslat zprávu jako „%s“, když je účet nastaven pro "
+"adresu „%s“"
+
+#: ../src/camel/camel-ews-transport.c:162
+#, c-format
+msgid "Service not connected"
+msgstr "Služba není připojena"
+
+#: ../src/collection/e-ews-backend.c:406
+#: ../src/configuration/e-mail-config-ews-gal.c:274
+msgid "Global Address List"
+msgstr "Globální seznam adres"
+
+#: ../src/collection/e-ews-backend.c:793
+#, c-format
+msgid "Could not determine a suitable folder class for a new folder named '%s'"
+msgstr "Nelze určit vhodnou třídu složky pro novou složku s názvem „%s“"
+
+#: ../src/collection/e-ews-backend.c:882
+#, c-format
+msgid "Data source '%s' does not represent an Exchange Web Services folder"
+msgstr "Zdroj dat „%s“ se nenachází ve složce Exchange Web Services"
+
+#: ../src/configuration/e-ews-config-utils.c:511
+#, c-format
+msgid "Cannot edit permissions of folder '%s', choose other folder."
+msgstr "Nelze upravit oprávnění složky „%s“, zvolte jinou složku."
+
+#: ../src/configuration/e-ews-config-utils.c:589
+msgid "Subscribe to folder of other user..."
+msgstr "Přihlásit odběr složky jiného uživatele…"
+
+#: ../src/configuration/e-ews-config-utils.c:598
+#: ../src/configuration/e-ews-config-utils.c:879
+#: ../src/configuration/e-ews-config-utils.c:910
+#: ../src/configuration/e-ews-config-utils.c:941
+#: ../src/configuration/e-ews-config-utils.c:972
+msgid "Permissions..."
+msgstr "Oprávnění…"
+
+#: ../src/configuration/e-ews-config-utils.c:600
+msgid "Edit EWS folder permissions"
+msgstr "Upravit oprávnění složky EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:881
+msgid "Edit EWS calendar permissions"
+msgstr "Upravit oprávnění kalendáře EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:912
+msgid "Edit EWS tasks permissions"
+msgstr "Upravit oprávnění úkolů EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:943
+msgid "Edit EWS memos permissions"
+msgstr "Upravit oprávnění poznámek EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:974
+msgid "Edit EWS contacts permissions"
+msgstr "Upravit oprávnění kontaktů EWS"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:87
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:499
+msgctxt "PermissionsLevel"
+msgid "None"
+msgstr "Žádná"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:88
+msgctxt "PermissionsLevel"
+msgid "Owner"
+msgstr "Vlastník"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:98
+msgctxt "PermissionsLevel"
+msgid "Publishing Editor"
+msgstr "Vydávající editor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:107
+msgctxt "PermissionsLevel"
+msgid "Editor"
+msgstr "Editor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:115
+msgctxt "PermissionsLevel"
+msgid "Publishing Author"
+msgstr "Vydávající autor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:122
+msgctxt "PermissionsLevel"
+msgid "Author"
+msgstr "Autor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:128
+msgctxt "PermissionsLevel"
+msgid "Nonediting Author"
+msgstr "Neupravující autor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:133
+msgctxt "PermissionsLevel"
+msgid "Reviewer"
+msgstr "Korektor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:136
+msgctxt "PermissionsLevel"
+msgid "Contributor"
+msgstr "Přispěvatel"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:139
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time"
+msgstr "Volný/obsazený čas"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:141
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time, subject, location"
+msgstr "Volný/obsazený čas, předmět, místo"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:143
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:520
+msgctxt "PermissionsLevel"
+msgid "Custom"
+msgstr "Vlastní"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:267
+msgid "Writing folder permissions, please wait..."
+msgstr "Zapisují se oprávnění složky, čekejte prosím…"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:759
+msgctxt "User"
+msgid "Anonymous"
+msgstr "Anonymní"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:762
+msgctxt "User"
+msgid "Default"
+msgstr "Výchozí"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:768
+msgctxt "User"
+msgid "Unknown"
+msgstr "Neznámý"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:849
+#: ../src/configuration/e-ews-search-user.c:430
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1075
+msgid "Name"
+msgstr "Jméno"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:855
+msgid "Permission level"
+msgstr "Úroveň oprávnění"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:907
+msgid "Edit EWS folder permissions..."
+msgstr "Úprava oprávnění složky EWS…"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:932
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:633
+msgid "Account:"
+msgstr "Účet:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:960
+msgid "Folder name:"
+msgstr "Název složky:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:983
+msgid "Folder ID:"
+msgstr "ID složky:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1047
+msgid "Permissions"
+msgstr "Oprávnění"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1069
+msgid "Permi_ssion level:"
+msgstr "Úroveň op_rávnění:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1103
+msgctxt "Permissions"
+msgid "Read"
+msgstr "Čtení"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1115
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1182
+msgctxt "Permissions"
+msgid "None"
+msgstr "nic"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1121
+msgctxt "Permissions"
+msgid "Free/Busy time"
+msgstr "volný/obsazený čas"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1126
+msgctxt "Permissions"
+msgid "Free/Busy time, subject, location"
+msgstr "volný/obsazený čas, předmět, místo"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1132
+msgctxt "Permissions"
+msgid "Full Details"
+msgstr "úplné podrobnosti"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1138
+msgctxt "Permissions"
+msgid "Write"
+msgstr "Zápis"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1150
+msgctxt "Permissions"
+msgid "Create items"
+msgstr "vytvářet položky"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1154
+msgctxt "Permissions"
+msgid "Create subfolders"
+msgstr "vytvářet podsložky"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1158
+msgctxt "Permissions"
+msgid "Edit own"
+msgstr "upravovat vlastní"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1162
+msgctxt "Permissions"
+msgid "Edit all"
+msgstr "upravovat vše"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1170
+msgctxt "Permissions"
+msgid "Delete items"
+msgstr "Mazání položek"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1187
+msgctxt "Permissions"
+msgid "Own"
+msgstr "vlastní"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1192
+msgctxt "Permissions"
+msgid "All"
+msgstr "všechny"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1198
+msgctxt "Permissions"
+msgid "Other"
+msgstr "Ostatní"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1210
+msgctxt "Permissions"
+msgid "Folder owner"
+msgstr "vlastník složky"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1214
+msgctxt "Permissions"
+msgid "Folder contact"
+msgstr "kontakt složky"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1218
+msgctxt "Permissions"
+msgid "Folder visible"
+msgstr "viditelnost složky"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1291
+msgid "Reading folder permissions, please wait..."
+msgstr "Čtou se oprávnění složky, čekejte prosím…"
+
+#: ../src/configuration/e-ews-search-user.c:208
+#, c-format
+msgid "No users found, only one contact"
+msgid_plural "No users found, only %d contacts"
+msgstr[0] "Nenalezeni žádní uživatelé, pouze jeden kontakt"
+msgstr[1] "Nenalezeni žádní uživatelé, pouze %d kontakty"
+msgstr[2] "Nenalezeni žádní uživatelé, pouze %d kontaktů"
+
+#: ../src/configuration/e-ews-search-user.c:213
+msgid "No users found"
+msgstr "Nenalezeni žádní uživatelé"
+
+#: ../src/configuration/e-ews-search-user.c:217
+#, c-format
+msgid "Found one user"
+msgid_plural "Found %d users"
+msgstr[0] "Nalezen jeden uživatel"
+msgstr[1] "Nalezeni %d uživatelé"
+msgstr[2] "Nalezeno %d uživatelů"
+
+#: ../src/configuration/e-ews-search-user.c:223
+#, c-format
+msgid "Found more than 100 users, but showing only first %d"
+msgid_plural "Found more than 100 users, but showing only first %d"
+msgstr[0] "Nalezeno více než 100 uživatelů, ale zobrazuje se pouze první %d"
+msgstr[1] "Nalezeno více než 100 uživatelů, ale zobrazují se pouze první %d"
+msgstr[2] "Nalezeno více než 100 uživatelů, ale zobrazuje se pouze prvních %d"
+
+#: ../src/configuration/e-ews-search-user.c:356
+#: ../src/configuration/e-ews-search-user.c:539
+msgid "Search for a user"
+msgstr "Vyhledávání uživatele"
+
+#: ../src/configuration/e-ews-search-user.c:436
+msgid "E-mail"
+msgstr "E-mail"
+
+#: ../src/configuration/e-ews-search-user.c:473
+msgid "Choose EWS user..."
+msgstr "Výběr uživatele EWS…"
+
+#: ../src/configuration/e-ews-search-user.c:496
+msgid "_Search:"
+msgstr "Vy_hledat:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:97
+#: ../src/server/e-ews-folder.c:591
+#, c-format
+msgid "Cannot add folder, folder already exists as '%s'"
+msgstr "Nelze přidat složku, složka již existuje jako „%s“"
+
+#. Translators: The '%s' is replaced with user name, to whom the foreign mailbox belongs.
+#. * Example result: "Mailbox - John Smith"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:107
+#, c-format
+msgctxt "ForeignFolder"
+msgid "Mailbox - %s"
+msgstr "Schránka – %s"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:272
+msgid "Cannot test foreign folder availability while in offline mode"
+msgstr "Test dostupnosti vzdálené složky nelze provést v režimu off-line"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:297
+#, c-format
+msgid "User '%s' was not found on the server"
+msgstr "Uživatel „%s“ nebyl na serveru nalezen"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:333
+#, c-format
+msgid "User name '%s' is ambiguous, specify it more precisely, please"
+msgstr "Jméno uživatele „%s“ je nejednoznačné, zadejte jej prosím přesněji"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:355
+#, c-format
+msgid ""
+"Folder '%s' not found. Either it does not exist or you do not have "
+"permission to access it."
+msgstr ""
+"Složka „%s“ nebyla nalezena. Buď neexistuje nebo nemáte oprávnění přístupu k "
+"ní."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:373
+msgid "Cannot add folder, cannot determine folder's type"
+msgstr "Nelze přidat složku, nelze určit typ složky"
+
+#. Translators: This is used to name foreign folder.
+#. * The first '%s' is replaced with user name to whom the folder belongs,
+#. * the second '%s' is replaced with folder name.
+#. * Example result: "John Smith - Calendar"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:418
+#, c-format
+msgctxt "ForeignFolder"
+msgid "%s - %s"
+msgstr "%s – %s"
+
+#. convert well-known names to their non-localized form
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:511
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:718
+msgid "Inbox"
+msgstr "Doručená pošta"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:513
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:719
+msgid "Contacts"
+msgstr "Kontakty"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:515
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:720
+msgid "Calendar"
+msgstr "Kalendář"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:517
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:721
+msgid "Memos"
+msgstr "Poznámky"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:519
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:722
+msgid "Tasks"
+msgstr "Úkoly"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:536
+#, c-format
+msgid "Testing availability of folder '%s' of user '%s', please wait..."
+msgstr "Testuje se dostupnost složky „%s“ uživatele „%s“, čekejte prosím…"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:612
+msgid "Subscribe to folder of other EWS user..."
+msgstr "Přihlásit odběr složky jiného uživatele EWS…"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:663
+msgid "User"
+msgstr "Uživatel"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:670
+msgid "_User:"
+msgstr "_Uživatel:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:685
+msgid "C_hoose..."
+msgstr "Vy_brat…"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:701
+msgid "_Folder name:"
+msgstr "Název _složky:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:731
+msgid "Include _subfolders"
+msgstr "Včetně pod_složek"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:129
+msgid "Querying Autodiscover service"
+msgstr "Dotazuje se služby automatického vyhledávání"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:212
+msgid "Fetch _URL"
+msgstr "Získat adresu _URL"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:140
+msgid "Configuration"
+msgstr "Nastavení"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:158
+msgid "User_name:"
+msgstr "Jmé_no uživatele:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:172
+msgid "_Host URL:"
+msgstr "Adresa URL _počítače:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:191
+msgid "OAB U_RL:"
+msgstr "Adresa U_RL s OAB:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:205
+msgid "Open _Mailbox of other user"
+msgstr "Otevřít _schránku jiného uživatele"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:239
+msgid "S_earch..."
+msgstr "Hl_edat…"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:250
+msgid "Authentication"
+msgstr "Autentizace"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:500
+msgctxt "PermissionsLevel"
+msgid "Reviewer (can read items)"
+msgstr "Korektor (může číst položky)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:501
+msgctxt "PermissionsLevel"
+msgid "Author (can read and create items)"
+msgstr "Autor (může číst a vytvářet položky)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:502
+msgctxt "PermissionsLevel"
+msgid "Editor (can read, create and modify items)"
+msgstr "Editor (může číst, vytvářet a měnit položky)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:605
+msgid "Delegate permissions"
+msgstr "Delegovat oprávnění"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:623
+msgid "C_alendar"
+msgstr "K_alendář"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:626
+msgid "_Delegate receives copies of meeting-related messages sent to me"
+msgstr "Delegát ob_drží kopie zpráv ohledně shůzek zaslané na mne"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:631
+msgid "_Tasks"
+msgstr "Ú_koly"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:634
+msgid "_Inbox"
+msgstr "_Doručená pošta"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:637
+msgid "C_ontacts"
+msgstr "K_ontakty"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:640
+msgid "_Notes"
+msgstr "Poz_námky"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:643
+msgid "_Journal"
+msgstr "Ž_urnál"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:646
+#, c-format
+msgid "Delegate '%s' has the following permissions"
+msgstr "Delegát „%s“ má následující oprávnění"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:664
+msgid "Delegate can see my _private items"
+msgstr "Delegát může vidět mé soukromé _položky"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:987
+msgid "Retrieving current user permissions, please wait..."
+msgstr "Získávají se aktuální oprávnění uživatele, čekejte prosím…"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1108
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1638
+msgid "Delegates"
+msgstr "Delegáti"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1132
+msgid ""
+"Delegates can send items on your behalf, including creating and responding "
+"to meeting requests. If you want to grant folder permissions without giving "
+"send-on-behalf-of permissions, close this dialog box, right-click the "
+"folder, click Permissions and change the options there."
+msgstr ""
+"Delegáti mohou posílat položky vaším jménem, včetně vytváření žádostí o "
+"schuzky a odpovědí na ně. Pokud chcete přidělit oprávnění ke složce bez "
+"oprávnění k odesílání vaším jménem, zavřete toto dialogové okno, klikněte "
+"pravým tlačítkem na složku, klikněte na „Oprávnění“ a volby změňte."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1181
+msgid ""
+"Deliver meeting requests addressed to me and responses to meeting requests "
+"where I am the organizer to:"
+msgstr ""
+"Doručovat žádosti o schůzky adresované na mne a odpovědi na žádosti o "
+"schuzky, u kterých jsem pořadatel, na:"
+
+#. new-line break, because GtkRadioButton doesn't allow wrapping of the inner label
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1190
+msgid ""
+"My delegates only, but _send a copy of meeting requests\n"
+"and responses to me (recommended)"
+msgstr ""
+"Jen moji delegáti, ale po_sílat mi kopie žádostí o schůzky\n"
+"a odpovědi na ně (doporučeno)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1197
+msgid "My d_elegates only"
+msgstr "Jen moji delegáti"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1204
+msgid "My delegates a_nd me"
+msgstr "Moji delegáti a já"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1713
+msgid "Retrieving \"Delegates\" settings"
+msgstr "Získává se nastavení „delegátů“"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:221
+msgid "Locating offline address books"
+msgstr "Hledá se off-line adresář"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:301
+msgid "Cache o_ffline address book"
+msgstr "Uložit off-line adresář do mezipaměti"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:327
+msgid "Select ad_dress list:"
+msgstr "Vyberte seznam a_dres: "
+
+#: ../src/configuration/e-mail-config-ews-gal.c:351
+msgid "Fetch List"
+msgstr "Získat seznam"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:444
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:923
+msgid "Out of Office"
+msgstr "Mimo kancelář"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:460
+msgid ""
+"The messages specified below will be automatically sent to each internal and "
+"external person who sends a mail to you."
+msgstr ""
+"Zprávy zadané níže budou automaticky rozeslány každé\n"
+" z interních a externích osob, která vám zasílá e-maily."
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:468
+msgid "Do _not send Out of Office replies"
+msgstr "_Neposílat odpovědi „Mimo kancelář“"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:476
+msgid "_Send Out of Office replies"
+msgstr "Po_sílat odpovědi „Mimo kancelář“"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:484
+msgid "Send Out of Office replies only _during this time period:"
+msgstr "Posílat odpovědi „Mimo kancelář“ jen v tomto časovém rozmezí:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:504
+msgid "_From:"
+msgstr "_Od:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:529
+msgid "_To:"
+msgstr "_Do:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:554
+msgid "I_nternal:"
+msgstr "I_nterní:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:563
+msgid "Message to be sent within the organization"
+msgstr "Zpráva, která se má rozesílat v rámci organizace"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:590
+msgid "E_xternal:"
+msgstr "E_xterní:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:598
+msgid "Message to be sent outside the organization"
+msgstr "Zpráva, která se má rozesílat mimo organizaci"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:608
+msgid "Do not reply to senders outside the organization"
+msgstr "Neodpovídat odesilatelům mimo organizaci"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:611
+msgid "Reply only to known senders outside the organization"
+msgstr "Odpovídat pouze známým odesilatelům mimo organizaci"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:614
+msgid "Reply to any sender outside the organization"
+msgstr "Odpovídat libovolným odesilatelům mimo organizaci"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:999
+msgid "Retrieving \"Out of Office\" settings"
+msgstr "Získává se nastavení „Mimo kancelář“"
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:1
+msgid "Autodiscovery query failed."
+msgstr "Automatický dotaz selhal."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:2
+msgid "The reported error was &quot;{0}&quot;."
+msgstr "Oznámená chyba byla „{0}“."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:3
+msgid "Failed to locate offline address books."
+msgstr "Selhalo vyhledání off-line adresářů."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:4
+msgid "Failed to retrieve &quot;Out of Office&quot; settings."
+msgstr "Selhalo získání nastavení „Mimo kancelář“."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:5
+msgid "Failed to retrieve &quot;Delegates&quot; settings."
+msgstr "Selhalo získání nastavení „Delegátů“."
+
+#: ../src/server/e-ews-connection.c:493
+msgid "Operation Cancelled"
+msgstr "Operace zrušena"
+
+#: ../src/server/e-ews-connection.c:562
+msgid "Authentication failed"
+msgstr "Autentizace selhala"
+
+#: ../src/server/e-ews-connection.c:573
+#, c-format
+msgid "No response: %s"
+msgstr "Bez odezvy: %s"
+
+#: ../src/server/e-ews-connection.c:1877
+#, c-format
+msgid "Failed to parse autodiscover response XML"
+msgstr "Selhala analýza odpovědi XML na automatické nalezení"
+
+#: ../src/server/e-ews-connection.c:1884
+#, c-format
+msgid "Failed to find <Autodiscover> element"
+msgstr "Selhalo vyhledání prvku <Autodiscover>"
+
+#: ../src/server/e-ews-connection.c:1895
+#, c-format
+msgid "Failed to find <Response> element"
+msgstr "Selhalo vyhledání prvku <Response>"
+
+#: ../src/server/e-ews-connection.c:1906
+#, c-format
+msgid "Failed to find <Account> element"
+msgstr "Selhalo vyhledání prvku <Account>"
+
+#: ../src/server/e-ews-connection.c:1925
+#, c-format
+msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
+msgstr ""
+"Selhalo vyhledání <ASUrl> a <OABUrl> v odpovědi na automatické nalezení"
+
+#: ../src/server/e-ews-connection.c:2007
+msgid "URL cannot be NULL"
+msgstr "Adresa URL nesmí být prázdná"
+
+#: ../src/server/e-ews-connection.c:2015
+#, c-format
+msgid "URL '%s' is not valid"
+msgstr "Adresa URL „%s“ není platná"
+
+#: ../src/server/e-ews-connection.c:2117
+msgid "Email address is missing a domain part"
+msgstr "U e-mailové adresy schází doménová část"
+
+#: ../src/server/e-ews-connection.c:2429
+msgid "Failed to parse oab XML"
+msgstr "Selhala analýza XML OAB"
+
+#: ../src/server/e-ews-connection.c:2437
+msgid "Failed to find <OAB> element\n"
+msgstr "Selhalo vyhledání prvku <OAB>\n"
+
+#: ../src/server/e-ews-connection.c:3609
+msgid "No items found"
+msgstr "Nenalezeny žádné položky"
+
+#: ../src/server/e-ews-folder.c:546
+msgid "Cannot add folder, unsupported folder type"
+msgstr "Nelze přidat složku, nepodporovaný typ složky"
+
+#: ../src/server/e-ews-folder.c:551
+msgid "Cannot add folder, master source not found"
+msgstr "Nelze přidat složku, nenalezen hlavní zdroj"
+
+#: ../src/utils/ews-camel-common.c:187
+#, c-format
+msgid "CreateItem call failed to return ID for new message"
+msgstr ""
+"Selhalo volání funkce CreateItem, provedené kvůli získání ID pro novou zprávu"
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/da.po evolution-ews.sync-with-3.8.2/po/da.po
--- evolution-ews.git-gnome-3-0/po/da.po	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/po/da.po	2013-05-29 08:46:45.664988876 +0200
@@ -0,0 +1,445 @@
+# Danish translation for evolution-ews.
+# Copyright (C) 2011 evolution-ews's COPYRIGHT HOLDER
+# This file is distributed under the same license as the evolution-ews package.
+# Joe Hansen <joedalton2@yahoo.dk>, 2011, 2012.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: evolution-ews master\n"
+"Report-Msgid-Bugs-To: \n"
+"POT-Creation-Date: 2012-03-25 22:53+0200\n"
+"PO-Revision-Date: 2012-03-25 21:38+0000\n"
+"Last-Translator: Joe Hansen <joedalton2@yahoo.dk>\n"
+"Language-Team: Dansk-gruppen <dansk@dansk-gruppen.dk>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-listener.c:242
+msgid "Global Address list"
+msgstr "Global adresseliste"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:177
+msgid "Select a valid time range"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:286
+#, c-format
+msgid ""
+"Unable to fetch out of office settings: \n"
+"%s"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:318
+msgid ""
+"The messages specified below will be automatically sent to \n"
+" each internal and external personal who sends a mail to you."
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:323
+msgid "Status:"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:328
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:333
+msgid "I am _out of the office"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:329
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:332
+msgid "I am _in the office"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:354
+msgid "_From:"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:359
+msgid "_To:"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:376
+msgid "I_nternal:"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:378
+msgid "Message to be sent inside organization"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:385
+msgid "None"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:386
+msgid "Known"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:387
+msgid "All"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:389
+msgid "Send Message to"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:409
+msgid "E_xternal:"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:411
+msgid "Message to be sent outside organization"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:575
+msgid "Out of Office"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:581
+msgid "Fetching out of office settings..."
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:111
+#, c-format
+msgid "Autodiscover failed: %s"
+msgstr "Automatisk registrering mislykkedes: %s"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:154
+#, c-format
+msgid "Enter Password for %s"
+msgstr "Indtast adgangskode for %s"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:163
+msgid "Could not get password."
+msgstr "Kunne ikke indhente adgangskode."
+
+#. OAB url entry
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:286
+msgid "OAB U_RL:"
+msgstr "OAB U_RL:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:298
+msgid "_Host URL:"
+msgstr "_Værts-URL:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:313
+msgid "Fetch _URL"
+msgstr "Hent _URL"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:478
+msgid "Could not fetch oal list: "
+msgstr "Kunne ikke hente oal-liste: "
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:524
+msgid "Fetching..."
+msgstr "Henter..."
+
+#. Add cache check box
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:661
+msgid "Cache o_ffline address book"
+msgstr "Cache _frakoblet adressebog"
+
+#. Add label
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:667
+msgid "Select Ad_dress list: "
+msgstr "Vælg _adresseliste: "
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:677
+msgid "Fetch _list"
+msgstr "Hent _liste"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:764
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:1
+#, fuzzy
+msgid "EWS Settings"
+msgstr "GAL-opsætning"
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:2
+#: ../src/camel/camel-ews-provider.c:69
+msgid "Exchange Web Services"
+msgstr "Exchange Web-tjenester"
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:3
+msgid "Exchange Web Services Plugin"
+msgstr "Udvidelsesmodul for Exchange Web-tjenester"
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:4
+msgid "GAL settings"
+msgstr "GAL-opsætning"
+
+#: ../src/addressbook/e-book-backend-ews.c:913
+msgid "The backend does not support bulk additions"
+msgstr "Motoren understøtter ikke massetilføjelser"
+
+#: ../src/addressbook/e-book-backend-ews.c:1184
+msgid "The backend does not support bulk modifications"
+msgstr "Motoren understøtter ikke masseændringer"
+
+#: ../src/addressbook/e-book-backend-ews.c:1358
+msgid "Wait till syncing is done"
+msgstr ""
+
+#: ../src/addressbook/e-book-backend-ews.c:1676
+#, c-format
+msgid "Downloading contacts in %s %d%% completed... "
+msgstr "Hentning af kontakter i %s %d%% er færdig... "
+
+#: ../src/addressbook/e-book-backend-ews.c:2165
+msgid "Syncing contacts..."
+msgstr "Synkroniserer kontakter..."
+
+#: ../src/addressbook/e-book-backend-ews.c:2357
+msgid "Searching..."
+msgstr "Søger..."
+
+#: ../src/addressbook/e-book-backend-sqlitedb.c:474
+#, c-format
+msgid "Insufficient memory"
+msgstr "Utilstrækkelig hukommelse"
+
+#: ../src/camel/camel-ews-folder.c:262
+#, c-format
+msgid "Unable to open mimecontent temporary file!"
+msgstr "Kan ikke åbne midlertidig fil for MIME-indhold (mimecontent)!"
+
+#: ../src/camel/camel-ews-folder.c:269
+#, c-format
+msgid "Unable to generate parser from mimecontent!"
+msgstr "Kan ikke oprette fortolker fra MIME-indhold (mimecontent)!"
+
+#: ../src/camel/camel-ews-folder.c:278
+#, c-format
+msgid "Unable to parse meeting request mimecontent!"
+msgstr "Kan ikke fortolke mødeanmodning fra MIME-indhold (mimecontent)!"
+
+#: ../src/camel/camel-ews-folder.c:335
+#, c-format
+msgid "Unable to create cache file"
+msgstr "Kan ikke oprette cachefil"
+
+#: ../src/camel/camel-ews-folder.c:436 ../src/camel/camel-ews-folder.c:505
+#, c-format
+msgid "Unable to create cache path"
+msgstr "Kan ikke oprette cachesti"
+
+#: ../src/camel/camel-ews-folder.c:514
+#, c-format
+msgid "Failed to move message cache file"
+msgstr "Kunne ikke flytte beskedcachefil"
+
+#: ../src/camel/camel-ews-folder.c:917
+#, c-format
+msgid "Could not load summary for %s"
+msgstr "Kunne ikke indlæse referat for %s"
+
+#: ../src/camel/camel-ews-folder.c:1258 ../src/camel/camel-ews-store.c:757
+#: ../src/camel/camel-ews-store.c:813 ../src/camel/camel-ews-store.c:883
+#, c-format
+msgid "Cant perform actions on the folder while in offline mode"
+msgstr "Kan ikke udføre handlinger på mappen i frakoblet tilstand"
+
+#: ../src/camel/camel-ews-provider.c:48
+msgid "Checking for new mail"
+msgstr "Kontrollerer for ny post"
+
+#: ../src/camel/camel-ews-provider.c:50
+msgid "C_heck for new messages in all folders"
+msgstr "_Kontroller for nye beskeder i alle mapper"
+
+#: ../src/camel/camel-ews-provider.c:53
+msgid "Options"
+msgstr "Indstillinger"
+
+#: ../src/camel/camel-ews-provider.c:55
+msgid "_Apply filters to new messages in Inbox on this server"
+msgstr "_Anvend filtre for nye beskeder i Indbakken på denne server"
+
+#: ../src/camel/camel-ews-provider.c:57
+#, fuzzy
+msgid "Check new messages for _Junk contents"
+msgstr "Kontroller nye beskeder for _skraldindhold"
+
+#: ../src/camel/camel-ews-provider.c:59
+msgid "Only check for Junk messages in the IN_BOX folder"
+msgstr "Kontroller kun for skraldbeskeder i mappen _INDBAKKE (INBOX)"
+
+#: ../src/camel/camel-ews-provider.c:61
+msgid "Automatically synchroni_ze remote mail locally"
+msgstr "Synkroniser automatisk ekstern post lokalt"
+
+#: ../src/camel/camel-ews-provider.c:71
+msgid "For accessing Exchange servers using Web Services"
+msgstr "For adgang til Exchangeservere der bruger internettjenester"
+
+#: ../src/camel/camel-ews-provider.c:87
+msgid "Password"
+msgstr "Adgangskode"
+
+#: ../src/camel/camel-ews-provider.c:89
+msgid ""
+"This option will connect to the Exchange server using a plaintext password."
+msgstr ""
+"Denne indstilling vil forbinde til Exchangeserveren med brug af en "
+"adgangskode i klartekst."
+
+#: ../src/camel/camel-ews-store.c:184
+#, c-format
+msgid "Session has no storage path"
+msgstr "Session har ingen lagersti"
+
+#: ../src/camel/camel-ews-store.c:554
+#, c-format
+msgid "No such folder: %s"
+msgstr "Ingen sådan mappe: %s"
+
+#: ../src/camel/camel-ews-store.c:750
+#, c-format
+msgid "Parent folder %s does not exist"
+msgstr "Overmappe %s findes ikke"
+
+#: ../src/camel/camel-ews-store.c:807
+#, c-format
+msgid "Folder does not exist"
+msgstr "Mappe findes ikke"
+
+#: ../src/camel/camel-ews-store.c:891
+#, c-format
+msgid "Folder %s does not exist"
+msgstr "Mappe %s findes ikke"
+
+#: ../src/camel/camel-ews-store.c:900
+#, c-format
+msgid "No change key record for folder %s"
+msgstr "Ingen change-nøglepost for mappe %s"
+
+#: ../src/camel/camel-ews-store.c:939
+#, c-format
+msgid "Cannot both rename and move a folder at the same time"
+msgstr "Kan ikke både omdøbe og flytte en mappe på samme tid"
+
+#: ../src/camel/camel-ews-store.c:970
+#, c-format
+msgid "Cannot find folder ID for parent folder %s"
+msgstr "Kan ikke finde mappe-ID for overmappe %s"
+
+#: ../src/camel/camel-ews-store.c:1007 ../src/camel/camel-ews-transport.c:66
+#, c-format
+msgid "Exchange server %s"
+msgstr "Exchangeserver %s"
+
+# på eller den?
+#: ../src/camel/camel-ews-store.c:1009
+#, c-format
+msgid "Exchange service for %s on %s"
+msgstr "Exchangetjeneste for %s på %s"
+
+#: ../src/camel/camel-ews-store.c:1049
+#, c-format
+msgid "You must be working online to complete this operation"
+msgstr "Du skal være på nettet for at fuldføre denne handling"
+
+#: ../src/camel/camel-ews-transport.c:69
+#, c-format
+msgid "Exchange mail delivery via %s"
+msgstr "Exchangepostlevering via %s"
+
+#: ../src/camel/camel-ews-transport.c:106
+msgid "Cannot send message with no From address"
+msgstr ""
+
+#: ../src/camel/camel-ews-transport.c:110
+msgid "Exchange server cannot send message with multiple From addresses"
+msgstr ""
+
+#: ../src/camel/camel-ews-transport.c:118
+#, fuzzy
+msgid "Failed to read From address"
+msgstr "Kunne ikke fortolke oab-XML"
+
+#: ../src/camel/camel-ews-transport.c:124
+#, c-format
+msgid ""
+"Exchange server cannot send message as '%s', when the account was configured "
+"for address '%s'"
+msgstr ""
+
+#: ../src/camel/camel-ews-transport.c:135
+#, c-format
+msgid "Service not connected"
+msgstr "Tjeneste ikke forbundet"
+
+#: ../src/server/e-ews-connection.c:360
+msgid "Operation Cancelled"
+msgstr "Handling afbrudt"
+
+#: ../src/server/e-ews-connection.c:422
+msgid "Authentication failed"
+msgstr "Godkendelse mislykkedes"
+
+#: ../src/server/e-ews-connection.c:430
+#, c-format
+msgid "No response: %s"
+msgstr "Intet svar: %s"
+
+#: ../src/server/e-ews-connection.c:1284 ../src/server/e-ews-connection.c:1642
+#: ../src/server/e-ews-connection.c:1881
+#, c-format
+msgid "Code: %d - Unexpected response from server"
+msgstr "Kode: %d - Uventet svar fra server"
+
+#: ../src/server/e-ews-connection.c:1296
+#, c-format
+msgid "Failed to parse autodiscover response XML"
+msgstr "Kunne ikke fortolke svar-XML for autodiscover"
+
+#: ../src/server/e-ews-connection.c:1304
+#, c-format
+msgid "Failed to find <Autodiscover> element\n"
+msgstr "Kunne ikke finde <Autodiscover>-element\n"
+
+#: ../src/server/e-ews-connection.c:1316
+#, c-format
+msgid "Failed to find <Response> element\n"
+msgstr "Kunne ikke finde <Response>-element\n"
+
+#: ../src/server/e-ews-connection.c:1328
+#, c-format
+msgid "Failed to find <Account> element\n"
+msgstr "Kunne ikke finde <Account>-element\n"
+
+#: ../src/server/e-ews-connection.c:1347
+#, c-format
+msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
+msgstr "Kunne ikke finde <ASUrl> og <OABUrl> i autodiscoversvar"
+
+#: ../src/server/e-ews-connection.c:1449
+#, c-format
+msgid "Both email and password must be provided"
+msgstr "Både e-post og adgangskode skal angives"
+
+#: ../src/server/e-ews-connection.c:1456
+#, c-format
+msgid "Wrong email id"
+msgstr "Forkert e-post-id"
+
+#: ../src/server/e-ews-connection.c:1652
+#, c-format
+msgid "Failed to parse oab XML"
+msgstr "Kunne ikke fortolke oab-XML"
+
+#: ../src/server/e-ews-connection.c:1659
+#, c-format
+msgid "Failed to find <OAB> element\n"
+msgstr "Kunne ikke finde <OAB>-element\n"
+
+#: ../src/utils/ews-camel-common.c:170
+#, c-format
+msgid "CreateItem call failed to return ID for new message"
+msgstr "CreateItem-kald returnerede ikke ID for ny besked"
+
+#~ msgid "Unknown calendar property '%s'"
+#~ msgstr "Ukendt kalenderegenskab \"%s\""
+
+#~ msgid "EWS service has no host URL"
+#~ msgstr "EWS-tjeneste har ingen værtsadresse (URL)"
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/de.po evolution-ews.sync-with-3.8.2/po/de.po
--- evolution-ews.git-gnome-3-0/po/de.po	2013-05-17 14:36:16.326670276 +0200
+++ evolution-ews.sync-with-3.8.2/po/de.po	2013-05-29 08:46:45.664988876 +0200
@@ -1,149 +1,102 @@
 # German evolution-ews translation.
-# Mario Blättermann <mariobl@freenet.de>, 2011.
+# Mario Blättermann <mario.blaettermann@gmail.com>, 2011, 2012.
 #
 msgid ""
 msgstr ""
 "Project-Id-Version: evolution-ews master\n"
 "Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
 "product=evolution-ews&keywords=I18N+L10N&component=general\n"
-"POT-Creation-Date: 2011-10-18 11:43+0000\n"
-"PO-Revision-Date: 2011-10-11 21:17+0100\n"
-"Last-Translator: Mario Blättermann <mariobl@freenet.de>\n"
+"POT-Creation-Date: 2012-09-16 15:11+0000\n"
+"PO-Revision-Date: 2012-09-23 17:41+0100\n"
+"Last-Translator: Mario Blättermann <mario.blaettermann@gmail.com>\n"
 "Language-Team: German <gnome-de@gnome.org>\n"
+"Language: de\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
-"Language: de\n"
 "Plural-Forms: nplurals=2; plural=(n != 1)\n"
 "X-Poedit-Language: German\n"
 "X-Poedit-Country: GERMANY\n"
 
-#: ../src/account-setup-eplugin/exchange-ews-account-listener.c:240
-msgid "Global Address list"
-msgstr "Globale Adressliste"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:110
-#, c-format
-msgid "Autodiscover failed: %s"
-msgstr "Automatische Erkennung gescheitert: %s"
+#: ../src/addressbook/e-book-backend-ews.c:980
+msgid "The backend does not support bulk additions"
+msgstr "Das Backend unterstützt keine Massenhinzufügungen"
+
+#: ../src/addressbook/e-book-backend-ews.c:1264
+msgid "The backend does not support bulk modifications"
+msgstr "Das Backend unterstützt keine Massenänderungen"
+
+#: ../src/addressbook/e-book-backend-ews.c:1447
+msgid "Wait till syncing is done"
+msgstr "Warten Sie, bis der Abgleich beendet ist"
 
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:145
-#, c-format
-msgid "Enter Password for %s"
-msgstr "Passwort für %s eingeben"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:154
-msgid "Could not get password."
-msgstr "Passwort konnte nicht geholt werden."
-
-#. OAB url entry
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:258
-msgid "OAB U_RL:"
-msgstr "OAB-Ad_resse:"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:270
-msgid "_Host URL:"
-msgstr "Rec_hneradresse:"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:283
-msgid "Fetch _URL"
-msgstr "Adresse _holen"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:449
-msgid "Could not fetch oal list: "
-msgstr "OAL-Liste konnte nicht geholt werden:"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:491
-msgid "Fetching..."
-msgstr "Holen …"
-
-#. Add cache check box
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:628
-msgid "Cache o_ffline address book"
-msgstr "O_ffline-Adressbuch zwischenspeichern"
-
-#. Add label
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:634
-msgid "Select Ad_dress list: "
-msgstr "A_dressliste auswählen:"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:644
-msgid "Fetch _list"
-msgstr "_Liste holen"
-
-#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:1
-#: ../src/camel/camel-ews-provider.c:69
-msgid "Exchange Web Services"
-msgstr "Exchange-Webdienste"
-
-#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:2
-msgid "Exchange Web Services Plugin"
-msgstr "Plugin für Exchange-Webdienste"
-
-#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:3
-msgid "GAL settings"
-msgstr "GAL-Einstellungen"
-
-#: ../src/addressbook/e-book-backend-ews.c:1465
+#: ../src/addressbook/e-book-backend-ews.c:1785
 #, c-format
 msgid "Downloading contacts in %s %d%% completed... "
 msgstr "Herunterladen der Kontakte in %s zu %d%% abgeschlossen …"
 
-#: ../src/addressbook/e-book-backend-ews.c:1855
+#: ../src/addressbook/e-book-backend-ews.c:2301
 msgid "Syncing contacts..."
 msgstr "Kontakte werden abgeglichen …"
 
-#: ../src/addressbook/e-book-backend-ews.c:2052
+#: ../src/addressbook/e-book-backend-ews.c:2504
+#: ../src/configuration/e-ews-search-user.c:361
 msgid "Searching..."
 msgstr "Suche läuft …"
 
-#: ../src/addressbook/e-book-backend-sqlitedb.c:470
+#: ../src/addressbook/ews-book-backend-sqlitedb.c:478
 #, c-format
 msgid "Insufficient memory"
 msgstr "Nicht ausreichender Speicher"
 
-#: ../src/calendar/e-cal-backend-ews.c:3796
-#, c-format
-msgid "Unknown calendar property '%s'"
-msgstr "Unbekannte Kalendereigenschaft »%s«"
+#: ../src/calendar/e-cal-backend-ews.c:1060
+msgid "EWS does not support bulk removals"
+msgstr "EWS unterstützt keine Massenänderungen"
+
+#: ../src/calendar/e-cal-backend-ews.c:1645
+msgid "EWS does not support bulk additions"
+msgstr "EWS unterstützt keine Massenhinzufügungen"
+
+#: ../src/calendar/e-cal-backend-ews.c:2147
+msgid "EWS does not support bulk modifications"
+msgstr "EWS unterstützt keine Massenänderungen"
 
-#: ../src/camel/camel-ews-folder.c:186
+#: ../src/camel/camel-ews-folder.c:267
 #, c-format
 msgid "Unable to open mimecontent temporary file!"
 msgstr "Temporäre MIME-Inhaltsdatei konnte nicht geöffnet werden."
 
-#: ../src/camel/camel-ews-folder.c:193
+#: ../src/camel/camel-ews-folder.c:275
 #, c-format
 msgid "Unable to generate parser from mimecontent!"
 msgstr "Parser konnte nicht aus dem MIME-Inhalt erstellt werden"
 
-#: ../src/camel/camel-ews-folder.c:202
+#: ../src/camel/camel-ews-folder.c:284
 #, c-format
 msgid "Unable to parse meeting request mimecontent!"
 msgstr "MIME-Inhalt der Besprechungsanfrage konnte nicht verarbeitet werden"
 
-#: ../src/camel/camel-ews-folder.c:259
+#: ../src/camel/camel-ews-folder.c:344
 #, c-format
 msgid "Unable to create cache file"
 msgstr "Temporäre Datei konnte nicht erzeugt werden"
 
-#: ../src/camel/camel-ews-folder.c:356 ../src/camel/camel-ews-folder.c:425
+#: ../src/camel/camel-ews-folder.c:449 ../src/camel/camel-ews-folder.c:529
 #, c-format
 msgid "Unable to create cache path"
 msgstr "Zwischenspeicher-Pfad konnte nicht angelegt werden"
 
-#: ../src/camel/camel-ews-folder.c:434
+#: ../src/camel/camel-ews-folder.c:539
 #, c-format
 msgid "Failed to move message cache file"
 msgstr "Die Temporärdatei konnte nicht verschoben werden"
 
-#: ../src/camel/camel-ews-folder.c:777
+#: ../src/camel/camel-ews-folder.c:1140
 #, c-format
 msgid "Could not load summary for %s"
 msgstr "Zusammenfassung für %s konnte nicht geladen werden"
 
-#: ../src/camel/camel-ews-folder.c:1101 ../src/camel/camel-ews-store.c:536
-#: ../src/camel/camel-ews-store.c:592 ../src/camel/camel-ews-store.c:660
+#: ../src/camel/camel-ews-folder.c:1529
 #, c-format
 msgid "Cant perform actions on the folder while in offline mode"
 msgstr "Ordner-Aktionen können im Offline-Modus nicht ausgeführt werden"
@@ -165,7 +118,7 @@ msgid "_Apply filters to new messages in
 msgstr "Filter auf neue Nachrichten im Eingang dieses Servers an_wenden"
 
 #: ../src/camel/camel-ews-provider.c:57
-msgid "Check new messages for Jun_k contents"
+msgid "Check new messages for _Junk contents"
 msgstr "Neue Nachrichten auf _unerwünschten Inhalt prüfen"
 
 #: ../src/camel/camel-ews-provider.c:59
@@ -176,158 +129,933 @@ msgstr "A_usschließlich den Eingangsord
 msgid "Automatically synchroni_ze remote mail locally"
 msgstr "Entfernte E-Mails automatisch lokal a_bgleichen"
 
-#: ../src/camel/camel-ews-provider.c:71
+#: ../src/camel/camel-ews-provider.c:64
+msgid "Connection"
+msgstr "Verbindung"
+
+#. Translators: '%s' is preplaced with a widget, where "
+#. * user can select how long the timeout should be.
+#: ../src/camel/camel-ews-provider.c:68
+#, c-format
+msgid "Connection _timeout (in seconds) %s"
+msgstr "_Verbindungsablauf (in Sekunden) %s"
+
+#: ../src/camel/camel-ews-provider.c:76
+msgid "Exchange Web Services"
+msgstr "Exchange-Webdienste"
+
+#: ../src/camel/camel-ews-provider.c:78
 msgid "For accessing Exchange servers using Web Services"
 msgstr "Für den Zugriff auf Exchange-Server über Webdienste"
 
-#: ../src/camel/camel-ews-provider.c:87
-msgid "Password"
-msgstr "Passwort"
+#: ../src/camel/camel-ews-provider.c:93
+msgid "NTLM"
+msgstr "NTLM"
+
+#: ../src/camel/camel-ews-provider.c:95
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with NTLM authentication."
+msgstr ""
+"Diese Option stellt eine Verbindung mit dem Exchange-Server her, wobei ein "
+"einfaches Klartext-Passwort mit NTLM-Legitimierung verwendet wird."
+
+#: ../src/camel/camel-ews-provider.c:103
+msgid "Basic"
+msgstr "Einfach"
 
-#: ../src/camel/camel-ews-provider.c:89
+#: ../src/camel/camel-ews-provider.c:105
 msgid ""
-"This option will connect to the Exchange server using a plaintext password."
+"This option will connect to the Exchange server using a plaintext password "
+"with Basic authentication."
 msgstr ""
 "Diese Option stellt eine Verbindung mit dem Exchange-Server her, wobei ein "
-"einfaches Klartext-Passwort verwendet wird."
+"einfaches Klartext-Passwort mit einfacher Legitimierung verwendet wird."
 
-#: ../src/camel/camel-ews-store.c:140
+#: ../src/camel/camel-ews-store.c:183
 #, c-format
 msgid "Session has no storage path"
 msgstr "Sitzung hat keinen Pfad zum Speichern"
 
-#: ../src/camel/camel-ews-store.c:150
+#: ../src/camel/camel-ews-store.c:281
 #, c-format
-msgid "EWS service has no host URL"
-msgstr "EWS-Dienst hat keine Rechneradresse"
+msgctxt "ForeignFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
 
-#: ../src/camel/camel-ews-store.c:322
+#: ../src/camel/camel-ews-store.c:525
+msgid "Authentication password not available"
+msgstr "Legitimierungspasswort ist nicht verfügbar"
+
+#: ../src/camel/camel-ews-store.c:640
+msgid "Query for authentication types is not supported"
+msgstr "Abfrage der Legitimierungstypen wird nicht unterstützt"
+
+#: ../src/camel/camel-ews-store.c:692
 #, c-format
 msgid "No such folder: %s"
 msgstr "Ordner existiert nicht: %s"
 
-#: ../src/camel/camel-ews-store.c:529
+#: ../src/camel/camel-ews-store.c:839
+msgid ""
+"Cannot list folders available for subscription of Exchange Web Services "
+"account, use 'Subscribe to folder of other user' context menu option above "
+"the account node in the folder tree instead."
+msgstr ""
+"Für ein Abonnement des »Exchange Web Services«-Konto verfügbare Ordner können "
+"nicht aufgelistet werden. Verwenden Sie stattdessen die Option »Ordner eines "
+"anderen Benutzers abonnieren« im Kontextmenü, oberhalb der Kontoeinstellungen "
+"im Ordnerbaum."
+
+#: ../src/camel/camel-ews-store.c:932
+#, c-format
+msgid "Cannot create folder '%s', folder already exists"
+msgstr "Ordner »%s« kann nicht angelegt werden, der Ordner existiert bereits"
+
+#: ../src/camel/camel-ews-store.c:947
 #, c-format
 msgid "Parent folder %s does not exist"
 msgstr "Übergeordneter Ordner %s existiert nicht"
 
-#: ../src/camel/camel-ews-store.c:586
+#: ../src/camel/camel-ews-store.c:957
+#, c-format
+msgid ""
+"Cannot create folder under '%s', it is used for folders of other users only"
+msgstr ""
+"Ordner unterhalb von »%s« konnte nicht angelegt werden, dies wird "
+"ausschließlich für andere Benutzer verwendet"
+
+#: ../src/camel/camel-ews-store.c:1026
 #, c-format
 msgid "Folder does not exist"
 msgstr "Ordner existiert nicht"
 
-#: ../src/camel/camel-ews-store.c:668
+#: ../src/camel/camel-ews-store.c:1035
+#, c-format
+msgid "Cannot remove folder '%s', it is used for folders of other users only"
+msgstr ""
+"Ordner »%s« konnte nicht entfernt werden, er wird ausschließlich für andere "
+"Benutzer verwendet"
+
+#: ../src/camel/camel-ews-store.c:1142
 #, c-format
 msgid "Folder %s does not exist"
 msgstr "Ordner »%s« existiert nicht"
 
-#: ../src/camel/camel-ews-store.c:677
+#: ../src/camel/camel-ews-store.c:1152
 #, c-format
 msgid "No change key record for folder %s"
 msgstr "Keine Änderung des Schlüsseleintrags für Ordner %s"
 
-#: ../src/camel/camel-ews-store.c:716
+#: ../src/camel/camel-ews-store.c:1194
 #, c-format
 msgid "Cannot both rename and move a folder at the same time"
 msgstr "Ordner können nicht gleichzeitig umbenannt und verschoben werden."
 
-#: ../src/camel/camel-ews-store.c:747
+#: ../src/camel/camel-ews-store.c:1230
 #, c-format
 msgid "Cannot find folder ID for parent folder %s"
 msgstr "Kennung für übergeordneten Ordner %s kann nicht gefunden werden"
 
-#: ../src/camel/camel-ews-store.c:776 ../src/camel/camel-ews-transport.c:58
+#: ../src/camel/camel-ews-store.c:1280 ../src/camel/camel-ews-transport.c:69
 #, c-format
 msgid "Exchange server %s"
 msgstr "Exchange-Server %s"
 
-#: ../src/camel/camel-ews-store.c:778
+#: ../src/camel/camel-ews-store.c:1283
 #, c-format
 msgid "Exchange service for %s on %s"
 msgstr "Exchange-Dienst für %s auf %s"
 
-#: ../src/camel/camel-ews-store.c:813
+#: ../src/camel/camel-ews-store.c:1327
+#, c-format
+msgid "Could not locate Trash folder"
+msgstr "Der Müllordner konnte nicht ermittelt werden"
+
+#: ../src/camel/camel-ews-store.c:1362
+#, c-format
+msgid "Could not locate Junk folder"
+msgstr "Der Unerwünscht-Ordner konnte nicht ermittelt werden"
+
+#: ../src/camel/camel-ews-store.c:1440
+msgid "Cannot subscribe EWS folders in offline mode"
+msgstr "EWS-Ordner können im Offline-Modus nicht abonniert werden"
+
+#: ../src/camel/camel-ews-store.c:1462
+msgid "Cannot unsubscribe EWS folders in offline mode"
+msgstr "OEWS-Ordner können im Offline-Modus nicht abbestellt werden"
+
+#: ../src/camel/camel-ews-store.c:1504
 #, c-format
 msgid "You must be working online to complete this operation"
 msgstr "Sie müssen online arbeiten, um diesen Vorgang abzuschließen"
 
-#: ../src/camel/camel-ews-transport.c:62
+#: ../src/camel/camel-ews-transport.c:72
 #, c-format
 msgid "Exchange mail delivery via %s"
 msgstr "Exchange E-Mail-Auslieferung über %s"
 
-#: ../src/camel/camel-ews-transport.c:88
+#: ../src/camel/camel-ews-transport.c:120
+msgid "Cannot send message with no From address"
+msgstr "Ohne Absenderadresse kann die Nachricht nicht versendet werden"
+
+#: ../src/camel/camel-ews-transport.c:126
+msgid "Exchange server cannot send message with multiple From addresses"
+msgstr ""
+"Der Exchange-Server kann keine Nachricht mit mehreren Absenderadressen "
+"versenden"
+
+#: ../src/camel/camel-ews-transport.c:137
+msgid "Failed to read From address"
+msgstr "Absenderadresse konnte nicht gelesen werden"
+
+#: ../src/camel/camel-ews-transport.c:149
+#, c-format
+msgid ""
+"Exchange server cannot send message as '%s', when the account was configured "
+"for address '%s'"
+msgstr ""
+"Der Exchange-Server kann die Nachricht nicht als »%s« versenden, da das Konto "
+"für die Adresse »%s« eingerichtet wurde"
+
+#: ../src/camel/camel-ews-transport.c:163
 #, c-format
 msgid "Service not connected"
 msgstr "Dienst nicht verbunden"
 
-#: ../src/server/e-ews-connection.c:354
+#: ../src/collection/e-ews-backend.c:382
+#: ../src/configuration/e-mail-config-ews-gal.c:268
+msgid "Global Address List"
+msgstr "Globale Adressliste"
+
+#: ../src/collection/e-ews-backend.c:767
+#, c-format
+msgid "Could not determine a suitable folder class for a new folder named '%s'"
+msgstr ""
+"Es konnte keine passende Ordnerklasse für einen neuen Ordner namens »%s« "
+"ermittelt werden"
+
+#: ../src/collection/e-ews-backend.c:858
+#, c-format
+msgid "Data source '%s' does not represent an Exchange Web Services folder"
+msgstr "Die Datenquelle »%s« ist kein »Exchange Web Services«-Ordner"
+
+#: ../src/configuration/e-ews-config-utils.c:510
+#, c-format
+msgid "Cannot edit permissions of folder '%s', choose other folder."
+msgstr ""
+"Die Zugriffsrechte des Ordners »%s« können nicht bearbeitet werden, bitte "
+"wählen Sie einen anderen Ordner."
+
+#: ../src/configuration/e-ews-config-utils.c:588
+msgid "Subscribe to folder of other user..."
+msgstr "Ordner eines anderen Benutzers abonnieren …"
+
+#: ../src/configuration/e-ews-config-utils.c:597
+#: ../src/configuration/e-ews-config-utils.c:878
+#: ../src/configuration/e-ews-config-utils.c:909
+#: ../src/configuration/e-ews-config-utils.c:940
+#: ../src/configuration/e-ews-config-utils.c:971
+msgid "Permissions..."
+msgstr "Berechtigungen …"
+
+#: ../src/configuration/e-ews-config-utils.c:599
+msgid "Edit EWS folder permissions"
+msgstr "EWS-Ordnerzugriffsrechte bearbeiten"
+
+#: ../src/configuration/e-ews-config-utils.c:880
+msgid "Edit EWS calendar permissions"
+msgstr "EWS-Kalenderberechtigungen bearbeiten"
+
+#: ../src/configuration/e-ews-config-utils.c:911
+msgid "Edit EWS tasks permissions"
+msgstr "EWS-Aufgaben-Zugriffsrechte"
+
+#: ../src/configuration/e-ews-config-utils.c:942
+msgid "Edit EWS memos permissions"
+msgstr "EWS-Notizen-Zugriffsrechte"
+
+#: ../src/configuration/e-ews-config-utils.c:973
+msgid "Edit EWS contacts permissions"
+msgstr "EWS-Kontakte-Zugriffsrechte"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:87
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:502
+msgctxt "PermissionsLevel"
+msgid "None"
+msgstr "Keine"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:88
+msgctxt "PermissionsLevel"
+msgid "Owner"
+msgstr "Besitzer"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:98
+msgctxt "PermissionsLevel"
+msgid "Publishing Editor"
+msgstr "Veröffentlichender Bearbeiter"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:107
+msgctxt "PermissionsLevel"
+msgid "Editor"
+msgstr "Bearbeiter"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:115
+msgctxt "PermissionsLevel"
+msgid "Publishing Author"
+msgstr "Veröffentlichender Autor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:122
+msgctxt "PermissionsLevel"
+msgid "Author"
+msgstr "Autor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:128
+msgctxt "PermissionsLevel"
+msgid "Nonediting Author"
+msgstr "Nicht bearbeitender Autor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:133
+msgctxt "PermissionsLevel"
+msgid "Reviewer"
+msgstr "Überarbeiter"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:136
+msgctxt "PermissionsLevel"
+msgid "Contributor"
+msgstr "Mitwirkender"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:139
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time"
+msgstr "Verfügbarkeitsinformationen"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:141
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time, subject, location"
+msgstr "Verfügbarkeitsinformationen, Betreff, Ort"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:143
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:523
+msgctxt "PermissionsLevel"
+msgid "Custom"
+msgstr "Benutzerdefiniert"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:267
+msgid "Writing folder permissions, please wait..."
+msgstr "Zugriffsrechte des Ordners werden geschrieben, bitte warten …"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:759
+msgctxt "User"
+msgid "Anonymous"
+msgstr "Anonym"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:762
+msgctxt "User"
+msgid "Default"
+msgstr "Vorgabe"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:768
+msgctxt "User"
+msgid "Unknown"
+msgstr "Bekannt"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:849
+#: ../src/configuration/e-ews-search-user.c:427
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1078
+msgid "Name"
+msgstr "Name"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:855
+msgid "Permission level"
+msgstr "Stufe der Zugriffsrechte"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:907
+msgid "Edit EWS folder permissions..."
+msgstr "EWS-Ordner-Zugriffsrechte bearbeiten …"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:932
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:621
+msgid "Account:"
+msgstr "Konto:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:960
+msgid "Folder name:"
+msgstr "Ordnername:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:983
+msgid "Folder ID:"
+msgstr "Ordnerkennung:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1047
+msgid "Permissions"
+msgstr "Berechtigungen"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1069
+msgid "Permi_ssion level:"
+msgstr "_Berechtigungsstufe:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1103
+msgctxt "Permissions"
+msgid "Read"
+msgstr "Lesen"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1115
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1182
+msgctxt "Permissions"
+msgid "None"
+msgstr "Keine"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1121
+msgctxt "Permissions"
+msgid "Free/Busy time"
+msgstr "Verfügbarkeitsinformationen"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1126
+msgctxt "Permissions"
+msgid "Free/Busy time, subject, location"
+msgstr "Verfügbarkeitsinformationen, Betreff, Ort"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1132
+msgctxt "Permissions"
+msgid "Full Details"
+msgstr "Alle Details"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1138
+msgctxt "Permissions"
+msgid "Write"
+msgstr "Schreiben"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1150
+msgctxt "Permissions"
+msgid "Create items"
+msgstr "Objekte erstellen"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1154
+msgctxt "Permissions"
+msgid "Create subfolders"
+msgstr "Unterordner anlegen"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1158
+msgctxt "Permissions"
+msgid "Edit own"
+msgstr "Eigene bearbeiten"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1162
+msgctxt "Permissions"
+msgid "Edit all"
+msgstr "Alles bearbeiten"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1170
+msgctxt "Permissions"
+msgid "Delete items"
+msgstr "Objekte löschen"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1187
+msgctxt "Permissions"
+msgid "Own"
+msgstr "Eigene"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1192
+msgctxt "Permissions"
+msgid "All"
+msgstr "Alle"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1198
+msgctxt "Permissions"
+msgid "Other"
+msgstr "Andere"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1210
+msgctxt "Permissions"
+msgid "Folder owner"
+msgstr "Besitzer des Ordners"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1214
+msgctxt "Permissions"
+msgid "Folder contact"
+msgstr "Ordnerkontakt"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1218
+msgctxt "Permissions"
+msgid "Folder visible"
+msgstr "Ordner sichtbar"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1291
+msgid "Reading folder permissions, please wait..."
+msgstr "Zugriffsrechte des Ordners werden gelesen, bitte warten …"
+
+#: ../src/configuration/e-ews-search-user.c:208
+#, c-format
+msgid "No users found, only one contact"
+msgid_plural "No users found, only %d contacts"
+msgstr[0] "Keine Benutzer gefunden, nur ein Kontakt"
+msgstr[1] "Keine Benutzer gefunden, nur %d Kontakte"
+
+#: ../src/configuration/e-ews-search-user.c:213
+msgid "No users found"
+msgstr "Keine Benutzer gefunden"
+
+#: ../src/configuration/e-ews-search-user.c:217
+#, c-format
+msgid "Found one user"
+msgid_plural "Found %d users"
+msgstr[0] "Ein Benutzer gefunden"
+msgstr[1] "%d Benutzer gefunden"
+
+#: ../src/configuration/e-ews-search-user.c:223
+#, c-format
+msgid "Found more than 100 users, but showing only first %d"
+msgid_plural "Found more than 100 users, but showing only first %d"
+msgstr[0] ""
+"Mehr als 100 Benutzer gefunden, es werden nur die ersten %d angezeigt"
+msgstr[1] ""
+"Mehr als 100 Benutzer gefunden, es werden nur die ersten %d angezeigt"
+
+#: ../src/configuration/e-ews-search-user.c:353
+#: ../src/configuration/e-ews-search-user.c:536
+msgid "Search for a user"
+msgstr "Nach einem Benutzer suchen"
+
+#: ../src/configuration/e-ews-search-user.c:433
+msgid "E-mail"
+msgstr "E-Mail"
+
+#: ../src/configuration/e-ews-search-user.c:470
+msgid "Choose EWS user..."
+msgstr "EWS-Benutzer wählen …"
+
+#: ../src/configuration/e-ews-search-user.c:493
+msgid "_Search:"
+msgstr "_Suche:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:96
+#: ../src/server/e-ews-folder.c:584
+#, c-format
+msgid "Cannot add folder, folder already exists as '%s'"
+msgstr ""
+"Ordner konnte nicht hinzugefügt werden, der Ordner existiert bereits als »%s«"
+
+#. Translators: The '%s' is replaced with user name, to whom the foreign mailbox belongs.
+#. * Example result: "Mailbox - John Smith"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:106
+#, c-format
+msgctxt "ForeignFolder"
+msgid "Mailbox - %s"
+msgstr "Postfach - %s"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:264
+msgid "Cannot test foreign folder availability while in offline mode"
+msgstr ""
+"Fähigkeiten des Fremdordners können im Offline-Modus nicht überprüft werden"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:289
+#, c-format
+msgid "User '%s' was not found on the server"
+msgstr "Benutzer »%s« wurde auf diesem Server nicht gefunden"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:325
+#, c-format
+msgid "User name '%s' is ambiguous, specify it more precisely, please"
+msgstr ""
+"Der Benutzername »%s« ist nicht eindeutig, bitte geben Sie ihn etwas genauer "
+"an"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:347
+#, c-format
+msgid ""
+"Folder '%s' not found. Either it does not exist or you do not have permission "
+"to access it."
+msgstr ""
+"Der Ordner »%s« wurde nicht gefunden. Entweder existiert er nicht oder Ihnen "
+"fehlen die nötigen Zugriffsrechte."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:365
+msgid "Cannot add folder, cannot determine folder's type"
+msgstr ""
+"Ordner konnte nicht hinzugefügt werden, der Ordnertyp konnte nicht bestimmt "
+"werden"
+
+#. Translators: This is used to name foreign folder.
+#. * The first '%s' is replaced with user name to whom the folder belongs,
+#. * the second '%s' is replaced with folder name.
+#. * Example result: "John Smith - Calendar"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:410
+#, c-format
+msgctxt "ForeignFolder"
+msgid "%s - %s"
+msgstr "%s - %s"
+
+#. convert well-known names to their non-localized form
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:500
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:706
+msgid "Inbox"
+msgstr "Eingang"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:502
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:707
+msgid "Contacts"
+msgstr "Kontakte"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:504
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:708
+msgid "Calendar"
+msgstr "Kalender"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:506
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:709
+msgid "Memos"
+msgstr "Notizen"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:508
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:710
+msgid "Tasks"
+msgstr "Aufgaben"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:524
+#, c-format
+msgid "Testing availability of folder '%s' of user '%s', please wait..."
+msgstr ""
+"Fähigkeiten des Ordners »%s« des Benutzers »%s« werden überprüft, bitte "
+"warten …"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:600
+msgid "Subscribe to folder of other EWS user..."
+msgstr "Einen Ordner eines anderen EWS-Benutzers abonnieren …"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:651
+msgid "User"
+msgstr "Benutzer"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:658
+msgid "_User:"
+msgstr "_Benutzer:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:673
+msgid "C_hoose..."
+msgstr "_Auswählen …"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:689
+msgid "_Folder name:"
+msgstr "_Ordnername:"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:126
+msgid "Querying Autodiscover service"
+msgstr "Autodiscover-Dienst wird abgefragt"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:209
+msgid "Fetch _URL"
+msgstr "Adresse _holen"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:109
+msgid "Configuration"
+msgstr "Konfiguration"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:127
+msgid "User_name:"
+msgstr "Benutzer_name:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:141
+msgid "_Host URL:"
+msgstr "Rec_hneradresse:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:160
+msgid "OAB U_RL:"
+msgstr "OAB-Ad_resse:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:174
+msgid "Authentication"
+msgstr "Legitimierung"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:215
+msgid "Locating offline address books"
+msgstr "Offline-Adressbuch wird gesucht"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:295
+msgid "Cache o_ffline address book"
+msgstr "O_ffline-Adressbuch zwischenspeichern"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:321
+msgid "Select ad_dress list:"
+msgstr "A_dressliste auswählen:"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:345
+msgid "Fetch List"
+msgstr "Liste holen"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:503
+msgctxt "PermissionsLevel"
+msgid "Reviewer (can read items)"
+msgstr "Überarbeiter (kann Objekte einsehen)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:504
+msgctxt "PermissionsLevel"
+msgid "Author (can read and create items)"
+msgstr "Autor (kann Objekte einsehen und anlegen)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:505
+msgctxt "PermissionsLevel"
+msgid "Editor (can read, create and modify items)"
+msgstr "Bearbeiter (kann Objekte einsehen, anlegen und ändern)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:608
+msgid "Delegate permissions"
+msgstr "Berechtigungen des Vertreters"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:626
+msgid "C_alendar"
+msgstr "Ka_lender:"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:629
+msgid "_Delegate receives copies of meeting-related messages sent to me"
+msgstr ""
+"Vertreter erhalten Kopien der besprechungsbezogenen Nachrichten, _die an mich "
+"gesendet wurden"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:634
+msgid "_Tasks"
+msgstr "_Aufgaben"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:637
+msgid "_Inbox"
+msgstr "E_ingang:"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:640
+msgid "C_ontacts"
+msgstr "_Kontakte"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:643
+msgid "_Notes"
+msgstr "_Notizen"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:646
+msgid "_Journal"
+msgstr "_Journal"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:649
+#, c-format
+msgid "Delegate '%s' has the following permissions"
+msgstr "Der Vertreter %s hat folgende Berechtigungen"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:667
+msgid "Delegate can see my _private items"
+msgstr "Der Vertreter kann meine _privaten Einträge sehen"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:990
+msgid "Retrieving current user permissions, please wait..."
+msgstr "Aktuelle Benutzerrechte werden ermittelt, bitte warten …"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1111
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1641
+msgid "Delegates"
+msgstr "Vertreter"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1135
+msgid ""
+"Delegates can send items on your behalf, including creating and responding to "
+"meeting requests. If you want to grant folder permissions without giving send-"
+"on-behalf-of permissions, close this dialog box, right-click the folder, "
+"click Permissions and change the options there."
+msgstr ""
+"Der Vertreter kann Objekte in meinem Namen versenden, einschließlich "
+"Erstellen von und Antworten auf Besprechungsanfragen. Wenn Sie "
+"Ordnerzugriffsrechte gewähren wollen, ohne besondere Vertreterrechte zu "
+"vergeben, schließen Sie diesen Dialog, klicken mit der rechten Maustaste auf "
+"den Ordner und anschließend auf »Berechtigungen« und ändern die dortigen "
+"Optionen."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1184
+msgid ""
+"Deliver meeting requests addressed to me and responses to meeting requests "
+"where I am the organizer to:"
+msgstr ""
+"An mich adressierte Besprechungsanfragen an mich senden und auf "
+"Besprechungsanfragen antworten, die ich organisiert habe:"
+
+#. new-line break, because GtkRadioButton doesn't allow wrapping of the inner label
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1193
+msgid ""
+"My delegates only, but _send a copy of meeting requests\n"
+"and responses to me (recommended)"
+msgstr ""
+"Nur an meine Vertreter, aber Kopien der Besprechungsanfragen\n"
+"und Antworten sollen an mich gesendet werden (empfohlen)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1200
+msgid "My d_elegates only"
+msgstr "Nur an meine _Vertreter"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1207
+msgid "My delegates a_nd me"
+msgstr "An meine Vertreter u_nd mich"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1716
+msgid "Retrieving \"Delegates\" settings"
+msgstr "Vertretereinstellungen werden ermittelt"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:446
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:925
+msgid "Out of Office"
+msgstr "Nicht im Büro"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:462
+msgid ""
+"The messages specified below will be automatically sent to each internal and "
+"external person who sends a mail to you."
+msgstr ""
+"Die nachfolgend angegebenen Nachrichten werden automatisch an alle internen "
+"und externen Personen versendet, die Ihnen eine Nachricht gesendet haben."
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:470
+msgid "Do _not send Out of Office replies"
+msgstr "Kei_ne Abwesenheitsantworten versenden"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:478
+msgid "_Send Out of Office replies"
+msgstr "_Abwesenheits-Antworten verschicken"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:486
+msgid "Send Out of Office replies only _during this time period:"
+msgstr "Abwesenheitsantworten nur während _dieser Zeit versenden:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:506
+msgid "_From:"
+msgstr "_Von:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:531
+msgid "_To:"
+msgstr "_An:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:556
+msgid "I_nternal:"
+msgstr "I_ntern:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:565
+msgid "Message to be sent within the organization"
+msgstr "Innerhalb der Organisation zu versendende Nachricht"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:592
+msgid "E_xternal:"
+msgstr "E_xtern:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:600
+msgid "Message to be sent outside the organization"
+msgstr "Außerhalb der Organisation zu versendende Nachricht"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:610
+msgid "Do not reply to senders outside the organization"
+msgstr "Nicht an Absender außerhalb der Organisation antworten"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:613
+msgid "Reply only to known senders outside the organization"
+msgstr "Nur an bekannte Absender außerhalb der Organisation antworten"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:616
+msgid "Reply to any sender outside the organization"
+msgstr "An alle Absender außerhalb der Organisation antworten"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:1001
+msgid "Retrieving \"Out of Office\" settings"
+msgstr "Abwesenheitseinstellungen werden ermittelt"
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:1
+msgid "Autodiscovery query failed."
+msgstr "Abfrage des Autodiscover-Dienstes ist fehlgeschlagen."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:2
+msgid "The reported error was &quot;{0}&quot;."
+msgstr "Die Fehlermeldung war &quot;{0}&quot;."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:3
+msgid "Failed to locate offline address books."
+msgstr "Offline-Adressbuch konnte nicht gefunden werden"
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:4
+msgid "Failed to retrieve &quot;Out of Office&quot; settings."
+msgstr "Abwesenheitseinstellungen konnten nicht ermittelt werden."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:5
+msgid "Failed to retrieve &quot;Delegates&quot; settings."
+msgstr "Vertretereinstellungen konnten nicht ermittelt werden."
+
+#: ../src/server/e-ews-connection.c:488
 msgid "Operation Cancelled"
 msgstr "Operation abgebrochen"
 
-#: ../src/server/e-ews-connection.c:408
+#: ../src/server/e-ews-connection.c:557
 msgid "Authentication failed"
 msgstr "Legitimation gescheitert"
 
-#: ../src/server/e-ews-connection.c:416
+#: ../src/server/e-ews-connection.c:568
 #, c-format
 msgid "No response: %s"
 msgstr "Keine Antwort: %s"
 
-#: ../src/server/e-ews-connection.c:1072 ../src/server/e-ews-connection.c:1388
-#: ../src/server/e-ews-connection.c:1625
-#, c-format
-msgid "Code: %d - Unexpected response from server"
-msgstr "Code: %d - Unerwartete Antwort vom Server"
-
-#: ../src/server/e-ews-connection.c:1084
+#: ../src/server/e-ews-connection.c:1852
 #, c-format
 msgid "Failed to parse autodiscover response XML"
 msgstr "XML der Autodiscover-Antwort konnte nicht verarbeitet werden"
 
-#: ../src/server/e-ews-connection.c:1092
+#: ../src/server/e-ews-connection.c:1859
 #, c-format
-msgid "Failed to find <Autodiscover> element\n"
-msgstr "<Autodiscover>-Element konnte nicht gefunden werden\n"
+msgid "Failed to find <Autodiscover> element"
+msgstr "<Autodiscover>-Element konnte nicht gefunden werden"
 
-#: ../src/server/e-ews-connection.c:1104
+#: ../src/server/e-ews-connection.c:1870
 #, c-format
-msgid "Failed to find <Response> element\n"
-msgstr "<Response>-Element konnte nicht gefunden werden\n"
+msgid "Failed to find <Response> element"
+msgstr "<Response>-Element konnte nicht gefunden werden"
 
-#: ../src/server/e-ews-connection.c:1116
+#: ../src/server/e-ews-connection.c:1881
 #, c-format
-msgid "Failed to find <Account> element\n"
-msgstr "<Account>-Element konnte nicht gefunden werden\n"
+msgid "Failed to find <Account> element"
+msgstr "<Account>-Element konnte nicht gefunden werden"
 
-#: ../src/server/e-ews-connection.c:1135
+#: ../src/server/e-ews-connection.c:1900
 #, c-format
 msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
 msgstr ""
 "<ASUrl> und <OABUrl> konnten in Autodiscover-Antwort nicht gefunden werden"
 
-#: ../src/server/e-ews-connection.c:1231
-#, c-format
-msgid "Both email and password must be provided"
-msgstr "Sowohl E-Mail-Adresse als auch Passwort müssen angegeben werden"
+#: ../src/server/e-ews-connection.c:1980
+msgid "URL cannot be NULL"
+msgstr "Die Adresse darf nicht NULL sein"
 
-#: ../src/server/e-ews-connection.c:1238
+#: ../src/server/e-ews-connection.c:1987
 #, c-format
-msgid "Wrong email id"
-msgstr "Falsche E-Mail-Kennung"
+msgid "URL '%s' is not valid"
+msgstr "Adresse »%s« ist ungültig"
 
-#: ../src/server/e-ews-connection.c:1398
-#, c-format
+#: ../src/server/e-ews-connection.c:2089
+msgid "Email address is missing a domain part"
+msgstr "In der E-Mail-Adresse fehlt der Domain-Teil"
+
+#: ../src/server/e-ews-connection.c:2359
 msgid "Failed to parse oab XML"
 msgstr "OAB-XML konnte nicht verarbeitet werden"
 
-#: ../src/server/e-ews-connection.c:1405
-#, c-format
+#: ../src/server/e-ews-connection.c:2367
 msgid "Failed to find <OAB> element\n"
 msgstr "<OAB>-Element konnte nicht gefunden werden\n"
 
-#: ../src/utils/ews-camel-common.c:138
+#: ../src/server/e-ews-connection.c:3509
+msgid "No items found"
+msgstr "Keine Objekte gefunden"
+
+#: ../src/server/e-ews-folder.c:539
+msgid "Cannot add folder, unsupported folder type"
+msgstr ""
+"Ordner konnte nicht hinzugefügt werden, der Ordnertyp wird nicht unterstützt"
+
+#: ../src/server/e-ews-folder.c:544
+msgid "Cannot add folder, master source not found"
+msgstr "Ordner kann nicht hinzugefügt werden, Hauptquelle wurde nicht gefunden"
+
+#: ../src/utils/ews-camel-common.c:176
 #, c-format
 msgid "CreateItem call failed to return ID for new message"
 msgstr ""
 "CreateItem-Aufruf konnte die Kennung der neuen Nachricht nicht zurückgeben"
+
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/en_GB.po evolution-ews.sync-with-3.8.2/po/en_GB.po
--- evolution-ews.git-gnome-3-0/po/en_GB.po	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/po/en_GB.po	2013-05-29 08:46:45.662641660 +0200
@@ -0,0 +1,1036 @@
+# British English translation for evolution-ews.
+# Copyright (C) 2012 evolution-ews's COPYRIGHT HOLDER
+# This file is distributed under the same license as the evolution-ews package.
+# olpc user <cjlhomeaddress@gmail.com>, 2012.
+# Bruce Cowan <bruce@bcowan.me.uk>, 2012.
+msgid ""
+msgstr ""
+"Project-Id-Version: evolution-ews master\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product"
+"=evolution-ews&keywords=I18N+L10N&component=general\n"
+"POT-Creation-Date: 2012-09-06 09:10+0000\n"
+"PO-Revision-Date: 2012-09-12 18:58+0100\n"
+"Last-Translator: Bruce Cowan <bruce@bcowan.me.uk>\n"
+"Language-Team: British English <en@li.org>\n"
+"Language: en_GB\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+"X-Generator: Virtaal 0.7.1\n"
+"X-Project-Style: gnome\n"
+
+#: ../src/addressbook/e-book-backend-ews.c:980
+msgid "The backend does not support bulk additions"
+msgstr "The backend does not support bulk additions"
+
+#: ../src/addressbook/e-book-backend-ews.c:1264
+msgid "The backend does not support bulk modifications"
+msgstr "The backend does not support bulk modifications"
+
+#: ../src/addressbook/e-book-backend-ews.c:1447
+msgid "Wait till syncing is done"
+msgstr "Wait till syncing is done"
+
+#: ../src/addressbook/e-book-backend-ews.c:1785
+#, c-format
+msgid "Downloading contacts in %s %d%% completed... "
+msgstr "Downloading contacts in %s %d%% completed… "
+
+#: ../src/addressbook/e-book-backend-ews.c:2301
+msgid "Syncing contacts..."
+msgstr "Syncing contacts…"
+
+#: ../src/addressbook/e-book-backend-ews.c:2504
+#: ../src/configuration/e-ews-search-user.c:361
+msgid "Searching..."
+msgstr "Searching…"
+
+#: ../src/addressbook/ews-book-backend-sqlitedb.c:478
+#, c-format
+msgid "Insufficient memory"
+msgstr "Insufficient memory"
+
+#: ../src/calendar/e-cal-backend-ews.c:1060
+msgid "EWS does not support bulk removals"
+msgstr "EWS does not support bulk removals"
+
+#: ../src/calendar/e-cal-backend-ews.c:1645
+msgid "EWS does not support bulk additions"
+msgstr "EWS does not support bulk additions"
+
+#: ../src/calendar/e-cal-backend-ews.c:2147
+msgid "EWS does not support bulk modifications"
+msgstr "EWS does not support bulk modifications"
+
+#: ../src/camel/camel-ews-folder.c:267
+#, c-format
+msgid "Unable to open mimecontent temporary file!"
+msgstr "Unable to open mimecontent temporary file!"
+
+#: ../src/camel/camel-ews-folder.c:275
+#, c-format
+msgid "Unable to generate parser from mimecontent!"
+msgstr "Unable to generate parser from mimecontent!"
+
+#: ../src/camel/camel-ews-folder.c:284
+#, c-format
+msgid "Unable to parse meeting request mimecontent!"
+msgstr "Unable to parse meeting request mimecontent!"
+
+#: ../src/camel/camel-ews-folder.c:344
+#, c-format
+msgid "Unable to create cache file"
+msgstr "Unable to create cache file"
+
+#: ../src/camel/camel-ews-folder.c:449 ../src/camel/camel-ews-folder.c:529
+#, c-format
+msgid "Unable to create cache path"
+msgstr "Unable to create cache path"
+
+#: ../src/camel/camel-ews-folder.c:539
+#, c-format
+msgid "Failed to move message cache file"
+msgstr "Failed to move message cache file"
+
+#: ../src/camel/camel-ews-folder.c:1140
+#, c-format
+msgid "Could not load summary for %s"
+msgstr "Could not load summary for %s"
+
+#: ../src/camel/camel-ews-folder.c:1529
+#, c-format
+msgid "Cant perform actions on the folder while in offline mode"
+msgstr "Can't perform actions on the folder while in offline mode"
+
+#: ../src/camel/camel-ews-provider.c:48
+msgid "Checking for new mail"
+msgstr "Checking for new mail"
+
+#: ../src/camel/camel-ews-provider.c:50
+msgid "C_heck for new messages in all folders"
+msgstr "C_heck for new messages in all folders"
+
+#: ../src/camel/camel-ews-provider.c:53
+msgid "Options"
+msgstr "Options"
+
+#: ../src/camel/camel-ews-provider.c:55
+msgid "_Apply filters to new messages in Inbox on this server"
+msgstr "_Apply filters to new messages in Inbox on this server"
+
+#: ../src/camel/camel-ews-provider.c:57
+msgid "Check new messages for _Junk contents"
+msgstr "Check new messages for _Junk contents"
+
+#: ../src/camel/camel-ews-provider.c:59
+msgid "Only check for Junk messages in the IN_BOX folder"
+msgstr "Only check for Junk messages in the IN_BOX folder"
+
+#: ../src/camel/camel-ews-provider.c:61
+msgid "Automatically synchroni_ze remote mail locally"
+msgstr "Automatically synchroni_se remote mail locally"
+
+#: ../src/camel/camel-ews-provider.c:64
+msgid "Connection"
+msgstr "Connection"
+
+#. Translators: '%s' is preplaced with a widget, where "
+#. * user can select how long the timeout should be.
+#: ../src/camel/camel-ews-provider.c:68
+#, c-format
+msgid "Connection _timeout (in seconds) %s"
+msgstr "Connection _timeout (in seconds) %s"
+
+#: ../src/camel/camel-ews-provider.c:76
+msgid "Exchange Web Services"
+msgstr "Exchange Web Services"
+
+#: ../src/camel/camel-ews-provider.c:78
+msgid "For accessing Exchange servers using Web Services"
+msgstr "For accessing Exchange servers using Web Services"
+
+#: ../src/camel/camel-ews-provider.c:93
+msgid "NTLM"
+msgstr "NTLM"
+
+#: ../src/camel/camel-ews-provider.c:95
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with NTLM authentication."
+msgstr ""
+"This option will connect to the Exchange server using a plaintext password "
+"with NTLM authentication."
+
+#: ../src/camel/camel-ews-provider.c:103
+msgid "Basic"
+msgstr "Basic"
+
+#: ../src/camel/camel-ews-provider.c:105
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with Basic authentication."
+msgstr ""
+"This option will connect to the Exchange server using a plaintext password "
+"with Basic authentication."
+
+#: ../src/camel/camel-ews-store.c:183
+#, c-format
+msgid "Session has no storage path"
+msgstr "Session has no storage path"
+
+#: ../src/camel/camel-ews-store.c:281
+#, c-format
+msgctxt "ForeignFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:525
+msgid "Authentication password not available"
+msgstr "Authentication password not available"
+
+#: ../src/camel/camel-ews-store.c:640
+msgid "Query for authentication types is not supported"
+msgstr "Query for authentication types is not supported"
+
+#: ../src/camel/camel-ews-store.c:692
+#, c-format
+msgid "No such folder: %s"
+msgstr "No such folder: %s"
+
+#: ../src/camel/camel-ews-store.c:839
+msgid ""
+"Cannot list folders available for subscription of Exchange Web Services "
+"account, use 'Subscribe to folder of other user' context menu option above "
+"the account node in the folder tree instead."
+msgstr ""
+"Cannot list folders available for subscription of Exchange Web Services "
+"account, use 'Subscribe to folder of other user' context menu option above "
+"the account node in the folder tree instead."
+
+#: ../src/camel/camel-ews-store.c:932
+#, c-format
+msgid "Cannot create folder '%s', folder already exists"
+msgstr "Cannot create folder '%s', folder already exists"
+
+#: ../src/camel/camel-ews-store.c:947
+#, c-format
+msgid "Parent folder %s does not exist"
+msgstr "Parent folder %s does not exist"
+
+#: ../src/camel/camel-ews-store.c:957
+#, c-format
+msgid ""
+"Cannot create folder under '%s', it is used for folders of other users only"
+msgstr ""
+"Cannot create folder under '%s', it is used for folders of other users only"
+
+#: ../src/camel/camel-ews-store.c:1026
+#, c-format
+msgid "Folder does not exist"
+msgstr "Folder does not exist"
+
+#: ../src/camel/camel-ews-store.c:1035
+#, c-format
+msgid "Cannot remove folder '%s', it is used for folders of other users only"
+msgstr "Cannot remove folder '%s', it is used for folders of other users only"
+
+#: ../src/camel/camel-ews-store.c:1142
+#, c-format
+msgid "Folder %s does not exist"
+msgstr "Folder %s does not exist"
+
+#: ../src/camel/camel-ews-store.c:1152
+#, c-format
+msgid "No change key record for folder %s"
+msgstr "No change key record for folder %s"
+
+#: ../src/camel/camel-ews-store.c:1194
+#, c-format
+msgid "Cannot both rename and move a folder at the same time"
+msgstr "Cannot both rename and move a folder at the same time"
+
+#: ../src/camel/camel-ews-store.c:1230
+#, c-format
+msgid "Cannot find folder ID for parent folder %s"
+msgstr "Cannot find folder ID for parent folder %s"
+
+#: ../src/camel/camel-ews-store.c:1280 ../src/camel/camel-ews-transport.c:69
+#, c-format
+msgid "Exchange server %s"
+msgstr "Exchange server %s"
+
+#: ../src/camel/camel-ews-store.c:1283
+#, c-format
+msgid "Exchange service for %s on %s"
+msgstr "Exchange service for %s on %s"
+
+#: ../src/camel/camel-ews-store.c:1327
+#, c-format
+msgid "Could not locate Trash folder"
+msgstr "Could not locate Trash folder"
+
+#: ../src/camel/camel-ews-store.c:1362
+#, c-format
+msgid "Could not locate Junk folder"
+msgstr "Could not locate Junk folder"
+
+#: ../src/camel/camel-ews-store.c:1440
+msgid "Cannot subscribe EWS folders in offline mode"
+msgstr "Cannot subscribe EWS folders in offline mode"
+
+#: ../src/camel/camel-ews-store.c:1462
+msgid "Cannot unsubscribe EWS folders in offline mode"
+msgstr "Cannot unsubscribe EWS folders in offline mode"
+
+#: ../src/camel/camel-ews-store.c:1504
+#, c-format
+msgid "You must be working online to complete this operation"
+msgstr "You must be working online to complete this operation"
+
+#: ../src/camel/camel-ews-transport.c:72
+#, c-format
+msgid "Exchange mail delivery via %s"
+msgstr "Exchange mail delivery via %s"
+
+#: ../src/camel/camel-ews-transport.c:120
+msgid "Cannot send message with no From address"
+msgstr "Cannot send message with no From address"
+
+#: ../src/camel/camel-ews-transport.c:126
+msgid "Exchange server cannot send message with multiple From addresses"
+msgstr "Exchange server cannot send message with multiple From addresses"
+
+#: ../src/camel/camel-ews-transport.c:137
+msgid "Failed to read From address"
+msgstr "Failed to read From address"
+
+#: ../src/camel/camel-ews-transport.c:149
+#, c-format
+msgid ""
+"Exchange server cannot send message as '%s', when the account was configured "
+"for address '%s'"
+msgstr ""
+"Exchange server cannot send message as '%s', when the account was configured "
+"for address '%s'"
+
+#: ../src/camel/camel-ews-transport.c:163
+#, c-format
+msgid "Service not connected"
+msgstr "Service not connected"
+
+#: ../src/collection/e-ews-backend.c:382
+#: ../src/configuration/e-mail-config-ews-gal.c:268
+msgid "Global Address List"
+msgstr "Global Address List"
+
+#: ../src/collection/e-ews-backend.c:767
+#, c-format
+msgid "Could not determine a suitable folder class for a new folder named '%s'"
+msgstr ""
+"Could not determine a suitable folder class for a new folder named '%s'"
+
+#: ../src/collection/e-ews-backend.c:858
+#, c-format
+msgid "Data source '%s' does not represent an Exchange Web Services folder"
+msgstr "Data source '%s' does not represent an Exchange Web Services folder"
+
+#: ../src/configuration/e-ews-config-utils.c:510
+#, c-format
+msgid "Cannot edit permissions of folder '%s', choose other folder."
+msgstr "Cannot edit permissions of folder '%s', choose other folder."
+
+#: ../src/configuration/e-ews-config-utils.c:588
+msgid "Subscribe to folder of other user..."
+msgstr "Subscribe to folder of other user…"
+
+#: ../src/configuration/e-ews-config-utils.c:597
+#: ../src/configuration/e-ews-config-utils.c:878
+#: ../src/configuration/e-ews-config-utils.c:909
+#: ../src/configuration/e-ews-config-utils.c:940
+#: ../src/configuration/e-ews-config-utils.c:971
+msgid "Permissions..."
+msgstr "Permissions…"
+
+#: ../src/configuration/e-ews-config-utils.c:599
+msgid "Edit EWS folder permissions"
+msgstr "Edit EWS folder permissions"
+
+#: ../src/configuration/e-ews-config-utils.c:880
+msgid "Edit EWS calendar permissions"
+msgstr "Edit EWS calendar permissions"
+
+#: ../src/configuration/e-ews-config-utils.c:911
+msgid "Edit EWS tasks permissions"
+msgstr "Edit EWS tasks permissions"
+
+#: ../src/configuration/e-ews-config-utils.c:942
+msgid "Edit EWS memos permissions"
+msgstr "Edit EWS memos permissions"
+
+#: ../src/configuration/e-ews-config-utils.c:973
+msgid "Edit EWS contacts permissions"
+msgstr "Edit EWS contacts permissions"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:87
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:502
+msgctxt "PermissionsLevel"
+msgid "None"
+msgstr "None"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:88
+msgctxt "PermissionsLevel"
+msgid "Owner"
+msgstr "Owner"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:98
+msgctxt "PermissionsLevel"
+msgid "Publishing Editor"
+msgstr "Publishing Editor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:107
+msgctxt "PermissionsLevel"
+msgid "Editor"
+msgstr "Editor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:115
+msgctxt "PermissionsLevel"
+msgid "Publishing Author"
+msgstr "Publishing Author"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:122
+msgctxt "PermissionsLevel"
+msgid "Author"
+msgstr "Author"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:128
+msgctxt "PermissionsLevel"
+msgid "Nonediting Author"
+msgstr "Nonediting Author"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:133
+msgctxt "PermissionsLevel"
+msgid "Reviewer"
+msgstr "Reviewer"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:136
+msgctxt "PermissionsLevel"
+msgid "Contributor"
+msgstr "Contributor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:139
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time"
+msgstr "Free/Busy time"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:141
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time, subject, location"
+msgstr "Free/Busy time, subject, location"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:143
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:523
+msgctxt "PermissionsLevel"
+msgid "Custom"
+msgstr "Custom"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:267
+msgid "Writing folder permissions, please wait..."
+msgstr "Writing folder permissions, please wait…"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:759
+msgctxt "User"
+msgid "Anonymous"
+msgstr "Anonymous"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:762
+msgctxt "User"
+msgid "Default"
+msgstr "Default"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:768
+msgctxt "User"
+msgid "Unknown"
+msgstr "Unknown"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:849
+#: ../src/configuration/e-ews-search-user.c:427
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1078
+msgid "Name"
+msgstr "Name"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:855
+msgid "Permission level"
+msgstr "Permission level"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:907
+msgid "Edit EWS folder permissions..."
+msgstr "Edit EWS folder permissions…"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:932
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:621
+msgid "Account:"
+msgstr "Account:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:960
+msgid "Folder name:"
+msgstr "Folder name:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:983
+msgid "Folder ID:"
+msgstr "Folder ID:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1047
+msgid "Permissions"
+msgstr "Permissions"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1069
+msgid "Permi_ssion level:"
+msgstr "Permi_ssion level:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1103
+msgctxt "Permissions"
+msgid "Read"
+msgstr "Read"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1115
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1182
+msgctxt "Permissions"
+msgid "None"
+msgstr "None"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1121
+msgctxt "Permissions"
+msgid "Free/Busy time"
+msgstr "Free/Busy time"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1126
+msgctxt "Permissions"
+msgid "Free/Busy time, subject, location"
+msgstr "Free/Busy time, subject, location"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1132
+msgctxt "Permissions"
+msgid "Full Details"
+msgstr "Full Details"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1138
+msgctxt "Permissions"
+msgid "Write"
+msgstr "Write"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1150
+msgctxt "Permissions"
+msgid "Create items"
+msgstr "Create items"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1154
+msgctxt "Permissions"
+msgid "Create subfolders"
+msgstr "Create subfolders"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1158
+msgctxt "Permissions"
+msgid "Edit own"
+msgstr "Edit own"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1162
+msgctxt "Permissions"
+msgid "Edit all"
+msgstr "Edit all"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1170
+msgctxt "Permissions"
+msgid "Delete items"
+msgstr "Delete items"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1187
+msgctxt "Permissions"
+msgid "Own"
+msgstr "Own"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1192
+msgctxt "Permissions"
+msgid "All"
+msgstr "All"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1198
+msgctxt "Permissions"
+msgid "Other"
+msgstr "Other"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1210
+msgctxt "Permissions"
+msgid "Folder owner"
+msgstr "Folder owner"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1214
+msgctxt "Permissions"
+msgid "Folder contact"
+msgstr "Folder contact"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1218
+msgctxt "Permissions"
+msgid "Folder visible"
+msgstr "Folder visible"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1291
+msgid "Reading folder permissions, please wait..."
+msgstr "Reading folder permissions, please wait…"
+
+#: ../src/configuration/e-ews-search-user.c:208
+#, c-format
+msgid "No users found, only one contact"
+msgid_plural "No users found, only %d contacts"
+msgstr[0] "No users found, only one contact"
+msgstr[1] "No users found, only %d contacts"
+
+#: ../src/configuration/e-ews-search-user.c:213
+msgid "No users found"
+msgstr "No users found"
+
+#: ../src/configuration/e-ews-search-user.c:217
+#, c-format
+msgid "Found one user"
+msgid_plural "Found %d users"
+msgstr[0] "Found one user"
+msgstr[1] "Found %d users"
+
+#: ../src/configuration/e-ews-search-user.c:223
+#, c-format
+msgid "Found more than 100 users, but showing only first %d"
+msgid_plural "Found more than 100 users, but showing only first %d"
+msgstr[0] "Found more than 100 users, but showing only first %d"
+msgstr[1] "Found more than 100 users, but showing only first %d"
+
+#: ../src/configuration/e-ews-search-user.c:353
+#: ../src/configuration/e-ews-search-user.c:536
+msgid "Search for a user"
+msgstr "Search for a user"
+
+#: ../src/configuration/e-ews-search-user.c:433
+msgid "E-mail"
+msgstr "E-mail"
+
+#: ../src/configuration/e-ews-search-user.c:470
+msgid "Choose EWS user..."
+msgstr "Choose EWS user…"
+
+#: ../src/configuration/e-ews-search-user.c:493
+msgid "_Search:"
+msgstr "_Search:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:96
+#: ../src/server/e-ews-folder.c:584
+#, c-format
+msgid "Cannot add folder, folder already exists as '%s'"
+msgstr "Cannot add folder, folder already exists as '%s'"
+
+#. Translators: The '%s' is replaced with user name, to whom the foreign mailbox belongs.
+#. * Example result: "Mailbox - John Smith"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:106
+#, c-format
+msgctxt "ForeignFolder"
+msgid "Mailbox - %s"
+msgstr "Mailbox - %s"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:264
+msgid "Cannot test foreign folder availability while in offline mode"
+msgstr "Cannot test foreign folder availability while in offline mode"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:289
+#, c-format
+msgid "User '%s' was not found on the server"
+msgstr "User '%s' was not found on the server"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:325
+#, c-format
+msgid "User name '%s' is ambiguous, specify it more precisely, please"
+msgstr "User name '%s' is ambiguous, specify it more precisely, please"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:347
+#, c-format
+msgid ""
+"Folder '%s' not found. Either it does not exist or you do not have "
+"permission to access it."
+msgstr ""
+"Folder '%s' not found. Either it does not exist or you do not have "
+"permission to access it."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:365
+msgid "Cannot add folder, cannot determine folder's type"
+msgstr "Cannot add folder, cannot determine folder's type"
+
+#. Translators: This is used to name foreign folder.
+#. * The first '%s' is replaced with user name to whom the folder belongs,
+#. * the second '%s' is replaced with folder name.
+#. * Example result: "John Smith - Calendar"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:410
+#, c-format
+msgctxt "ForeignFolder"
+msgid "%s - %s"
+msgstr "%s - %s"
+
+#. convert well-known names to their non-localized form
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:500
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:706
+msgid "Inbox"
+msgstr "Inbox"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:502
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:707
+msgid "Contacts"
+msgstr "Contacts"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:504
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:708
+msgid "Calendar"
+msgstr "Calendar"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:506
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:709
+msgid "Memos"
+msgstr "Memos"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:508
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:710
+msgid "Tasks"
+msgstr "Tasks"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:524
+#, c-format
+msgid "Testing availability of folder '%s' of user '%s', please wait..."
+msgstr "Testing availability of folder '%s' of user '%s', please wait…"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:600
+msgid "Subscribe to folder of other EWS user..."
+msgstr "Subscribe to folder of other EWS user…"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:651
+msgid "User"
+msgstr "User"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:658
+msgid "_User:"
+msgstr "_User:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:673
+msgid "C_hoose..."
+msgstr "C_hoose…"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:689
+msgid "_Folder name:"
+msgstr "_Folder name:"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:126
+msgid "Querying Autodiscover service"
+msgstr "Querying Autodiscover service"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:209
+msgid "Fetch _URL"
+msgstr "Fetch _URL"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:109
+msgid "Configuration"
+msgstr "Configuration"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:127
+msgid "User_name:"
+msgstr "User_name:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:141
+msgid "_Host URL:"
+msgstr "_Host URL:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:160
+msgid "OAB U_RL:"
+msgstr "OAB U_RL:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:174
+msgid "Authentication"
+msgstr "Authentication"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:215
+msgid "Locating offline address books"
+msgstr "Locating offline address books"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:295
+msgid "Cache o_ffline address book"
+msgstr "Cache o_ffline address book"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:321
+msgid "Select ad_dress list:"
+msgstr "Select ad_dress list:"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:345
+msgid "Fetch List"
+msgstr "Fetch List"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:503
+msgctxt "PermissionsLevel"
+msgid "Reviewer (can read items)"
+msgstr "Reviewer (can read items)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:504
+msgctxt "PermissionsLevel"
+msgid "Author (can read and create items)"
+msgstr "Author (can read and create items)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:505
+msgctxt "PermissionsLevel"
+msgid "Editor (can read, create and modify items)"
+msgstr "Editor (can read, create and modify items)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:608
+msgid "Delegate permissions"
+msgstr "Delegate permissions"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:626
+msgid "C_alendar"
+msgstr "C_alendar"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:629
+msgid "_Delegate receives copies of meeting-related messages sent to me"
+msgstr "_Delegate receives copies of meeting-related messages sent to me"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:634
+msgid "_Tasks"
+msgstr "_Tasks"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:637
+msgid "_Inbox"
+msgstr "_Inbox"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:640
+msgid "C_ontacts"
+msgstr "C_ontacts"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:643
+msgid "_Notes"
+msgstr "_Notes"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:646
+msgid "_Journal"
+msgstr "_Journal"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:649
+#, c-format
+msgid "Delegate '%s' has the following permissions"
+msgstr "Delegate '%s' has the following permissions"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:667
+msgid "Delegate can see my _private items"
+msgstr "Delegate can see my _private items"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:990
+msgid "Retrieving current user permissions, please wait..."
+msgstr "Retrieving current user permissions, please wait…"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1111
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1641
+msgid "Delegates"
+msgstr "Delegates"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1135
+msgid ""
+"Delegates can send items on your behalf, including creating and responding "
+"to meeting requests. If you want to grant folder permissions without giving "
+"send-on-behalf-of permissions, close this dialog box, right-click the "
+"folder, click Permissions and change the options there."
+msgstr ""
+"Delegates can send items on your behalf, including creating and responding "
+"to meeting requests. If you want to grant folder permissions without giving "
+"send-on-behalf-of permissions, close this dialogue box, right-click the "
+"folder, click Permissions and change the options there."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1184
+msgid ""
+"Deliver meeting requests addressed to me and responses to meeting requests "
+"where I am the organizer to:"
+msgstr ""
+"Deliver meeting requests addressed to me and responses to meeting requests "
+"where I am the organiser to:"
+
+#. new-line break, because GtkRadioButton doesn't allow wrapping of the inner label
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1193
+msgid ""
+"My delegates only, but _send a copy of meeting requests\n"
+"and responses to me (recommended)"
+msgstr ""
+"My delegates only, but _send a copy of meeting requests\n"
+"and responses to me (recommended)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1200
+msgid "My d_elegates only"
+msgstr "My d_elegates only"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1207
+msgid "My delegates a_nd me"
+msgstr "My delegates a_nd me"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1716
+msgid "Retrieving \"Delegates\" settings"
+msgstr "Retrieving \"Delegates\" settings"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:446
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:925
+msgid "Out of Office"
+msgstr "Out of Office"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:462
+msgid ""
+"The messages specified below will be automatically sent to each internal and "
+"external person who sends a mail to you."
+msgstr ""
+"The messages specified below will be automatically sent to each internal and "
+"external person who sends a mail to you."
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:470
+msgid "Do _not send Out of Office replies"
+msgstr "Do _not send Out of Office replies"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:478
+msgid "_Send Out of Office replies"
+msgstr "_Send Out of Office replies"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:486
+msgid "Send Out of Office replies only _during this time period:"
+msgstr "Send Out of Office replies only _during this time period:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:506
+msgid "_From:"
+msgstr "_From:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:531
+msgid "_To:"
+msgstr "_To:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:556
+msgid "I_nternal:"
+msgstr "I_nternal:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:565
+msgid "Message to be sent within the organization"
+msgstr "Message to be sent within the organisation"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:592
+msgid "E_xternal:"
+msgstr "E_xternal:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:600
+msgid "Message to be sent outside the organization"
+msgstr "Message to be sent outside the organisation"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:610
+msgid "Do not reply to senders outside the organization"
+msgstr "Do not reply to senders outside the organisation"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:613
+msgid "Reply only to known senders outside the organization"
+msgstr "Reply only to known senders outside the organisation"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:616
+msgid "Reply to any sender outside the organization"
+msgstr "Reply to any sender outside the organisation"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:1001
+msgid "Retrieving \"Out of Office\" settings"
+msgstr "Retrieving \"Out of Office\" settings"
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:1
+msgid "Autodiscovery query failed."
+msgstr "Autodiscovery query failed."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:2
+msgid "The reported error was &quot;{0}&quot;."
+msgstr "The reported error was &quot;{0}&quot;."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:3
+msgid "Failed to locate offline address books."
+msgstr "Failed to locate offline address books."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:4
+msgid "Failed to retrieve &quot;Out of Office&quot; settings."
+msgstr "Failed to retrieve &quot;Out of Office&quot; settings."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:5
+msgid "Failed to retrieve &quot;Delegates&quot; settings."
+msgstr "Failed to retrieve &quot;Delegates&quot; settings."
+
+#: ../src/server/e-ews-connection.c:488
+msgid "Operation Cancelled"
+msgstr "Operation Cancelled"
+
+#: ../src/server/e-ews-connection.c:557
+msgid "Authentication failed"
+msgstr "Authentication failed"
+
+#: ../src/server/e-ews-connection.c:568
+#, c-format
+msgid "No response: %s"
+msgstr "No response: %s"
+
+#: ../src/server/e-ews-connection.c:1852
+#, c-format
+msgid "Failed to parse autodiscover response XML"
+msgstr "Failed to parse autodiscover response XML"
+
+#: ../src/server/e-ews-connection.c:1859
+#, c-format
+msgid "Failed to find <Autodiscover> element"
+msgstr "Failed to find <Autodiscover> element"
+
+#: ../src/server/e-ews-connection.c:1870
+#, c-format
+msgid "Failed to find <Response> element"
+msgstr "Failed to find <Response> element"
+
+#: ../src/server/e-ews-connection.c:1881
+#, c-format
+msgid "Failed to find <Account> element"
+msgstr "Failed to find <Account> element"
+
+#: ../src/server/e-ews-connection.c:1900
+#, c-format
+msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
+msgstr "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
+
+#: ../src/server/e-ews-connection.c:1980
+msgid "URL cannot be NULL"
+msgstr "URL cannot be NULL"
+
+#: ../src/server/e-ews-connection.c:1987
+#, c-format
+msgid "URL '%s' is not valid"
+msgstr "URL '%s' is not valid"
+
+#: ../src/server/e-ews-connection.c:2089
+msgid "Email address is missing a domain part"
+msgstr "Email address is missing a domain part"
+
+#: ../src/server/e-ews-connection.c:2359
+msgid "Failed to parse oab XML"
+msgstr "Failed to parse oab XML"
+
+#: ../src/server/e-ews-connection.c:2367
+msgid "Failed to find <OAB> element\n"
+msgstr "Failed to find <OAB> element\n"
+
+#: ../src/server/e-ews-connection.c:3509
+msgid "No items found"
+msgstr "No items found"
+
+#: ../src/server/e-ews-folder.c:539
+msgid "Cannot add folder, unsupported folder type"
+msgstr "Cannot add folder, unsupported folder type"
+
+#: ../src/server/e-ews-folder.c:544
+msgid "Cannot add folder, master source not found"
+msgstr "Cannot add folder, master source not found"
+
+#: ../src/utils/ews-camel-common.c:176
+#, c-format
+msgid "CreateItem call failed to return ID for new message"
+msgstr "CreateItem call failed to return ID for new message"
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/es.po evolution-ews.sync-with-3.8.2/po/es.po
--- evolution-ews.git-gnome-3-0/po/es.po	2013-05-17 14:36:16.327453615 +0200
+++ evolution-ews.sync-with-3.8.2/po/es.po	2013-05-29 08:46:45.649863705 +0200
@@ -1,152 +1,108 @@
-# Spanish translation for evolution-ews.
-# Copyright (C) 2011 evolution-ews's COPYRIGHT HOLDER
-# This file is distributed under the same license as the evolution-ews package.
-# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
-# Daniel Mustieles <daniel.mustieles@gmail.com>, 2011.
+# Spanish translation for evolution-ews.
+# Copyright (C) 2011 evolution-ews's COPYRIGHT HOLDER
+# This file is distributed under the same license as the evolution-ews package.
+# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
+# Nicolás Satragno <nicoymatu9@hotmail.com>, 2011.
+# 
+# 
+# Javier Mazorra Rodríguez <mazi.debian@gmail.com>, 2012.
+# Daniel Mustieles <daniel.mustieles@gmail.com>, 2011, 2012., 2013.
 #
 msgid ""
 msgstr ""
 "Project-Id-Version: evolution-ews master\n"
 "Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
 "product=evolution-ews&keywords=I18N+L10N&component=general\n"
-"POT-Creation-Date: 2011-10-10 07:51+0000\n"
-"PO-Revision-Date: 2011-10-13 11:28+0200\n"
+"POT-Creation-Date: 2013-01-17 11:11+0000\n"
+"PO-Revision-Date: 2013-01-18 10:33+0100\n"
 "Last-Translator: Daniel Mustieles <daniel.mustieles@gmail.com>\n"
 "Language-Team: Español <gnome-es-list@gnome.org>\n"
+"Language: \n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
-"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+"Plural-Forms: nplurals=2; plural=(n!=1);\n"
+"X-Generator: Gtranslator 2.91.5\n"
 
-#: ../src/account-setup-eplugin/exchange-ews-account-listener.c:247
-msgid "Global Address list"
-msgstr "Lista global de direcciones"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:114
-#, c-format
-msgid "Autodiscover failed: %s"
-msgstr ""
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:149
-#, c-format
-msgid "Enter Password for %s"
-msgstr "Introduzca la contraseña para %s"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:158
-msgid "Could not get password."
-msgstr "No se pudo obtener la contraseña."
-
-#. OAB url entry
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:262
-msgid "OAB U_RL:"
-msgstr ""
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:274
-msgid "_Host URL:"
-msgstr ""
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:287
-msgid "Fetch _URL"
-msgstr ""
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:453
-msgid "Could not fetch oal list: "
-msgstr ""
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:495
-msgid "Fetching..."
-msgstr ""
-
-#. Add cache check box
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:632
-msgid "Cache o_ffline address book"
-msgstr ""
-
-#. Add label
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:638
-msgid "Select Ad_dress list: "
-msgstr ""
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:648
-msgid "Fetch _list"
-msgstr ""
-
-#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:1
-#: ../src/camel/camel-ews-provider.c:69
-msgid "Exchange Web Services"
-msgstr ""
-
-#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:2
-msgid "Exchange Web Services Plugin"
-msgstr ""
-
-#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:3
-msgid "GAL settings"
-msgstr "Configuración de GAL"
+#: ../src/addressbook/e-book-backend-ews.c:969
+msgid "The backend does not support bulk additions"
+msgstr "El «backend» no soporta adiciones"
+
+#: ../src/addressbook/e-book-backend-ews.c:1253
+msgid "The backend does not support bulk modifications"
+msgstr "El «backend» no soporta modificaciones"
 
 #: ../src/addressbook/e-book-backend-ews.c:1436
+msgid "Wait till syncing is done"
+msgstr "Esperar a que termine la sincronización"
+
+#: ../src/addressbook/e-book-backend-ews.c:1775
 #, c-format
 msgid "Downloading contacts in %s %d%% completed... "
-msgstr ""
+msgstr "Descarga de contactos en %s %d%% completada… "
 
-#: ../src/addressbook/e-book-backend-ews.c:1826
+#: ../src/addressbook/e-book-backend-ews.c:2324
 msgid "Syncing contacts..."
 msgstr "Sincronizando contactos…"
 
-#: ../src/addressbook/e-book-backend-ews.c:2023
+#: ../src/addressbook/e-book-backend-ews.c:2548
+#: ../src/configuration/e-ews-search-user.c:364
 msgid "Searching..."
 msgstr "Buscando…"
 
-#: ../src/addressbook/e-book-backend-sqlitedb.c:470
-#, c-format
-msgid "Insufficient memory"
-msgstr "Memoria insuficiente"
-
-#: ../src/calendar/e-cal-backend-ews.c:3793
-#, c-format
-msgid "Unknown calendar property '%s'"
-msgstr ""
+#: ../src/calendar/e-cal-backend-ews.c:1001
+msgid "EWS does not support bulk removals"
+msgstr "EWS no soporta eliminaciones"
+
+#: ../src/calendar/e-cal-backend-ews.c:1644
+msgid "EWS does not support bulk additions"
+msgstr "EWS no soporta adiciones"
+
+#: ../src/calendar/e-cal-backend-ews.c:2223
+msgid "EWS does not support bulk modifications"
+msgstr "EWS no soporta modificaciones"
 
-#: ../src/camel/camel-ews-folder.c:200
+#: ../src/camel/camel-ews-folder.c:267
 #, c-format
 msgid "Unable to open mimecontent temporary file!"
-msgstr ""
+msgstr "No se pudo abrir el archivo temporal de contenido MIME."
 
-#: ../src/camel/camel-ews-folder.c:207
+#: ../src/camel/camel-ews-folder.c:275
 #, c-format
 msgid "Unable to generate parser from mimecontent!"
-msgstr ""
+msgstr "No se pudo generar analizador desde el contenido MIME."
 
-#: ../src/camel/camel-ews-folder.c:215
+#: ../src/camel/camel-ews-folder.c:284
 #, c-format
 msgid "Unable to parse meeting request mimecontent!"
-msgstr ""
+msgstr "No se pudo analizar el contenido MIME de la petición de encuentro."
 
-#: ../src/camel/camel-ews-folder.c:272
+#: ../src/camel/camel-ews-folder.c:344
 #, c-format
 msgid "Unable to create cache file"
-msgstr ""
+msgstr "No se pudo crear el archivo de la caché"
 
-#: ../src/camel/camel-ews-folder.c:372 ../src/camel/camel-ews-folder.c:441
+#: ../src/camel/camel-ews-folder.c:449 ../src/camel/camel-ews-folder.c:529
 #, c-format
 msgid "Unable to create cache path"
-msgstr ""
+msgstr "No se pudo crear la ruta de la caché"
 
-#: ../src/camel/camel-ews-folder.c:450
+#: ../src/camel/camel-ews-folder.c:539
 #, c-format
 msgid "Failed to move message cache file"
-msgstr ""
+msgstr "Falló al mover el archivo de la caché de mensajes"
 
-#: ../src/camel/camel-ews-folder.c:798
+#: ../src/camel/camel-ews-folder.c:1186
 #, c-format
 msgid "Could not load summary for %s"
 msgstr "No se pudo cargar el resumen para %s"
 
-#: ../src/camel/camel-ews-folder.c:1124 ../src/camel/camel-ews-store.c:575
-#: ../src/camel/camel-ews-store.c:632 ../src/camel/camel-ews-store.c:701
+#: ../src/camel/camel-ews-folder.c:1622
 #, c-format
 msgid "Cant perform actions on the folder while in offline mode"
 msgstr ""
+"No se pueden realizar las acciones sobre la carpeta estando en modo "
+"desconectado"
 
 #: ../src/camel/camel-ews-provider.c:48
 msgid "Checking for new mail"
@@ -163,169 +119,1090 @@ msgstr "Opciones"
 #: ../src/camel/camel-ews-provider.c:55
 msgid "_Apply filters to new messages in Inbox on this server"
 msgstr ""
+"_Aplicar filtros a los mensajes nuevos de la Bandeja de entrada en este "
+"servidor"
 
 #: ../src/camel/camel-ews-provider.c:57
-msgid "Check new messages for Jun_k contents"
-msgstr ""
+msgid "Check new messages for _Junk contents"
+msgstr "Comprobar si el contenido de los mensajes nuevos es _spam"
 
 #: ../src/camel/camel-ews-provider.c:59
 msgid "Only check for Junk messages in the IN_BOX folder"
-msgstr ""
+msgstr "Sólo verificar spam en la carpeta _Bandeja de entrada"
 
 #: ../src/camel/camel-ews-provider.c:61
 msgid "Automatically synchroni_ze remote mail locally"
-msgstr ""
+msgstr "Sincroni_zar automáticamente el correo remoto de manera local"
+
+#: ../src/camel/camel-ews-provider.c:64
+msgid "Connection"
+msgstr "Conexión"
 
-#: ../src/camel/camel-ews-provider.c:71
+#. Translators: '%s' is preplaced with a widget, where "
+#. * user can select how long the timeout should be.
+#: ../src/camel/camel-ews-provider.c:68
+#, c-format
+msgid "Connection _timeout (in seconds) %s"
+msgstr "_Tiempo de espera (en segundos) de la conexión %s"
+
+#: ../src/camel/camel-ews-provider.c:76
+msgid "Exchange Web Services"
+msgstr "Servicios web Exchange"
+
+#: ../src/camel/camel-ews-provider.c:78
 msgid "For accessing Exchange servers using Web Services"
 msgstr "Para acceder a servidores Exchange usando servicios web"
 
-#: ../src/camel/camel-ews-provider.c:87
-msgid "Password"
-msgstr "Contraseña"
+#: ../src/camel/camel-ews-provider.c:93
+msgid "NTLM"
+msgstr "NTLM"
+
+#: ../src/camel/camel-ews-provider.c:95
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with NTLM authentication."
+msgstr ""
+"Esta opción conectará al servidor de Exchange usando una contraseña de texto "
+"plano con autenticación NTLM."
+
+#: ../src/camel/camel-ews-provider.c:103
+msgid "Basic"
+msgstr "Básica"
 
-#: ../src/camel/camel-ews-provider.c:89
+#: ../src/camel/camel-ews-provider.c:105
 msgid ""
-"This option will connect to the Exchange server using a plaintext password."
+"This option will connect to the Exchange server using a plaintext password "
+"with Basic authentication."
 msgstr ""
-"Esta opción conectará al servidor de Exchange unsado una contraseña de texto "
-"plano."
+"Esta opción conectará al servidor de Exchange usando una contraseña de texto "
+"plano con autenticación básica."
 
-#: ../src/camel/camel-ews-store.c:174
+#: ../src/camel/camel-ews-store.c:189
 #, c-format
 msgid "Session has no storage path"
-msgstr ""
+msgstr "La sesión no tiene ruta de almacenamiento"
 
-#: ../src/camel/camel-ews-store.c:184
+#: ../src/camel/camel-ews-store.c:226
 #, c-format
-msgid "EWS service has no host URL"
-msgstr ""
+#| msgctxt "ForeignFolders"
+#| msgid "%s_%d"
+msgctxt "PublicFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:355
+#, c-format
+msgctxt "ForeignFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:678
+msgid "Updating foreign folder structure"
+msgstr "Actualizando la estructura de carpetas externas"
 
-#: ../src/camel/camel-ews-store.c:359
+#: ../src/camel/camel-ews-store.c:957
+msgid "Authentication password not available"
+msgstr "Autenticación de contraseña no disponible"
+
+#: ../src/camel/camel-ews-store.c:1109
+msgid "Query for authentication types is not supported"
+msgstr "La petición de tipos de autenticación no está soportada"
+
+#: ../src/camel/camel-ews-store.c:1161
 #, c-format
 msgid "No such folder: %s"
 msgstr "No existe la carpeta: %s"
 
-#: ../src/camel/camel-ews-store.c:568
+#: ../src/camel/camel-ews-store.c:1472
+#| msgid "Cannot subscribe EWS folders in offline mode"
+msgid "Cannot list EWS public folders in offline mode"
+msgstr "No se pueden listar las carpetas EWS en modo desconectado"
+
+#: ../src/camel/camel-ews-store.c:1545
+#| msgid "No such folder: %s"
+msgid "Cannot find any EWS public folders"
+msgstr "No se puede encontrar ninguna carpeta EWS pública"
+
+#: ../src/camel/camel-ews-store.c:1650
+#, c-format
+msgid "Cannot create folder '%s', folder already exists"
+msgstr "No se puede crear la carpeta «%s», la carpeta ya existe"
+
+#: ../src/camel/camel-ews-store.c:1665
 #, c-format
 msgid "Parent folder %s does not exist"
 msgstr "La carpeta padre %s no existe"
 
-#: ../src/camel/camel-ews-store.c:626
+#: ../src/camel/camel-ews-store.c:1675
+#, c-format
+msgid ""
+"Cannot create folder under '%s', it is used for folders of other users only"
+msgstr ""
+"No se puede crear la carpeta bajo «%s», sólo la usan carpetas de otros "
+"usuarios"
+
+#: ../src/camel/camel-ews-store.c:1685
+#, c-format
+#| msgid ""
+#| "Cannot create folder under '%s', it is used for folders of other users "
+#| "only"
+msgid "Cannot create folder under '%s', it is used for public folders only"
+msgstr ""
+"No se puede crear la carpeta bajo «%s», se usa sólo para carpetas públicas"
+
+#: ../src/camel/camel-ews-store.c:1754
 #, c-format
 msgid "Folder does not exist"
 msgstr "La carpeta no existe"
 
-#: ../src/camel/camel-ews-store.c:709
+#: ../src/camel/camel-ews-store.c:1763
+#, c-format
+msgid "Cannot remove folder '%s', it is used for folders of other users only"
+msgstr ""
+"No se puede eliminar la carpeta «%s», sólo la usan carpetas de otros usuarios"
+
+#: ../src/camel/camel-ews-store.c:1773
+#, c-format
+#| msgid ""
+#| "Cannot remove folder '%s', it is used for folders of other users only"
+msgid "Cannot remove folder '%s', it is used for public folders only"
+msgstr "No se puede quitar la carpeta «%s», se usa sólo para carpetas públicas"
+
+#: ../src/camel/camel-ews-store.c:1881
 #, c-format
 msgid "Folder %s does not exist"
 msgstr "La carpeta %s no existe"
 
-#: ../src/camel/camel-ews-store.c:718
+#: ../src/camel/camel-ews-store.c:1891
 #, c-format
 msgid "No change key record for folder %s"
-msgstr ""
+msgstr "No hay cambios en registros clave de la carpeta %s"
 
-#: ../src/camel/camel-ews-store.c:757
+#: ../src/camel/camel-ews-store.c:1933
 #, c-format
 msgid "Cannot both rename and move a folder at the same time"
 msgstr "No se puede renombrar y mover una carpeta al mismo tiempo"
 
-#: ../src/camel/camel-ews-store.c:788
+#: ../src/camel/camel-ews-store.c:1969
 #, c-format
 msgid "Cannot find folder ID for parent folder %s"
-msgstr ""
+msgstr "No se puede encontrar el ID de carpeta para la carpeta padre %s"
 
-#: ../src/camel/camel-ews-store.c:817 ../src/camel/camel-ews-transport.c:61
+#: ../src/camel/camel-ews-store.c:2019 ../src/camel/camel-ews-transport.c:69
 #, c-format
 msgid "Exchange server %s"
-msgstr ""
+msgstr "Servidor Exchange %s"
 
-#: ../src/camel/camel-ews-store.c:819
+#: ../src/camel/camel-ews-store.c:2022
 #, c-format
 msgid "Exchange service for %s on %s"
+msgstr "Servicio Exchange para %s en %s"
+
+#: ../src/camel/camel-ews-store.c:2066
+#, c-format
+msgid "Could not locate Trash folder"
+msgstr "No se pudo localizar la carpeta de la Papelera"
+
+#: ../src/camel/camel-ews-store.c:2101
+#, c-format
+msgid "Could not locate Junk folder"
+msgstr "No se puedo encontrar la carpeta de Correo no deseado"
+
+#: ../src/camel/camel-ews-store.c:2291
+msgid "Cannot subscribe EWS folders in offline mode"
+msgstr "No se puede suscribir a las carpetas EWS en modo desconectado"
+
+#: ../src/camel/camel-ews-store.c:2309
+#, c-format
+#| msgid "Cannot create folder '%s', folder already exists"
+msgid "Cannot subscribe folder '%s', no public folder available"
 msgstr ""
+"No se puede suscribir a la carpeta «%s», no hay ninguna carpeta pública "
+"disponible"
+
+#: ../src/camel/camel-ews-store.c:2319
+#, c-format
+#| msgid "No such folder: %s"
+msgid "Cannot subscribe folder '%s', folder not found"
+msgstr "No se puede suscribir a la carpeta «%s», no se ha encontrado la carpeta"
+
+#: ../src/camel/camel-ews-store.c:2409
+msgid "Cannot unsubscribe EWS folders in offline mode"
+msgstr "No se puede desuscribir de las carpetas EWS en modo desconectado"
 
-#: ../src/camel/camel-ews-store.c:856
+#: ../src/camel/camel-ews-store.c:2525
 #, c-format
 msgid "You must be working online to complete this operation"
 msgstr "Debe estar conectado para completar esta operación"
 
-#: ../src/camel/camel-ews-transport.c:65
+#: ../src/camel/camel-ews-transport.c:72
 #, c-format
 msgid "Exchange mail delivery via %s"
+msgstr "Correo Exchange entregado por %s"
+
+#: ../src/camel/camel-ews-transport.c:119
+msgid "Cannot send message with no From address"
+msgstr "No se puede enviar un mensaje sin una dirección en «Para»"
+
+#: ../src/camel/camel-ews-transport.c:125
+msgid "Exchange server cannot send message with multiple From addresses"
 msgstr ""
+"El servidor Exchange no puede enviar un mensaje con varias direcciones «Para»"
 
-#: ../src/camel/camel-ews-transport.c:92
+#: ../src/camel/camel-ews-transport.c:136
+msgid "Failed to read From address"
+msgstr "Falló al la dirección «Para»"
+
+#: ../src/camel/camel-ews-transport.c:148
+#, c-format
+msgid ""
+"Exchange server cannot send message as '%s', when the account was configured "
+"for address '%s'"
+msgstr ""
+"El servidor Exchange no puede enviar un mensaje como «%s», cuando la cuenta "
+"se ha configurado para la dirección «%s»"
+
+#: ../src/camel/camel-ews-transport.c:162
 #, c-format
 msgid "Service not connected"
 msgstr "Servicio no conectado"
 
-#: ../src/server/e-ews-connection.c:354
+#: ../src/collection/e-ews-backend.c:406
+#: ../src/configuration/e-mail-config-ews-gal.c:274
+msgid "Global Address List"
+msgstr "Lista global de direcciones"
+
+#: ../src/collection/e-ews-backend.c:793
+#, c-format
+msgid "Could not determine a suitable folder class for a new folder named '%s'"
+msgstr ""
+"No se pudo determinar una clase de carpeta apropiada para una nueva carpeta "
+"llamada «%s»"
+
+#: ../src/collection/e-ews-backend.c:882
+#, c-format
+msgid "Data source '%s' does not represent an Exchange Web Services folder"
+msgstr ""
+"El origen de los datos «%s» no representa una carpeta de servicios web de "
+"Exchange"
+
+#: ../src/configuration/e-ews-config-utils.c:511
+#, c-format
+msgid "Cannot edit permissions of folder '%s', choose other folder."
+msgstr ""
+"No se pueden editar los permisos de la carpeta «%s», elija otra carpeta."
+
+#: ../src/configuration/e-ews-config-utils.c:589
+msgid "Subscribe to folder of other user..."
+msgstr "Suscribirse a la carpeta de otro usuario…"
+
+#: ../src/configuration/e-ews-config-utils.c:598
+#: ../src/configuration/e-ews-config-utils.c:879
+#: ../src/configuration/e-ews-config-utils.c:910
+#: ../src/configuration/e-ews-config-utils.c:941
+#: ../src/configuration/e-ews-config-utils.c:972
+msgid "Permissions..."
+msgstr "Permisos…"
+
+#: ../src/configuration/e-ews-config-utils.c:600
+msgid "Edit EWS folder permissions"
+msgstr "Editar permisos de la carpeta EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:881
+msgid "Edit EWS calendar permissions"
+msgstr "Editar permisos del calendario EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:912
+msgid "Edit EWS tasks permissions"
+msgstr "Editar permisos de las tareas EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:943
+msgid "Edit EWS memos permissions"
+msgstr "Editar permisos de notas EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:974
+msgid "Edit EWS contacts permissions"
+msgstr "Editar permisos de contactos EWS"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:87
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:499
+msgctxt "PermissionsLevel"
+msgid "None"
+msgstr "Nadie"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:88
+msgctxt "PermissionsLevel"
+msgid "Owner"
+msgstr "Propietario"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:98
+msgctxt "PermissionsLevel"
+msgid "Publishing Editor"
+msgstr "Editor de la publicación"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:107
+msgctxt "PermissionsLevel"
+msgid "Editor"
+msgstr "Editor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:115
+msgctxt "PermissionsLevel"
+msgid "Publishing Author"
+msgstr "Autor de la publicación"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:122
+msgctxt "PermissionsLevel"
+msgid "Author"
+msgstr "Autor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:128
+msgctxt "PermissionsLevel"
+msgid "Nonediting Author"
+msgstr "Autor no editor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:133
+msgctxt "PermissionsLevel"
+msgid "Reviewer"
+msgstr "Revisor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:136
+msgctxt "PermissionsLevel"
+msgid "Contributor"
+msgstr "Contribuidor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:139
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time"
+msgstr "Tiempo libre/ocupado"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:141
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time, subject, location"
+msgstr "Tiempo libre/ocupado, asunto, ubicación"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:143
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:520
+msgctxt "PermissionsLevel"
+msgid "Custom"
+msgstr "Personalizado"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:267
+msgid "Writing folder permissions, please wait..."
+msgstr "Escribiendo permisos de la carpeta, espere…"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:759
+msgctxt "User"
+msgid "Anonymous"
+msgstr "Anónimo"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:762
+msgctxt "User"
+msgid "Default"
+msgstr "Predeterminado"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:768
+msgctxt "User"
+msgid "Unknown"
+msgstr "Desconocido"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:849
+#: ../src/configuration/e-ews-search-user.c:430
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1075
+msgid "Name"
+msgstr "Nombre"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:855
+msgid "Permission level"
+msgstr "Nivel de permisos"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:907
+msgid "Edit EWS folder permissions..."
+msgstr "Editar permisos de la carpeta de EWS…"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:932
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:633
+msgid "Account:"
+msgstr "Cuenta"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:960
+msgid "Folder name:"
+msgstr "Nombre de carpeta:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:983
+msgid "Folder ID:"
+msgstr "ID de la carpeta:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1047
+msgid "Permissions"
+msgstr "Permisos"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1069
+msgid "Permi_ssion level:"
+msgstr "Nivel de permi_sos:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1103
+msgctxt "Permissions"
+msgid "Read"
+msgstr "Leer"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1115
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1182
+msgctxt "Permissions"
+msgid "None"
+msgstr "Nadie"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1121
+msgctxt "Permissions"
+msgid "Free/Busy time"
+msgstr "Tiempo libre/ocupado"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1126
+msgctxt "Permissions"
+msgid "Free/Busy time, subject, location"
+msgstr "Tiempo libre/ocupado, asunto, ubicación"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1132
+msgctxt "Permissions"
+msgid "Full Details"
+msgstr "Detalles completos"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1138
+msgctxt "Permissions"
+msgid "Write"
+msgstr "Escritura"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1150
+msgctxt "Permissions"
+msgid "Create items"
+msgstr "Crear elementos"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1154
+msgctxt "Permissions"
+msgid "Create subfolders"
+msgstr "Crear subcarpetas"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1158
+msgctxt "Permissions"
+msgid "Edit own"
+msgstr "Edición propia"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1162
+msgctxt "Permissions"
+msgid "Edit all"
+msgstr "Editar todo"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1170
+msgctxt "Permissions"
+msgid "Delete items"
+msgstr "Eliminar elementos"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1187
+msgctxt "Permissions"
+msgid "Own"
+msgstr "Propio"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1192
+msgctxt "Permissions"
+msgid "All"
+msgstr "Todos"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1198
+msgctxt "Permissions"
+msgid "Other"
+msgstr "Otro"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1210
+msgctxt "Permissions"
+msgid "Folder owner"
+msgstr "Propietario de la carpeta"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1214
+msgctxt "Permissions"
+msgid "Folder contact"
+msgstr "Contacto de la carpeta"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1218
+msgctxt "Permissions"
+msgid "Folder visible"
+msgstr "Carpeta visible"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1291
+msgid "Reading folder permissions, please wait..."
+msgstr "Leyendo permisos de la carpeta, espere…"
+
+#: ../src/configuration/e-ews-search-user.c:208
+#, c-format
+msgid "No users found, only one contact"
+msgid_plural "No users found, only %d contacts"
+msgstr[0] "No se encontraron usuarios, sólo un contacto"
+msgstr[1] "No se encontraron usuarios, sólo %d contactos"
+
+#: ../src/configuration/e-ews-search-user.c:213
+msgid "No users found"
+msgstr "No se encontraron usuarios"
+
+#: ../src/configuration/e-ews-search-user.c:217
+#, c-format
+msgid "Found one user"
+msgid_plural "Found %d users"
+msgstr[0] "Se encontró un usuario"
+msgstr[1] "Se encontraron %d usuarios"
+
+#: ../src/configuration/e-ews-search-user.c:223
+#, c-format
+msgid "Found more than 100 users, but showing only first %d"
+msgid_plural "Found more than 100 users, but showing only first %d"
+msgstr[0] ""
+"Se encontraron más de 100 usuarios, sin embargo se muestran sólo los %d "
+"primeros"
+msgstr[1] ""
+"Se encontraron más de 100 usuarios, sin embargo se muestran sólo los %d "
+"primeros"
+
+#: ../src/configuration/e-ews-search-user.c:356
+#: ../src/configuration/e-ews-search-user.c:539
+msgid "Search for a user"
+msgstr "Buscar un usuario"
+
+#: ../src/configuration/e-ews-search-user.c:436
+msgid "E-mail"
+msgstr "Correo-e"
+
+#: ../src/configuration/e-ews-search-user.c:473
+msgid "Choose EWS user..."
+msgstr "Elegir usuario EWS…"
+
+#: ../src/configuration/e-ews-search-user.c:496
+msgid "_Search:"
+msgstr "Bu_scar:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:97
+#: ../src/server/e-ews-folder.c:591
+#, c-format
+msgid "Cannot add folder, folder already exists as '%s'"
+msgstr "No se puede añadir la carpeta, la carpeta ya existe como «%s»"
+
+#. Translators: The '%s' is replaced with user name, to whom the foreign mailbox belongs.
+#. * Example result: "Mailbox - John Smith"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:107
+#, c-format
+msgctxt "ForeignFolder"
+msgid "Mailbox - %s"
+msgstr "Buzón - %s"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:272
+msgid "Cannot test foreign folder availability while in offline mode"
+msgstr ""
+"No se puede probar la disponibilidad de la carpeta externa en modo "
+"desconectado"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:297
+#, c-format
+msgid "User '%s' was not found on the server"
+msgstr "No se encontró el usuario «%s» en el servidor"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:333
+#, c-format
+msgid "User name '%s' is ambiguous, specify it more precisely, please"
+msgstr ""
+"El nombre de usuario «%s» es ambiguo, especifíquelo de forma más precisa"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:355
+#, c-format
+msgid ""
+"Folder '%s' not found. Either it does not exist or you do not have "
+"permission to access it."
+msgstr ""
+"No se encontró la carpeta «%s». O no existe o no tiene permiso para acceder a "
+"ella."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:373
+msgid "Cannot add folder, cannot determine folder's type"
+msgstr ""
+"No se puede añadir la carpeta, no se puede determinar el tipo de carpeta"
+
+#. Translators: This is used to name foreign folder.
+#. * The first '%s' is replaced with user name to whom the folder belongs,
+#. * the second '%s' is replaced with folder name.
+#. * Example result: "John Smith - Calendar"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:418
+#, c-format
+msgctxt "ForeignFolder"
+msgid "%s - %s"
+msgstr "%s - %s"
+
+#. convert well-known names to their non-localized form
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:511
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:718
+msgid "Inbox"
+msgstr "Bandeja de entrada"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:513
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:719
+msgid "Contacts"
+msgstr "Contactos"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:515
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:720
+msgid "Calendar"
+msgstr "Calendario"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:517
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:721
+msgid "Memos"
+msgstr "Notas"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:519
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:722
+msgid "Tasks"
+msgstr "Tareas"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:536
+#, c-format
+msgid "Testing availability of folder '%s' of user '%s', please wait..."
+msgstr "Probando la disponibilidad de la carpeta «%s» del usuario «%s», espere…"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:612
+msgid "Subscribe to folder of other EWS user..."
+msgstr "Suscribirse a la carpeta de otro usuario EWS…"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:663
+msgid "User"
+msgstr "Usuario"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:670
+msgid "_User:"
+msgstr "_Usuario:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:685
+msgid "C_hoose..."
+msgstr "E_legir…"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:701
+msgid "_Folder name:"
+msgstr "Nombre de la _carpeta:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:731
+msgid "Include _subfolders"
+msgstr "Incluir _subcarpetas"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:129
+msgid "Querying Autodiscover service"
+msgstr "Consultando servicio de autodetección"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:212
+msgid "Fetch _URL"
+msgstr "Obtener _URL"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:140
+msgid "Configuration"
+msgstr "Configuración"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:158
+msgid "User_name:"
+msgstr "Nombre de _usuario:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:172
+msgid "_Host URL:"
+msgstr "URL del _equipo:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:191
+msgid "OAB U_RL:"
+msgstr "U_RL OAB:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:205
+msgid "Open _Mailbox of other user"
+msgstr "Abrir la b_andeja de entrada de otro usuario"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:239
+msgid "S_earch..."
+msgstr "_Buscar…"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:250
+msgid "Authentication"
+msgstr "Autenticación"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:500
+msgctxt "PermissionsLevel"
+msgid "Reviewer (can read items)"
+msgstr "Revisor (puede leer elementos)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:501
+msgctxt "PermissionsLevel"
+msgid "Author (can read and create items)"
+msgstr "Autor (puede leer y crear elementos)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:502
+msgctxt "PermissionsLevel"
+msgid "Editor (can read, create and modify items)"
+msgstr "Editor (puede leer, crear y modificar elementos)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:605
+msgid "Delegate permissions"
+msgstr "Permisos de delegado"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:623
+msgid "C_alendar"
+msgstr "C_alendario"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:626
+msgid "_Delegate receives copies of meeting-related messages sent to me"
+msgstr ""
+"El _delegado recibe copias de los mensajes relacionados con la reunión que "
+"me envían"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:631
+msgid "_Tasks"
+msgstr "_Tareas"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:634
+msgid "_Inbox"
+msgstr "_Bandeja de entrada"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:637
+msgid "C_ontacts"
+msgstr "C_ontactos"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:640
+msgid "_Notes"
+msgstr "_Notas"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:643
+msgid "_Journal"
+msgstr "_Diario"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:646
+#, c-format
+msgid "Delegate '%s' has the following permissions"
+msgstr "El delegado «%s» tiene los siguientes permisos"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:664
+msgid "Delegate can see my _private items"
+msgstr "El delegado puede ver mis elementos _privados"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:987
+msgid "Retrieving current user permissions, please wait..."
+msgstr "Obteniendo los permisos actuales del usuario, espere…"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1108
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1638
+msgid "Delegates"
+msgstr "Delegados"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1132
+msgid ""
+"Delegates can send items on your behalf, including creating and responding "
+"to meeting requests. If you want to grant folder permissions without giving "
+"send-on-behalf-of permissions, close this dialog box, right-click the "
+"folder, click Permissions and change the options there."
+msgstr ""
+"Los delegados pueden enviar elementos en su nombre, incluyendo la creación y "
+"respuesta de solicitud de reuniones. Si desea conceder permisos de carpeta "
+"sin dar permisos de «enviar en nombre de», cierre este cuadro de diálogo, "
+"pulse con el botón derecho en la carpeta, pulse en Permisos y cambie las ahí "
+"opciones."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1181
+msgid ""
+"Deliver meeting requests addressed to me and responses to meeting requests "
+"where I am the organizer to:"
+msgstr ""
+"Entregar las solicitudes de reunión dirigidas a mí y las respuestas a las "
+"solicitudes de reunión donde yo soy el organizador:"
+
+#. new-line break, because GtkRadioButton doesn't allow wrapping of the inner label
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1190
+msgid ""
+"My delegates only, but _send a copy of meeting requests\n"
+"and responses to me (recommended)"
+msgstr ""
+"Sólo mis delegados, pero _enviar una copia de las peticiones de reunión\n"
+"y responderme (recomendado)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1197
+msgid "My d_elegates only"
+msgstr "Sólo mis _delegados "
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1204
+msgid "My delegates a_nd me"
+msgstr "Mis delegados _y yo"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1713
+msgid "Retrieving \"Delegates\" settings"
+msgstr "Obteniendo la configuración de «Delegados»"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:221
+msgid "Locating offline address books"
+msgstr "Buscando libretas de direcciones sin conexión"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:301
+msgid "Cache o_ffline address book"
+msgstr "Caché de libro de direcciones _sin conexión"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:327
+msgid "Select ad_dress list:"
+msgstr "Seleccionar lista de _direcciones:"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:351
+msgid "Fetch List"
+msgstr "Obtener lista"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:444
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:923
+msgid "Out of Office"
+msgstr "Fuera de la oficina"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:460
+msgid ""
+"The messages specified below will be automatically sent to each internal and "
+"external person who sends a mail to you."
+msgstr ""
+"Los mensajes especificados más abajo se enviarán a todo el personal interno "
+"y externo que le envíe un correo."
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:468
+msgid "Do _not send Out of Office replies"
+msgstr "_No enviar respuestas «Estoy fuera de la oficina»"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:476
+msgid "_Send Out of Office replies"
+msgstr "_Enviar respuestas «Estoy fuera de la oficina»"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:484
+msgid "Send Out of Office replies only _during this time period:"
+msgstr ""
+"_Enviar respuestas «Estoy fuera de la oficina» solo durante este período de "
+"tiempo:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:504
+msgid "_From:"
+msgstr "_De:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:529
+msgid "_To:"
+msgstr "_Para:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:554
+msgid "I_nternal:"
+msgstr "I_nterno:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:563
+msgid "Message to be sent within the organization"
+msgstr "Mensaje que enviar dentro de la organización"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:590
+msgid "E_xternal:"
+msgstr "E_xterno:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:598
+msgid "Message to be sent outside the organization"
+msgstr "Mensaje que enviar fuera de la organización"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:608
+msgid "Do not reply to senders outside the organization"
+msgstr "No responder a los remitentes fuera de la organización"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:611
+msgid "Reply only to known senders outside the organization"
+msgstr "Responder sólo a los remitentes fuera de la organización"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:614
+msgid "Reply to any sender outside the organization"
+msgstr "Responder a cualquier remitente fuera de la organización"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:999
+msgid "Retrieving \"Out of Office\" settings"
+msgstr "Obteniendo la configuración de «Estoy fuera de la oficina»"
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:1
+msgid "Autodiscovery query failed."
+msgstr "Falló la consulta de autodetección."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:2
+msgid "The reported error was &quot;{0}&quot;."
+msgstr "El error devuelto fue «{0}»."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:3
+msgid "Failed to locate offline address books."
+msgstr "Falló al buscar libretas de direcciones sin conexión."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:4
+msgid "Failed to retrieve &quot;Out of Office&quot; settings."
+msgstr "Falló al obtener la configuración de «Estoy fuera de la oficina»."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:5
+msgid "Failed to retrieve &quot;Delegates&quot; settings."
+msgstr "Falló al obtener la configuración de «Delegados»"
+
+#: ../src/server/e-ews-connection.c:493
 msgid "Operation Cancelled"
 msgstr "Operación cancelada"
 
-#: ../src/server/e-ews-connection.c:408
+#: ../src/server/e-ews-connection.c:562
 msgid "Authentication failed"
 msgstr "Falló la autenticación"
 
-#: ../src/server/e-ews-connection.c:416
+#: ../src/server/e-ews-connection.c:573
 #, c-format
 msgid "No response: %s"
 msgstr "Sin respuesta: %s"
 
-#: ../src/server/e-ews-connection.c:1072 ../src/server/e-ews-connection.c:1388
-#: ../src/server/e-ews-connection.c:1625
-#, c-format
-msgid "Code: %d - Unexpected response from server"
-msgstr ""
-
-#: ../src/server/e-ews-connection.c:1084
+#: ../src/server/e-ews-connection.c:1877
 #, c-format
 msgid "Failed to parse autodiscover response XML"
-msgstr ""
+msgstr "Falló al analizar la respuesta XML de la autodetección"
 
-#: ../src/server/e-ews-connection.c:1092
+#: ../src/server/e-ews-connection.c:1884
 #, c-format
-msgid "Failed to find <Autodiscover> element\n"
-msgstr "Falló al buscar el elemento <Autodiscover>\n"
+msgid "Failed to find <Autodiscover> element"
+msgstr "Falló al buscar el elemento <Autodiscover>"
 
-#: ../src/server/e-ews-connection.c:1104
+#: ../src/server/e-ews-connection.c:1895
 #, c-format
-msgid "Failed to find <Response> element\n"
-msgstr "Falló al buscar el elemento<Response>\n"
+msgid "Failed to find <Response> element"
+msgstr "Falló al buscar el elemento<Response>"
 
-#: ../src/server/e-ews-connection.c:1116
+#: ../src/server/e-ews-connection.c:1906
 #, c-format
-msgid "Failed to find <Account> element\n"
-msgstr ""
+msgid "Failed to find <Account> element"
+msgstr "Falló al buscar el elemento <Account>"
 
-#: ../src/server/e-ews-connection.c:1135
+#: ../src/server/e-ews-connection.c:1925
 #, c-format
 msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
-msgstr ""
+msgstr "Falló al buscar <ASUrl> y <OABUrl> en la respuesta de la autodetección"
 
-#: ../src/server/e-ews-connection.c:1231
-#, c-format
-msgid "Both email and password must be provided"
-msgstr "Se deben proporcionar el correo-e y la contraseña"
+#: ../src/server/e-ews-connection.c:2007
+msgid "URL cannot be NULL"
+msgstr "El URL no puede ser NULL"
 
-#: ../src/server/e-ews-connection.c:1238
+#: ../src/server/e-ews-connection.c:2015
 #, c-format
-msgid "Wrong email id"
-msgstr ""
+msgid "URL '%s' is not valid"
+msgstr "El URL «%s» no es válida"
 
-#: ../src/server/e-ews-connection.c:1398
-#, c-format
+#: ../src/server/e-ews-connection.c:2117
+msgid "Email address is missing a domain part"
+msgstr "Falta el dominio en la dirección de correo-e"
+
+#: ../src/server/e-ews-connection.c:2429
 msgid "Failed to parse oab XML"
-msgstr ""
+msgstr "Falló al analizar el XML oab"
 
-#: ../src/server/e-ews-connection.c:1405
-#, c-format
+#: ../src/server/e-ews-connection.c:2437
 msgid "Failed to find <OAB> element\n"
 msgstr "Falló al buscar el elemento <OAB>\n"
 
-#: ../src/utils/ews-camel-common.c:139
+#: ../src/server/e-ews-connection.c:3609
+msgid "No items found"
+msgstr "No se encontraron elementos"
+
+#: ../src/server/e-ews-folder.c:546
+msgid "Cannot add folder, unsupported folder type"
+msgstr "No se puede añadir la carpeta, tipo de carpeta no soportado"
+
+#: ../src/server/e-ews-folder.c:551
+msgid "Cannot add folder, master source not found"
+msgstr "No se puede añadir la carpeta, fuente principal no encontrada"
+
+#: ../src/utils/ews-camel-common.c:187
 #, c-format
 msgid "CreateItem call failed to return ID for new message"
-msgstr ""
+msgstr "CreateItem falló al devolver el ID para el mensaje nuevo"
+
+#~ msgid ""
+#~ "Cannot list folders available for subscription of Exchange Web Services "
+#~ "account, use 'Subscribe to folder of other user' context menu option "
+#~ "above the account node in the folder tree instead."
+#~ msgstr ""
+#~ "No se pueden listar las carpetas disponibles para suscripción de la "
+#~ "cuenta de servicios web de Exchange, utilice en su lugar la opción de "
+#~ "menú de contexto «Suscribir a una carpeta de otro usuario» encima del nodo "
+#~ "de cuenta en el árbol de carpetas."
+
+#~ msgid "Insufficient memory"
+#~ msgstr "Memoria insuficiente"
+
+#, fuzzy
+#~| msgctxt "PermissionsLevel"
+#~| msgid "Owner"
+#~ msgctxt "ForeignFolder"
+#~ msgid "Owner"
+#~ msgstr "Propietario"
+
+#, fuzzy
+#~| msgid "Folder %s does not exist"
+#~ msgid "Folder '%s' not found"
+#~ msgstr "La carpeta %s no existe"
+
+#~ msgid "Global Address list"
+#~ msgstr "Lista global de direcciones"
+
+#~ msgid "Cannot set Date-Time in Past"
+#~ msgstr "No se puede establecer una fecha/hora pasadas"
+
+#~ msgid "Select a valid time range"
+#~ msgstr "Seleccionar un rango de tiempo válido"
+
+#~ msgid ""
+#~ "The messages specified below will be automatically sent to \n"
+#~ " each internal and external personal who sends a mail to you."
+#~ msgstr ""
+#~ "Los mensajes que se especifican más abajo se enviarán a todo el personal "
+#~ "interno y externo que le envíe un correo."
+
+#~ msgid "Status:"
+#~ msgstr "Estado:"
+
+#~ msgid "I am _out of the office"
+#~ msgstr "Estoy _fuera de la oficina"
+
+#~ msgid "I am _in the office"
+#~ msgstr "Estoy _en la oficina"
+
+#~ msgid "Send Message to"
+#~ msgstr "Enviar mensaje a"
+
+#~ msgid "Enter Password for %s"
+#~ msgstr "Introduzca la contraseña para %s"
+
+#~ msgid "Could not get password."
+#~ msgstr "No se pudo obtener la contraseña."
+
+#~ msgid "Could not fetch oal list: "
+#~ msgstr "No se pudo obtener la lista oal: "
+
+#~ msgid "Fetching..."
+#~ msgstr "Obteniendo…"
+
+#~ msgid "Select Ad_dress list: "
+#~ msgstr "Seleccionar lista de _direcciones: "
+
+#~ msgid "Fetch _list"
+#~ msgstr "Obtener _lista"
+
+#~ msgid "EWS Settings"
+#~ msgstr "Configuración de EWS"
+
+#~ msgid "GAL settings"
+#~ msgstr "Configuración de GAL"
+
+#~ msgid "Exchange Web Services Plugin"
+#~ msgstr "Complemento de servicios web Exchange"
+
+#~ msgid "Password"
+#~ msgstr "Contraseña"
+
+#~ msgid "Code: %d - Unexpected response from server"
+#~ msgstr "Código: %d: respuesta inesperada del servidor"
+
+#~ msgid "Both email and password must be provided"
+#~ msgstr "Se deben proporcionar el correo-e y la contraseña"
+
+#~ msgid "Wrong email id"
+#~ msgstr "ID del correo-e no válido"
+
+#~ msgid "Unknown calendar property '%s'"
+#~ msgstr "Propiedad «%s» del calendario desconocida"
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/fr.po evolution-ews.sync-with-3.8.2/po/fr.po
--- evolution-ews.git-gnome-3-0/po/fr.po	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/po/fr.po	2013-05-29 08:46:45.662641660 +0200
@@ -0,0 +1,518 @@
+# French translation for evolution-ews.
+# Copyright (C) 2012 evolution-ews's COPYRIGHT HOLDER
+# This file is distributed under the same license as the evolution-ews package.
+# Bruno Brouard <annoa.b@gmail.com>, 2012.
+# Andre Matuch <andre.matuch@videotron.ca>, 2012
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: evolution-ews master\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
+"product=evolution-ews&keywords=I18N+L10N&component=general\n"
+"POT-Creation-Date: 2012-06-15 11:45+0000\n"
+"PO-Revision-Date: 2012-06-06 19:41+0100\n"
+"Last-Translator: Pierre Henry <pierrehenry73@yahoo.fr>\n"
+"Language-Team: GNOME French Team <gnomefr@traduc.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n > 1);\n"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-listener.c:246
+msgid "Global Address list"
+msgstr "Liste d'adresses globale"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:188
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:200
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:217
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:231
+msgid "Cannot set Date-Time in Past"
+msgstr "Impossible de définir Date-Heure dans le passé"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:207
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:238
+msgid "Select a valid time range"
+msgstr "Sélectionner une période temporelle valide"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:318
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:359
+#, c-format
+msgid ""
+"Unable to fetch out of office settings: \n"
+"%s"
+msgstr ""
+"Impossible de récupérer les paramètres d'absence du bureau : \n"
+"%s"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:350
+msgid ""
+"The messages specified below will be automatically sent to \n"
+" each internal and external personal who sends a mail to you."
+msgstr ""
+"Les messages spécifiés ci-dessous seront automatiquement envoyés à \n"
+" chaque personnel interne et externe qui vous envoie un courriel."
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:355
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:695
+msgid "Status:"
+msgstr "Statut :"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:360
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:365
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:702
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:707
+msgid "I am _out of the office"
+msgstr "Je suis _absent du bureau"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:361
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:364
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:703
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:706
+msgid "I am _in the office"
+msgstr "Je suis au _bureau"
+
+#. Check box for setting date
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:374
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:717
+msgid "_Send only during this time period"
+msgstr "À n'en_voyer que pendant cette période temporelle"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:392
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:740
+msgid "_From:"
+msgstr "_De :"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:397
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:745
+msgid "_To:"
+msgstr "_À :"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:414
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:764
+msgid "I_nternal:"
+msgstr "I_nterne :"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:416
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:766
+msgid "Message to be sent inside organization"
+msgstr "Message à envoyer à l'intérieur de la société"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:423
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:773
+msgid "None"
+msgstr "Aucun"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:424
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:774
+msgid "Known"
+msgstr "Connaissances"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:425
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:775
+msgid "All"
+msgstr "Tous"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:427
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:779
+msgid "Send Message to"
+msgstr "Envoyer le message à"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:447
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:803
+msgid "E_xternal:"
+msgstr "E_xterne :"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:449
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:805
+msgid "Message to be sent outside organization"
+msgstr "Message à envoyer à l'extérieur de la société"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:623
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:522
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:662
+msgid "Out of Office"
+msgstr "Absent du bureau"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:633
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:532
+msgid "Fetching out of office settings..."
+msgstr "Récupération des paramètres d'absence du bureau..."
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:130
+#, c-format
+msgid "Enter Password for %s"
+msgstr "Saisissez le mot de passe pour %s"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:139
+msgid "Could not get password."
+msgstr "Impossible d'obtenir le mot de passe."
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:226
+msgid "Could not fetch oal list: "
+msgstr "Impossible de récupérer la liste oal : "
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:269
+msgid "Fetching..."
+msgstr "Récupération..."
+
+#. Add cache check box
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:323
+#: ../src/configuration/e-mail-config-ews-gal.c:294
+msgid "Cache o_ffline address book"
+msgstr "Mettre le carnet d'adresses hors-li_gne en cache"
+
+#. Add label
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:329
+msgid "Select Ad_dress list: "
+msgstr "Sélectionner la liste d'a_dresses : "
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:339
+msgid "Fetch _list"
+msgstr "Récupérer la _liste"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:428
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:3
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:885
+msgid "EWS Settings"
+msgstr "Paramètres EWS"
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:1
+#: ../src/camel/camel-ews-provider.c:69
+msgid "Exchange Web Services"
+msgstr "Exchange Web Services"
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:2
+msgid "GAL settings"
+msgstr "Paramètres GAL"
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:4
+msgid "Exchange Web Services Plugin"
+msgstr "Greffon Exchange Web Services"
+
+#: ../src/addressbook/e-book-backend-ews.c:979
+msgid "The backend does not support bulk additions"
+msgstr "Le moteur ne prend pas en charge les ajouts par lot"
+
+#: ../src/addressbook/e-book-backend-ews.c:1257
+msgid "The backend does not support bulk modifications"
+msgstr "Le moteur ne prend pas en charge les modifications par lot"
+
+#: ../src/addressbook/e-book-backend-ews.c:1439
+msgid "Wait till syncing is done"
+msgstr "Attendre la fin de la synchronisation"
+
+#: ../src/addressbook/e-book-backend-ews.c:1767
+#, c-format
+msgid "Downloading contacts in %s %d%% completed... "
+msgstr "Téléchargement des contacts dans %s en cours, %d%% terminé... "
+
+#: ../src/addressbook/e-book-backend-ews.c:2289
+msgid "Syncing contacts..."
+msgstr "Synchronisation des contacts..."
+
+#: ../src/addressbook/e-book-backend-ews.c:2491
+msgid "Searching..."
+msgstr "Recherche..."
+
+#: ../src/addressbook/ews-book-backend-sqlitedb.c:475
+#, c-format
+msgid "Insufficient memory"
+msgstr "Mémoire insuffisante"
+
+#: ../src/calendar/e-cal-backend-ews.c:1054
+msgid "EWS does not support bulk removals"
+msgstr "EWS ne prend pas en charge les suppressions par lot"
+
+#: ../src/calendar/e-cal-backend-ews.c:1637
+msgid "EWS does not support bulk additions"
+msgstr "EWS ne prend pas en charge les ajouts par lot"
+
+#: ../src/calendar/e-cal-backend-ews.c:2127
+msgid "EWS does not support bulk modifications"
+msgstr "EWS ne prend pas en charge les modifications par lot"
+
+#: ../src/camel/camel-ews-folder.c:263
+#, c-format
+msgid "Unable to open mimecontent temporary file!"
+msgstr "Impossible d'ouvrir le fichier temporaire mimecontent"
+
+#: ../src/camel/camel-ews-folder.c:270
+#, c-format
+msgid "Unable to generate parser from mimecontent!"
+msgstr "Impossible de générer l'analyseur à partir de mimecontent"
+
+#: ../src/camel/camel-ews-folder.c:279
+#, c-format
+msgid "Unable to parse meeting request mimecontent!"
+msgstr "Impossible d'analyser la requête de réunion mimecontent"
+
+#: ../src/camel/camel-ews-folder.c:336
+#, c-format
+msgid "Unable to create cache file"
+msgstr "Impossible de créer le fichier cache"
+
+#: ../src/camel/camel-ews-folder.c:437 ../src/camel/camel-ews-folder.c:509
+#, c-format
+msgid "Unable to create cache path"
+msgstr "Impossible de créer le chemin du cache"
+
+#: ../src/camel/camel-ews-folder.c:518
+#, c-format
+msgid "Failed to move message cache file"
+msgstr "Échec du déplacement du fichier cache des messages"
+
+#: ../src/camel/camel-ews-folder.c:1056
+#, c-format
+msgid "Could not load summary for %s"
+msgstr "Impossible de charger le résumé pour %s"
+
+#: ../src/camel/camel-ews-folder.c:1397 ../src/camel/camel-ews-store.c:745
+#: ../src/camel/camel-ews-store.c:802 ../src/camel/camel-ews-store.c:873
+#, c-format
+msgid "Cant perform actions on the folder while in offline mode"
+msgstr "Impossible de réaliser les actions sur le dossier en mode hors-ligne"
+
+#: ../src/camel/camel-ews-provider.c:48
+msgid "Checking for new mail"
+msgstr "Vérification des nouveaux messages"
+
+#: ../src/camel/camel-ews-provider.c:50
+msgid "C_heck for new messages in all folders"
+msgstr "_Vérifier la présence de nouveaux messages dans tous les dossiers"
+
+#: ../src/camel/camel-ews-provider.c:53
+msgid "Options"
+msgstr "Options"
+
+#: ../src/camel/camel-ews-provider.c:55
+msgid "_Apply filters to new messages in Inbox on this server"
+msgstr ""
+"_Appliquer les filtres sur les nouveaux messages dans la Boîte de réception "
+"sur ce serveur"
+
+#: ../src/camel/camel-ews-provider.c:57
+msgid "Check new messages for _Junk contents"
+msgstr "Détecter les _Pourriels dans les nouveaux messages"
+
+#: ../src/camel/camel-ews-provider.c:59
+msgid "Only check for Junk messages in the IN_BOX folder"
+msgstr "Détecter les Pourriels _seulement dans la Boîte de réception"
+
+#: ../src/camel/camel-ews-provider.c:61
+msgid "Automatically synchroni_ze remote mail locally"
+msgstr "_Synchroniser automatiquement le courriel à distance localement"
+
+#: ../src/camel/camel-ews-provider.c:71
+msgid "For accessing Exchange servers using Web Services"
+msgstr "Pour accéder aux serveurs Exchange en utilisant Web Services"
+
+#: ../src/camel/camel-ews-provider.c:87
+msgid "Password"
+msgstr "Mot de Passe"
+
+#: ../src/camel/camel-ews-provider.c:89
+msgid ""
+"This option will connect to the Exchange server using a plaintext password."
+msgstr ""
+"Cette option implique une connexion au serveur Exchange en utilisant un mot "
+"de passe en clair."
+
+#: ../src/camel/camel-ews-store.c:181
+#, c-format
+msgid "Session has no storage path"
+msgstr "La session n'a pas de chemin de stockage"
+
+#: ../src/camel/camel-ews-store.c:540
+#, c-format
+msgid "No such folder: %s"
+msgstr "Aucun dossier de ce type : %s"
+
+#: ../src/camel/camel-ews-store.c:738
+#, c-format
+msgid "Parent folder %s does not exist"
+msgstr "Le dossier parent %s n'existe pas"
+
+#: ../src/camel/camel-ews-store.c:796
+#, c-format
+msgid "Folder does not exist"
+msgstr "Le dossier n'existe pas"
+
+#: ../src/camel/camel-ews-store.c:881
+#, c-format
+msgid "Folder %s does not exist"
+msgstr "Le dossier %s n'existe pas"
+
+#: ../src/camel/camel-ews-store.c:890
+#, c-format
+msgid "No change key record for folder %s"
+msgstr "Aucun enregistrement de modification de clé pour le dossier %s"
+
+#: ../src/camel/camel-ews-store.c:929
+#, c-format
+msgid "Cannot both rename and move a folder at the same time"
+msgstr "Impossible de renommer et déplacer un dossier simultanément"
+
+#: ../src/camel/camel-ews-store.c:961
+#, c-format
+msgid "Cannot find folder ID for parent folder %s"
+msgstr ""
+"Impossible de trouver l'identification de dossier pour le dossier parent %s"
+
+#: ../src/camel/camel-ews-store.c:999 ../src/camel/camel-ews-transport.c:68
+#, c-format
+msgid "Exchange server %s"
+msgstr "Serveur Exchange %s"
+
+#: ../src/camel/camel-ews-store.c:1001
+#, c-format
+msgid "Exchange service for %s on %s"
+msgstr "Service Exchange pour %s sur %s"
+
+#: ../src/camel/camel-ews-store.c:1077
+#, c-format
+msgid "You must be working online to complete this operation"
+msgstr "Vous devez travailler en-ligne pour achever cette opération"
+
+#: ../src/camel/camel-ews-transport.c:71
+#, c-format
+msgid "Exchange mail delivery via %s"
+msgstr "Livraison de courriel Exchange par %s"
+
+#: ../src/camel/camel-ews-transport.c:108
+msgid "Cannot send message with no From address"
+msgstr "Impossible d'envoyer un message sans adresse Expéditeur"
+
+#: ../src/camel/camel-ews-transport.c:112
+msgid "Exchange server cannot send message with multiple From addresses"
+msgstr ""
+"Le serveur Exchange ne peut envoyer des message avec plusieurs adresses "
+"Expéditeur"
+
+#: ../src/camel/camel-ews-transport.c:120
+msgid "Failed to read From address"
+msgstr "Impossible de lire l'adresse Expéditeur"
+
+#: ../src/camel/camel-ews-transport.c:126
+#, c-format
+msgid ""
+"Exchange server cannot send message as '%s', when the account was configured "
+"for address '%s'"
+msgstr ""
+"Le serveur Exchange ne peut envoyer le message sous le nom « %s » alors que "
+"le compte a été configuré avec l'adresse « %s »"
+
+#: ../src/camel/camel-ews-transport.c:137
+#, c-format
+msgid "Service not connected"
+msgstr "Service non connecté"
+
+#: ../src/collection/e-ews-backend.c:328
+#: ../src/configuration/e-mail-config-ews-gal.c:267
+msgid "Global Address List"
+msgstr "Liste d'adresses globale"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:125
+msgid "Querying Autodiscover service"
+msgstr "Interrogation du service Autodécouverte"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:208
+msgid "Fetch _URL"
+msgstr "Récupérer l'_URL"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:109
+msgid "Configuration"
+msgstr "Configuration"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:127
+msgid "User_name:"
+msgstr "_Nom d'utilisateur :"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:141
+msgid "_Host URL:"
+msgstr "URL _hôte :"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:160
+msgid "OAB U_RL:"
+msgstr "U_RL OAB :"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:174
+msgid "Authentication"
+msgstr "Authentification"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:214
+msgid "Locating offline address books"
+msgstr "Localisation des carnets d'adresses hors-ligne"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:320
+msgid "Select ad_dress list:"
+msgstr "Sélectionner la liste d'a_dresses :"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:344
+msgid "Fetch List"
+msgstr "Récupérer la liste"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:680
+msgid ""
+"The messages specified below will be automatically sent to each internal and "
+"external personal who sends a mail to you."
+msgstr ""
+"Les messages spécifiés ci-dessous seront automatiquement envoyés à chaque "
+"personnel interne et externe qui vous envoie un courriel."
+
+#: ../src/server/e-ews-connection.c:389
+msgid "Operation Cancelled"
+msgstr "Opération annulée"
+
+#: ../src/server/e-ews-connection.c:453
+msgid "Authentication failed"
+msgstr "Échec d'authentification"
+
+#: ../src/server/e-ews-connection.c:461
+#, c-format
+msgid "No response: %s"
+msgstr "Aucune réponse : %s"
+
+#: ../src/server/e-ews-connection.c:1419
+#, c-format
+msgid "Failed to parse autodiscover response XML"
+msgstr "Échec d'analyse de la réponse d'autodécouverte XML"
+
+#: ../src/server/e-ews-connection.c:1426
+#, c-format
+msgid "Failed to find <Autodiscover> element"
+msgstr "Échec de l'obtention de l'élément <Autodiscover>"
+
+#: ../src/server/e-ews-connection.c:1437
+#, c-format
+msgid "Failed to find <Response> element"
+msgstr "Échec de l'obtention de l'élément <Response>"
+
+#: ../src/server/e-ews-connection.c:1448
+#, c-format
+msgid "Failed to find <Account> element"
+msgstr "Échec de l'obtention de l'élément <Account>"
+
+#: ../src/server/e-ews-connection.c:1467
+#, c-format
+msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
+msgstr ""
+"Échec de l'obtention de <ASUrl> et <OABUrl> dans la réponse d'autodécouverte"
+
+#: ../src/server/e-ews-connection.c:1630
+msgid "Email address is missing a domain part"
+msgstr "Il manque une partie domaine à l'adresse électronique"
+
+#: ../src/server/e-ews-connection.c:1913
+msgid "Failed to parse oab XML"
+msgstr "Échec d'analyse oab XML"
+
+#: ../src/server/e-ews-connection.c:1921
+msgid "Failed to find <OAB> element\n"
+msgstr "Échec de l'obtention de l'élément <OAB>\n"
+
+#: ../src/utils/ews-camel-common.c:172
+#, c-format
+msgid "CreateItem call failed to return ID for new message"
+msgstr ""
+"L'appel CreateItem n'a pas réussi à renvoyer un identifiant pour le nouveau "
+"message"
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/gl.po evolution-ews.sync-with-3.8.2/po/gl.po
--- evolution-ews.git-gnome-3-0/po/gl.po	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/po/gl.po	2013-05-29 08:46:45.648863785 +0200
@@ -0,0 +1,469 @@
+# Galician translation for evolution-ews.
+# Copyright (C) 2012 evolution-ews's COPYRIGHT HOLDER
+# This file is distributed under the same license as the evolution-ews package.
+# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
+# Fran Dieguez <frandieguez@gnome.org>, 2012.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: evolution-ews master\n"
+"Report-Msgid-Bugs-To: \n"
+"POT-Creation-Date: 2012-04-13 15:48+0200\n"
+"PO-Revision-Date: 2012-04-13 15:49+0200\n"
+"Last-Translator: Fran Dieguez <frandieguez@gnome.org>\n"
+"Language-Team: Galician <gnome-l10n-gl@gnome.org>\n"
+"Language: gl\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n!=1);\n"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-listener.c:242
+msgid "Global Address list"
+msgstr "Lista global de enderezos"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:185
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:197
+msgid "Cannot set Date-Time in Past"
+msgstr "No é posíbel estabelecer unha data/hora pasadas"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:204
+msgid "Select a valid time range"
+msgstr "Seleccionar un rango de tempo válido"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:315
+#, c-format
+msgid ""
+"Unable to fetch out of office settings: \n"
+"%s"
+msgstr ""
+"Non foi posiel obter a configuración de oficina:\n"
+"%s"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:347
+msgid ""
+"The messages specified below will be automatically sent to \n"
+" each internal and external personal who sends a mail to you."
+msgstr ""
+"As mensaxes que se especifican máis abaixo enviaranse automaticamente\n"
+"a todo o persoal interno e externo que lle envíe un correo."
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:352
+msgid "Status:"
+msgstr "Estado:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:357
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:362
+msgid "I am _out of the office"
+msgstr "Estou _fóra da oficina"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:358
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:361
+msgid "I am _in the office"
+msgstr "Estou _na oficina"
+
+#. Check box for setting date
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:371
+msgid "_Send only during this time period"
+msgstr "_Enviar só durante este período de tempo"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:390
+msgid "_From:"
+msgstr "_De:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:395
+msgid "_To:"
+msgstr "_Para:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:412
+msgid "I_nternal:"
+msgstr "I_nterno:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:414
+msgid "Message to be sent inside organization"
+msgstr "Mensaxe que enviar dentro da organización"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:421
+msgid "None"
+msgstr "Nadie"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:422
+msgid "Known"
+msgstr "Coñecidos"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:423
+msgid "All"
+msgstr "Todos"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:425
+msgid "Send Message to"
+msgstr "Envair mensaxe a"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:445
+msgid "E_xternal:"
+msgstr "E_xterno:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:447
+msgid "Message to be sent outside organization"
+msgstr "Mensaxe que envair fóra da organización"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:621
+msgid "Out of Office"
+msgstr "Fóra da oficina"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:631
+msgid "Fetching out of office settings..."
+msgstr "Obtendo a configuración de oficina…"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:111
+#, c-format
+msgid "Autodiscover failed: %s"
+msgstr "Produciuse un fallo na autodetección: %s"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:154
+#, c-format
+msgid "Enter Password for %s"
+msgstr "Escriba o contrasinal para %s"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:163
+msgid "Could not get password."
+msgstr "Non foi posíbel obter o contrasinal."
+
+#. OAB url entry
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:286
+msgid "OAB U_RL:"
+msgstr "U_RL OAB:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:298
+msgid "_Host URL:"
+msgstr "URL do _equipo:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:313
+msgid "Fetch _URL"
+msgstr "Obter _URL"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:478
+msgid "Could not fetch oal list: "
+msgstr "Non foi posíbel obter a lista oal:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:524
+msgid "Fetching..."
+msgstr "Obtendo…"
+
+#. Add cache check box
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:661
+msgid "Cache o_ffline address book"
+msgstr "Caché do libro de enderezos _sen conexión"
+
+#. Add label
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:667
+msgid "Select Ad_dress list: "
+msgstr "Seleccionar a lista de _enderezos:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:677
+msgid "Fetch _list"
+msgstr "Obter _lista"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:764
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:3
+msgid "EWS Settings"
+msgstr "Configuración de EWS"
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:1
+#: ../src/camel/camel-ews-provider.c:69
+msgid "Exchange Web Services"
+msgstr "Servizos web Exchange"
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:2
+msgid "GAL settings"
+msgstr "Configuración de GAL"
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:4
+msgid "Exchange Web Services Plugin"
+msgstr "Engadido de servizos web Exchange"
+
+#: ../src/addressbook/e-book-backend-ews.c:913
+msgid "The backend does not support bulk additions"
+msgstr "O «backend» non admite adicións"
+
+#: ../src/addressbook/e-book-backend-ews.c:1184
+msgid "The backend does not support bulk modifications"
+msgstr "O «backend» non admite modificacións"
+
+#: ../src/addressbook/e-book-backend-ews.c:1358
+msgid "Wait till syncing is done"
+msgstr "Agarde a que termine a sincronización"
+
+#: ../src/addressbook/e-book-backend-ews.c:1676
+#, c-format
+msgid "Downloading contacts in %s %d%% completed... "
+msgstr "Descarga de contactos en %s %d%% completada…"
+
+#: ../src/addressbook/e-book-backend-ews.c:2178
+msgid "Syncing contacts..."
+msgstr "Sincronizando contactos…"
+
+#: ../src/addressbook/e-book-backend-ews.c:2370
+msgid "Searching..."
+msgstr "Buscando…"
+
+#: ../src/addressbook/e-book-backend-sqlitedb.c:474
+#, c-format
+msgid "Insufficient memory"
+msgstr "Memoria insuficiente"
+
+#: ../src/calendar/e-cal-backend-ews.c:1047
+msgid "EWS does not support bulk removals"
+msgstr "EWS non admite eliminacións en lote"
+
+#: ../src/calendar/e-cal-backend-ews.c:1622
+msgid "EWS does not support bulk additions"
+msgstr "EWS non admite adicións en lote"
+
+#: ../src/calendar/e-cal-backend-ews.c:2111
+msgid "EWS does not support bulk modifications"
+msgstr "EWS non admite modificacións en lote"
+
+#: ../src/camel/camel-ews-folder.c:262
+#, c-format
+msgid "Unable to open mimecontent temporary file!"
+msgstr "Non foi posiel abrir o ficheiro temporal de contido MIME."
+
+#: ../src/camel/camel-ews-folder.c:269
+#, c-format
+msgid "Unable to generate parser from mimecontent!"
+msgstr "Non foi posíbel xerar analizador desde o contido MIME."
+
+#: ../src/camel/camel-ews-folder.c:278
+#, c-format
+msgid "Unable to parse meeting request mimecontent!"
+msgstr "Non foi posiel analizar o contido MIME da petición de encontro."
+
+#: ../src/camel/camel-ews-folder.c:335
+#, c-format
+msgid "Unable to create cache file"
+msgstr "Non foi posíbel crear o ficheiro da caché"
+
+#: ../src/camel/camel-ews-folder.c:436 ../src/camel/camel-ews-folder.c:505
+#, c-format
+msgid "Unable to create cache path"
+msgstr "Non foi posíbel crear a ruta da caché"
+
+#: ../src/camel/camel-ews-folder.c:514
+#, c-format
+msgid "Failed to move message cache file"
+msgstr "Produciuse un fallo ao mover o ficheiro da caché de mensaxes"
+
+#: ../src/camel/camel-ews-folder.c:920
+#, c-format
+msgid "Could not load summary for %s"
+msgstr "Non foi posíbel cargar o resumo para %s"
+
+#: ../src/camel/camel-ews-folder.c:1261 ../src/camel/camel-ews-store.c:757
+#: ../src/camel/camel-ews-store.c:813 ../src/camel/camel-ews-store.c:883
+#, c-format
+msgid "Cant perform actions on the folder while in offline mode"
+msgstr ""
+"Non foi posíbel realizar as accións sobre o cartafol estando en modo "
+"desconectado"
+
+#: ../src/camel/camel-ews-provider.c:48
+msgid "Checking for new mail"
+msgstr "Comprobar se hai correo novo"
+
+#: ../src/camel/camel-ews-provider.c:50
+msgid "C_heck for new messages in all folders"
+msgstr "C_omprobar se hai mensaxes novos en todos os cartafoles"
+
+#: ../src/camel/camel-ews-provider.c:53
+msgid "Options"
+msgstr "Opcións"
+
+#: ../src/camel/camel-ews-provider.c:55
+msgid "_Apply filters to new messages in Inbox on this server"
+msgstr ""
+"_Aplicar filtros aos mensaxes novos da Bandexa de entrada neste servidor"
+
+#: ../src/camel/camel-ews-provider.c:57
+msgid "Check new messages for _Junk contents"
+msgstr "Comprobar se o contido das mensaxes novas é _spam"
+
+#: ../src/camel/camel-ews-provider.c:59
+msgid "Only check for Junk messages in the IN_BOX folder"
+msgstr "Só comprobar spam no cartafol _Caixa de entrada"
+
+#: ../src/camel/camel-ews-provider.c:61
+msgid "Automatically synchroni_ze remote mail locally"
+msgstr "Sincroni_zar automaticamente o correo remoto de maneira local"
+
+#: ../src/camel/camel-ews-provider.c:71
+msgid "For accessing Exchange servers using Web Services"
+msgstr "Para acceder a servidor Exchange usando servizos web"
+
+#: ../src/camel/camel-ews-provider.c:87
+msgid "Password"
+msgstr "Contrasinal"
+
+#: ../src/camel/camel-ews-provider.c:89
+msgid ""
+"This option will connect to the Exchange server using a plaintext password."
+msgstr ""
+"Esta opción conectará ao servidor de Exchange usando un contrasinal en texto "
+"plano."
+
+#: ../src/camel/camel-ews-store.c:184
+#, c-format
+msgid "Session has no storage path"
+msgstr "A sesión non ten ruta de almacenamento"
+
+#: ../src/camel/camel-ews-store.c:554
+#, c-format
+msgid "No such folder: %s"
+msgstr "Non existe o cartafol: %s"
+
+#: ../src/camel/camel-ews-store.c:750
+#, c-format
+msgid "Parent folder %s does not exist"
+msgstr "O cartafol pai %s non existe"
+
+#: ../src/camel/camel-ews-store.c:807
+#, c-format
+msgid "Folder does not exist"
+msgstr "O cartafol non existe"
+
+#: ../src/camel/camel-ews-store.c:891
+#, c-format
+msgid "Folder %s does not exist"
+msgstr "O cartafol %s non existe"
+
+#: ../src/camel/camel-ews-store.c:900
+#, c-format
+msgid "No change key record for folder %s"
+msgstr "Non hai cambios en rexistros chave do cartafol %s"
+
+#: ../src/camel/camel-ews-store.c:939
+#, c-format
+msgid "Cannot both rename and move a folder at the same time"
+msgstr "Non é posíbel renomear e mover un cartafol ao mesmo tempo"
+
+#: ../src/camel/camel-ews-store.c:970
+#, c-format
+msgid "Cannot find folder ID for parent folder %s"
+msgstr "Non é posíbel atopar o ID do cartafol para o cartafol pai %s"
+
+#: ../src/camel/camel-ews-store.c:1007 ../src/camel/camel-ews-transport.c:66
+#, c-format
+msgid "Exchange server %s"
+msgstr "Servidor Exchange %s"
+
+#: ../src/camel/camel-ews-store.c:1009
+#, c-format
+msgid "Exchange service for %s on %s"
+msgstr "Servizo Exchange para %s en %s"
+
+#: ../src/camel/camel-ews-store.c:1049
+#, c-format
+msgid "You must be working online to complete this operation"
+msgstr "Debe estar conectado para completar esta operación"
+
+#: ../src/camel/camel-ews-transport.c:69
+#, c-format
+msgid "Exchange mail delivery via %s"
+msgstr "Correo Exchange entregado por %s"
+
+#: ../src/camel/camel-ews-transport.c:106
+msgid "Cannot send message with no From address"
+msgstr "Non é posíbel enviar unha mensaxe sen un enderezo en «Para»"
+
+#: ../src/camel/camel-ews-transport.c:110
+msgid "Exchange server cannot send message with multiple From addresses"
+msgstr ""
+"O servidor Exchange non pode envair unha mensaxe con varios enderezos «Para»"
+
+#: ../src/camel/camel-ews-transport.c:118
+msgid "Failed to read From address"
+msgstr "produciuse un fallo ao ler o enderezo «Para»"
+
+#: ../src/camel/camel-ews-transport.c:124
+#, c-format
+msgid ""
+"Exchange server cannot send message as '%s', when the account was configured "
+"for address '%s'"
+msgstr ""
+"O servidor Exchange non pode enviar un mensaxe como «%s», cando a conta foi "
+"configurada para o enderezo «%s»"
+
+#: ../src/camel/camel-ews-transport.c:135
+#, c-format
+msgid "Service not connected"
+msgstr "Servizo non conectado"
+
+#: ../src/server/e-ews-connection.c:383
+msgid "Operation Cancelled"
+msgstr "Operación cancelada"
+
+#: ../src/server/e-ews-connection.c:445
+msgid "Authentication failed"
+msgstr "Produciuse un fallo na autenticación"
+
+#: ../src/server/e-ews-connection.c:453
+#, c-format
+msgid "No response: %s"
+msgstr "Sen resposta: %s"
+
+#: ../src/server/e-ews-connection.c:1366 ../src/server/e-ews-connection.c:1724
+#: ../src/server/e-ews-connection.c:1963
+#, c-format
+msgid "Code: %d - Unexpected response from server"
+msgstr "Código: %d: resposta non agardada do servidor"
+
+#: ../src/server/e-ews-connection.c:1378
+#, c-format
+msgid "Failed to parse autodiscover response XML"
+msgstr "Produciuse un fallo ao analizar a resposta XML da autodetección"
+
+#: ../src/server/e-ews-connection.c:1386
+#, c-format
+msgid "Failed to find <Autodiscover> element\n"
+msgstr "Produciuse un fallo ao buscar o elemento <Autodiscover>\n"
+
+#: ../src/server/e-ews-connection.c:1398
+#, c-format
+msgid "Failed to find <Response> element\n"
+msgstr "Produciuse un fallo ao buscar o elemento<Response>\n"
+
+#: ../src/server/e-ews-connection.c:1410
+#, c-format
+msgid "Failed to find <Account> element\n"
+msgstr "Produciuse un fallo ao buscar o elemento <Account>\n"
+
+#: ../src/server/e-ews-connection.c:1429
+#, c-format
+msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
+msgstr ""
+"Produciuse un fallo ao buscar <ASUrl> e <OABUrl> na resposta da autodetección"
+
+#: ../src/server/e-ews-connection.c:1531
+#, c-format
+msgid "Both email and password must be provided"
+msgstr "Débese fornecer o correo-e e o contrasinal"
+
+#: ../src/server/e-ews-connection.c:1538
+#, c-format
+msgid "Wrong email id"
+msgstr "ID de correo-e non válida"
+
+#: ../src/server/e-ews-connection.c:1734
+#, c-format
+msgid "Failed to parse oab XML"
+msgstr "Produciuse un fallo ao analizar o XML oab"
+
+#: ../src/server/e-ews-connection.c:1741
+#, c-format
+msgid "Failed to find <OAB> element\n"
+msgstr "Produciuse un fallo ao buscar o elemento <OAB>\n"
+
+#: ../src/utils/ews-camel-common.c:170
+#, c-format
+msgid "CreateItem call failed to return ID for new message"
+msgstr "CreateItem fallou ao devolver o ID para a mensaxe nova"
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/hu.po evolution-ews.sync-with-3.8.2/po/hu.po
--- evolution-ews.git-gnome-3-0/po/hu.po	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/po/hu.po	2013-05-29 08:46:45.663988785 +0200
@@ -0,0 +1,1116 @@
+# Hungarian translation of evolution-ews
+# Copyright (C) 2011, 2012. Free Software Foundation, Inc.
+# This file is distributed under the same license as the evolution-ews package.
+#
+# Mézi Zoltán <mezi dot zoltan at gmail dot com>, 2011.
+# Gabor Kelemen <kelemeng at gnome dot hu>, 2011, 2012.
+# Balázs Úr <urbalazs at gmail dot com>, 2012, 2013.
+msgid ""
+msgstr ""
+"Project-Id-Version: evolution-ews master\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
+"product=evolution-ews&keywords=I18N+L10N&component=general\n"
+"POT-Creation-Date: 2013-03-07 11:53+0000\n"
+"PO-Revision-Date: 2013-03-20 21:09+0100\n"
+"Last-Translator: Balázs Úr <urbalazs at gmail dot com>\n"
+"Language-Team: Hungarian <gnome-hu-list at gnome dot org>\n"
+"Language: hu\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"X-Poedit-Language: Hungarian\n"
+"X-Poedit-Country: HUNGARY\n"
+"Plural-Forms:  nplurals=2; plural=(n != 1);\n"
+"X-Generator: Lokalize 1.2\n"
+
+#: ../src/addressbook/e-book-backend-ews.c:1001
+msgid "The backend does not support bulk additions"
+msgstr "A háttérprogram nem támogatja a tömeges hozzáadásokat"
+
+#: ../src/addressbook/e-book-backend-ews.c:1288
+msgid "The backend does not support bulk modifications"
+msgstr "A háttérprogram nem támogatja a tömeges módosításokat"
+
+#: ../src/addressbook/e-book-backend-ews.c:1476
+msgid "Wait till syncing is done"
+msgstr "Várakozás a szinkronizálás befejeződésére"
+
+#: ../src/addressbook/e-book-backend-ews.c:1815
+#, c-format
+msgid "Downloading contacts in %s %d%% completed... "
+msgstr "Kapcsolatok letöltése itt: %s %d%%-ban kész…"
+
+#: ../src/addressbook/e-book-backend-ews.c:2368
+msgid "Syncing contacts..."
+msgstr "Névjegyek szinkronizálása…"
+
+#: ../src/addressbook/e-book-backend-ews.c:2592
+#: ../src/configuration/e-ews-search-user.c:364
+msgid "Searching..."
+msgstr "Keresés…"
+
+#: ../src/calendar/e-cal-backend-ews.c:1055
+msgid "EWS does not support bulk removals"
+msgstr "Az EWS nem támogatja a tömeges módosításokat"
+
+#: ../src/calendar/e-cal-backend-ews.c:1698
+msgid "EWS does not support bulk additions"
+msgstr "Az EWS nem támogatja a tömeges hozzáadásokat"
+
+#: ../src/calendar/e-cal-backend-ews.c:2281
+msgid "EWS does not support bulk modifications"
+msgstr "Az EWS nem támogatja a tömeges módosításokat"
+
+#: ../src/camel/camel-ews-folder.c:268
+#, c-format
+msgid "Unable to open mimecontent temporary file!"
+msgstr "Nem nyitható meg a MIME-tartalom átmeneti fájlja!"
+
+#: ../src/camel/camel-ews-folder.c:276
+#, c-format
+msgid "Unable to generate parser from mimecontent!"
+msgstr "Nem hozható létre a MIME-tartalom feldolgozója!"
+
+#: ../src/camel/camel-ews-folder.c:285
+#, c-format
+msgid "Unable to parse meeting request mimecontent!"
+msgstr "Nem dolgozható fel a találkozókérés MIME-tartalma!"
+
+#: ../src/camel/camel-ews-folder.c:346
+#, c-format
+msgid "Unable to create cache file"
+msgstr "Nem hozató létre gyorsítótárfájl"
+
+#: ../src/camel/camel-ews-folder.c:451 ../src/camel/camel-ews-folder.c:531
+#, c-format
+msgid "Unable to create cache path"
+msgstr "Nem hozható létre a gyorsítótár útvonala"
+
+#: ../src/camel/camel-ews-folder.c:541
+#, c-format
+msgid "Failed to move message cache file"
+msgstr "Sikertelen az üzenetgyorsítótár-fájl áthelyezése"
+
+#: ../src/camel/camel-ews-folder.c:1188
+#, c-format
+msgid "Could not load summary for %s"
+msgstr "„%s” összefoglalása nem tölthető be"
+
+#: ../src/camel/camel-ews-folder.c:1624
+#, c-format
+msgid "Cant perform actions on the folder while in offline mode"
+msgstr "Kapcsolat nélküli módban nem lehet végrehajtani a műveleteket a mappán"
+
+#: ../src/camel/camel-ews-provider.c:48
+msgid "Checking for new mail"
+msgstr "Új levelek keresése"
+
+#: ../src/camel/camel-ews-provider.c:50
+msgid "C_heck for new messages in all folders"
+msgstr "_Új levelek keresése minden mappában"
+
+#: ../src/camel/camel-ews-provider.c:53
+msgid "Options"
+msgstr "Beállítások"
+
+#: ../src/camel/camel-ews-provider.c:55
+msgid "_Apply filters to new messages in Inbox on this server"
+msgstr "S_zűrők alkalmazása az új üzenetekre ezen kiszolgáló bejövő mappájában"
+
+#: ../src/camel/camel-ews-provider.c:57
+msgid "Check new messages for _Junk contents"
+msgstr "_Levélszemét keresése az új levelek között"
+
+#: ../src/camel/camel-ews-provider.c:59
+msgid "Only check for Junk messages in the IN_BOX folder"
+msgstr "Csak a BEÉ_RKEZETT ÜZENETEK mappában keressen levélszemetet"
+
+#: ../src/camel/camel-ews-provider.c:61
+msgid "Automatically synchroni_ze remote mail locally"
+msgstr "A távoli levelek automatikus helyi s_zinkronizációja"
+
+#: ../src/camel/camel-ews-provider.c:64
+msgid "Connection"
+msgstr "Kapcsolat"
+
+#. Translators: '%s' is preplaced with a widget, where "
+#. * user can select how long the timeout should be.
+#: ../src/camel/camel-ews-provider.c:68
+#, c-format
+msgid "Connection _timeout (in seconds) %s"
+msgstr "K_apcsolat időtúllépése %s (másodperc)"
+
+#: ../src/camel/camel-ews-provider.c:76
+msgid "Exchange Web Services"
+msgstr "Exchange webszolgáltatások"
+
+#: ../src/camel/camel-ews-provider.c:78
+msgid "For accessing Exchange servers using Web Services"
+msgstr "Exchange kiszolgálók eléréséhez webszolgáltatások használatával"
+
+#: ../src/camel/camel-ews-provider.c:93
+msgid "NTLM"
+msgstr "NTLM"
+
+#: ../src/camel/camel-ews-provider.c:95
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with NTLM authentication."
+msgstr ""
+"Ezzel az opcióval az Exchange kiszolgálóhoz sima szöveges jelszóval fog "
+"kapcsolódni NTLM hitelesítés használatával."
+
+#: ../src/camel/camel-ews-provider.c:103
+msgid "Basic"
+msgstr "Alap"
+
+#: ../src/camel/camel-ews-provider.c:105
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with Basic authentication."
+msgstr ""
+"Ezzel az opcióval az Exchange kiszolgálóhoz sima szöveges jelszóval fog "
+"kapcsolódni alap hitelesítés használatával."
+
+#: ../src/camel/camel-ews-store.c:192
+#, c-format
+msgid "Session has no storage path"
+msgstr "A munkamenet nem rendelkezik tárolási útvonallal"
+
+#: ../src/camel/camel-ews-store.c:229
+#, c-format
+#| msgctxt "ForeignFolders"
+#| msgid "%s_%d"
+msgctxt "PublicFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:358
+#, c-format
+msgctxt "ForeignFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:688
+msgid "Updating foreign folder structure"
+msgstr "Idegen mappaszerkezet frissítése"
+
+#: ../src/camel/camel-ews-store.c:973
+msgid "Authentication password not available"
+msgstr "A hitelesítési jelszó nem érhető el"
+
+#: ../src/camel/camel-ews-store.c:1138
+msgid "Query for authentication types is not supported"
+msgstr "A hitelesítési típusok lekérése nem támogatott"
+
+#: ../src/camel/camel-ews-store.c:1190
+#, c-format
+msgid "No such folder: %s"
+msgstr "Nincs %s nevű mappa"
+
+#: ../src/camel/camel-ews-store.c:1502
+#| msgid "Cannot subscribe EWS folders in offline mode"
+msgid "Cannot list EWS public folders in offline mode"
+msgstr "Nem lehet listázni a nyilvános EWS mappákat kapcsolat nélküli módban"
+
+#: ../src/camel/camel-ews-store.c:1575
+#| msgid "Cannot find folder ID for parent folder %s"
+msgid "Cannot find any EWS public folders"
+msgstr "Nem található egyetlen EWS nyilvános mappa sem"
+
+#: ../src/camel/camel-ews-store.c:1680
+#, c-format
+msgid "Cannot create folder '%s', folder already exists"
+msgstr "A mappa („%s”) nem hozható létre, mert már létezik"
+
+#: ../src/camel/camel-ews-store.c:1695
+#, c-format
+msgid "Parent folder %s does not exist"
+msgstr "A szülő mappa (%s) nem létezik"
+
+#: ../src/camel/camel-ews-store.c:1705
+#, c-format
+msgid ""
+"Cannot create folder under '%s', it is used for folders of other users only"
+msgstr ""
+"Nem hozható létre mappa a(z) „%s” alatt, mert az csak más felhasználók "
+"mappáihoz van használatban"
+
+#: ../src/camel/camel-ews-store.c:1715
+#, c-format
+#| msgid ""
+#| "Cannot create folder under '%s', it is used for folders of other users "
+#| "only"
+msgid "Cannot create folder under '%s', it is used for public folders only"
+msgstr ""
+"Nem hozható létre mappa a(z) „%s” alatt, mert az csak a nyilvános mappákhoz "
+"van használatban"
+
+#: ../src/camel/camel-ews-store.c:1784
+#, c-format
+msgid "Folder does not exist"
+msgstr "A mappa nem létezik"
+
+#: ../src/camel/camel-ews-store.c:1793
+#, c-format
+msgid "Cannot remove folder '%s', it is used for folders of other users only"
+msgstr ""
+"Nem távolítható el a(z) „%s” mappa, mert az csak más felhasználók mappáihoz "
+"van használatban"
+
+#: ../src/camel/camel-ews-store.c:1803
+#, c-format
+#| msgid ""
+#| "Cannot remove folder '%s', it is used for folders of other users only"
+msgid "Cannot remove folder '%s', it is used for public folders only"
+msgstr ""
+"Nem távolítható el a(z) „%s” mappa, mert az csak a nyilvános mappákhoz van "
+"használatban"
+
+#: ../src/camel/camel-ews-store.c:1911
+#, c-format
+msgid "Folder %s does not exist"
+msgstr "A(z) %s mappa nem létezik"
+
+#: ../src/camel/camel-ews-store.c:1921
+#, c-format
+msgid "No change key record for folder %s"
+msgstr "Nem változott a(z) %s mappa fő rekordja"
+
+#: ../src/camel/camel-ews-store.c:1963
+#, c-format
+msgid "Cannot both rename and move a folder at the same time"
+msgstr "Nem lehet egyszerre átnevezni és mozgatni a mappát"
+
+#: ../src/camel/camel-ews-store.c:1999
+#, c-format
+msgid "Cannot find folder ID for parent folder %s"
+msgstr "Nem található a(z) %s szülőmappa mappaazonosítója"
+
+#: ../src/camel/camel-ews-store.c:2049 ../src/camel/camel-ews-transport.c:69
+#, c-format
+msgid "Exchange server %s"
+msgstr "%s Exchange kiszolgáló"
+
+#: ../src/camel/camel-ews-store.c:2052
+#, c-format
+msgid "Exchange service for %s on %s"
+msgstr "Exchange szolgáltatás %s számára ezen: %s"
+
+#: ../src/camel/camel-ews-store.c:2096
+#, c-format
+msgid "Could not locate Trash folder"
+msgstr "A Kuka mappa nem található"
+
+#: ../src/camel/camel-ews-store.c:2131
+#, c-format
+msgid "Could not locate Junk folder"
+msgstr "A Levélszemét mappa nem található"
+
+#: ../src/camel/camel-ews-store.c:2321
+msgid "Cannot subscribe EWS folders in offline mode"
+msgstr "Nem lehet EWS mappákra feliratkozni kapcsolat nélküli módban"
+
+#: ../src/camel/camel-ews-store.c:2339
+#, c-format
+#| msgid "Cannot create folder '%s', folder already exists"
+msgid "Cannot subscribe folder '%s', no public folder available"
+msgstr ""
+"Nem lehet feliratkozni a(z) „%s” mappára, nem érhető el nyilvános mappa"
+
+#: ../src/camel/camel-ews-store.c:2349
+#, c-format
+#| msgid "Cannot subscribe EWS folders in offline mode"
+msgid "Cannot subscribe folder '%s', folder not found"
+msgstr "Nem lehet feliratkozni a(z) „%s” mappára, a mappa nem található"
+
+#: ../src/camel/camel-ews-store.c:2440
+msgid "Cannot unsubscribe EWS folders in offline mode"
+msgstr "Nem lehet EWS mappákról leiratkozni kapcsolat nélküli módban"
+
+#: ../src/camel/camel-ews-store.c:2557
+#, c-format
+msgid "You must be working online to complete this operation"
+msgstr "A művelet befejezéséhez online kell dolgoznia"
+
+#: ../src/camel/camel-ews-transport.c:72
+#, c-format
+msgid "Exchange mail delivery via %s"
+msgstr "Exchange levélkézbesítés %s segítségével"
+
+#: ../src/camel/camel-ews-transport.c:119
+msgid "Cannot send message with no From address"
+msgstr "Nem küldhető el a levél a feladó címe nélkül"
+
+#: ../src/camel/camel-ews-transport.c:125
+msgid "Exchange server cannot send message with multiple From addresses"
+msgstr ""
+"Az Exchange kiszolgáló nem tud több Feladó címmel rendelkező üzenetet küldeni"
+
+#: ../src/camel/camel-ews-transport.c:136
+msgid "Failed to read From address"
+msgstr "Nem sikerült olvasni a feladó címét"
+
+#: ../src/camel/camel-ews-transport.c:148
+#, c-format
+msgid ""
+"Exchange server cannot send message as '%s', when the account was configured "
+"for address '%s'"
+msgstr ""
+"Az Exchange kiszolgáló nem tud „%s”-ként levelet küldeni, ha a fiók a "
+"következő címhez van beállítva: „%s”"
+
+#: ../src/camel/camel-ews-transport.c:162
+#, c-format
+msgid "Service not connected"
+msgstr "Nem kapcsolódott a szolgáltatáshoz"
+
+#: ../src/collection/e-ews-backend.c:428
+#: ../src/configuration/e-mail-config-ews-gal.c:274
+msgid "Global Address List"
+msgstr "Globális címlista"
+
+#: ../src/collection/e-ews-backend.c:813
+#, c-format
+msgid "Could not determine a suitable folder class for a new folder named '%s'"
+msgstr "Nem határozható meg megfelelő mappaosztály a(z) „%s” nevű új mappához"
+
+#: ../src/collection/e-ews-backend.c:902
+#, c-format
+msgid "Data source '%s' does not represent an Exchange Web Services folder"
+msgstr ""
+"A(z) „%s” adatforrás nem az Exchange webszolgáltatások egyik mappáját "
+"képviseli"
+
+#: ../src/configuration/e-ews-config-utils.c:516
+#, c-format
+msgid "Cannot edit permissions of folder '%s', choose other folder."
+msgstr ""
+"Nem szerkeszthetők a(z) „%s” mappa jogosultságai, válasszon másik mappát."
+
+#: ../src/configuration/e-ews-config-utils.c:594
+msgid "Subscribe to folder of other user..."
+msgstr "Feliratkozás más felhasználó mappájára…"
+
+#: ../src/configuration/e-ews-config-utils.c:603
+#: ../src/configuration/e-ews-config-utils.c:884
+#: ../src/configuration/e-ews-config-utils.c:915
+#: ../src/configuration/e-ews-config-utils.c:946
+#: ../src/configuration/e-ews-config-utils.c:977
+msgid "Permissions..."
+msgstr "Jogosultságok…"
+
+#: ../src/configuration/e-ews-config-utils.c:605
+msgid "Edit EWS folder permissions"
+msgstr "EWS mappajogosultságok szerkesztése"
+
+#: ../src/configuration/e-ews-config-utils.c:886
+msgid "Edit EWS calendar permissions"
+msgstr "EWS naptárjogosultságok szerkesztése"
+
+#: ../src/configuration/e-ews-config-utils.c:917
+msgid "Edit EWS tasks permissions"
+msgstr "EWS feladatjogosultságok szerkesztése"
+
+#: ../src/configuration/e-ews-config-utils.c:948
+msgid "Edit EWS memos permissions"
+msgstr "EWS feljegyzésjogosultságok szerkesztése"
+
+#: ../src/configuration/e-ews-config-utils.c:979
+msgid "Edit EWS contacts permissions"
+msgstr "EWS névjegyjogosultságok szerkesztése"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:87
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:499
+msgctxt "PermissionsLevel"
+msgid "None"
+msgstr "Nincs"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:88
+msgctxt "PermissionsLevel"
+msgid "Owner"
+msgstr "Tulajdonos"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:98
+msgctxt "PermissionsLevel"
+msgid "Publishing Editor"
+msgstr "Kiadványszerkesztő"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:107
+msgctxt "PermissionsLevel"
+msgid "Editor"
+msgstr "Szerkesztő"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:115
+msgctxt "PermissionsLevel"
+msgid "Publishing Author"
+msgstr "Kiadványszerző"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:122
+msgctxt "PermissionsLevel"
+msgid "Author"
+msgstr "Szerző"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:128
+msgctxt "PermissionsLevel"
+msgid "Nonediting Author"
+msgstr "Nem szerkesztő szerző"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:133
+msgctxt "PermissionsLevel"
+msgid "Reviewer"
+msgstr "Véleményező"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:136
+msgctxt "PermissionsLevel"
+msgid "Contributor"
+msgstr "Hozzájáruló"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:139
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time"
+msgstr "Időbeosztás"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:141
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time, subject, location"
+msgstr "Időbeosztás ideje, tárgya, helye"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:143
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:520
+msgctxt "PermissionsLevel"
+msgid "Custom"
+msgstr "Egyéni"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:267
+msgid "Writing folder permissions, please wait..."
+msgstr "Mappajogosultságok írása, kis türelmet…"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:759
+msgctxt "User"
+msgid "Anonymous"
+msgstr "Anonymous"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:762
+msgctxt "User"
+msgid "Default"
+msgstr "Alapértelmezett"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:768
+msgctxt "User"
+msgid "Unknown"
+msgstr "Ismeretlen"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:849
+#: ../src/configuration/e-ews-search-user.c:430
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1075
+msgid "Name"
+msgstr "Név"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:855
+msgid "Permission level"
+msgstr "Jogosultsági szint"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:907
+msgid "Edit EWS folder permissions..."
+msgstr "EWS mappajogosultságok szerkesztése…"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:932
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:635
+msgid "Account:"
+msgstr "Fiók:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:960
+msgid "Folder name:"
+msgstr "Mappa neve:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:983
+msgid "Folder ID:"
+msgstr "Mappaazonosító:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1047
+msgid "Permissions"
+msgstr "Jogosultságok"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1069
+msgid "Permi_ssion level:"
+msgstr "J_ogosultsági szint:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1103
+msgctxt "Permissions"
+msgid "Read"
+msgstr "Olvasás"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1115
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1182
+msgctxt "Permissions"
+msgid "None"
+msgstr "Nincs"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1121
+msgctxt "Permissions"
+msgid "Free/Busy time"
+msgstr "Időbeosztás"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1126
+msgctxt "Permissions"
+msgid "Free/Busy time, subject, location"
+msgstr "Időbeosztás ideje, tárgya, helye"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1132
+msgctxt "Permissions"
+msgid "Full Details"
+msgstr "Minden részlet"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1138
+msgctxt "Permissions"
+msgid "Write"
+msgstr "Írás"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1150
+msgctxt "Permissions"
+msgid "Create items"
+msgstr "Elemek létrehozása"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1154
+msgctxt "Permissions"
+msgid "Create subfolders"
+msgstr "Almappák létrehozása"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1158
+msgctxt "Permissions"
+msgid "Edit own"
+msgstr "Saját szerkesztése"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1162
+msgctxt "Permissions"
+msgid "Edit all"
+msgstr "Összes szerkesztése"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1170
+msgctxt "Permissions"
+msgid "Delete items"
+msgstr "Elemek törlése"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1187
+msgctxt "Permissions"
+msgid "Own"
+msgstr "Saját"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1192
+msgctxt "Permissions"
+msgid "All"
+msgstr "Összes"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1198
+msgctxt "Permissions"
+msgid "Other"
+msgstr "Egyéb"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1210
+msgctxt "Permissions"
+msgid "Folder owner"
+msgstr "Mappa tulajdonosa"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1214
+msgctxt "Permissions"
+msgid "Folder contact"
+msgstr "Mappakapcsolat"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1218
+msgctxt "Permissions"
+msgid "Folder visible"
+msgstr "Látható mappa"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1291
+msgid "Reading folder permissions, please wait..."
+msgstr "Mappajogosultságok olvasása, kis türelmet…"
+
+#: ../src/configuration/e-ews-search-user.c:208
+#, c-format
+msgid "No users found, only one contact"
+msgid_plural "No users found, only %d contacts"
+msgstr[0] "Nem találhatók felhasználók, csak egy névjegy"
+msgstr[1] "Nem találhatók felhasználók, csak %d névjegy"
+
+#: ../src/configuration/e-ews-search-user.c:213
+msgid "No users found"
+msgstr "Nem találhatók felhasználók"
+
+#: ../src/configuration/e-ews-search-user.c:217
+#, c-format
+msgid "Found one user"
+msgid_plural "Found %d users"
+msgstr[0] "Egy felhasználó található"
+msgstr[1] "%d felhasználó található"
+
+#: ../src/configuration/e-ews-search-user.c:223
+#, c-format
+msgid "Found more than 100 users, but showing only first %d"
+msgid_plural "Found more than 100 users, but showing only first %d"
+msgstr[0] "100-nál több felhasználó található, de csak az első %d jelenik meg"
+msgstr[1] "100-nál több felhasználó található, de csak az első %d jelenik meg"
+
+#: ../src/configuration/e-ews-search-user.c:356
+#: ../src/configuration/e-ews-search-user.c:539
+msgid "Search for a user"
+msgstr "Felhasználó keresése"
+
+#: ../src/configuration/e-ews-search-user.c:436
+msgid "E-mail"
+msgstr "E-mail"
+
+#: ../src/configuration/e-ews-search-user.c:473
+msgid "Choose EWS user..."
+msgstr "Válasszon EWS felhasználót…"
+
+#: ../src/configuration/e-ews-search-user.c:496
+msgid "_Search:"
+msgstr "_Keresés:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:97
+#: ../src/server/e-ews-folder.c:632
+#, c-format
+msgid "Cannot add folder, folder already exists as '%s'"
+msgstr "A mappa nem vehető fel, mert már létezik „%s” néven"
+
+#. Translators: The '%s' is replaced with user name, to whom the foreign mailbox belongs.
+#. * Example result: "Mailbox - John Smith"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:107
+#, c-format
+msgctxt "ForeignFolder"
+msgid "Mailbox - %s"
+msgstr "%s postafiókja"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:272
+msgid "Cannot test foreign folder availability while in offline mode"
+msgstr ""
+"Kapcsolat nélküli módban nem lehet tesztelni a távoli mappa elérhetőségét"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:297
+#, c-format
+msgid "User '%s' was not found on the server"
+msgstr "„%s” felhasználó nem található a kiszolgálón"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:333
+#, c-format
+msgid "User name '%s' is ambiguous, specify it more precisely, please"
+msgstr "A felhasználónév („%s”) nem egyértelmű, adja meg pontosabban"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:355
+#, c-format
+msgid ""
+"Folder '%s' not found. Either it does not exist or you do not have "
+"permission to access it."
+msgstr ""
+"A mappa („%s”) nem található. Vagy nem létezik, vagy nincs jogosultsága "
+"elérni."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:373
+msgid "Cannot add folder, cannot determine folder's type"
+msgstr "Nem vehető fel a mappa, nem határozható meg a mappa típusa"
+
+#. Translators: This is used to name foreign folder.
+#. * The first '%s' is replaced with user name to whom the folder belongs,
+#. * the second '%s' is replaced with folder name.
+#. * Example result: "John Smith - Calendar"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:418
+#, c-format
+msgctxt "ForeignFolder"
+msgid "%s - %s"
+msgstr "%s – %s"
+
+#. convert well-known names to their non-localized form
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:512
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:720
+msgid "Inbox"
+msgstr "Beérkezett üzenetek"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:514
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:721
+msgid "Contacts"
+msgstr "Névjegyek"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:516
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:722
+msgid "Calendar"
+msgstr "Naptár"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:518
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:723
+msgid "Memos"
+msgstr "Feljegyzések"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:520
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:724
+msgid "Tasks"
+msgstr "Feladatok"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:537
+#, c-format
+msgid "Testing availability of folder '%s' of user '%s', please wait..."
+msgstr ""
+"„%2$s” felhasználó „%1$s” mappájának elérhetőségének tesztelése, kis "
+"türelmet…"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:614
+msgid "Subscribe to folder of other EWS user..."
+msgstr "Feliratkozás más EWS felhasználó mappájára…"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:665
+msgid "User"
+msgstr "Felhasználó"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:672
+msgid "_User:"
+msgstr "_Felhasználó:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:687
+msgid "C_hoose..."
+msgstr "_Válasszon…"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:703
+msgid "_Folder name:"
+msgstr "_Mappa neve:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:733
+msgid "Include _subfolders"
+msgstr "_Almappákat beleértve"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:129
+msgid "Querying Autodiscover service"
+msgstr "Automatikus feltérképezési szolgáltatás lekérdezése"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:212
+msgid "Fetch _URL"
+msgstr "_URL lekérése"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:140
+msgid "Configuration"
+msgstr "Beállítás"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:158
+msgid "User_name:"
+msgstr "_Felhasználónév:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:172
+msgid "_Host URL:"
+msgstr "_Gép URL:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:191
+msgid "OAB U_RL:"
+msgstr "OAB U_RL:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:205
+msgid "Open _Mailbox of other user"
+msgstr "_Más felhasználó postafiókjának megnyitása"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:239
+msgid "S_earch..."
+msgstr "_Keresés…"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:250
+msgid "Authentication"
+msgstr "Hitelesítés"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:500
+msgctxt "PermissionsLevel"
+msgid "Reviewer (can read items)"
+msgstr "Véleményező (olvashat elemeket)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:501
+msgctxt "PermissionsLevel"
+msgid "Author (can read and create items)"
+msgstr "Szerző (olvashat és létrehozhat elemeket)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:502
+msgctxt "PermissionsLevel"
+msgid "Editor (can read, create and modify items)"
+msgstr "Szerkesztő (olvashat, létrehozhat és szerkeszthet elemeket)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:605
+msgid "Delegate permissions"
+msgstr "Meghatalmazott jogosultságai"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:623
+msgid "C_alendar"
+msgstr "_Naptár"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:626
+msgid "_Delegate receives copies of meeting-related messages sent to me"
+msgstr ""
+"_Meghatalmazott másolatokat kap a találkozóval kapcsolatban nekem küldött "
+"üzenetekről"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:631
+msgid "_Tasks"
+msgstr "_Feladatok"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:634
+msgid "_Inbox"
+msgstr "Beérkezett ü_zenetek"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:637
+msgid "C_ontacts"
+msgstr "Névj_egyek"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:640
+msgid "_Notes"
+msgstr "Fel_jegyzések"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:643
+msgid "_Journal"
+msgstr "_Napló"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:646
+#, c-format
+msgid "Delegate '%s' has the following permissions"
+msgstr "„%s” meghatalmazott jogosultságai"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:664
+msgid "Delegate can see my _private items"
+msgstr "Meghatalmazott láthatja s_zemélyes elemeimet"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:987
+msgid "Retrieving current user permissions, please wait..."
+msgstr "Aktuális felhasználó jogosultságainak lekérése, kis türelmet…"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1108
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1638
+msgid "Delegates"
+msgstr "Meghatalmazottak"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1132
+msgid ""
+"Delegates can send items on your behalf, including creating and responding "
+"to meeting requests. If you want to grant folder permissions without giving "
+"send-on-behalf-of permissions, close this dialog box, right-click the "
+"folder, click Permissions and change the options there."
+msgstr ""
+"A meghatalmazottak elemeket küldhetnek az Ön nevében, beleértve "
+"találkozókérések létrehozását és válaszolást azokra. Ha csak "
+"mappajogosultságokat szeretne adni a nevében való küldés joga nélkül, akkor "
+"zárja be ezt az ablakot, kattintson a jobb egérgombbal a mappán, válassza a "
+"Jogosultságok elemet, és módosítsa az ottani beállításokat."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1181
+msgid ""
+"Deliver meeting requests addressed to me and responses to meeting requests "
+"where I am the organizer to:"
+msgstr ""
+"Nekem címzett találkozókérések és az általam szervezett találkozók kéréseire "
+"adott válaszok kézbesítése:"
+
+#. new-line break, because GtkRadioButton doesn't allow wrapping of the inner label
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1190
+msgid ""
+"My delegates only, but _send a copy of meeting requests\n"
+"and responses to me (recommended)"
+msgstr ""
+"Csak megbízottaimnak, de _küldjön másolatot a\n"
+"találkozókérésekről és válaszokról (javasolt)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1197
+msgid "My d_elegates only"
+msgstr "_Csak megbízottaimnak"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1204
+msgid "My delegates a_nd me"
+msgstr "Megbízottaimnak és _nekem"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1713
+msgid "Retrieving \"Delegates\" settings"
+msgstr "„Megbízottak” beállításainak lekérése"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:221
+msgid "Locating offline address books"
+msgstr "Kapcsolat nélküli címjegyzék keresése"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:301
+msgid "Cache o_ffline address book"
+msgstr "_Kapcsolat nélküli címjegyzék gyorsítótárazása"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:327
+msgid "Select ad_dress list:"
+msgstr "Válasszon _címlistát:"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:351
+msgid "Fetch List"
+msgstr "Lista letöltése"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:444
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:923
+msgid "Out of Office"
+msgstr "Házon kívül"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:460
+msgid ""
+"The messages specified below will be automatically sent to each internal and "
+"external person who sends a mail to you."
+msgstr ""
+"Az alább megadott üzenetek automatikusan elküldésre kerülnek minden belső és "
+"külső feladónak, aki Önnek levelet küld."
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:468
+msgid "Do _not send Out of Office replies"
+msgstr "_Ne küldjön házon kívül válaszokat"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:476
+msgid "_Send Out of Office replies"
+msgstr "_Házon kívül válaszok küldése"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:484
+msgid "Send Out of Office replies only _during this time period:"
+msgstr "Házon _kívül válaszok küldése csak ebben az időszakban:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:504
+msgid "_From:"
+msgstr "_Feladó:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:529
+msgid "_To:"
+msgstr "_Címzett:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:554
+msgid "I_nternal:"
+msgstr "B_első:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:563
+msgid "Message to be sent within the organization"
+msgstr "A szervezeten belülre küldendő üzenet"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:590
+msgid "E_xternal:"
+msgstr "_Külső:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:598
+msgid "Message to be sent outside the organization"
+msgstr "A szervezeten kívülre küldendő üzenet"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:608
+msgid "Do not reply to senders outside the organization"
+msgstr "Ne válaszoljon a szervezeten kívüli feladóknak"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:611
+msgid "Reply only to known senders outside the organization"
+msgstr "Válasz csak a szervezeten kívüli ismert feladóknak"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:614
+msgid "Reply to any sender outside the organization"
+msgstr "Válasz a szervezeten kívüli összes feladónak"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:999
+msgid "Retrieving \"Out of Office\" settings"
+msgstr "„Házon kívül” állapot beállításainak lekérése"
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:1
+msgid "Autodiscovery query failed."
+msgstr "Az automatikus felismerés lekérdezése sikertelen."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:2
+msgid "The reported error was &quot;{0}&quot;."
+msgstr "A jelentett hiba: „{0}”."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:3
+msgid "Failed to locate offline address books."
+msgstr "A kapcsolat nélküli címjegyzékek nem találhatók."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:4
+msgid "Failed to retrieve &quot;Out of Office&quot; settings."
+msgstr "Nem sikerült lekérni a „Házon kívül” állapot beállításait."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:5
+msgid "Failed to retrieve &quot;Delegates&quot; settings."
+msgstr "Nem sikerült lekérni a „Megbízottak” beállításait."
+
+#: ../src/server/e-ews-connection.c:493
+msgid "Operation Cancelled"
+msgstr "Művelet megszakítva"
+
+#: ../src/server/e-ews-connection.c:562
+msgid "Authentication failed"
+msgstr "A hitelesítés sikertelen"
+
+#: ../src/server/e-ews-connection.c:573
+#, c-format
+msgid "No response: %s"
+msgstr "Nincs válasz: %s"
+
+#: ../src/server/e-ews-connection.c:1880
+#, c-format
+msgid "Failed to parse autodiscover response XML"
+msgstr "Az automatikus felderítésre adott válasz XML feldolgozása sikertelen"
+
+#: ../src/server/e-ews-connection.c:1887
+#, c-format
+msgid "Failed to find <Autodiscover> element"
+msgstr "Nem sikerült megtalálni az <Autodiscover> elemet"
+
+#: ../src/server/e-ews-connection.c:1898
+#, c-format
+msgid "Failed to find <Response> element"
+msgstr "Nem sikerült megtalálni a <Response> elemet"
+
+#: ../src/server/e-ews-connection.c:1909
+#, c-format
+msgid "Failed to find <Account> element"
+msgstr "Nem sikerült megtalálni az <Account> elemet"
+
+#: ../src/server/e-ews-connection.c:1928
+#, c-format
+msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
+msgstr ""
+"Az <ASUrl> és <OABUrl> nem található az automatikus felderítésre adott "
+"válaszban"
+
+#: ../src/server/e-ews-connection.c:2010
+msgid "URL cannot be NULL"
+msgstr "Az URL nem lehet NULL"
+
+#: ../src/server/e-ews-connection.c:2018
+#, c-format
+msgid "URL '%s' is not valid"
+msgstr "A(z) „%s” URL nem érvényes"
+
+#: ../src/server/e-ews-connection.c:2120
+msgid "Email address is missing a domain part"
+msgstr "Az e-mail címből hiányzik a tartomány rész"
+
+#: ../src/server/e-ews-connection.c:2432
+msgid "Failed to parse oab XML"
+msgstr "Nem sikerült feldolgozni az oab XML-t"
+
+#: ../src/server/e-ews-connection.c:2440
+msgid "Failed to find <OAB> element\n"
+msgstr "Nem sikerült megtalálni az <OAB> elemet\n"
+
+#: ../src/server/e-ews-connection.c:3612
+msgid "No items found"
+msgstr "Nem találhatók elemek"
+
+#: ../src/server/e-ews-folder.c:587
+msgid "Cannot add folder, unsupported folder type"
+msgstr "Nem vehető fel a mappa, nem támogatott a mappa típusa"
+
+#: ../src/server/e-ews-folder.c:592
+msgid "Cannot add folder, master source not found"
+msgstr "Nem vehető fel a mappa, nem található az elsődleges forrás"
+
+#: ../src/utils/ews-camel-common.c:187
+#, c-format
+msgid "CreateItem call failed to return ID for new message"
+msgstr "A CreateItem hívás nem adott vissza új üzenetazonosítót"
+
+#~ msgid ""
+#~ "Cannot list folders available for subscription of Exchange Web Services "
+#~ "account, use 'Subscribe to folder of other user' context menu option "
+#~ "above the account node in the folder tree instead."
+#~ msgstr ""
+#~ "Nem sorolhatók fel az Exchange webszolgáltatások fiókkal feliratkozáshoz "
+#~ "elérhető mappák, használja inkább a mappafa fiókcsomópontja fölötti helyi "
+#~ "menü „Feliratkozás más felhasználó mappájára” menüpontját."
+
+#~ msgid "Insufficient memory"
+#~ msgstr "Nincs elég memória"
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/id.po evolution-ews.sync-with-3.8.2/po/id.po
--- evolution-ews.git-gnome-3-0/po/id.po	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/po/id.po	2013-05-29 08:46:45.665987863 +0200
@@ -0,0 +1,1037 @@
+# Indonesian translation for evolution-ews.
+# Copyright (C) 2012 evolution-ews' COPYRIGHT HOLDER
+# This file is distributed under the same license as the evolution-ews package.
+# Andika Triwidada <andika@gmail.com>, 2012.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: evolution-ews gnome-3-6\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
+"product=evolution-ews&keywords=I18N+L10N&component=general\n"
+"POT-Creation-Date: 2012-09-23 15:44+0000\n"
+"PO-Revision-Date: 2012-10-07 12:56+0700\n"
+"Last-Translator: Andika Triwidada <andika@gmail.com>\n"
+"Language-Team: Indonesian <gnome@i15n.org>\n"
+"Language: id\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=1; plural=0;\n"
+"X-Generator: Poedit 1.5.3\n"
+
+#: ../src/addressbook/e-book-backend-ews.c:980
+msgid "The backend does not support bulk additions"
+msgstr "Backend tak mendukung penambahan masal"
+
+#: ../src/addressbook/e-book-backend-ews.c:1264
+msgid "The backend does not support bulk modifications"
+msgstr "Backend tak mendukung pengubahan masal"
+
+#: ../src/addressbook/e-book-backend-ews.c:1447
+msgid "Wait till syncing is done"
+msgstr "Menunggu sampai penyelarasan selesai"
+
+#: ../src/addressbook/e-book-backend-ews.c:1785
+#, c-format
+msgid "Downloading contacts in %s %d%% completed... "
+msgstr "Mengunduh kontak dalam %s %d%% komplit..."
+
+#: ../src/addressbook/e-book-backend-ews.c:2301
+msgid "Syncing contacts..."
+msgstr "Menyelaraskan kontak…"
+
+#: ../src/addressbook/e-book-backend-ews.c:2504
+#: ../src/configuration/e-ews-search-user.c:361
+msgid "Searching..."
+msgstr "Mencari…"
+
+#: ../src/addressbook/ews-book-backend-sqlitedb.c:478
+#, c-format
+msgid "Insufficient memory"
+msgstr "Memori tidak cukup"
+
+#: ../src/calendar/e-cal-backend-ews.c:1060
+msgid "EWS does not support bulk removals"
+msgstr "EWS tak mendukung penghapusan masa"
+
+#: ../src/calendar/e-cal-backend-ews.c:1645
+msgid "EWS does not support bulk additions"
+msgstr "EWS tak mendukung penambahan masal"
+
+#: ../src/calendar/e-cal-backend-ews.c:2147
+msgid "EWS does not support bulk modifications"
+msgstr "EWS tak mendukung pengubahan masal"
+
+#: ../src/camel/camel-ews-folder.c:267
+#, c-format
+msgid "Unable to open mimecontent temporary file!"
+msgstr "Tak bisa membuka berkas temporer mimecontent!"
+
+#: ../src/camel/camel-ews-folder.c:275
+#, c-format
+msgid "Unable to generate parser from mimecontent!"
+msgstr "Tak bisa menghasilkan pengurai dari mimecontent!"
+
+#: ../src/camel/camel-ews-folder.c:284
+#, c-format
+msgid "Unable to parse meeting request mimecontent!"
+msgstr "Tak bisa mengura mimecontent permintaan rapat!"
+
+#: ../src/camel/camel-ews-folder.c:344
+#, c-format
+msgid "Unable to create cache file"
+msgstr "Tak bisa membuat berkas singgahan"
+
+#: ../src/camel/camel-ews-folder.c:449 ../src/camel/camel-ews-folder.c:529
+#, c-format
+msgid "Unable to create cache path"
+msgstr "Tak bisa membuat path singgahan"
+
+#: ../src/camel/camel-ews-folder.c:539
+#, c-format
+msgid "Failed to move message cache file"
+msgstr "Gagal memindah berkas singgahan pesan"
+
+#: ../src/camel/camel-ews-folder.c:1140
+#, c-format
+msgid "Could not load summary for %s"
+msgstr "Tak bisa memuat ringkasan untuk %s"
+
+#: ../src/camel/camel-ews-folder.c:1529
+#, c-format
+msgid "Cant perform actions on the folder while in offline mode"
+msgstr "Tak bisa melakukan aksi pada folder ketika dalam mode luring"
+
+#: ../src/camel/camel-ews-provider.c:48
+msgid "Checking for new mail"
+msgstr "Sedang memeriksa surat baru"
+
+#: ../src/camel/camel-ews-provider.c:50
+msgid "C_heck for new messages in all folders"
+msgstr "C_ek pesan baru dalam semua folder"
+
+#: ../src/camel/camel-ews-provider.c:53
+msgid "Options"
+msgstr "Opsi"
+
+#: ../src/camel/camel-ews-provider.c:55
+msgid "_Apply filters to new messages in Inbox on this server"
+msgstr "Ter_apkan penyaring pada pesan baru dalam Kotak Masuk pada server ini"
+
+#: ../src/camel/camel-ews-provider.c:57
+msgid "Check new messages for _Junk contents"
+msgstr "Periksa pesan baru untuk isi _Spam"
+
+#: ../src/camel/camel-ews-provider.c:59
+msgid "Only check for Junk messages in the IN_BOX folder"
+msgstr "Ha_nya periksa pesan SPAM pada folder IN_BOX"
+
+#: ../src/camel/camel-ews-provider.c:61
+msgid "Automatically synchroni_ze remote mail locally"
+msgstr "Otomatis men_sinkronkan surat jauh ke lokal"
+
+#: ../src/camel/camel-ews-provider.c:64
+msgid "Connection"
+msgstr "Koneksi"
+
+#. Translators: '%s' is preplaced with a widget, where "
+#. * user can select how long the timeout should be.
+#: ../src/camel/camel-ews-provider.c:68
+#, c-format
+msgid "Connection _timeout (in seconds) %s"
+msgstr "Tenggang wak_tu koneksi (dalam detik) %s"
+
+#: ../src/camel/camel-ews-provider.c:76
+msgid "Exchange Web Services"
+msgstr "Layanan Web Exchange"
+
+#: ../src/camel/camel-ews-provider.c:78
+msgid "For accessing Exchange servers using Web Services"
+msgstr "Untuk mengakses server Exchange memakai Layanan Web"
+
+#: ../src/camel/camel-ews-provider.c:93
+msgid "NTLM"
+msgstr "NTLM"
+
+#: ../src/camel/camel-ews-provider.c:95
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with NTLM authentication."
+msgstr ""
+"Opsi ini akan menyambung ke server Exchange menggunakan sandi teks polos "
+"dengan otentikasi NTLM."
+
+#: ../src/camel/camel-ews-provider.c:103
+msgid "Basic"
+msgstr "Dasar"
+
+#: ../src/camel/camel-ews-provider.c:105
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with Basic authentication."
+msgstr ""
+"Opsi ini akan menyambung ke server Exchange menggunakan sandi teks polos "
+"dengan otentikasi Dasar."
+
+#: ../src/camel/camel-ews-store.c:183
+#, c-format
+msgid "Session has no storage path"
+msgstr "Sesi tak memiliki path penyimpanan"
+
+#: ../src/camel/camel-ews-store.c:281
+#, c-format
+msgctxt "ForeignFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:525
+msgid "Authentication password not available"
+msgstr "Sandi otentikasi tak tersedia"
+
+#: ../src/camel/camel-ews-store.c:640
+msgid "Query for authentication types is not supported"
+msgstr "Query bagi tipe otentikasi tak didukung"
+
+#: ../src/camel/camel-ews-store.c:692
+#, c-format
+msgid "No such folder: %s"
+msgstr "Tak ada folder begitu: %s"
+
+#: ../src/camel/camel-ews-store.c:839
+msgid ""
+"Cannot list folders available for subscription of Exchange Web Services "
+"account, use 'Subscribe to folder of other user' context menu option above "
+"the account node in the folder tree instead."
+msgstr ""
+"Tak bisa mendapat daftar folder yang tersedia untuk dilanggani dari akun "
+"Layanan Web Exchange, gunakan opsi menu konteks 'Berlangganan ke folder dari "
+"pengguna lain' di atas node akun dalam pohon folder saja."
+
+#: ../src/camel/camel-ews-store.c:932
+#, c-format
+msgid "Cannot create folder '%s', folder already exists"
+msgstr "Tak bisa membuat folder '%s', folder telah ada"
+
+#: ../src/camel/camel-ews-store.c:947
+#, c-format
+msgid "Parent folder %s does not exist"
+msgstr "Folder induk %s tidak ada"
+
+#: ../src/camel/camel-ews-store.c:957
+#, c-format
+msgid ""
+"Cannot create folder under '%s', it is used for folders of other users only"
+msgstr ""
+"Tak bisa membuat folder di bawah '%s', itu hanya dipakai bagi folder "
+"pengguna lain"
+
+#: ../src/camel/camel-ews-store.c:1026
+#, c-format
+msgid "Folder does not exist"
+msgstr "Folder tidak ada"
+
+#: ../src/camel/camel-ews-store.c:1035
+#, c-format
+msgid "Cannot remove folder '%s', it is used for folders of other users only"
+msgstr ""
+"Tak bisa menghapus folder '%s', itu hanya dipakai bagi folder pengguna lain"
+
+#: ../src/camel/camel-ews-store.c:1142
+#, c-format
+msgid "Folder %s does not exist"
+msgstr "Folder %s tidak ada"
+
+#: ../src/camel/camel-ews-store.c:1152
+#, c-format
+msgid "No change key record for folder %s"
+msgstr "Tidak ada catatan kunci perubahan bagi folder %s"
+
+#: ../src/camel/camel-ews-store.c:1194
+#, c-format
+msgid "Cannot both rename and move a folder at the same time"
+msgstr "Tak bisa sekaligus mengubah nama dan memindah folder di saat yang sama"
+
+#: ../src/camel/camel-ews-store.c:1230
+#, c-format
+msgid "Cannot find folder ID for parent folder %s"
+msgstr "Tak bisa temukan ID folder bagi folder induk %s"
+
+#: ../src/camel/camel-ews-store.c:1280 ../src/camel/camel-ews-transport.c:69
+#, c-format
+msgid "Exchange server %s"
+msgstr "Server Exchange %s"
+
+#: ../src/camel/camel-ews-store.c:1283
+#, c-format
+msgid "Exchange service for %s on %s"
+msgstr "Layanan Exchange untuk %s pada %s"
+
+#: ../src/camel/camel-ews-store.c:1327
+#, c-format
+msgid "Could not locate Trash folder"
+msgstr "Tak bisa temukan folder Tong Sampah"
+
+#: ../src/camel/camel-ews-store.c:1362
+#, c-format
+msgid "Could not locate Junk folder"
+msgstr "Tak bisa temukan folder Sampah"
+
+#: ../src/camel/camel-ews-store.c:1440
+msgid "Cannot subscribe EWS folders in offline mode"
+msgstr "Tak bisa berlangganan folder EWS dalam mode luring"
+
+#: ../src/camel/camel-ews-store.c:1462
+msgid "Cannot unsubscribe EWS folders in offline mode"
+msgstr "Tak bisa berhenti berlangganan folder EWS dalam mode luring"
+
+#: ../src/camel/camel-ews-store.c:1504
+#, c-format
+msgid "You must be working online to complete this operation"
+msgstr "Anda mesti daring untuk menuntaskan operasi ini"
+
+#: ../src/camel/camel-ews-transport.c:72
+#, c-format
+msgid "Exchange mail delivery via %s"
+msgstr "Pengantaran surel Exchange melalui %s"
+
+#: ../src/camel/camel-ews-transport.c:120
+msgid "Cannot send message with no From address"
+msgstr "Tak bisa mengirim pesan tanpa alamat Dari"
+
+#: ../src/camel/camel-ews-transport.c:126
+msgid "Exchange server cannot send message with multiple From addresses"
+msgstr "Server Exchange tak bisa mengirim pesan dengan alamat Dari berganda"
+
+#: ../src/camel/camel-ews-transport.c:137
+msgid "Failed to read From address"
+msgstr "Gagal membaca alamat Dari"
+
+#: ../src/camel/camel-ews-transport.c:149
+#, c-format
+msgid ""
+"Exchange server cannot send message as '%s', when the account was configured "
+"for address '%s'"
+msgstr ""
+"Server Exchange tak bisa mengirim pesan sebagai '%s', ketika akun ditata "
+"bagi alamat '%s'"
+
+#: ../src/camel/camel-ews-transport.c:163
+#, c-format
+msgid "Service not connected"
+msgstr "Layanan tidak tersambung"
+
+#: ../src/collection/e-ews-backend.c:382
+#: ../src/configuration/e-mail-config-ews-gal.c:268
+msgid "Global Address List"
+msgstr "Daftar Alamat Global"
+
+#: ../src/collection/e-ews-backend.c:767
+#, c-format
+msgid "Could not determine a suitable folder class for a new folder named '%s'"
+msgstr ""
+"Tak bisa menentukan kelas folder yang cocok bagi folder baru bernama '%s'"
+
+#: ../src/collection/e-ews-backend.c:858
+#, c-format
+msgid "Data source '%s' does not represent an Exchange Web Services folder"
+msgstr ""
+"Sumber data '%s' tak merepresentasikan suatu folder Layanan Web Exchange"
+
+#: ../src/configuration/e-ews-config-utils.c:510
+#, c-format
+msgid "Cannot edit permissions of folder '%s', choose other folder."
+msgstr "Tak bisa menyunting hak akses folder '%s', pilih folder lain."
+
+#: ../src/configuration/e-ews-config-utils.c:588
+msgid "Subscribe to folder of other user..."
+msgstr "Berlangganan ke folder milik pengguna lain…"
+
+#: ../src/configuration/e-ews-config-utils.c:597
+#: ../src/configuration/e-ews-config-utils.c:878
+#: ../src/configuration/e-ews-config-utils.c:909
+#: ../src/configuration/e-ews-config-utils.c:940
+#: ../src/configuration/e-ews-config-utils.c:971
+msgid "Permissions..."
+msgstr "Izin…"
+
+#: ../src/configuration/e-ews-config-utils.c:599
+msgid "Edit EWS folder permissions"
+msgstr "Sunting hak akses folder EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:880
+msgid "Edit EWS calendar permissions"
+msgstr "Sunting hak akses kalender EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:911
+msgid "Edit EWS tasks permissions"
+msgstr "Sunting hak akses tugas EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:942
+msgid "Edit EWS memos permissions"
+msgstr "Sunting hak akses memo EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:973
+msgid "Edit EWS contacts permissions"
+msgstr "Sunting hak akses kontak EWS"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:87
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:502
+msgctxt "PermissionsLevel"
+msgid "None"
+msgstr "Nihil"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:88
+msgctxt "PermissionsLevel"
+msgid "Owner"
+msgstr "Pemilik"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:98
+msgctxt "PermissionsLevel"
+msgid "Publishing Editor"
+msgstr "Penyunting Penerbit"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:107
+msgctxt "PermissionsLevel"
+msgid "Editor"
+msgstr "Penyunting"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:115
+msgctxt "PermissionsLevel"
+msgid "Publishing Author"
+msgstr "Penulis Penerbit"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:122
+msgctxt "PermissionsLevel"
+msgid "Author"
+msgstr "Penulis"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:128
+msgctxt "PermissionsLevel"
+msgid "Nonediting Author"
+msgstr "Penulis Nonpenyuntingan"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:133
+msgctxt "PermissionsLevel"
+msgid "Reviewer"
+msgstr "Pemeriksa"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:136
+msgctxt "PermissionsLevel"
+msgid "Contributor"
+msgstr "Penyumbang"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:139
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time"
+msgstr "Waktu luang/sibuk"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:141
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time, subject, location"
+msgstr "Waktu luang/sibuk, subjek, lokasi"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:143
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:523
+msgctxt "PermissionsLevel"
+msgid "Custom"
+msgstr "Gubahan"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:267
+msgid "Writing folder permissions, please wait..."
+msgstr "Sedang menulis hak akses folder, silakan tunggu…"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:759
+msgctxt "User"
+msgid "Anonymous"
+msgstr "Anonim"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:762
+msgctxt "User"
+msgid "Default"
+msgstr "Baku"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:768
+msgctxt "User"
+msgid "Unknown"
+msgstr "Tak dikenal"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:849
+#: ../src/configuration/e-ews-search-user.c:427
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1078
+msgid "Name"
+msgstr "Nama"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:855
+msgid "Permission level"
+msgstr "Aras hak akses"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:907
+msgid "Edit EWS folder permissions..."
+msgstr "Sunting hak akses folder EWS…"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:932
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:621
+msgid "Account:"
+msgstr "Akun:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:960
+msgid "Folder name:"
+msgstr "Nama folder:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:983
+msgid "Folder ID:"
+msgstr "ID folder:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1047
+msgid "Permissions"
+msgstr "Izin"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1069
+msgid "Permi_ssion level:"
+msgstr "Ara_s hak akses:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1103
+msgctxt "Permissions"
+msgid "Read"
+msgstr "Baca"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1115
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1182
+msgctxt "Permissions"
+msgid "None"
+msgstr "Nihil"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1121
+msgctxt "Permissions"
+msgid "Free/Busy time"
+msgstr "Waktu luang/sibuk"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1126
+msgctxt "Permissions"
+msgid "Free/Busy time, subject, location"
+msgstr "Waktu luang/sibuk, subjek, lokasi"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1132
+msgctxt "Permissions"
+msgid "Full Details"
+msgstr "Rincian Lengkap"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1138
+msgctxt "Permissions"
+msgid "Write"
+msgstr "Tulis"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1150
+msgctxt "Permissions"
+msgid "Create items"
+msgstr "Buat butir"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1154
+msgctxt "Permissions"
+msgid "Create subfolders"
+msgstr "Buat subfolder"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1158
+msgctxt "Permissions"
+msgid "Edit own"
+msgstr "Sunting milik sendiri"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1162
+msgctxt "Permissions"
+msgid "Edit all"
+msgstr "Sunting semua"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1170
+msgctxt "Permissions"
+msgid "Delete items"
+msgstr "Hapus butir"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1187
+msgctxt "Permissions"
+msgid "Own"
+msgstr "Milik sendiri"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1192
+msgctxt "Permissions"
+msgid "All"
+msgstr "Semua"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1198
+msgctxt "Permissions"
+msgid "Other"
+msgstr "Lainnya"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1210
+msgctxt "Permissions"
+msgid "Folder owner"
+msgstr "Folder pemilik"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1214
+msgctxt "Permissions"
+msgid "Folder contact"
+msgstr "Folder kontak"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1218
+msgctxt "Permissions"
+msgid "Folder visible"
+msgstr "Folder nampak"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1291
+msgid "Reading folder permissions, please wait..."
+msgstr "Sedang membaca hak akses folder, silakan tunggu…"
+
+#: ../src/configuration/e-ews-search-user.c:208
+#, c-format
+msgid "No users found, only one contact"
+msgid_plural "No users found, only %d contacts"
+msgstr[0] "Tak ditemukan pengguna, hanya %d kontak"
+
+#: ../src/configuration/e-ews-search-user.c:213
+msgid "No users found"
+msgstr "Tak ditemukan pengguna"
+
+#: ../src/configuration/e-ews-search-user.c:217
+#, c-format
+msgid "Found one user"
+msgid_plural "Found %d users"
+msgstr[0] "Ditemukan %d pengguna"
+
+#: ../src/configuration/e-ews-search-user.c:223
+#, c-format
+msgid "Found more than 100 users, but showing only first %d"
+msgid_plural "Found more than 100 users, but showing only first %d"
+msgstr[0] ""
+"Ditemukan lebih dari 100 pengguna, tapi hanya menampilkan %d pertama"
+
+#: ../src/configuration/e-ews-search-user.c:353
+#: ../src/configuration/e-ews-search-user.c:536
+msgid "Search for a user"
+msgstr "Cari seorang pengguna"
+
+#: ../src/configuration/e-ews-search-user.c:433
+msgid "E-mail"
+msgstr "Surel"
+
+#: ../src/configuration/e-ews-search-user.c:470
+msgid "Choose EWS user..."
+msgstr "Pilih pengguna EWS…"
+
+#: ../src/configuration/e-ews-search-user.c:493
+msgid "_Search:"
+msgstr "_Cari:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:96
+#: ../src/server/e-ews-folder.c:584
+#, c-format
+msgid "Cannot add folder, folder already exists as '%s'"
+msgstr "Tak bisa menambah folder, folder telah ada sebagai '%s'"
+
+#. Translators: The '%s' is replaced with user name, to whom the foreign mailbox belongs.
+#. * Example result: "Mailbox - John Smith"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:106
+#, c-format
+msgctxt "ForeignFolder"
+msgid "Mailbox - %s"
+msgstr "Kotak surat - %s"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:264
+msgid "Cannot test foreign folder availability while in offline mode"
+msgstr "Tak bisa menguji ketersediaan folder asing ketika dalam mode luring"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:289
+#, c-format
+msgid "User '%s' was not found on the server"
+msgstr "Pengguna '%s' tak ditemukan pada server"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:325
+#, c-format
+msgid "User name '%s' is ambiguous, specify it more precisely, please"
+msgstr "Nama pengguna '%s' ambigu, harap nyatakan secara lebih presisi"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:347
+#, c-format
+msgid ""
+"Folder '%s' not found. Either it does not exist or you do not have "
+"permission to access it."
+msgstr ""
+"Folder '%s' tak ditemukan. Entah itu tak ada atau Anda tak punya hak untuk "
+"mengaksesnya."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:365
+msgid "Cannot add folder, cannot determine folder's type"
+msgstr "Tak bisa menambah folder, tak bisa menentukan tipe folder"
+
+#. Translators: This is used to name foreign folder.
+#. * The first '%s' is replaced with user name to whom the folder belongs,
+#. * the second '%s' is replaced with folder name.
+#. * Example result: "John Smith - Calendar"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:410
+#, c-format
+msgctxt "ForeignFolder"
+msgid "%s - %s"
+msgstr "%s - %s"
+
+#. convert well-known names to their non-localized form
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:500
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:706
+msgid "Inbox"
+msgstr "Inbox"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:502
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:707
+msgid "Contacts"
+msgstr "Kontak"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:504
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:708
+msgid "Calendar"
+msgstr "Kalender"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:506
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:709
+msgid "Memos"
+msgstr "Memo"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:508
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:710
+msgid "Tasks"
+msgstr "Tugas"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:524
+#, c-format
+msgid "Testing availability of folder '%s' of user '%s', please wait..."
+msgstr "Menguji ketersediaan folder '%s' dari pengguna '%s', silakan tunggu…"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:600
+msgid "Subscribe to folder of other EWS user..."
+msgstr "Berlangganan ke folder pengguna EWS lain…"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:651
+msgid "User"
+msgstr "Pengguna"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:658
+msgid "_User:"
+msgstr "Pengg_una:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:673
+msgid "C_hoose..."
+msgstr "_Pilih…"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:689
+msgid "_Folder name:"
+msgstr "Nama _folder:"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:126
+msgid "Querying Autodiscover service"
+msgstr "Mengquery layanan Autodiscover"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:209
+msgid "Fetch _URL"
+msgstr "_URL Ambil"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:109
+msgid "Configuration"
+msgstr "Konfigurasi"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:127
+msgid "User_name:"
+msgstr "_Nama pengguna:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:141
+msgid "_Host URL:"
+msgstr "URL _Host:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:160
+msgid "OAB U_RL:"
+msgstr "U_RL OAB:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:174
+msgid "Authentication"
+msgstr "Otentikasi"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:215
+msgid "Locating offline address books"
+msgstr "Mencari buku alamat luring"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:295
+msgid "Cache o_ffline address book"
+msgstr "_Singgahkan buku alamat luring"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:321
+msgid "Select ad_dress list:"
+msgstr "Pilih _daftar alamat:"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:345
+msgid "Fetch List"
+msgstr "Ambil Daftar"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:503
+msgctxt "PermissionsLevel"
+msgid "Reviewer (can read items)"
+msgstr "Pemeriksa (dapat membaca butir)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:504
+msgctxt "PermissionsLevel"
+msgid "Author (can read and create items)"
+msgstr "Penulis (bisa membaca dan membuat butir-butir)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:505
+msgctxt "PermissionsLevel"
+msgid "Editor (can read, create and modify items)"
+msgstr "Penyunting (dapat membaca, membuat, dan mengubah butir)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:608
+msgid "Delegate permissions"
+msgstr "Delegasikan hak"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:626
+msgid "C_alendar"
+msgstr "K_alender"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:629
+msgid "_Delegate receives copies of meeting-related messages sent to me"
+msgstr ""
+"Men_delegasikan penerimaan salinan pesan terkait rapat yang dikirim ke saya"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:634
+msgid "_Tasks"
+msgstr "_Tugas"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:637
+msgid "_Inbox"
+msgstr "_Inbox"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:640
+msgid "C_ontacts"
+msgstr "K_ontak"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:643
+msgid "_Notes"
+msgstr "Catata_n"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:646
+msgid "_Journal"
+msgstr "_Jurnal"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:649
+#, c-format
+msgid "Delegate '%s' has the following permissions"
+msgstr "Delegasi '%s' memiliki hak berikut"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:667
+msgid "Delegate can see my _private items"
+msgstr "Delegasi dapat melihat butir-butir _pribadi saya"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:990
+msgid "Retrieving current user permissions, please wait..."
+msgstr "Mengambil info hak pengguna kini, harap tunggu..."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1111
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1641
+msgid "Delegates"
+msgstr "Delegasi"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1135
+msgid ""
+"Delegates can send items on your behalf, including creating and responding "
+"to meeting requests. If you want to grant folder permissions without giving "
+"send-on-behalf-of permissions, close this dialog box, right-click the "
+"folder, click Permissions and change the options there."
+msgstr ""
+"Delegasi dapat mengirim butir-butir atas nama Anda, termasuk membuat dan "
+"merespon permintaan rapat. Bila Anda ingin memberi hak folder tanpa memberi "
+"hak kirim-atas-nama, tutup kotak dialog ini, klik kanan pada folder, klik "
+"Hak, dan ubah opsi di sana."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1184
+msgid ""
+"Deliver meeting requests addressed to me and responses to meeting requests "
+"where I am the organizer to:"
+msgstr ""
+"Kirim permintaan rapat yang dialamatkan ke saya dan respon ke permintaan "
+"rapat dimana saya adalah pengelolanya ke:"
+
+#. new-line break, because GtkRadioButton doesn't allow wrapping of the inner label
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1193
+msgid ""
+"My delegates only, but _send a copy of meeting requests\n"
+"and responses to me (recommended)"
+msgstr ""
+"Hanya delegasi saya, tapi kirim _salinan permintaan rapat\n"
+"dan respon ke saya (disarankan)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1200
+msgid "My d_elegates only"
+msgstr "Hanya d_elegasi saya"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1207
+msgid "My delegates a_nd me"
+msgstr "Delegasi saya da_n saya"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1716
+msgid "Retrieving \"Delegates\" settings"
+msgstr "Mengambil pengaturan \"Delegasi\""
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:446
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:925
+msgid "Out of Office"
+msgstr "Keluar Kantor"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:462
+msgid ""
+"The messages specified below will be automatically sent to each internal and "
+"external person who sends a mail to you."
+msgstr ""
+"Pesan yang dinyatakan di bawah akan secara otomatis dikirim ke setiap orang "
+"internal dan eksternal yang mengirim surel ke Anda."
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:470
+msgid "Do _not send Out of Office replies"
+msgstr "Janga_n kirim jawaban Di Luar Kantor"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:478
+msgid "_Send Out of Office replies"
+msgstr "_Kirim jawaban Di Luar Kantor"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:486
+msgid "Send Out of Office replies only _during this time period:"
+msgstr "Kirim jawaban Di Luar Kantor hanya selama perio_da ini:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:506
+msgid "_From:"
+msgstr "_Dari:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:531
+msgid "_To:"
+msgstr "_Kepada:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:556
+msgid "I_nternal:"
+msgstr "I_nternal:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:565
+msgid "Message to be sent within the organization"
+msgstr "Pesan akan dikim di dalam organisasi"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:592
+msgid "E_xternal:"
+msgstr "E_ksternal:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:600
+msgid "Message to be sent outside the organization"
+msgstr "Pesan akan dikim di luar organisasi"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:610
+msgid "Do not reply to senders outside the organization"
+msgstr "Jangan kirim jawaban ke pengirim di luar organisasi"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:613
+msgid "Reply only to known senders outside the organization"
+msgstr "Jawab hanya ke pengirim yang dikenal di luar organisasi"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:616
+msgid "Reply to any sender outside the organization"
+msgstr "Balas ke pengirim manapun di luar organisasi"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:1001
+msgid "Retrieving \"Out of Office\" settings"
+msgstr "Mengambail pengaturan \"Di Luar Kantor\""
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:1
+msgid "Autodiscovery query failed."
+msgstr "Query penemuan otomatis gagal."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:2
+msgid "The reported error was &quot;{0}&quot;."
+msgstr "Galat yang dilaporkan adalah &quot;{0}&quot;."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:3
+msgid "Failed to locate offline address books."
+msgstr "Gagal temukan buku alamat luring."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:4
+msgid "Failed to retrieve &quot;Out of Office&quot; settings."
+msgstr "Gagal mengambil pengatura &quot;Di Luar Kantor&quot;."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:5
+msgid "Failed to retrieve &quot;Delegates&quot; settings."
+msgstr "Gagal mengambil pengaturan &quot;Delegasi&quot;."
+
+#: ../src/server/e-ews-connection.c:488
+msgid "Operation Cancelled"
+msgstr "Operasi Dibatalkan"
+
+#: ../src/server/e-ews-connection.c:557
+msgid "Authentication failed"
+msgstr "Otentikasi gagal"
+
+#: ../src/server/e-ews-connection.c:568
+#, c-format
+msgid "No response: %s"
+msgstr "Tak ada respon: %s"
+
+#: ../src/server/e-ews-connection.c:1852
+#, c-format
+msgid "Failed to parse autodiscover response XML"
+msgstr "Gagal mengurai XML respon autodiscover"
+
+#: ../src/server/e-ews-connection.c:1859
+#, c-format
+msgid "Failed to find <Autodiscover> element"
+msgstr "Gagal menemukan elemen <Autodiscover>"
+
+#: ../src/server/e-ews-connection.c:1870
+#, c-format
+msgid "Failed to find <Response> element"
+msgstr "Gagal menemukan elemen <Response>"
+
+#: ../src/server/e-ews-connection.c:1881
+#, c-format
+msgid "Failed to find <Account> element"
+msgstr "Gagal menemukan elemen <Account>"
+
+#: ../src/server/e-ews-connection.c:1900
+#, c-format
+msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
+msgstr "Gagal menemukan <ASUrl> dan <OABUrl> dalam respon autodiscover"
+
+#: ../src/server/e-ews-connection.c:1980
+msgid "URL cannot be NULL"
+msgstr "URL tak boleh NULL"
+
+#: ../src/server/e-ews-connection.c:1987
+#, c-format
+msgid "URL '%s' is not valid"
+msgstr "URL '%s' tak valid"
+
+#: ../src/server/e-ews-connection.c:2089
+msgid "Email address is missing a domain part"
+msgstr "Alamat surel kurang bagian domain"
+
+#: ../src/server/e-ews-connection.c:2359
+msgid "Failed to parse oab XML"
+msgstr "Gagal mengurai XML oab"
+
+#: ../src/server/e-ews-connection.c:2367
+msgid "Failed to find <OAB> element\n"
+msgstr "Gagal menemukan elemen <OAB>\n"
+
+#: ../src/server/e-ews-connection.c:3509
+msgid "No items found"
+msgstr "Tak temukan butir"
+
+#: ../src/server/e-ews-folder.c:539
+msgid "Cannot add folder, unsupported folder type"
+msgstr "Tak bisa menambah folder, tipe folder tak didukung"
+
+#: ../src/server/e-ews-folder.c:544
+msgid "Cannot add folder, master source not found"
+msgstr "Tak bisa menambah folder, sumber induk tak ditemukan"
+
+#: ../src/utils/ews-camel-common.c:176
+#, c-format
+msgid "CreateItem call failed to return ID for new message"
+msgstr "Pemanggilan CreateItem gagal mengembalikan ID bagi pesan baru"
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/LINGUAS evolution-ews.sync-with-3.8.2/po/LINGUAS
--- evolution-ews.git-gnome-3-0/po/LINGUAS	2013-05-17 14:36:16.324555251 +0200
+++ evolution-ews.sync-with-3.8.2/po/LINGUAS	2013-05-29 08:46:45.664988876 +0200
@@ -1,5 +1,20 @@
 # Keep this list sorted alphabetically
+cs
+da
 de
+en_GB
 es
+fr
+gl
+hu
+id
+lv
+mr
+nb
 pl
+pt_BR
 sl
+sr
+sr@latin
+sv
+zh_CN
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/lv.po evolution-ews.sync-with-3.8.2/po/lv.po
--- evolution-ews.git-gnome-3-0/po/lv.po	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/po/lv.po	2013-05-29 08:46:45.664988876 +0200
@@ -0,0 +1,521 @@
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+# Rūdolfs Mazurs <rudolfs.mazurs@gmail.com>, 2012.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: \n"
+"Report-Msgid-Bugs-To: \n"
+"POT-Creation-Date: 2012-06-20 19:50+0300\n"
+"PO-Revision-Date: 2012-06-20 19:55+0300\n"
+"Last-Translator: Rūdolfs Mazurs <rudolfs.mazurs@gmail.com>\n"
+"Language-Team: Latviešu <lata-l10n@googlegroups.com>\n"
+"Language: lv\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n != 0 ? 1 : "
+"2);\n"
+"X-Generator: Lokalize 1.4\n"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-listener.c:246
+msgid "Global Address list"
+msgstr "Globāls adrešu saraksts"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:188
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:200
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:217
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:231
+msgid "Cannot set Date-Time in Past"
+msgstr "Nevar iestatīt datumu un laiku pagātnē"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:207
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:238
+msgid "Select a valid time range"
+msgstr "Izvēlieties derīgu laika apgabalu"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:318
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:359
+#, c-format
+msgid ""
+"Unable to fetch out of office settings: \n"
+"%s"
+msgstr ""
+"Nevar saņemt “ārpus biroja” iestatījumus: \n"
+"%s"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:350
+msgid ""
+"The messages specified below will be automatically sent to \n"
+" each internal and external personal who sends a mail to you."
+msgstr ""
+"Zemāk uzrakstītais ziņojums tiks automātiski nosūtīts katrai \n"
+"iekšējai vai ārējai personai, kas nosūtīs jums vēstuli."
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:355
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:695
+msgid "Status:"
+msgstr "Statuss:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:360
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:365
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:702
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:707
+msgid "I am _out of the office"
+msgstr "Esmu ārpus biroja"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:361
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:364
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:703
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:706
+msgid "I am _in the office"
+msgstr "Esmu birojā"
+
+#. Check box for setting date
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:374
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:717
+msgid "_Send only during this time period"
+msgstr "_Sūtīt tikai šajā laika periodā"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:392
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:740
+msgid "_From:"
+msgstr "_No:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:397
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:745
+msgid "_To:"
+msgstr "_Kam:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:414
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:764
+msgid "I_nternal:"
+msgstr "Ie_kšējs:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:416
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:766
+msgid "Message to be sent inside organization"
+msgstr "Ziņojums, ko sūtīt organizācijas iekšienē"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:423
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:773
+msgid "None"
+msgstr "Nevienam"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:424
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:774
+msgid "Known"
+msgstr "Zināmiem"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:425
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:775
+msgid "All"
+msgstr "Visiem"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:427
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:779
+msgid "Send Message to"
+msgstr "Sūtīt vēstuli"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:447
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:803
+msgid "E_xternal:"
+msgstr "Ā_rējs:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:449
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:805
+msgid "Message to be sent outside organization"
+msgstr "Ziņojums, ko sūtīt ārpus organizācijas"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:623
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:522
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:662
+msgid "Out of Office"
+msgstr "Neatrodas birojā"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:633
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:532
+msgid "Fetching out of office settings..."
+msgstr "Saņem “ārpus biroja” iestatījumus..."
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:130
+#, c-format
+msgid "Enter Password for %s"
+msgstr "Ievadiet %s paroli"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:139
+msgid "Could not get password."
+msgstr "Neizdevās saņemt paroli."
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:226
+msgid "Could not fetch oal list: "
+msgstr "Neizdevās saņemt oal sarakstu: "
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:269
+msgid "Fetching..."
+msgstr "Saņem..."
+
+#. Add cache check box
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:323
+#: ../src/configuration/e-mail-config-ews-gal.c:294
+msgid "Cache o_ffline address book"
+msgstr "Pieglabāt _nesaistes adrešu grāmatas"
+
+#. Add label
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:329
+msgid "Select Ad_dress list: "
+msgstr "Izvēlieties a_drešu sarakstu: "
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:339
+msgid "Fetch _list"
+msgstr "Saņemt _sarakstu:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:428
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:3
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:885
+msgid "EWS Settings"
+msgstr "EWS iestatījumi"
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:1
+#: ../src/camel/camel-ews-provider.c:69
+msgid "Exchange Web Services"
+msgstr "Exchange Web Services"
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:2
+msgid "GAL settings"
+msgstr "GAL iestatījumi"
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:4
+msgid "Exchange Web Services Plugin"
+msgstr "Exchange Web Services spraudnis"
+
+#: ../src/addressbook/e-book-backend-ews.c:979
+msgid "The backend does not support bulk additions"
+msgstr "Aizmugure neatbalsta masveida pievienošanu"
+
+#: ../src/addressbook/e-book-backend-ews.c:1257
+msgid "The backend does not support bulk modifications"
+msgstr "Aizmugure neatbalsta masveida izmaiņas"
+
+#: ../src/addressbook/e-book-backend-ews.c:1439
+msgid "Wait till syncing is done"
+msgstr "Uzgaidiet līdz sinhronizēšana ir pabeigta"
+
+#: ../src/addressbook/e-book-backend-ews.c:1767
+#, c-format
+msgid "Downloading contacts in %s %d%% completed... "
+msgstr "Lejupielādē kontaktus no %s, %d%% ir pabeigti..."
+
+#: ../src/addressbook/e-book-backend-ews.c:2289
+msgid "Syncing contacts..."
+msgstr "Sinhronizē kontaktus..."
+
+#: ../src/addressbook/e-book-backend-ews.c:2491
+msgid "Searching..."
+msgstr "Meklē..."
+
+#: ../src/addressbook/ews-book-backend-sqlitedb.c:475
+#, c-format
+msgid "Insufficient memory"
+msgstr "Nepietiek atmiņas"
+
+#: ../src/calendar/e-cal-backend-ews.c:1054
+msgid "EWS does not support bulk removals"
+msgstr "EWS neatbalsta masveida izņemšanu"
+
+#: ../src/calendar/e-cal-backend-ews.c:1637
+msgid "EWS does not support bulk additions"
+msgstr "EWS neatbalsta masveida pievienošanu"
+
+#: ../src/calendar/e-cal-backend-ews.c:2127
+msgid "EWS does not support bulk modifications"
+msgstr "EWS neatbalsta masveida izmaiņas"
+
+#: ../src/camel/camel-ews-folder.c:263
+#, c-format
+msgid "Unable to open mimecontent temporary file!"
+msgstr "Neizdevās atvērt mimecontent pagaidu failu!"
+
+#: ../src/camel/camel-ews-folder.c:270
+#, c-format
+msgid "Unable to generate parser from mimecontent!"
+msgstr "Neizdevās izveidot parseri no mimecontent!"
+
+#: ../src/camel/camel-ews-folder.c:279
+#, c-format
+msgid "Unable to parse meeting request mimecontent!"
+msgstr "Neizdevās saprast tikšanās pieprasījuma mimecontent!"
+
+#: ../src/camel/camel-ews-folder.c:336
+#, c-format
+msgid "Unable to create cache file"
+msgstr "Nevarē izveidot kešatmiņas failu"
+
+#: ../src/camel/camel-ews-folder.c:437 ../src/camel/camel-ews-folder.c:509
+#, c-format
+msgid "Unable to create cache path"
+msgstr "Nevarē izveidot kešatmiņas ceļu"
+
+#: ../src/camel/camel-ews-folder.c:518
+#, c-format
+msgid "Failed to move message cache file"
+msgstr "Neizdevās pārvietot vēstuļu kešatmiņas failu"
+
+#: ../src/camel/camel-ews-folder.c:1056
+#, c-format
+msgid "Could not load summary for %s"
+msgstr "Nevar ielādēt %s kopsavilkumu"
+
+#: ../src/camel/camel-ews-folder.c:1397 ../src/camel/camel-ews-store.c:745
+#: ../src/camel/camel-ews-store.c:802 ../src/camel/camel-ews-store.c:873
+#, c-format
+msgid "Cant perform actions on the folder while in offline mode"
+msgstr "Nevar veikt darbības ar mapi, kamēr atrodas nesaistes režīmā"
+
+#: ../src/camel/camel-ews-provider.c:48
+msgid "Checking for new mail"
+msgstr "Pārbauda jauno pastu"
+
+#: ../src/camel/camel-ews-provider.c:50
+msgid "C_heck for new messages in all folders"
+msgstr "_Pārbaudīt visās mapēs, vai nav jaunu vēstuļu"
+
+#: ../src/camel/camel-ews-provider.c:53
+msgid "Options"
+msgstr "Opcijas"
+
+#: ../src/camel/camel-ews-provider.c:55
+msgid "_Apply filters to new messages in Inbox on this server"
+msgstr "_Attiecināt filtrus uz jaunajām vēstulēm iesūtnē šajā serverī"
+
+#: ../src/camel/camel-ews-provider.c:57
+msgid "Check new messages for _Junk contents"
+msgstr "Pārbaudīt, vai jaunās vēstules nav _mēstules"
+
+#: ../src/camel/camel-ews-provider.c:59
+msgid "Only check for Junk messages in the IN_BOX folder"
+msgstr "Pārbaudīt uz mēstulēm tikai iesūtnes mapē"
+
+#: ../src/camel/camel-ews-provider.c:61
+msgid "Automatically synchroni_ze remote mail locally"
+msgstr "Automātiski sinhroni_zēt attālināto pastu lokāli"
+
+#: ../src/camel/camel-ews-provider.c:71
+msgid "For accessing Exchange servers using Web Services"
+msgstr "Lai piekļūtu Exchange serveriem, izmantojot Web Services"
+
+#: ../src/camel/camel-ews-provider.c:87
+msgid "Password"
+msgstr "Parole"
+
+#: ../src/camel/camel-ews-provider.c:89
+msgid ""
+"This option will connect to the Exchange server using a plaintext password."
+msgstr ""
+"Šī opcija savienos ar Exchange serveri, lietojot parasta teksta paroli."
+
+#: ../src/camel/camel-ews-store.c:181
+#, c-format
+msgid "Session has no storage path"
+msgstr "Sesijai nav glabātuves ceļa"
+
+#: ../src/camel/camel-ews-store.c:540
+#, c-format
+msgid "No such folder: %s"
+msgstr "Nav tādas mapes: %s"
+
+#: ../src/camel/camel-ews-store.c:738
+#, c-format
+msgid "Parent folder %s does not exist"
+msgstr "Vecāka mape %s neeksistē"
+
+#: ../src/camel/camel-ews-store.c:796
+#, c-format
+msgid "Folder does not exist"
+msgstr "Mape neeksistē"
+
+#: ../src/camel/camel-ews-store.c:881
+#, c-format
+msgid "Folder %s does not exist"
+msgstr "Mape %s neeksistē"
+
+#: ../src/camel/camel-ews-store.c:890
+#, c-format
+msgid "No change key record for folder %s"
+msgstr "Mapei %s nav maiņas atslēgas ieraksta"
+
+#: ../src/camel/camel-ews-store.c:929
+#, c-format
+msgid "Cannot both rename and move a folder at the same time"
+msgstr "Nevar vienlaicīgi pārsaukt un pārvietot mapi"
+
+#: ../src/camel/camel-ews-store.c:961
+#, c-format
+msgid "Cannot find folder ID for parent folder %s"
+msgstr "Nevar atrast mapes ID vecāka mapei %s"
+
+#: ../src/camel/camel-ews-store.c:999 ../src/camel/camel-ews-transport.c:68
+#, c-format
+msgid "Exchange server %s"
+msgstr "Exchange serveris %s"
+
+#: ../src/camel/camel-ews-store.c:1001
+#, c-format
+msgid "Exchange service for %s on %s"
+msgstr "%s Exchange serviss %s"
+
+#: ../src/camel/camel-ews-store.c:1077
+#, c-format
+msgid "You must be working online to complete this operation"
+msgstr "Jums ir jāstrādā tiešsaistē, lai izpildītu šo darbību"
+
+#: ../src/camel/camel-ews-transport.c:71
+#, c-format
+msgid "Exchange mail delivery via %s"
+msgstr "Exchange pasta nosūtīšana caur  %s"
+
+#: ../src/camel/camel-ews-transport.c:108
+msgid "Cannot send message with no From address"
+msgstr "Nevar nosūtīt vēstuli bez “No” adreses"
+
+#: ../src/camel/camel-ews-transport.c:112
+msgid "Exchange server cannot send message with multiple From addresses"
+msgstr "Exchange serveris nevar nosūtīt vēstules ar vairākām “No” adresēm"
+
+#: ../src/camel/camel-ews-transport.c:120
+msgid "Failed to read From address"
+msgstr "Neizdevās nolasīt “No” adreses"
+
+#: ../src/camel/camel-ews-transport.c:126
+#, c-format
+msgid ""
+"Exchange server cannot send message as '%s', when the account was configured "
+"for address '%s'"
+msgstr ""
+"Exchange serveris nevar nosūtīt vēstules kā “%s”, kad konts ir konfigurēts "
+"adresei “%s”"
+
+#: ../src/camel/camel-ews-transport.c:137
+#, c-format
+msgid "Service not connected"
+msgstr "Serviss nav savienojies"
+
+#: ../src/collection/e-ews-backend.c:328
+#: ../src/configuration/e-mail-config-ews-gal.c:267
+msgid "Global Address List"
+msgstr "Globāls adrešu saraksts"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:125
+msgid "Querying Autodiscover service"
+msgstr "Apvaicā automātiskās atklāšanas servisu"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:208
+msgid "Fetch _URL"
+msgstr "Saņemt _URL"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:109
+msgid "Configuration"
+msgstr "Konfigurācija"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:127
+msgid "User_name:"
+msgstr "Lietotāj_vārds:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:141
+msgid "_Host URL:"
+msgstr "_Servera URL:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:160
+msgid "OAB U_RL:"
+msgstr "OAB U_RL:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:174
+msgid "Authentication"
+msgstr "Autentifikācija"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:214
+msgid "Locating offline address books"
+msgstr "Meklē nesaistes adrešu grāmatas"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:320
+msgid "Select ad_dress list:"
+msgstr "Izvēlieties a_drešu sarakstu: "
+
+#: ../src/configuration/e-mail-config-ews-gal.c:344
+msgid "Fetch List"
+msgstr "Saņemt sarakstu"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:680
+msgid ""
+"The messages specified below will be automatically sent to each internal and "
+"external personal who sends a mail to you."
+msgstr ""
+"Zemāk uzrakstītais ziņojums tiks automātiski nosūtīts katrai iekšējai vai "
+"ārējai personai, kas nosūtīs jums vēstuli."
+
+#: ../src/server/e-ews-connection.c:389
+msgid "Operation Cancelled"
+msgstr "Darbība atcelta"
+
+#: ../src/server/e-ews-connection.c:453
+msgid "Authentication failed"
+msgstr "Autentifikācija neizdevās"
+
+#: ../src/server/e-ews-connection.c:461
+#, c-format
+msgid "No response: %s"
+msgstr "Nav atbildes — %s"
+
+#: ../src/server/e-ews-connection.c:1419
+#, c-format
+msgid "Failed to parse autodiscover response XML"
+msgstr "Neizdevās saprast automātiskās atklāšanas atbildes XML"
+
+#: ../src/server/e-ews-connection.c:1426
+#, c-format
+msgid "Failed to find <Autodiscover> element"
+msgstr "Neizdevās atrast <Autodiscover> elementu"
+
+#: ../src/server/e-ews-connection.c:1437
+#, c-format
+msgid "Failed to find <Response> element"
+msgstr "Neizdevās atrast <Response> elementu"
+
+#: ../src/server/e-ews-connection.c:1448
+#, c-format
+msgid "Failed to find <Account> element"
+msgstr "Neizdevās atrast <Account> elementu"
+
+#: ../src/server/e-ews-connection.c:1467
+#, c-format
+msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
+msgstr "Neizdevās atrast <ASUrl> un <OABUrl> automātiskās atklāšanas atbildē"
+
+#: ../src/server/e-ews-connection.c:1630
+msgid "Email address is missing a domain part"
+msgstr "E-pasta adresei trūkst domēna daļas"
+
+#: ../src/server/e-ews-connection.c:1913
+msgid "Failed to parse oab XML"
+msgstr "Neizdevās saprast oab XML"
+
+#: ../src/server/e-ews-connection.c:1921
+msgid "Failed to find <OAB> element\n"
+msgstr "Neizdevās atrast <OAB> elementu\n"
+
+#: ../src/utils/ews-camel-common.c:172
+#, c-format
+msgid "CreateItem call failed to return ID for new message"
+msgstr "CreateItem izsaukumam neizdevās atgriezt jaunās vēstules ID"
+
+#~ msgid "Autodiscover failed: %s"
+#~ msgstr "Automātiskā atklāšana neveiksmīga — %s"
+
+#~ msgid "Code: %d - Unexpected response from server"
+#~ msgstr "Kods: %d — negaidīta atbilde no servera"
+
+#~ msgid "Both email and password must be provided"
+#~ msgstr "Jānorāda gan e-pasts gan parole"
+
+#~ msgid "Wrong email id"
+#~ msgstr "Nepareizs e-pasta id"
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/mr.po evolution-ews.sync-with-3.8.2/po/mr.po
--- evolution-ews.git-gnome-3-0/po/mr.po	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/po/mr.po	2013-05-29 08:46:45.663988785 +0200
@@ -0,0 +1,1542 @@
+# Marathi translation for evolution-ews.
+# Copyright (C) 2012 evolution-ews's COPYRIGHT HOLDER
+# This file is distributed under the same license as the evolution-ews package.
+#
+# Sandeep Shedmake <sshedmak@redhat.com>, 2012.
+msgid ""
+msgstr ""
+"Project-Id-Version: evolution-ews master\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
+"product=evolution-ews&keywords=I18N+L10N&component=general\n"
+"POT-Creation-Date: 2012-11-25 11:12+0000\n"
+"PO-Revision-Date: 2012-11-25 19:20+0530\n"
+"Last-Translator: Sandeep Shedmake <sshedmak@redhat.com>\n"
+"Language-Team: Marathi <maajhe-sanganak@freelists.org>\n"
+"Language: mr\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+"X-Generator: Lokalize 1.5\n"
+
+#: ../src/addressbook/e-book-backend-ews.c:982
+msgid "The backend does not support bulk additions"
+msgstr "बॅकएंड बल्क समाविष्टांकरीता समर्थन पुरवत नाही"
+
+#: ../src/addressbook/e-book-backend-ews.c:1266
+msgid "The backend does not support bulk modifications"
+msgstr "बॅकएंड बल्क संपादनकरीता समर्थन पुरवत नाही"
+
+#: ../src/addressbook/e-book-backend-ews.c:1449
+msgid "Wait till syncing is done"
+msgstr "सिंकिंग पूर्ण होईपर्यंत थांबा"
+
+#: ../src/addressbook/e-book-backend-ews.c:1787
+#, c-format
+msgid "Downloading contacts in %s %d%% completed... "
+msgstr "%s %d%% मध्ये संपर्क डाउनोलड करणे पूर्ण झाले... "
+
+#: ../src/addressbook/e-book-backend-ews.c:2332
+#| msgid "Caching contact %d"
+msgid "Syncing contacts..."
+msgstr "संपर्क सिंग करत आहे..."
+
+#: ../src/addressbook/e-book-backend-ews.c:2550
+#: ../src/configuration/e-ews-search-user.c:364
+msgid "Searching..."
+msgstr "शोधत आहे..."
+
+#: ../src/calendar/e-cal-backend-ews.c:1022
+#| msgid "The backend does not support bulk modifications"
+msgid "EWS does not support bulk removals"
+msgstr "EWS बल्क काढून टाकण्यास समर्थन पुरवत नाही"
+
+#: ../src/calendar/e-cal-backend-ews.c:1607
+#| msgid "The backend does not support bulk additions"
+msgid "EWS does not support bulk additions"
+msgstr "EWS बल्क समावेषनकरीता समर्थन पुरवत नाही"
+
+#: ../src/calendar/e-cal-backend-ews.c:2109
+#| msgid "The backend does not support bulk modifications"
+msgid "EWS does not support bulk modifications"
+msgstr "EWS बल्क् संपादनकरीता समर्थन पुरवत नाही"
+
+#: ../src/camel/camel-ews-folder.c:267
+#, c-format
+msgid "Unable to open mimecontent temporary file!"
+msgstr "माइमकंटेंट टेम्पररि फाइल उघडण्यास अशक्य!"
+
+#: ../src/camel/camel-ews-folder.c:275
+#, c-format
+msgid "Unable to generate parser from mimecontent!"
+msgstr "माइमकंटेंटपासून पार्सर निर्माण करण्यास अशक्य!"
+
+#: ../src/camel/camel-ews-folder.c:284
+#, c-format
+msgid "Unable to parse meeting request mimecontent!"
+msgstr "सभा रिक्वेस्ट माइमटकंटेंट वाचण्यास अशक्य!"
+
+#: ../src/camel/camel-ews-folder.c:344
+#, c-format
+#| msgid "Could not create cache file"
+msgid "Unable to create cache file"
+msgstr "कॅश फाइल निर्माण करण्यास अशक्य"
+
+#: ../src/camel/camel-ews-folder.c:449 ../src/camel/camel-ews-folder.c:529
+#, c-format
+#| msgid "Could not create cache file"
+msgid "Unable to create cache path"
+msgstr "कॅश मार्ग निर्माण करण्यास अशक्य"
+
+#: ../src/camel/camel-ews-folder.c:539
+#, c-format
+#| msgid "Failed to remove public folder"
+msgid "Failed to move message cache file"
+msgstr "संदेश कॅश फाइल हलवण्यास अपयशी"
+
+#: ../src/camel/camel-ews-folder.c:1140
+#, c-format
+msgid "Could not load summary for %s"
+msgstr "%s करीता सारांश लोड करणे अशक्य"
+
+#: ../src/camel/camel-ews-folder.c:1576
+#, c-format
+#| msgid "Cannot create MAPI folders in offline mode"
+msgid "Cant perform actions on the folder while in offline mode"
+msgstr "ऑफलाइन मोडमध्ये फोल्डरवरील कृती करण्यास अशक्य"
+
+#: ../src/camel/camel-ews-provider.c:48
+msgid "Checking for new mail"
+msgstr "नवीन मेलसाठी तपासणी करत आहे"
+
+#: ../src/camel/camel-ews-provider.c:50
+msgid "C_heck for new messages in all folders"
+msgstr "सर्व फोल्डर्स् मध्ये नवीन संदेशकरीता तपासणी करा (_h)"
+
+#: ../src/camel/camel-ews-provider.c:53
+msgid "Options"
+msgstr "पर्याय"
+
+#: ../src/camel/camel-ews-provider.c:55
+msgid "_Apply filters to new messages in Inbox on this server"
+msgstr "ह्या सर्व्हरवरील इंबॉक्समध्ये नवीन संदेशकरिता फिल्टर्स् लागू करा (_A)"
+
+#: ../src/camel/camel-ews-provider.c:57
+msgid "Check new messages for _Junk contents"
+msgstr "जंक अंतर्भुत माहितीकरीता नवीन संदेशची तपासणी करा (_J)"
+
+#: ../src/camel/camel-ews-provider.c:59
+#| msgid "Only check for Junk messag_es in the Inbox folder"
+msgid "Only check for Junk messages in the IN_BOX folder"
+msgstr "INBOX फोल्डरमध्ये फक्त जंक संदेशकरीता तपासणी करा (_B)"
+
+#: ../src/camel/camel-ews-provider.c:61
+#| msgid "Automatically synchroni_ze account locally"
+msgid "Automatically synchroni_ze remote mail locally"
+msgstr "रिमोट मेल स्थानीयरित्या स्वयंरित्या समजुळणी करा (_z)"
+
+#: ../src/camel/camel-ews-provider.c:64
+#| msgid "Connecting to '%s'"
+msgid "Connection"
+msgstr "जोडणी"
+
+#. Translators: '%s' is preplaced with a widget, where "
+#. * user can select how long the timeout should be.
+#: ../src/camel/camel-ews-provider.c:68
+#, c-format
+msgid "Connection _timeout (in seconds) %s"
+msgstr "जोडणी वेळसमाप्ति (_t) (सेकंदात) %s"
+
+#: ../src/camel/camel-ews-provider.c:76
+#| msgid "Exchange MAPI server %s"
+msgid "Exchange Web Services"
+msgstr "एक्सचेंज वेब सर्व्हिसेस्"
+
+#: ../src/camel/camel-ews-provider.c:78
+msgid "For accessing Exchange servers using Web Services"
+msgstr ""
+"वेब सर्व्हिसेसचा वापर करून एक्सचेंज सर्व्हर्सकरीता प्रवेश प्राप्त करण्यासाठी"
+
+#: ../src/camel/camel-ews-provider.c:93
+msgid "NTLM"
+msgstr "NTLM"
+
+#: ../src/camel/camel-ews-provider.c:95
+#| msgid ""
+#| "This option will connect to the OpenChange server using a plaintext "
+#| "password."
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with NTLM authentication."
+msgstr ""
+"NTLM ओळखपटवासह प्लैनटेक्स्ट पासवर्डचा वापर करून हा पर्याय एक्सचेंज सर्व्हरशी "
+"जोडणी करेल."
+
+#: ../src/camel/camel-ews-provider.c:103
+msgid "Basic"
+msgstr "मूळ"
+
+#: ../src/camel/camel-ews-provider.c:105
+#| msgid ""
+#| "This option will connect to the OpenChange server using a plaintext "
+#| "password."
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with Basic authentication."
+msgstr ""
+"मूळ ओळखपटवासह प्लैनटेक्स्ट पासवर्डचा वापर करून हा पर्याय एक्सचेंज सर्व्हरशी "
+"जोडणी करेल."
+
+#: ../src/camel/camel-ews-store.c:185
+#, c-format
+msgid "Session has no storage path"
+msgstr "सत्रकडे स्टोरेज मार्ग नाही"
+
+#: ../src/camel/camel-ews-store.c:283
+#, c-format
+msgctxt "ForeignFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:571
+msgid "Updating foreign folder structure"
+msgstr "फॉरैन फोल्डर मांडणी सुधारित करत आहे"
+
+#: ../src/camel/camel-ews-store.c:741
+msgid "Authentication password not available"
+msgstr "ओळखपटवण्यासाठी पासवर्ड अनुपलब्ध"
+
+#: ../src/camel/camel-ews-store.c:885
+msgid "Query for authentication types is not supported"
+msgstr "ओळख पटवाकरीता चौकशी समर्थीत नाही"
+
+#: ../src/camel/camel-ews-store.c:937
+#, c-format
+#| msgid "No public folder found"
+msgid "No such folder: %s"
+msgstr "अशा प्रकारचे फोल्डर नाही: %s"
+
+#: ../src/camel/camel-ews-store.c:1084
+msgid ""
+"Cannot list folders available for subscription of Exchange Web Services "
+"account, use 'Subscribe to folder of other user' context menu option above "
+"the account node in the folder tree instead."
+msgstr ""
+"एक्सचेंज वेब सर्व्हिसेस् खातेच्या सबस्क्रिप्शनकरीता उपलब्ध फोल्डर्सची सूची "
+"दाखवणे अशक्य, फोल्डर ट्री ऐवजी खाते नोडवरील 'इतर वापरकर्त्याच्या फोल्डरकरीता "
+"सबस्क्रिब व्हा' संदर्भ मेन्यु पर्यायचा वापर करा."
+
+#: ../src/camel/camel-ews-store.c:1191
+#, c-format
+#| msgid "Cannot add folder, folder already exists as '%s'"
+msgid "Cannot create folder '%s', folder already exists"
+msgstr "फोल्डर '%s' निर्माण करणे अशक्य, फोल्डर आधिपासूनच अस्तित्वात आहे"
+
+#: ../src/camel/camel-ews-store.c:1206
+#, c-format
+#| msgid "Cannot rename MAPI folder '%s'. Folder does not exist"
+msgid "Parent folder %s does not exist"
+msgstr "पॅरेंट फोल्डर %s अस्तित्वात नाही"
+
+#: ../src/camel/camel-ews-store.c:1216
+#, c-format
+msgid ""
+"Cannot create folder under '%s', it is used for folders of other users only"
+msgstr ""
+"'%s' अंतर्गत फोल्डर निर्माण करणे अशक्य, त्याचा वापर इतर वापरकर्त्यांच्या "
+"वापरसाठीचे केला जातो"
+
+#: ../src/camel/camel-ews-store.c:1285
+#, c-format
+#| msgctxt "Permissions"
+#| msgid "Folder contact"
+msgid "Folder does not exist"
+msgstr "फोल्डर अस्तित्वात नाही"
+
+#: ../src/camel/camel-ews-store.c:1294
+#, c-format
+#| msgid "Cannot rename MAPI folder '%s'. Folder does not exist"
+msgid "Cannot remove folder '%s', it is used for folders of other users only"
+msgstr ""
+"फोल्डर '%s' काढून टाकणे अशक्य, त्याचा वापर फक्त इतर वापरकर्त्यांकरीताच केला "
+"जातो"
+
+#: ../src/camel/camel-ews-store.c:1401
+#, c-format
+#| msgid "Folder '%s' not found"
+msgid "Folder %s does not exist"
+msgstr "फोल्डर %s अस्तित्वात नाही"
+
+#: ../src/camel/camel-ews-store.c:1411
+#, c-format
+msgid "No change key record for folder %s"
+msgstr "फोल्डर %s करीता कि रेकॉर्डमध्ये बदल आढळले नाही"
+
+#: ../src/camel/camel-ews-store.c:1453
+#, c-format
+msgid "Cannot both rename and move a folder at the same time"
+msgstr "एकाच वेळी फोल्डरचे दोंही पुनःनामांकन व स्थानांतरन"
+
+#: ../src/camel/camel-ews-store.c:1489
+#, c-format
+#| msgid "Cannot find folder in a local cache"
+msgid "Cannot find folder ID for parent folder %s"
+msgstr "मुख्य फोल्डर %s करीता फोल्डर ID शोधणे अशक्य"
+
+#: ../src/camel/camel-ews-store.c:1539 ../src/camel/camel-ews-transport.c:69
+#, c-format
+#| msgid "Exchange MAPI server %s"
+msgid "Exchange server %s"
+msgstr "एक्चेंज सर्व्हर %s"
+
+#: ../src/camel/camel-ews-store.c:1542
+#, c-format
+#| msgid "Exchange MAPI service for %s on %s"
+msgid "Exchange service for %s on %s"
+msgstr "%s करीता %s वरील एक्सचेंज सर्व्हिस"
+
+#: ../src/camel/camel-ews-store.c:1586
+#, c-format
+#| msgid "Could not create cache file"
+msgid "Could not locate Trash folder"
+msgstr "ट्रॅश फोल्डर शोधणे अशक्य"
+
+#: ../src/camel/camel-ews-store.c:1621
+#, c-format
+#| msgid "Could not create cache file"
+msgid "Could not locate Junk folder"
+msgstr "जंक फोल्डर शोधणे अशक्य"
+
+#: ../src/camel/camel-ews-store.c:1699
+#| msgid "Cannot subscribe MAPI folders in offline mode"
+msgid "Cannot subscribe EWS folders in offline mode"
+msgstr "ऑफलाइन मोडमध्ये EWS फोल्डर्सशी सबस्क्राइब होणे अशक्य"
+
+#: ../src/camel/camel-ews-store.c:1721
+#| msgid "Cannot unsubscribe MAPI folders in offline mode"
+msgid "Cannot unsubscribe EWS folders in offline mode"
+msgstr "ऑफलाइन मोडमध्ये EWS फोल्डर्सला सबस्क्राइब करणे अशक्य"
+
+#: ../src/camel/camel-ews-store.c:1794
+#, c-format
+msgid "You must be working online to complete this operation"
+msgstr "हे कार्य पूर्ण करण्यासाठी ऑनलाइन कार्य करणे आवश्यक"
+
+#: ../src/camel/camel-ews-transport.c:72
+#, c-format
+#| msgid "Exchange MAPI server %s"
+msgid "Exchange mail delivery via %s"
+msgstr "%s तर्फे मेल डिलिवरि अदलाबदल करा"
+
+#: ../src/camel/camel-ews-transport.c:120
+#| msgid "Cannot append message to folder '%s'"
+msgid "Cannot send message with no From address"
+msgstr "विना प्रेषक पत्तासह संदेश पाठवणे अशक्य"
+
+#: ../src/camel/camel-ews-transport.c:126
+msgid "Exchange server cannot send message with multiple From addresses"
+msgstr "एकापेक्षाजास्त प्रेषक पत्तासह एक्सचेंज सर्व्हर संदेश पाठवण्यास अशक्य"
+
+#: ../src/camel/camel-ews-transport.c:137
+#| msgid "Failed to create item on a server"
+msgid "Failed to read From address"
+msgstr "पत्तापासून वाचण्यास अपयशी"
+
+#: ../src/camel/camel-ews-transport.c:149
+#, c-format
+msgid ""
+"Exchange server cannot send message as '%s', when the account was configured "
+"for address '%s'"
+msgstr ""
+"पत्ता '%2$s' करीता खाते संरचीत केल्यास, एक्सचेंज सर्व्हर '%1$s' प्रमाणे संदेश "
+"पाठवू शकत नाही"
+
+#: ../src/camel/camel-ews-transport.c:163
+#, c-format
+msgid "Service not connected"
+msgstr "सर्व्हिस खंडीत आहे"
+
+#: ../src/collection/e-ews-backend.c:391
+#: ../src/configuration/e-mail-config-ews-gal.c:274
+msgid "Global Address List"
+msgstr "ग्लोबल पत्ता सूची"
+
+#: ../src/collection/e-ews-backend.c:776
+#, c-format
+msgid "Could not determine a suitable folder class for a new folder named '%s'"
+msgstr "'%s' नावाच्या नवीन फोल्डरकरीता योग्य फोल्डर क्लास ओळखणे अशक्य"
+
+#: ../src/collection/e-ews-backend.c:867
+#, c-format
+#| msgid "Data source '%s' does not represent a MAPI folder"
+msgid "Data source '%s' does not represent an Exchange Web Services folder"
+msgstr "डाटा सोअर्स् '%s' एक्सचेंज वेब सर्व्हिसेस् फोल्डर प्रस्तुत करत नाही"
+
+#: ../src/configuration/e-ews-config-utils.c:515
+#, c-format
+msgid "Cannot edit permissions of folder '%s', choose other folder."
+msgstr "फोल्डर '%s' ची परवानगी संपादित करणे अशक्य, इतर फोल्डर नीवडा."
+
+#: ../src/configuration/e-ews-config-utils.c:593
+msgid "Subscribe to folder of other user..."
+msgstr "इतर वापरकर्त्याच्या फोल्डरकरीता सबस्क्राइब व्हा..."
+
+#: ../src/configuration/e-ews-config-utils.c:602
+#: ../src/configuration/e-ews-config-utils.c:883
+#: ../src/configuration/e-ews-config-utils.c:914
+#: ../src/configuration/e-ews-config-utils.c:945
+#: ../src/configuration/e-ews-config-utils.c:976
+msgid "Permissions..."
+msgstr "परवानगी..."
+
+#: ../src/configuration/e-ews-config-utils.c:604
+#| msgid "Edit MAPI folder permissions"
+msgid "Edit EWS folder permissions"
+msgstr "EWS फोल्डर परवानगी संपादित करा"
+
+#: ../src/configuration/e-ews-config-utils.c:885
+#| msgid "Edit MAPI calendar permissions"
+msgid "Edit EWS calendar permissions"
+msgstr "EWS दिनदर्शिका परवानगी संपादित करा"
+
+#: ../src/configuration/e-ews-config-utils.c:916
+#| msgid "Edit MAPI tasks permissions"
+msgid "Edit EWS tasks permissions"
+msgstr "EWS कार्ये परवानगी संपादित करा"
+
+#: ../src/configuration/e-ews-config-utils.c:947
+#| msgid "Edit MAPI memos permissions"
+msgid "Edit EWS memos permissions"
+msgstr "EWS मेमोज परवानगी संपादित करा"
+
+#: ../src/configuration/e-ews-config-utils.c:978
+#| msgid "Edit MAPI contacts permissions"
+msgid "Edit EWS contacts permissions"
+msgstr "EWS संपर्क परवानगी संपादित करा"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:87
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:504
+msgctxt "PermissionsLevel"
+msgid "None"
+msgstr "काहिच नाही"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:88
+msgctxt "PermissionsLevel"
+msgid "Owner"
+msgstr "मालक"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:98
+msgctxt "PermissionsLevel"
+msgid "Publishing Editor"
+msgstr "प्रकाशन संपादक"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:107
+msgctxt "PermissionsLevel"
+msgid "Editor"
+msgstr "संपादक"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:115
+msgctxt "PermissionsLevel"
+msgid "Publishing Author"
+msgstr "प्रकाशन लेखक"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:122
+msgctxt "PermissionsLevel"
+msgid "Author"
+msgstr "लेखक"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:128
+msgctxt "PermissionsLevel"
+msgid "Nonediting Author"
+msgstr "संपादनअशक्य लेखक"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:133
+msgctxt "PermissionsLevel"
+msgid "Reviewer"
+msgstr "पुनरवलोकनकर्ता"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:136
+msgctxt "PermissionsLevel"
+msgid "Contributor"
+msgstr "सहाय्यकर्ता"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:139
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time"
+msgstr "मोकळे/व्यस्त वेळ"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:141
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time, subject, location"
+msgstr "मोकळे/व्यस्त वेळ, विषय, ठिकाण"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:143
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:525
+msgctxt "PermissionsLevel"
+msgid "Custom"
+msgstr "पसंतीचे"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:267
+msgid "Writing folder permissions, please wait..."
+msgstr "फोल्डर परवानगी लिहित आहे, कृपया प्रतिक्षा करा..."
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:759
+msgctxt "User"
+msgid "Anonymous"
+msgstr "निनावी"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:762
+msgctxt "User"
+msgid "Default"
+msgstr "पूर्वनिर्धारित"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:768
+msgctxt "User"
+msgid "Unknown"
+msgstr "अपरिचीत"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:849
+#: ../src/configuration/e-ews-search-user.c:430
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1080
+msgid "Name"
+msgstr "नाव"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:855
+msgid "Permission level"
+msgstr "परवानगी स्तर"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:907
+#| msgid "Edit MAPI folder permissions..."
+msgid "Edit EWS folder permissions..."
+msgstr "EWS फोल्डर परवानगी संपादित करा..."
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:932
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:635
+msgid "Account:"
+msgstr "खाते:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:960
+msgid "Folder name:"
+msgstr "फोल्डर नाव:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:983
+msgid "Folder ID:"
+msgstr "फोल्डर ID:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1047
+msgid "Permissions"
+msgstr "परवानगी"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1069
+msgid "Permi_ssion level:"
+msgstr "परवानगी स्तर (_s):"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1103
+msgctxt "Permissions"
+msgid "Read"
+msgstr "वाचा"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1115
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1182
+msgctxt "Permissions"
+msgid "None"
+msgstr "काहिच नाही"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1121
+#| msgctxt "Permissions"
+#| msgid "Simple Free/Busy"
+msgctxt "Permissions"
+msgid "Free/Busy time"
+msgstr "मोकळे/व्यस्थ वेळ"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1126
+msgctxt "Permissions"
+msgid "Free/Busy time, subject, location"
+msgstr "मोकळे/व्यस्थ वेळ, विषय, ठिकाण"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1132
+msgctxt "Permissions"
+msgid "Full Details"
+msgstr "संपूर्ण तपशील"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1138
+msgctxt "Permissions"
+msgid "Write"
+msgstr "राइट"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1150
+msgctxt "Permissions"
+msgid "Create items"
+msgstr "घटक निर्माण करा"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1154
+msgctxt "Permissions"
+msgid "Create subfolders"
+msgstr "उपफोल्डर्स् निर्माण करा"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1158
+msgctxt "Permissions"
+msgid "Edit own"
+msgstr "स्वतः संपादित करा"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1162
+msgctxt "Permissions"
+msgid "Edit all"
+msgstr "सर्व संपादित करा"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1170
+msgctxt "Permissions"
+msgid "Delete items"
+msgstr "घटकांना नष्ट करा"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1187
+msgctxt "Permissions"
+msgid "Own"
+msgstr "स्वतः"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1192
+msgctxt "Permissions"
+msgid "All"
+msgstr "सर्व"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1198
+msgctxt "Permissions"
+msgid "Other"
+msgstr "इतर"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1210
+msgctxt "Permissions"
+msgid "Folder owner"
+msgstr "फोल्डरची मालकी"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1214
+msgctxt "Permissions"
+msgid "Folder contact"
+msgstr "फोल्डर संपर्क"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1218
+msgctxt "Permissions"
+msgid "Folder visible"
+msgstr "फोल्डर दृष्यास्पद"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1291
+msgid "Reading folder permissions, please wait..."
+msgstr "फोल्डर परवानगी लिहित आहे, कृपया प्रतिक्षा करा..."
+
+#: ../src/configuration/e-ews-search-user.c:208
+#, c-format
+#| msgid "No users found"
+msgid "No users found, only one contact"
+msgid_plural "No users found, only %d contacts"
+msgstr[0] "वापरकर्ते आढळले नाही, फक्त एक संपर्क आढळला"
+msgstr[1] "वापरकर्ते आढळले नाही, फक्त %d संपर्क आढळले"
+
+#: ../src/configuration/e-ews-search-user.c:213
+msgid "No users found"
+msgstr "वापरकर्ते आढळले नाही"
+
+#: ../src/configuration/e-ews-search-user.c:217
+#, c-format
+msgid "Found one user"
+msgid_plural "Found %d users"
+msgstr[0] "एक वापरकर्ता आढळला"
+msgstr[1] "%d वापरकर्ते आढळले"
+
+#: ../src/configuration/e-ews-search-user.c:223
+#, c-format
+#| msgid "Found %d user, but showing only first %d"
+#| msgid_plural "Found %d users, but showing only first %d"
+msgid "Found more than 100 users, but showing only first %d"
+msgid_plural "Found more than 100 users, but showing only first %d"
+msgstr[0] ""
+"100 पेक्षा जास्त वापरकर्ते आढळले, परंतु फक्त सुरूवातीचे %d दाखवत आहे"
+msgstr[1] ""
+"100 पेक्षा जास्त वापरकर्ते आढळले, परंतु फक्त सुरूवातीचे %d दाखवत आहे"
+
+#: ../src/configuration/e-ews-search-user.c:356
+#: ../src/configuration/e-ews-search-user.c:539
+msgid "Search for a user"
+msgstr "वापकर्ताकरीता शोधा"
+
+#: ../src/configuration/e-ews-search-user.c:436
+msgid "E-mail"
+msgstr "ईमेल"
+
+#: ../src/configuration/e-ews-search-user.c:473
+#| msgid "Choose MAPI user..."
+msgid "Choose EWS user..."
+msgstr "EWS वापरकर्ता पसंत करा..."
+
+#: ../src/configuration/e-ews-search-user.c:496
+msgid "_Search:"
+msgstr "शोध (_S):"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:98
+#: ../src/server/e-ews-folder.c:600
+#, c-format
+msgid "Cannot add folder, folder already exists as '%s'"
+msgstr ""
+"फोल्डर समाविष्ट करणे अशक्य, फोल्डर आधिपासूनच '%s' म्हणून अस्तित्वात आहे"
+
+#. Translators: The '%s' is replaced with user name, to whom the foreign mailbox belongs.
+#. * Example result: "Mailbox - John Smith"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:108
+#, c-format
+msgctxt "ForeignFolder"
+msgid "Mailbox - %s"
+msgstr "मेलबॉक्स् - %s"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:273
+#| msgid "Folder list is not available in offline mode"
+msgid "Cannot test foreign folder availability while in offline mode"
+msgstr "ऑफलाइन मोडमध्ये असताना फॉरेंन फोल्डर उपलब्धता चाचणी अशक्य"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:298
+#, c-format
+#| msgid "User name '%s' not found"
+msgid "User '%s' was not found on the server"
+msgstr "सर्व्हरवर वापरकर्ता '%s' आढळला नाही"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:334
+#, c-format
+#| msgid "User name '%s' is ambiguous"
+msgid "User name '%s' is ambiguous, specify it more precisely, please"
+msgstr ""
+"वापरकर्ता नाव '%s' गोंधळास्पद आहे, त्यास कृपया, व्यवस्थीत निर्देशीत करा"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:356
+#, c-format
+msgid ""
+"Folder '%s' not found. Either it does not exist or you do not have "
+"permission to access it."
+msgstr ""
+"फोल्डर '%s' आढळले नाही. एकतर अस्तित्वात नाही किंवा तुमच्याकडे प्रवेशकरीता "
+"परवानगी नाही."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:374
+msgid "Cannot add folder, cannot determine folder's type"
+msgstr "फोल्डर समाविष्ट करणे अशक्य, फोल्डर प्रकार ओळखणे अशक्य"
+
+#. Translators: This is used to name foreign folder.
+#. * The first '%s' is replaced with user name to whom the folder belongs,
+#. * the second '%s' is replaced with folder name.
+#. * Example result: "John Smith - Calendar"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:419
+#, c-format
+msgctxt "ForeignFolder"
+msgid "%s - %s"
+msgstr "%s - %s"
+
+#. convert well-known names to their non-localized form
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:513
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:720
+msgid "Inbox"
+msgstr "इंबॉक्स्"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:515
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:721
+msgid "Contacts"
+msgstr "संपर्क"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:517
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:722
+msgid "Calendar"
+msgstr "दिनदर्शिका"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:519
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:723
+msgid "Memos"
+msgstr "मेमोज्"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:521
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:724
+msgid "Tasks"
+msgstr "कार्ये"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:538
+#, c-format
+msgid "Testing availability of folder '%s' of user '%s', please wait..."
+msgstr ""
+"वापरकर्ता '%2$s' ची फोल्डर '%1$s' उपलब्धताची चाचणी करत आहे, कृपया प्रतिक्षा "
+"करा..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:614
+#| msgid "Subscribe to folder of other user..."
+msgid "Subscribe to folder of other EWS user..."
+msgstr "इतर EWS वापरकर्त्याच्या फोल्डरकरीता सबस्क्राइब व्हा..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:665
+msgid "User"
+msgstr "वापरकर्ता"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:672
+msgid "_User:"
+msgstr "वापरकर्ता (_U):"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:687
+msgid "C_hoose..."
+msgstr "पसंत करा (_h)..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:703
+msgid "_Folder name:"
+msgstr "फोल्डर नाव (_F):"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:733
+#| msgctxt "Permissions"
+#| msgid "Create subfolders"
+msgid "Include _subfolders"
+msgstr "सबफोल्डर्स् समाविष्ट करा (_s)"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:129
+msgid "Querying Autodiscover service"
+msgstr "स्वयंडिस्कवर सर्व्हिसची चौकशी करत आहे"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:212
+msgid "Fetch _URL"
+msgstr "फेच् URL (_U)"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:140
+msgid "Configuration"
+msgstr "संरचना"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:158
+msgid "User_name:"
+msgstr "वापरकर्तानाव (_n):"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:172
+msgid "_Host URL:"
+msgstr "यमजान URL (_H):"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:191
+msgid "OAB U_RL:"
+msgstr "OAB URL (_R):"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:205
+msgid "Open _Mailbox of other user"
+msgstr "इतर वापरकर्त्याचा मेलबॉक्स उघडा (_M)"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:239
+#| msgid "Searching..."
+msgid "S_earch..."
+msgstr "शोधा (_e)..."
+
+#: ../src/configuration/e-mail-config-ews-backend.c:250
+#| msgid "_Authenticate"
+msgid "Authentication"
+msgstr "ओळखपटवा"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:505
+msgctxt "PermissionsLevel"
+msgid "Reviewer (can read items)"
+msgstr "पुनरावलोकनकर्ता (घटकांचे वाचन शक्य)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:506
+msgctxt "PermissionsLevel"
+msgid "Author (can read and create items)"
+msgstr "लेखक (घटकांचे वाचन व निर्माण शक्य)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:507
+msgctxt "PermissionsLevel"
+msgid "Editor (can read, create and modify items)"
+msgstr "संपादक (घटकांचे वाचन, निर्माण व संपादन शक्य)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:610
+#| msgid "Permissions"
+msgid "Delegate permissions"
+msgstr "परवानगी द्या"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:628
+#| msgid "Calendar"
+msgid "C_alendar"
+msgstr "दिनदर्शिका (_a)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:631
+msgid "_Delegate receives copies of meeting-related messages sent to me"
+msgstr "डेलिगेटकडे मला पाठवलेले सभा-संदर्भात संदेश प्राप्त झाले (_D)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:636
+#| msgid "Tasks"
+msgid "_Tasks"
+msgstr "कार्ये (_T)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:639
+#| msgid "Inbox"
+msgid "_Inbox"
+msgstr "इंबॉक्स (_I)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:642
+#| msgid "Contacts"
+msgid "C_ontacts"
+msgstr "संपर्क (_o)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:645
+msgid "_Notes"
+msgstr "टिपण्णी (_N)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:648
+msgid "_Journal"
+msgstr "जर्नल (_J)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:651
+#, c-format
+msgid "Delegate '%s' has the following permissions"
+msgstr "डेलिगेट '%s' कडे खालील परवानगी आहे"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:669
+msgid "Delegate can see my _private items"
+msgstr "डिलिगेट माझे व्यक्तिगत घटके पाहू शकतात (_p)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:992
+#| msgid "Writing folder permissions, please wait..."
+msgid "Retrieving current user permissions, please wait..."
+msgstr "सध्याची वापरकर्ता परवागनी प्राप्त करत आहे, कृपया थांबा..."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1113
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1643
+#| msgctxt "Permissions"
+#| msgid "Delete items"
+msgid "Delegates"
+msgstr "डेलिगेट्स्"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1137
+msgid ""
+"Delegates can send items on your behalf, including creating and responding "
+"to meeting requests. If you want to grant folder permissions without giving "
+"send-on-behalf-of permissions, close this dialog box, right-click the "
+"folder, click Permissions and change the options there."
+msgstr ""
+"डेलिगेट्स् तुमच्याकरीता घटके पाठवू शकतात, ज्यामध्ये सभा विनंतीचे निर्माण व "
+"प्रतिसाद समाविष्टीत आहे. "
+"send-on-behalf-of परवानगीविना फोल्डर परवागनी द्यायची असल्यास, हे संवाद पटल "
+"बंद करा, फोल्डरवर उजवी-क्लिक द्या, परवानगी क्लिक करा व पर्याय बदला."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1186
+msgid ""
+"Deliver meeting requests addressed to me and responses to meeting requests "
+"where I am the organizer to:"
+msgstr ""
+"Deliver meeting requests addressed to me and responses to meeting requests "
+"where I am the organizer to:"
+
+#. new-line break, because GtkRadioButton doesn't allow wrapping of the inner label
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1195
+msgid ""
+"My delegates only, but _send a copy of meeting requests\n"
+"and responses to me (recommended)"
+msgstr ""
+"फक्त माझे डेलिगेट संदेश, परंतु सभा विनंती व प्रतिसादचे मला प्रत पाठवा\n"
+"(शिफारसीय) (_s)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1202
+msgid "My d_elegates only"
+msgstr "फक्त माझे डेलिगेट्स् (_e)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1209
+msgid "My delegates a_nd me"
+msgstr "माझे डेलिगेट्स् व मी (_n)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1718
+msgid "Retrieving \"Delegates\" settings"
+msgstr "\"डेलिगेट्स्\" सेटिंग्स् प्राप्त करत आहे"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:221
+msgid "Locating offline address books"
+msgstr "ऑफलाइन पत्ता पुस्तके शोधत आहे"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:301
+msgid "Cache o_ffline address book"
+msgstr "कॅश ऑफलाइन पत्ता पुस्तिका (_f)"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:327
+#| msgid "Global Address List"
+msgid "Select ad_dress list:"
+msgstr "पत्ता सूची पसंत करा (_d):"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:351
+msgid "Fetch List"
+msgstr "फेच् सूची"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:449
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:928
+msgid "Out of Office"
+msgstr "ऑट ऑफ ऑफिस"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:465
+msgid ""
+"The messages specified below will be automatically sent to each internal and "
+"external person who sends a mail to you."
+msgstr ""
+"खालील निर्देशीत संदेश स्वयंरित्या आंतरिक व बाहेरिल व्यक्तिकरीता पाठवले जाईल, "
+"ज्याचे तुम्हाला मेल प्राप्त होते."
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:473
+msgid "Do _not send Out of Office replies"
+msgstr "ऑट ऑफ ऑफिस प्रतिसाद पाठवू नका (_n)"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:481
+msgid "_Send Out of Office replies"
+msgstr "आउट ऑफ ऑफिस प्रतिसाद पाठवू नका (_S)"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:489
+msgid "Send Out of Office replies only _during this time period:"
+msgstr "फक्त ह्या कालावधीतच आउट ऑफ ऑफिस प्रतिसाद पाठवू नका (_d):"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:509
+msgid "_From:"
+msgstr "पासून (_F):"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:534
+msgid "_To:"
+msgstr "प्रति (_T):"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:559
+msgid "I_nternal:"
+msgstr "आंतरिक (_n):"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:568
+msgid "Message to be sent within the organization"
+msgstr "संस्था अंतर्गत संदेश पाठवा"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:595
+msgid "E_xternal:"
+msgstr "बाहेरिल (_x):"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:603
+msgid "Message to be sent outside the organization"
+msgstr "संस्थेच्या बाहेर पाठवण्याजोजी संदेश"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:613
+msgid "Do not reply to senders outside the organization"
+msgstr "संस्थेच्या बाहेरील प्रेषकांना प्रतिसाद पाठवू नका"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:616
+msgid "Reply only to known senders outside the organization"
+msgstr "फक्त संस्थेच्या बाहेरिल प्रेषकांनाच प्रतिसाद पाठवा"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:619
+msgid "Reply to any sender outside the organization"
+msgstr "संस्थेच्या बाहेरिल कोणत्याहि प्रेषकाला प्रतिसाद पाठवा"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:1004
+msgid "Retrieving \"Out of Office\" settings"
+msgstr "\"आउट ऑफ ऑफिस\" सेटिंग्स् प्राप्त करत आहे"
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:1
+msgid "Autodiscovery query failed."
+msgstr "Autodiscovery चौकशी अपयशी."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:2
+msgid "The reported error was &quot;{0}&quot;."
+msgstr "&quot;{0}&quot; त्रुटी कळवली."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:3
+#| msgid "Failed to close folder: %s"
+msgid "Failed to locate offline address books."
+msgstr "ऑफलाइन पत्ता पुस्तिका शोधण्यास अपयशी."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:4
+msgid "Failed to retrieve &quot;Out of Office&quot; settings."
+msgstr "&quot;आउट ऑफ ऑफिस&quot; सेटिंग्स् प्राप्त करण्यास अपयशी."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:5
+msgid "Failed to retrieve &quot;Delegates&quot; settings."
+msgstr "&quot;डेलिगेट्स्&quot; सेटिंग्स् प्राप्त करण्यास अपयशी."
+
+#: ../src/server/e-ews-connection.c:493
+msgid "Operation Cancelled"
+msgstr "कार्य रद्द केले"
+
+#: ../src/server/e-ews-connection.c:562
+msgid "Authentication failed"
+msgstr "ओळख पटवणे अपयशी"
+
+#: ../src/server/e-ews-connection.c:573
+#, c-format
+msgid "No response: %s"
+msgstr "प्रतिसाद नाही: %s"
+
+#: ../src/server/e-ews-connection.c:1877
+#, c-format
+msgid "Failed to parse autodiscover response XML"
+msgstr "ऑटोडिस्कवर रेसपाँस् XML वाचण्यास अपयशी"
+
+#: ../src/server/e-ews-connection.c:1884
+#, c-format
+msgid "Failed to find <Autodiscover> element"
+msgstr "<Autodiscover> एलिमेंट शोधण्यास अपयशी"
+
+#: ../src/server/e-ews-connection.c:1895
+#, c-format
+msgid "Failed to find <Response> element"
+msgstr "<Response> एलिमेंट शोधण्यास अपयशी"
+
+#: ../src/server/e-ews-connection.c:1906
+#, c-format
+#| msgid "Failed to count server contacts"
+msgid "Failed to find <Account> element"
+msgstr "<Account> एलिमेंट शोधण्यास अपयशी"
+
+#: ../src/server/e-ews-connection.c:1925
+#, c-format
+msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
+msgstr "autodiscover प्रतिसादमध्ये <ASUrl> व <OABUrl> शोधण्यास अपयशी"
+
+#: ../src/server/e-ews-connection.c:2007
+msgid "URL cannot be NULL"
+msgstr "URL  NULL असणे अशक्य"
+
+#: ../src/server/e-ews-connection.c:2015
+#, c-format
+msgid "URL '%s' is not valid"
+msgstr "URL '%s' वैध नाही"
+
+#: ../src/server/e-ews-connection.c:2117
+msgid "Email address is missing a domain part"
+msgstr "ईमेल पत्तामध्ये डोमेन भाग आढळले नाही"
+
+#: ../src/server/e-ews-connection.c:2429
+#| msgid "Failed to transfer objects: %s"
+msgid "Failed to parse oab XML"
+msgstr "oab XML वाचण्यास अपयशी"
+
+#: ../src/server/e-ews-connection.c:2437
+#| msgid "Failed to fetch GAL entries"
+msgid "Failed to find <OAB> element\n"
+msgstr "<OAB> एलिमेंट शोधण्यास अपयशी\n"
+
+#: ../src/server/e-ews-connection.c:3594
+#| msgid "No users found"
+msgid "No items found"
+msgstr "घटके आढळले नाही"
+
+#: ../src/server/e-ews-folder.c:554
+msgid "Cannot add folder, unsupported folder type"
+msgstr "फोल्डर समाविष्ट करणे अशक्य, असमर्थीत फोल्डर प्रकार"
+
+#: ../src/server/e-ews-folder.c:559
+msgid "Cannot add folder, master source not found"
+msgstr "फोल्डर समाविष्ट करणे अशक्य, मास्टर सोअर्स् आढळले नाही"
+
+#: ../src/utils/ews-camel-common.c:176
+#, c-format
+msgid "CreateItem call failed to return ID for new message"
+msgstr "नवीन संदेशकरीता CreateItem कॉल रिटर्न ID पुरवण्यास अपयशी"
+
+#~ msgid "Searching"
+#~ msgstr "शोधत आहे"
+
+#~ msgid "Unknown error"
+#~ msgstr "अपरिचीत त्रुटी"
+
+#~ msgid "Failed to modify item on a server"
+#~ msgstr "सर्व्हरवरील घटक संपादित करण्यास अपयशी"
+
+#~ msgid "Failed to fetch items from a server"
+#~ msgstr "सर्व्हरपासून घटकांना प्राप्त करण्यास अपयशी"
+
+#~ msgid "Caching contact %d/%d"
+#~ msgstr "संपर्क %d/%d कॅश करत आहे"
+
+#~ msgid "Failed to list items from a server"
+#~ msgstr "सर्व्हरपासून घटकांची सूची बनवण्यास अपयशी"
+
+#~ msgid "Failed to transfer contacts from a server"
+#~ msgstr "सर्व्हरपासून संपर्क स्थानांतरीत करतेवेळी त्रुटी आढळली"
+
+#~ msgid "Caching GAL contact %d"
+#~ msgstr "GAL संपर्क %d कॅश करत आहे"
+
+#~ msgid "Caching GAL contact %d/%d"
+#~ msgstr "GAL संपर्क %d/%d कॅश करत आहे"
+
+#~ msgid "Loading items in folder %s"
+#~ msgstr "फोल्डर %s अंतर्गत घटक दाखल करत आहे"
+
+#~ msgid "Failed to open folder: %s"
+#~ msgstr "फोल्डर: %s उघडण्यास अपयशी"
+
+#~ msgid "Failed to get folder properties: %s"
+#~ msgstr "फोल्डर गुणधर्म: %s प्राप्त करण्यास अपयशी"
+
+#~ msgid "Failed to list objects: %s"
+#~ msgstr "ऑब्जेक्ट्स्: %s सूचीत दाखवण्यास अपयशी"
+
+#~ msgid ""
+#~ "Support for modifying single instances of a recurring appointment is not "
+#~ "yet implemented. No change was made to the appointment on the server."
+#~ msgstr ""
+#~ "पुनराकृत भेट घटना संपादीत करण्याकरीता सर्मथन अजूनही लागू केले गेले नाही. सर्व्हर वरील "
+#~ "भेट करीता बदल लागू केले गेले नाही."
+
+#~ msgid "Cannot remove items from a server"
+#~ msgstr "सर्व्हरपासून घटकांना काढून टाकणे अशक्य"
+
+#~ msgid "Failed to get Free/Busy data"
+#~ msgstr "मोकळे/व्यस्त डाटा प्राप्त करण्यास अपयशी"
+
+#~ msgid "Refreshing folder '%s'"
+#~ msgstr "फोल्डर '%s' ताजे करत आहे"
+
+#~ msgid "Downloading messages in folder '%s'"
+#~ msgstr "फोल्डर '%s' मध्ये संदेश डाउनलोड करत आहे"
+
+#~ msgid "This message is not available in offline mode."
+#~ msgstr "हे संदेश ऑफलाइन पद्धतीत उपलब्ध नाही."
+
+#~ msgid "Fetching items failed: %s"
+#~ msgstr "घटकांना प्राप्त करणे अपयशी: %s"
+
+#~ msgid "Fetching items failed"
+#~ msgstr "घटक प्राप्त करणे अशक्य"
+
+#~ msgid "Offline."
+#~ msgstr "ऑफलाइन."
+
+#~ msgid "Failed to empty Trash: %s"
+#~ msgstr "कचरापेटी: %s रिकामे करण्यास अपयशी"
+
+#~ msgid "Failed to empty Trash"
+#~ msgstr "कचरापेटी रिकामे करण्यास अपयशी"
+
+#~ msgid "Cannot get message %s: %s"
+#~ msgstr "संदेश %s प्राप्त करणे अशक्य: %s"
+
+#~ msgid "No such message"
+#~ msgstr "यानुरूप संदेश आढळले नाही"
+
+#~ msgid "Could not get message: %s"
+#~ msgstr "संदेश: %s प्राप्त करणे अशक्य"
+
+#~ msgid "Could not get message"
+#~ msgstr "संदेश प्राप्त करणे अशक्य"
+
+#~ msgid "Receive quota"
+#~ msgstr "कोटा प्राप्त करा"
+
+#~ msgid "Send quota"
+#~ msgstr "कोट पाठवा"
+
+#~ msgid "No quota information available"
+#~ msgstr "कोट माहिती अनुपलब्ध"
+
+#~ msgid "Lis_ten for server notifications"
+#~ msgstr "सर्व्हर सूचनांकरीता ऐका (_t)"
+
+#~ msgid "For accessing Microsoft Exchange 2007/OpenChange servers via MAPI"
+#~ msgstr "MAPI तर्फे माइक्रोसॉफ्ट एक्सचेंज 2007/ओपनचेंज सर्व्हर्सकरीता प्रवेश करण्याकरीता"
+
+#~ msgid "Password"
+#~ msgstr "पासवर्ड"
+
+#~ msgid "Kerberos"
+#~ msgstr "केर्बेरोस्"
+
+#~ msgid "This option will connect to the server using kerberos key."
+#~ msgstr "हा पर्याय केर्बेरोस् किचा वापर करून सर्व्हरशी जोडणी स्थापीत करेल."
+
+#~ msgid "No folder found"
+#~ msgstr "फोल्डर आढळले नाही"
+
+#~ msgid "Cannot create new folder '%s'"
+#~ msgstr "नवीन फोल्डर '%s' निर्माण करणे अशक्य"
+
+#~ msgid "MAPI folders can be created only within mailbox of the logged user"
+#~ msgstr "प्रवेश केलेल्या वापरकर्त्याच्या मेलबॉक्समध्ये MAPI फोल्डर्सचे निर्माण करा"
+
+#~ msgid "Cannot find folder '%s'"
+#~ msgstr "फोल्डर '%s' शोधणे अशक्य"
+
+#~ msgid "Cannot create folder '%s': %s"
+#~ msgstr "'%s': %s निर्माण करणे अशक्य"
+
+#~ msgid "Cannot create folder '%s'"
+#~ msgstr "'%s' निर्माण करणे अशक्य"
+
+#~ msgid "Cannot delete MAPI folders in offline mode"
+#~ msgstr "ऑफलाइन पद्धतीत MAPI फोल्डर्स् नष्ट करणे अशक्य"
+
+#~ msgid "Cannot remove folder '%s': %s"
+#~ msgstr "फोल्डर '%s': %s ला काढून टाकणे अशक्य"
+
+#~ msgid "Cannot remove folder '%s'"
+#~ msgstr "फोल्डर '%s' काढून टाकणे अशक्य"
+
+#~ msgid "Cannot rename MAPI folders in offline mode"
+#~ msgstr "ऑफलाइन पद्धतीत MAPI फोल्डर्सकरीता पुनःनामांकन अशक्य"
+
+#~ msgid "Cannot rename MAPI default folder '%s' to '%s'"
+#~ msgstr "MAPI पूर्वनिर्धारित फोल्डर '%s' पासून '%s' असे पुन्हनामांकन अशक्य"
+
+#~ msgid "Cannot rename MAPI folder '%s' to '%s'"
+#~ msgstr "MAPI फोल्डरचे '%s' पासून '%s' असे पुन्हनामांकन अशक्य"
+
+#~ msgid "Cannot rename MAPI folder '%s' to '%s': %s"
+#~ msgstr "MAPI फोल्डर '%s' ला '%s': %s करीता पुनःनामांकीत करणे अशक्य"
+
+#~ msgid "Cannot connect MAPI store in offline mode"
+#~ msgstr "ऑफलाइन पद्धतीत MAPI स्टोरसह जोडणी अशक्य"
+
+#~ msgid "Mailbox '%s' is full, no new messages will be received or sent."
+#~ msgstr "मेलबॉक्स् '%s' भरले, नवीन संदेश प्राप्त करणे किंवा पाठवणे अशक्य."
+
+#~ msgid ""
+#~ "Mailbox '%s' is near its size limit, message send will be disabled soon."
+#~ msgstr ""
+#~ "मेलबॉक्स् '%s' मध्ये आकार मर्यादाच्या नजिक आले, पाठवलेल्या संदेशला लवकरत बंद केले जाईल."
+
+#~ msgid "Mailbox '%s' is full, no new messages will be received."
+#~ msgstr "मेलबॉक्स् '%s' भरले, नवीन संदेश प्राप्त करणे अशक्य."
+
+#~ msgid "Mailbox '%s' is near its size limit."
+#~ msgstr "मेलबॉक्स् '%s' आकार मर्यादाच्या नजिक आले."
+
+#~ msgid "Could not send message."
+#~ msgstr "संदेश पाठवण्यास अशक्य."
+
+#~ msgid "Could not send message: %s"
+#~ msgstr "संदेश पाठवणे अशक्य: %s"
+
+#~ msgid "Allow _partial search results"
+#~ msgstr "अपुरे शोध परिणाम स्वीकारा (_p)"
+
+#~ msgid "Select username"
+#~ msgstr "वापरकर्त्याचे नाव नीवडा"
+
+#~ msgid "Full name"
+#~ msgstr "पूर्ण नाव"
+
+#~ msgid "Username"
+#~ msgstr "वापरकर्तानाव"
+
+#~ msgid ""
+#~ "There are more users with similar user name on a server.\n"
+#~ "Please select that you would like to use from the below list."
+#~ msgstr ""
+#~ "सर्व्हरवर समान वापरकर्तानावसह एकापेक्षा जास्त वापरकर्ते आहेत.\n"
+#~ "कृपया खालिल सूचीपासून नीवडा."
+
+#~ msgid "Authentication finished successfully."
+#~ msgstr "ओळख पटवणे यशस्वीरित्या पूर्ण झाले."
+
+#~ msgid "Authentication failed."
+#~ msgstr "ओळख पटवणे अपयशी."
+
+#~ msgid "Cannot authenticate MAPI accounts in offline mode"
+#~ msgstr "ऑफलाइन पद्धतीत MAPI खात्यांची ओळख पटवणे अशक्य"
+
+#~ msgid ""
+#~ "Server, username and domain name cannot be empty. Please fill them with "
+#~ "correct values."
+#~ msgstr ""
+#~ "सर्व्हर, वापरकर्तानाव व क्षेत्र नाव रिकामे असू शकत नाही. कृपया योग्य मूल्य प्रविष्ट करा."
+
+#~ msgid ""
+#~ "Realm name cannot be empty when kerberos is selected. Please fill them "
+#~ "with correct values."
+#~ msgstr "कर्बेरोज् नीवडल्यानंतर रिअल्म रिकामे असणे अशक्य. कृपया त्यांना योग्य मूल्यांसह भरा."
+
+#~ msgid "Connecting to the server, please wait..."
+#~ msgstr "सर्व्हरशी जोडणी करत आहे, कृपया प्रतिक्षा करा..."
+
+#~ msgid "_Server:"
+#~ msgstr "सर्व्हर (_S):"
+
+#~ msgid "_Domain name:"
+#~ msgstr "क्षेत्र नाव (_D):"
+
+#~ msgid "_Use secure connection"
+#~ msgstr "सुरक्षीत जोडणीचा वापर करा (_U)"
+
+#~ msgid "_Kerberos authentication"
+#~ msgstr "कर्बेरोज ओळख पटवणे (_K)"
+
+#~ msgid "_Realm name:"
+#~ msgstr "रिअल्म नाव (_R):"
+
+#~ msgid "MAPI Settings"
+#~ msgstr "MAPI संरचना"
+
+#~ msgid "View the size of all Exchange folders"
+#~ msgstr "सर्व एक्सचेंज फोल्डर्सच्या आकाराचे दृष्य"
+
+#~ msgid "Folder _Size"
+#~ msgstr "फोल्डर आकार (_S)"
+
+#~ msgid "Folder"
+#~ msgstr "फोल्डर"
+
+#~ msgid "Size"
+#~ msgstr "आकार"
+
+#~ msgid "Unable to retrieve folder size information"
+#~ msgstr "फोल्डर आकार विषयी माहिती प्राप्त करण्यास अशक्य"
+
+#~ msgid "Folder Size"
+#~ msgstr "फोल्डरचे आकार"
+
+#~ msgid "Fetching folder list…"
+#~ msgstr "फोल्डर सूची प्राप्त करत आहे..."
+
+#~ msgid "Folder size..."
+#~ msgstr "फोल्डर आकार..."
+
+#~ msgid "Personal Folders"
+#~ msgstr "वैयक्तिक फोल्डर"
+
+#~ msgid "Searching remote MAPI folder structure, please wait..."
+#~ msgstr "दूरस्त MAPI फोल्डर मांडणी शोधत आहे, कृपया प्रतिक्षा करा..."
+
+#~ msgid "Cannot create MAPI calendar in offline mode"
+#~ msgstr "ऑफलाइन पद्धतीत MAPI दिनदर्शिका बनवणे अशक्य"
+
+#~ msgid "Cannot create MAPI task list in offline mode"
+#~ msgstr "ऑफलाइन पद्धतीत MAPI कार्य सूची निर्माण करणे अशक्य"
+
+#~ msgid "Cannot create MAPI memo list in offline mode"
+#~ msgstr "ऑफलाइन पद्धतीत MAPI मेमो सूची निर्माण करणे अशक्य"
+
+#~ msgid "Cannot create MAPI address book in offline mode"
+#~ msgstr "ऑफलाइन पद्धतीत MAPI फोल्डर बनवणे अशक्य"
+
+#~ msgid "Cannot create MAPI source in offline mode"
+#~ msgstr "ऑफलाइन पद्धतीत MAPI फोल्डर बनवणे अशक्य"
+
+#~ msgid "_Location:"
+#~ msgstr "ठिकाण (_L):"
+
+#~ msgctxt "Permissions"
+#~ msgid "Detailed Free/Busy"
+#~ msgstr "तपशील मोकळे/वयस्त"
+
+#~ msgid "Cannot add folder, failed to add to store's summary"
+#~ msgstr "फोल्डर समाविष्ट करणे अशक्य, स्टोरचे सारांश समाविष्ट करण्यास अपयशी"
+
+#~ msgid "Subscribe to folder of other MAPI user..."
+#~ msgstr "इतर MAPI वापरकर्ताच्या फोल्डरकरीता सबस्क्राइब व्हा..."
+
+#~ msgctxt "MeetingResp"
+#~ msgid "Accepted:"
+#~ msgstr "स्वीकारले:"
+
+#~ msgctxt "MeetingResp"
+#~ msgid "Tentative:"
+#~ msgstr "तात्पुर्ते:"
+
+#~ msgctxt "MeetingResp"
+#~ msgid "Declined:"
+#~ msgstr "नकारले:"
+
+#~ msgid "Failed to login into the server"
+#~ msgstr "सर्व्हरमध्ये प्रवेश करण्यास अपयशी"
+
+#~ msgid "Cannot create more sessions, session limit was reached"
+#~ msgstr "एकापेक्षा जास्त सत्र निर्माण करणे अशक्य, सत्र मर्यादा आढळली"
+
+#~ msgid "User cancelled operation"
+#~ msgstr "वापरकर्ताने कार्य रद्द केले"
+
+#~ msgid "Unable to abort"
+#~ msgstr "रद्द करणे अशक्य"
+
+#~ msgid "Network error"
+#~ msgstr "नेटवर्क त्रुटी"
+
+#~ msgid "Disk error"
+#~ msgstr "डिस्क त्रुटी"
+
+#~ msgid "Password change required"
+#~ msgstr "पासवर्ड बदल आवश्यक"
+
+#~ msgid "Password expired"
+#~ msgstr "पासवर्ड वेळसमाप्ति"
+
+#~ msgid "Invalid workstation account"
+#~ msgstr "अवैध वर्कस्टेशन खाते"
+
+#~ msgid "Invalid access time"
+#~ msgstr "अवैध प्रवेश वेळ"
+
+#~ msgid "Account is disabled"
+#~ msgstr "खाते बंद केले"
+
+#~ msgid "End of session"
+#~ msgstr "सत्राची समाप्ति"
+
+#~ msgid "MAPI is not initialized or connected"
+#~ msgstr "MAPI सुरू केले नाही किंवा जोडणी शक्य नाही"
+
+#~ msgid "Permission denied"
+#~ msgstr "परवानगी नाही"
+
+#~ msgid "Mailbox quota exceeded"
+#~ msgstr "मेलबॉक्स कोट वाढले"
+
+#~ msgid "MAPI error %s (0x%x) occurred"
+#~ msgstr "MAPI त्रुटी %s (0x%x) आढळली"
+
+#~ msgctxt "EXCHANGEMAPI_ERROR"
+#~ msgid "%s: %s"
+#~ msgstr "%s: %s"
+
+#~ msgid "Server '%s' cannot be reached"
+#~ msgstr "सर्व्हर '%s' पर्यंत पोहचणे अशक्य"
+
+#~ msgid "Folder name '%s' is not a known default folder name, nor folder ID."
+#~ msgstr "फोल्डर नाव '%s' परिचीत पूर्वनिर्धारित फोल्डर नाव, किंवा फोल्डर ID नाही."
+
+#~ msgid "Failed to open store for user '%s'"
+#~ msgstr "वापरकर्ता '%s' करीता स्टोर उघडण्यास अपयशी"
+
+#~ msgid "Folder of user '%s' not found"
+#~ msgstr "वापरकर्ता '%s' चे फोल्डर आढळले नाही"
+
+#~ msgid "Recipient '%s' is ambiguous"
+#~ msgstr "रेसिपिएंट '%s' संदिग्ध आहे"
+
+#~ msgid ""
+#~ "Search result exceeded allowed size limit. Use more specific search term, "
+#~ "please"
+#~ msgstr ""
+#~ "शोध परिणाम स्वीकार्य आकार मर्यादापेक्षा जास्त आहे. कृपया, अधिक निर्देशीत शोध संज्ञाचा "
+#~ "वापर करा"
+
+#~ msgid "All Public Folders"
+#~ msgstr "सर्व सार्वजणीक फोल्डर"
+
+#~ msgid "Enter Password for %s@%s"
+#~ msgstr "%s@%s करीता पासवर्ड प्रविष्ट करा"
+
+#~ msgid "Miscellaneous"
+#~ msgstr "मिश्र"
+
+#~ msgid "Failed to fetch changes from a server"
+#~ msgstr "सर्व्हरपासून बदल प्राप्त करण्यास अपयशी"
+
+#~ msgid "Could not create thread for populating cache"
+#~ msgstr "कॅशे करीता थ्रेड बनविण्यास अशक्य"
+
+#~ msgid "Updating local summary cache for new messages in %s"
+#~ msgstr "%s अंतर्गत नवीन संदेश करीता सारांश माहिती सुधारीत करत आहे"
+
+#~ msgid "Retrieving message IDs from server for %s"
+#~ msgstr "%s करीता सर्व्हरपासून संदेश IDs प्राप्त करत आहे"
+
+#~ msgid "Removing deleted messages from cache in %s"
+#~ msgstr "%s मधील कॅशे पासून रद्द केलेले संदेश काढून टाकत आहे"
+
+#~ msgid "Fetching summary information for new messages in %s"
+#~ msgstr "%s अंतर्गत नवीन संदेश करीता सारांश माहिती प्राप्त करत आहे"
+
+#~ msgid "%s Please enter the MAPI password for %s@%s"
+#~ msgstr "%2$s@%3$s करीता कृपया %1$s MAPI पासवर्ड प्रविष्ट करा"
+
+#~ msgid "You did not enter a password."
+#~ msgstr "तुम्ही पासवर्ड प्रविष्ट केला नाही."
+
+#~ msgid "Unable to authenticate to Exchange MAPI server: %s"
+#~ msgstr "एक्सचेंज MAPI सर्व्हर: %s सह ओळख पटवण्यास अशक्य"
+
+#~ msgid "Unable to authenticate to Exchange MAPI server"
+#~ msgstr "एक्सचेंज MAPI सर्व्हर सह ओळख पटवणे अशक्य."
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/nb.po evolution-ews.sync-with-3.8.2/po/nb.po
--- evolution-ews.git-gnome-3-0/po/nb.po	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/po/nb.po	2013-05-29 08:46:45.665987863 +0200
@@ -0,0 +1,341 @@
+# Norwegian bokmål translation of evolution-ews.
+# Copyright (C) 1998-2004, 2005 Free Software Foundation, Inc.
+#
+# Kjartan Maraas <kmaraas@gnome.org>, 1998-2011.
+# Terance Edward Sola <terance@lyse.net>, 2005.
+# Torstein Adolf Winterseth <kvikende@fsfe.org>, 2010.
+msgid ""
+msgstr ""
+"Project-Id-Version: evolution 3.3.x\n"
+"Report-Msgid-Bugs-To: \n"
+"POT-Creation-Date: 2011-12-21 14:21+0100\n"
+"PO-Revision-Date: 2011-12-21 14:36+0100\n"
+"Last-Translator: Kjartan Maraas <kmaraas@gnome.org>\n"
+"Language-Team: Norwegian Bokmål <i18n-nb@lister.ping.uio.no>\n"
+"Language: Norsk bokmål\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-listener.c:240
+msgid "Global Address list"
+msgstr "Global adresseliste"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:104
+#, c-format
+msgid "Autodiscover failed: %s"
+msgstr "Automatisk gjenkjenning feilet: %s"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:147
+#, c-format
+msgid "Enter Password for %s"
+msgstr "Skriv inn passord for %s"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:156
+msgid "Could not get password."
+msgstr "Fant ikke passord."
+
+#. OAB url entry
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:275
+msgid "OAB U_RL:"
+msgstr "U_RL til OAB:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:287
+msgid "_Host URL:"
+msgstr "_Verts-URL:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:302
+msgid "Fetch _URL"
+msgstr "Hent _URL"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:462
+#, fuzzy
+msgid "Could not fetch oal list: "
+msgstr "Kunne ikke åpne lenken."
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:507
+msgid "Fetching..."
+msgstr "Henter …"
+
+#. Add cache check box
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:636
+#, fuzzy
+msgid "Cache o_ffline address book"
+msgstr "evolution adressebok"
+
+#. Add label
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:642
+msgid "Select Ad_dress list: "
+msgstr "Velg a_dresseliste: "
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:652
+msgid "Fetch _list"
+msgstr "Hent _liste"
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:1
+#: ../src/camel/camel-ews-provider.c:69
+msgid "Exchange Web Services"
+msgstr ""
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:2
+msgid "Exchange Web Services Plugin"
+msgstr ""
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:3
+msgid "GAL settings"
+msgstr "Innstillinger for GAL"
+
+#: ../src/addressbook/e-book-backend-ews.c:827
+msgid "The backend does not support bulk additions"
+msgstr ""
+
+#: ../src/addressbook/e-book-backend-ews.c:1094
+#, fuzzy
+msgid "The backend does not support bulk modifications"
+msgstr "Denne tjeneren støtter ikke LDAPv3 schema-informasjon."
+
+#: ../src/addressbook/e-book-backend-ews.c:1494
+#, c-format
+msgid "Downloading contacts in %s %d%% completed... "
+msgstr ""
+
+#: ../src/addressbook/e-book-backend-ews.c:1884
+#, fuzzy
+msgid "Syncing contacts..."
+msgstr "_Finn i kontakt …"
+
+#: ../src/addressbook/e-book-backend-ews.c:2080
+msgid "Searching..."
+msgstr "Søker …"
+
+#: ../src/addressbook/e-book-backend-sqlitedb.c:470
+#, c-format
+msgid "Insufficient memory"
+msgstr "Ikke nok minne"
+
+#: ../src/calendar/e-cal-backend-ews.c:3556
+#, fuzzy, c-format
+msgid "Unknown calendar property '%s'"
+msgstr "Åpner kalender på %s"
+
+#: ../src/camel/camel-ews-folder.c:255
+#, fuzzy, c-format
+msgid "Unable to open mimecontent temporary file!"
+msgstr "Kan ikke lese lisensfilen."
+
+#: ../src/camel/camel-ews-folder.c:262
+#, fuzzy, c-format
+msgid "Unable to generate parser from mimecontent!"
+msgstr "Kunne ikke lese oppføring"
+
+#: ../src/camel/camel-ews-folder.c:271
+#, c-format
+msgid "Unable to parse meeting request mimecontent!"
+msgstr ""
+
+#: ../src/camel/camel-ews-folder.c:328
+#, fuzzy, c-format
+msgid "Unable to create cache file"
+msgstr "Kan ikke lese lisensfilen."
+
+#: ../src/camel/camel-ews-folder.c:425 ../src/camel/camel-ews-folder.c:494
+#, fuzzy, c-format
+msgid "Unable to create cache path"
+msgstr "Klarte ikke å opprette tråd: %s"
+
+#: ../src/camel/camel-ews-folder.c:503
+#, fuzzy, c-format
+msgid "Failed to move message cache file"
+msgstr "Klarte ikke å lagre meldinger til disk."
+
+#: ../src/camel/camel-ews-folder.c:883
+#, fuzzy, c-format
+msgid "Could not load summary for %s"
+msgstr "Kunne ikke laste «%s»"
+
+#: ../src/camel/camel-ews-folder.c:1213 ../src/camel/camel-ews-store.c:643
+#: ../src/camel/camel-ews-store.c:699 ../src/camel/camel-ews-store.c:767
+#, c-format
+msgid "Cant perform actions on the folder while in offline mode"
+msgstr ""
+
+#: ../src/camel/camel-ews-provider.c:48
+msgid "Checking for new mail"
+msgstr "Ser etter nye meldinger"
+
+#: ../src/camel/camel-ews-provider.c:50
+#, fuzzy
+msgid "C_heck for new messages in all folders"
+msgstr "Se etter nye meldinger ved oppstart"
+
+#: ../src/camel/camel-ews-provider.c:53
+msgid "Options"
+msgstr "Alternativer"
+
+#: ../src/camel/camel-ews-provider.c:55
+#, fuzzy
+msgid "_Apply filters to new messages in Inbox on this server"
+msgstr "Im nye meldinger kun skal varsles i innboksen."
+
+#: ../src/camel/camel-ews-provider.c:57
+#, fuzzy
+msgid "Check new messages for Jun_k contents"
+msgstr "Se etter nye meldinger ved oppstart"
+
+#: ../src/camel/camel-ews-provider.c:59
+#, fuzzy
+msgid "Only check for Junk messages in the IN_BOX folder"
+msgstr "Det er ingen meldinger i denne mappen."
+
+#: ../src/camel/camel-ews-provider.c:61
+msgid "Automatically synchroni_ze remote mail locally"
+msgstr ""
+
+#: ../src/camel/camel-ews-provider.c:71
+msgid "For accessing Exchange servers using Web Services"
+msgstr ""
+
+#: ../src/camel/camel-ews-provider.c:87
+msgid "Password"
+msgstr "Passord"
+
+#: ../src/camel/camel-ews-provider.c:89
+#, fuzzy
+msgid ""
+"This option will connect to the Exchange server using a plaintext password."
+msgstr "Dette valget vil koble til tjeneren via GNOME nettkontotjenesten"
+
+#: ../src/camel/camel-ews-store.c:183
+#, c-format
+msgid "Session has no storage path"
+msgstr ""
+
+#: ../src/camel/camel-ews-store.c:447
+#, c-format
+msgid "No such folder: %s"
+msgstr "Mappen eksisterer ikke: %s"
+
+#: ../src/camel/camel-ews-store.c:636
+#, c-format
+msgid "Parent folder %s does not exist"
+msgstr "Opphavsmappe %s eksisterer ikke"
+
+#: ../src/camel/camel-ews-store.c:693
+#, c-format
+msgid "Folder does not exist"
+msgstr "Mappen eksisterer ikke"
+
+#: ../src/camel/camel-ews-store.c:775
+#, c-format
+msgid "Folder %s does not exist"
+msgstr "Mappen %s eksisterer ikke"
+
+#: ../src/camel/camel-ews-store.c:784
+#, c-format
+msgid "No change key record for folder %s"
+msgstr ""
+
+#: ../src/camel/camel-ews-store.c:823
+#, c-format
+msgid "Cannot both rename and move a folder at the same time"
+msgstr ""
+
+#: ../src/camel/camel-ews-store.c:854
+#, c-format
+msgid "Cannot find folder ID for parent folder %s"
+msgstr ""
+
+#: ../src/camel/camel-ews-store.c:890 ../src/camel/camel-ews-transport.c:66
+#, c-format
+msgid "Exchange server %s"
+msgstr ""
+
+#: ../src/camel/camel-ews-store.c:892
+#, c-format
+msgid "Exchange service for %s on %s"
+msgstr ""
+
+#: ../src/camel/camel-ews-store.c:927
+#, c-format
+msgid "You must be working online to complete this operation"
+msgstr ""
+
+#: ../src/camel/camel-ews-transport.c:69
+#, c-format
+msgid "Exchange mail delivery via %s"
+msgstr ""
+
+#: ../src/camel/camel-ews-transport.c:102
+#, fuzzy, c-format
+msgid "Service not connected"
+msgstr "Pros_ent fullført:"
+
+#: ../src/server/e-ews-connection.c:354
+msgid "Operation Cancelled"
+msgstr "Operasjonen ble avbrutt"
+
+#: ../src/server/e-ews-connection.c:408
+msgid "Authentication failed"
+msgstr "Autentisering feilet"
+
+#: ../src/server/e-ews-connection.c:416
+#, c-format
+msgid "No response: %s"
+msgstr "Ikke svar: %s"
+
+#: ../src/server/e-ews-connection.c:1110 ../src/server/e-ews-connection.c:1455
+#: ../src/server/e-ews-connection.c:1692
+#, c-format
+msgid "Code: %d - Unexpected response from server"
+msgstr ""
+
+#: ../src/server/e-ews-connection.c:1122
+#, fuzzy, c-format
+msgid "Failed to parse autodiscover response XML"
+msgstr "Klarte ikke å tolke svar fra tjener."
+
+#: ../src/server/e-ews-connection.c:1130
+#, fuzzy, c-format
+msgid "Failed to find <Autodiscover> element\n"
+msgstr "Klarte ikke å finne duplikatmeldinger."
+
+#: ../src/server/e-ews-connection.c:1142
+#, c-format
+msgid "Failed to find <Response> element\n"
+msgstr ""
+
+#: ../src/server/e-ews-connection.c:1154
+#, c-format
+msgid "Failed to find <Account> element\n"
+msgstr ""
+
+#: ../src/server/e-ews-connection.c:1173
+#, c-format
+msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
+msgstr ""
+
+#: ../src/server/e-ews-connection.c:1271
+#, fuzzy, c-format
+msgid "Both email and password must be provided"
+msgstr "Passord ikke oppgitt"
+
+#: ../src/server/e-ews-connection.c:1278
+#, fuzzy, c-format
+msgid "Wrong email id"
+msgstr "Bruker e-postadresse"
+
+#: ../src/server/e-ews-connection.c:1465
+#, fuzzy, c-format
+msgid "Failed to parse oab XML"
+msgstr "Klarte ikke å åpne mappe."
+
+#: ../src/server/e-ews-connection.c:1472
+#, fuzzy, c-format
+msgid "Failed to find <OAB> element\n"
+msgstr "Klarte ikke å slette kontakt"
+
+#: ../src/utils/ews-camel-common.c:138
+#, c-format
+msgid "CreateItem call failed to return ID for new message"
+msgstr ""
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/pl.po evolution-ews.sync-with-3.8.2/po/pl.po
--- evolution-ews.git-gnome-3-0/po/pl.po	2013-05-17 14:36:16.328670463 +0200
+++ evolution-ews.sync-with-3.8.2/po/pl.po	2013-05-29 08:46:45.662641660 +0200
@@ -4,12 +4,14 @@
 # pomóc w jego rozwijaniu i pielęgnowaniu, napisz do nas:
 # gnomepl@aviary.pl
 # -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+# Piotr Drąg <piotrdrag@gmail.com>, 2010-2013.
+# Aviary.pl <gnomepl@aviary.pl>, 2010-2013.
 msgid ""
 msgstr ""
 "Project-Id-Version: evolution-ews\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2011-10-10 19:05+0200\n"
-"PO-Revision-Date: 2011-10-10 19:06+0200\n"
+"POT-Creation-Date: 2013-02-17 15:38+0100\n"
+"PO-Revision-Date: 2013-02-17 15:39+0100\n"
 "Last-Translator: Piotr Drąg <piotrdrag@gmail.com>\n"
 "Language-Team: Polish <gnomepl@aviary.pl>\n"
 "Language: pl\n"
@@ -21,133 +23,80 @@ msgstr ""
 "X-Poedit-Language: Polish\n"
 "X-Poedit-Country: Poland\n"
 
-#: ../src/account-setup-eplugin/exchange-ews-account-listener.c:247
-msgid "Global Address list"
-msgstr "Ogólna lista adresowa"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:114
-#, c-format
-msgid "Autodiscover failed: %s"
-msgstr "Wykrywanie automatyczne się nie powiodło: %s"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:149
-#, c-format
-msgid "Enter Password for %s"
-msgstr "Proszę wprowadzić hasło dla %s"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:158
-msgid "Could not get password."
-msgstr "Nie można uzyskać hasła."
-
-#. OAB url entry
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:262
-msgid "OAB U_RL:"
-msgstr "Adres U_RL OAB:"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:274
-msgid "_Host URL:"
-msgstr "Adres URL _komputera:"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:287
-msgid "Fetch _URL"
-msgstr "Pobierz adres _URL"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:453
-msgid "Could not fetch oal list: "
-msgstr "Nie można pobrać listy oal: "
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:495
-msgid "Fetching..."
-msgstr "Pobieranie..."
-
-#. Add cache check box
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:632
-msgid "Cache o_ffline address book"
-msgstr ""
-"_Przechowywanie książki adresowej w buforze podczas pracy w trybie offline"
-
-#. Add label
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:638
-msgid "Select Ad_dress list: "
-msgstr "Wybór listy a_dresów: "
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:648
-msgid "Fetch _list"
-msgstr "_Pobierz listę"
-
-#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:1
-#: ../src/camel/camel-ews-provider.c:69
-msgid "Exchange Web Services"
-msgstr "Exchange Web Services"
-
-#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:2
-msgid "Exchange Web Services Plugin"
-msgstr "Wtyczka usługi Exchange Web Services"
-
-#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:3
-msgid "GAL settings"
-msgstr "Ustawienia GAL"
+#: ../src/addressbook/e-book-backend-ews.c:969
+msgid "The backend does not support bulk additions"
+msgstr "Mechanizm nie obsługuje dodawania całości"
+
+#: ../src/addressbook/e-book-backend-ews.c:1253
+msgid "The backend does not support bulk modifications"
+msgstr "Mechanizm nie obsługuje modyfikacji całości"
 
 #: ../src/addressbook/e-book-backend-ews.c:1436
+msgid "Wait till syncing is done"
+msgstr "Oczekiwanie na ukończenie synchronizacji"
+
+#: ../src/addressbook/e-book-backend-ews.c:1775
 #, c-format
 msgid "Downloading contacts in %s %d%% completed... "
 msgstr "Pobieranie kontaktów w %s %d%% ukończono... "
 
-#: ../src/addressbook/e-book-backend-ews.c:1826
+#: ../src/addressbook/e-book-backend-ews.c:2324
 msgid "Syncing contacts..."
 msgstr "Synchronizowanie kontaktów..."
 
-#: ../src/addressbook/e-book-backend-ews.c:2023
+#: ../src/addressbook/e-book-backend-ews.c:2548
+#: ../src/configuration/e-ews-search-user.c:364
 msgid "Searching..."
 msgstr "Wyszukiwanie..."
 
-#: ../src/addressbook/e-book-backend-sqlitedb.c:470
-#, c-format
-msgid "Insufficient memory"
-msgstr "Brak pamięci"
-
-#: ../src/calendar/e-cal-backend-ews.c:3793
-#, c-format
-msgid "Unknown calendar property '%s'"
-msgstr "Nieznana właściwość kalendarza \"%s\""
+#: ../src/calendar/e-cal-backend-ews.c:1009
+msgid "EWS does not support bulk removals"
+msgstr "EWS nie obsługuje usuwania całości"
+
+#: ../src/calendar/e-cal-backend-ews.c:1652
+msgid "EWS does not support bulk additions"
+msgstr "EWS nie obsługuje dodawania całości"
+
+#: ../src/calendar/e-cal-backend-ews.c:2231
+msgid "EWS does not support bulk modifications"
+msgstr "EWS nie obsługuje modyfikacji całości"
 
-#: ../src/camel/camel-ews-folder.c:200
+#: ../src/camel/camel-ews-folder.c:268
 #, c-format
 msgid "Unable to open mimecontent temporary file!"
 msgstr "Nie można otworzyć tymczasowego pliku treści MIME."
 
-#: ../src/camel/camel-ews-folder.c:207
+#: ../src/camel/camel-ews-folder.c:276
 #, c-format
 msgid "Unable to generate parser from mimecontent!"
 msgstr "Nie można utworzyć parsera z treści MIME."
 
-#: ../src/camel/camel-ews-folder.c:215
+#: ../src/camel/camel-ews-folder.c:285
 #, c-format
 msgid "Unable to parse meeting request mimecontent!"
 msgstr "Nie można przetworzyć treści MIME żądania spotkania."
 
-#: ../src/camel/camel-ews-folder.c:272
+#: ../src/camel/camel-ews-folder.c:346
 #, c-format
 msgid "Unable to create cache file"
 msgstr "Nie można utworzyć pliku bufora"
 
-#: ../src/camel/camel-ews-folder.c:372 ../src/camel/camel-ews-folder.c:441
+#: ../src/camel/camel-ews-folder.c:451 ../src/camel/camel-ews-folder.c:531
 #, c-format
 msgid "Unable to create cache path"
 msgstr "Nie można utworzyć ścieżki bufora"
 
-#: ../src/camel/camel-ews-folder.c:450
+#: ../src/camel/camel-ews-folder.c:541
 #, c-format
 msgid "Failed to move message cache file"
 msgstr "Przeniesienie pliku bufora wiadomości się nie powiodło"
 
-#: ../src/camel/camel-ews-folder.c:798
+#: ../src/camel/camel-ews-folder.c:1188
 #, c-format
 msgid "Could not load summary for %s"
 msgstr "Nie można wczytać zestawienia dla %s"
 
-#: ../src/camel/camel-ews-folder.c:1124 ../src/camel/camel-ews-store.c:575
-#: ../src/camel/camel-ews-store.c:632 ../src/camel/camel-ews-store.c:701
+#: ../src/camel/camel-ews-folder.c:1624
 #, c-format
 msgid "Cant perform actions on the folder while in offline mode"
 msgstr "Nie można wykonać działań na katalogu w trybie offline"
@@ -170,7 +119,7 @@ msgstr ""
 "_Zastosowanie filtrów na nowych wiadomościach w Nadchodzących na tym serwerze"
 
 #: ../src/camel/camel-ews-provider.c:57
-msgid "Check new messages for Jun_k contents"
+msgid "Check new messages for _Junk contents"
 msgstr "Sp_rawdzanie nowych wiadomości pod kątem niechcianych wiadomości"
 
 #: ../src/camel/camel-ews-provider.c:59
@@ -181,158 +130,974 @@ msgstr "Sprawdzanie niechcianych wiadomo
 msgid "Automatically synchroni_ze remote mail locally"
 msgstr "Automatyczna _synchronizacja kont lokalnie"
 
-#: ../src/camel/camel-ews-provider.c:71
+#: ../src/camel/camel-ews-provider.c:64
+msgid "Connection"
+msgstr "Połączenie"
+
+#. Translators: '%s' is preplaced with a widget, where "
+#. * user can select how long the timeout should be.
+#: ../src/camel/camel-ews-provider.c:68
+#, c-format
+msgid "Connection _timeout (in seconds) %s"
+msgstr "_Czas oczekiwania na połączenie (w sekundach) %s"
+
+#: ../src/camel/camel-ews-provider.c:76
+msgid "Exchange Web Services"
+msgstr "Exchange Web Services"
+
+#: ../src/camel/camel-ews-provider.c:78
 msgid "For accessing Exchange servers using Web Services"
 msgstr "Dostęp do serwerów Exchange używając Web Services"
 
-#: ../src/camel/camel-ews-provider.c:87
-msgid "Password"
-msgstr "Hasło"
+#: ../src/camel/camel-ews-provider.c:93
+msgid "NTLM"
+msgstr "NTLM"
+
+#: ../src/camel/camel-ews-provider.c:95
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with NTLM authentication."
+msgstr ""
+"Ta opcja spowoduje połączenie z serwerem Exchange używając hasła tekstowego "
+"za pomocą uwierzytelniania NTLM."
+
+#: ../src/camel/camel-ews-provider.c:103
+msgid "Basic"
+msgstr "Podstawowe"
 
-#: ../src/camel/camel-ews-provider.c:89
+#: ../src/camel/camel-ews-provider.c:105
 msgid ""
-"This option will connect to the Exchange server using a plaintext password."
+"This option will connect to the Exchange server using a plaintext password "
+"with Basic authentication."
 msgstr ""
-"Ta opcja spowoduje połączenie z serwerem Exchange używając hasła tekstowego."
+"Ta opcja spowoduje połączenie z serwerem Exchange używając hasła tekstowego "
+"za pomocą uwierzytelniania podstawowego."
 
-#: ../src/camel/camel-ews-store.c:174
+#: ../src/camel/camel-ews-store.c:192
 #, c-format
 msgid "Session has no storage path"
 msgstr "Sesja nie powiada ścieżki do pamięci masowej"
 
-#: ../src/camel/camel-ews-store.c:184
+#: ../src/camel/camel-ews-store.c:229
 #, c-format
-msgid "EWS service has no host URL"
-msgstr "Usługa EWS nie posiada adresu URL komputera"
+msgctxt "PublicFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:358
+#, c-format
+msgctxt "ForeignFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:688
+msgid "Updating foreign folder structure"
+msgstr "Aktualizowanie obcej struktury katalogów"
 
-#: ../src/camel/camel-ews-store.c:359
+#: ../src/camel/camel-ews-store.c:973
+msgid "Authentication password not available"
+msgstr "Hasło uwierzytelniania jest niedostępne"
+
+#: ../src/camel/camel-ews-store.c:1138
+msgid "Query for authentication types is not supported"
+msgstr "Odpytywanie typu uwierzytelniania jest nieobsługiwane"
+
+#: ../src/camel/camel-ews-store.c:1190
 #, c-format
 msgid "No such folder: %s"
 msgstr "Nie ma takiego katalogu: %s"
 
-#: ../src/camel/camel-ews-store.c:568
+#: ../src/camel/camel-ews-store.c:1502
+msgid "Cannot list EWS public folders in offline mode"
+msgstr "Nie można wyświetlić listy katalogów publicznych EWS w trybie offline"
+
+#: ../src/camel/camel-ews-store.c:1575
+msgid "Cannot find any EWS public folders"
+msgstr "Nie można odnaleźć żadnych katalogów publicznych EWS"
+
+#: ../src/camel/camel-ews-store.c:1680
+#, c-format
+msgid "Cannot create folder '%s', folder already exists"
+msgstr "Nie można utworzyć katalogu \"%s\". Katalog już istnieje"
+
+#: ../src/camel/camel-ews-store.c:1695
 #, c-format
 msgid "Parent folder %s does not exist"
 msgstr "Katalog nadrzędny %s nie istnieje"
 
-#: ../src/camel/camel-ews-store.c:626
+#: ../src/camel/camel-ews-store.c:1705
+#, c-format
+msgid ""
+"Cannot create folder under '%s', it is used for folders of other users only"
+msgstr ""
+"Nie można utworzyć katalogu w \"%s\", jest on używany tylko dla katalogów "
+"innych użytkowników"
+
+#: ../src/camel/camel-ews-store.c:1715
+#, c-format
+msgid "Cannot create folder under '%s', it is used for public folders only"
+msgstr ""
+"Nie można utworzyć katalogu w \"%s\", jest on używany tylko dla katalogów "
+"publicznych"
+
+#: ../src/camel/camel-ews-store.c:1784
 #, c-format
 msgid "Folder does not exist"
 msgstr "Katalog nie istnieje"
 
-#: ../src/camel/camel-ews-store.c:709
+#: ../src/camel/camel-ews-store.c:1793
+#, c-format
+msgid "Cannot remove folder '%s', it is used for folders of other users only"
+msgstr ""
+"Nie można usunąć katalogu \"%s\", jest on używany tylko dla katalogów innych "
+"użytkowników"
+
+#: ../src/camel/camel-ews-store.c:1803
+#, c-format
+msgid "Cannot remove folder '%s', it is used for public folders only"
+msgstr ""
+"Nie można usunąć katalogu \"%s\", jest on używany tylko dla katalogów "
+"publicznych"
+
+#: ../src/camel/camel-ews-store.c:1911
 #, c-format
 msgid "Folder %s does not exist"
 msgstr "Katalog %s nie istnieje"
 
-#: ../src/camel/camel-ews-store.c:718
+#: ../src/camel/camel-ews-store.c:1921
 #, c-format
 msgid "No change key record for folder %s"
 msgstr "Brak wpisu klucza zmiany dla katalogu %s"
 
-#: ../src/camel/camel-ews-store.c:757
+#: ../src/camel/camel-ews-store.c:1963
 #, c-format
 msgid "Cannot both rename and move a folder at the same time"
 msgstr "Nie można zmienić nazwy i przenieść katalogu w tym samym czasie"
 
-#: ../src/camel/camel-ews-store.c:788
+#: ../src/camel/camel-ews-store.c:1999
 #, c-format
 msgid "Cannot find folder ID for parent folder %s"
 msgstr "Nie można odnaleźć identyfikatora katalogu dla katalogu nadrzędnego %s"
 
-#: ../src/camel/camel-ews-store.c:817 ../src/camel/camel-ews-transport.c:61
+#: ../src/camel/camel-ews-store.c:2049 ../src/camel/camel-ews-transport.c:69
 #, c-format
 msgid "Exchange server %s"
 msgstr "Serwer Exchange %s"
 
-#: ../src/camel/camel-ews-store.c:819
+#: ../src/camel/camel-ews-store.c:2052
 #, c-format
 msgid "Exchange service for %s on %s"
 msgstr "Usługa Exchange dla %s na %s"
 
-#: ../src/camel/camel-ews-store.c:856
+#: ../src/camel/camel-ews-store.c:2096
+#, c-format
+msgid "Could not locate Trash folder"
+msgstr "Nie można ustalić położenia katalogu Kosz"
+
+#: ../src/camel/camel-ews-store.c:2131
+#, c-format
+msgid "Could not locate Junk folder"
+msgstr "Nie można ustalić położenia katalogu Niechciane"
+
+#: ../src/camel/camel-ews-store.c:2321
+msgid "Cannot subscribe EWS folders in offline mode"
+msgstr "Nie można subskrybować katalogów EWS w trybie offline"
+
+#: ../src/camel/camel-ews-store.c:2339
+#, c-format
+msgid "Cannot subscribe folder '%s', no public folder available"
+msgstr ""
+"Nie można subskrybować katalogu \"%s\", żaden katalog publiczny nie jest "
+"dostępny"
+
+#: ../src/camel/camel-ews-store.c:2349
+#, c-format
+msgid "Cannot subscribe folder '%s', folder not found"
+msgstr "Nie można subskrybować katalogu \"%s\", nie odnaleziono katalogu"
+
+#: ../src/camel/camel-ews-store.c:2440
+msgid "Cannot unsubscribe EWS folders in offline mode"
+msgstr "Nie można usuwać subskrypcji katalogów EWS w trybie offline"
+
+#: ../src/camel/camel-ews-store.c:2557
 #, c-format
 msgid "You must be working online to complete this operation"
 msgstr "Należy pracować w trybie online, aby ukończyć to działanie"
 
-#: ../src/camel/camel-ews-transport.c:65
+#: ../src/camel/camel-ews-transport.c:72
 #, c-format
 msgid "Exchange mail delivery via %s"
 msgstr "Dostarczanie poczty Exchange przez %s"
 
-#: ../src/camel/camel-ews-transport.c:92
+#: ../src/camel/camel-ews-transport.c:119
+msgid "Cannot send message with no From address"
+msgstr "Nie można wysłać wiadomości bez adresata"
+
+#: ../src/camel/camel-ews-transport.c:125
+msgid "Exchange server cannot send message with multiple From addresses"
+msgstr "Serwer Exchange nie może wysłać wiadomości z wieloma adresatami"
+
+#: ../src/camel/camel-ews-transport.c:136
+msgid "Failed to read From address"
+msgstr "Odczytanie adresata się nie powiodło"
+
+#: ../src/camel/camel-ews-transport.c:148
+#, c-format
+msgid ""
+"Exchange server cannot send message as '%s', when the account was configured "
+"for address '%s'"
+msgstr ""
+"Serwer Exchange nie może wysłać wiadomości jako \"%s\", podczas gdy konto "
+"zostało skonfigurowane dla adresu \"%s\""
+
+#: ../src/camel/camel-ews-transport.c:162
 #, c-format
 msgid "Service not connected"
 msgstr "Usługa nie jest połączona"
 
-#: ../src/server/e-ews-connection.c:354
+#: ../src/collection/e-ews-backend.c:428
+#: ../src/configuration/e-mail-config-ews-gal.c:274
+msgid "Global Address List"
+msgstr "Ogólna lista adresowa"
+
+#: ../src/collection/e-ews-backend.c:815
+#, c-format
+msgid "Could not determine a suitable folder class for a new folder named '%s'"
+msgstr ""
+"Nie można ustalić odpowiedniej klasy katalogów dla nowego katalogu o nazwie "
+"\"%s\""
+
+#: ../src/collection/e-ews-backend.c:904
+#, c-format
+msgid "Data source '%s' does not represent an Exchange Web Services folder"
+msgstr "Źródło danych \"%s\" nie przedstawia katalog Exchange Web Services"
+
+#: ../src/configuration/e-ews-config-utils.c:511
+#, c-format
+msgid "Cannot edit permissions of folder '%s', choose other folder."
+msgstr ""
+"Nie można modyfikować uprawnień katalogu \"%s\". Proszę wybrać inny katalog."
+
+#: ../src/configuration/e-ews-config-utils.c:589
+msgid "Subscribe to folder of other user..."
+msgstr "Subskrybuj katalog innego użytkownika..."
+
+#: ../src/configuration/e-ews-config-utils.c:598
+#: ../src/configuration/e-ews-config-utils.c:879
+#: ../src/configuration/e-ews-config-utils.c:910
+#: ../src/configuration/e-ews-config-utils.c:941
+#: ../src/configuration/e-ews-config-utils.c:972
+msgid "Permissions..."
+msgstr "Uprawnienia..."
+
+#: ../src/configuration/e-ews-config-utils.c:600
+msgid "Edit EWS folder permissions"
+msgstr "Modyfikuj uprawnienia katalogu EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:881
+msgid "Edit EWS calendar permissions"
+msgstr "Modyfikuj uprawnienia kalendarza EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:912
+msgid "Edit EWS tasks permissions"
+msgstr "Modyfikuj uprawnienia zadań EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:943
+msgid "Edit EWS memos permissions"
+msgstr "Modyfikuj uprawnienia notatek EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:974
+msgid "Edit EWS contacts permissions"
+msgstr "Modyfikuj uprawnienia kontaktów EWS"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:87
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:499
+msgctxt "PermissionsLevel"
+msgid "None"
+msgstr "Brak"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:88
+msgctxt "PermissionsLevel"
+msgid "Owner"
+msgstr "Właściciel"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:98
+msgctxt "PermissionsLevel"
+msgid "Publishing Editor"
+msgstr "Publikujący redaktor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:107
+msgctxt "PermissionsLevel"
+msgid "Editor"
+msgstr "Redaktor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:115
+msgctxt "PermissionsLevel"
+msgid "Publishing Author"
+msgstr "Publikujący autor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:122
+msgctxt "PermissionsLevel"
+msgid "Author"
+msgstr "Autor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:128
+msgctxt "PermissionsLevel"
+msgid "Nonediting Author"
+msgstr "Nieredagujący autor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:133
+msgctxt "PermissionsLevel"
+msgid "Reviewer"
+msgstr "Recenzent"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:136
+msgctxt "PermissionsLevel"
+msgid "Contributor"
+msgstr "Współtwórca"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:139
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time"
+msgstr "Informacje o zajętości"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:141
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time, subject, location"
+msgstr "Informacje o zajętości, temat, położenie"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:143
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:520
+msgctxt "PermissionsLevel"
+msgid "Custom"
+msgstr "Własny"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:267
+msgid "Writing folder permissions, please wait..."
+msgstr "Zapisywanie uprawnień katalogu, proszę czekać..."
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:759
+msgctxt "User"
+msgid "Anonymous"
+msgstr "Anonimowy"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:762
+msgctxt "User"
+msgid "Default"
+msgstr "Domyślny"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:768
+msgctxt "User"
+msgid "Unknown"
+msgstr "Nieznany"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:849
+#: ../src/configuration/e-ews-search-user.c:430
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1075
+msgid "Name"
+msgstr "Nazwa"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:855
+msgid "Permission level"
+msgstr "Poziom uprawnień"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:907
+msgid "Edit EWS folder permissions..."
+msgstr "Modyfikuj uprawnienia katalogów EWS..."
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:932
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:634
+msgid "Account:"
+msgstr "Konto:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:960
+msgid "Folder name:"
+msgstr "Nazwa katalogu:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:983
+msgid "Folder ID:"
+msgstr "Identyfikator katalogu:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1047
+msgid "Permissions"
+msgstr "Uprawnienia"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1069
+msgid "Permi_ssion level:"
+msgstr "Po_ziom uprawnień:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1103
+msgctxt "Permissions"
+msgid "Read"
+msgstr "Odczyt"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1115
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1182
+msgctxt "Permissions"
+msgid "None"
+msgstr "Brak"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1121
+msgctxt "Permissions"
+msgid "Free/Busy time"
+msgstr "Informacje o zajętości"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1126
+msgctxt "Permissions"
+msgid "Free/Busy time, subject, location"
+msgstr "Informacje o zajętości, temat, położenie"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1132
+msgctxt "Permissions"
+msgid "Full Details"
+msgstr "Pełne informacje"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1138
+msgctxt "Permissions"
+msgid "Write"
+msgstr "Zapis"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1150
+msgctxt "Permissions"
+msgid "Create items"
+msgstr "Tworzenie elementów"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1154
+msgctxt "Permissions"
+msgid "Create subfolders"
+msgstr "Tworzenie podkatalogów"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1158
+msgctxt "Permissions"
+msgid "Edit own"
+msgstr "Modyfikowanie własnych"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1162
+msgctxt "Permissions"
+msgid "Edit all"
+msgstr "Modyfikowanie wszystkich"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1170
+msgctxt "Permissions"
+msgid "Delete items"
+msgstr "Usuwanie elementów"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1187
+msgctxt "Permissions"
+msgid "Own"
+msgstr "Własne"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1192
+msgctxt "Permissions"
+msgid "All"
+msgstr "Wszyscy"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1198
+msgctxt "Permissions"
+msgid "Other"
+msgstr "Inni"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1210
+msgctxt "Permissions"
+msgid "Folder owner"
+msgstr "Właściciel katalogu"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1214
+msgctxt "Permissions"
+msgid "Folder contact"
+msgstr "Kontakt katalogu"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1218
+msgctxt "Permissions"
+msgid "Folder visible"
+msgstr "Widoczność katalogu"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1291
+msgid "Reading folder permissions, please wait..."
+msgstr "Odczytywanie uprawnień katalogu, proszę czekać..."
+
+#: ../src/configuration/e-ews-search-user.c:208
+#, c-format
+msgid "No users found, only one contact"
+msgid_plural "No users found, only %d contacts"
+msgstr[0] "Nie odnaleziono użytkowników, tylko jeden kontakt"
+msgstr[1] "Nie odnaleziono użytkowników, tylko %d kontakty"
+msgstr[2] "Nie odnaleziono użytkowników, tylko %d kontaktów"
+
+#: ../src/configuration/e-ews-search-user.c:213
+msgid "No users found"
+msgstr "Nie odnaleziono użytkowników"
+
+#: ../src/configuration/e-ews-search-user.c:217
+#, c-format
+msgid "Found one user"
+msgid_plural "Found %d users"
+msgstr[0] "Odnaleziono jednego użytkownika"
+msgstr[1] "Odnaleziono %d użytkowników"
+msgstr[2] "Odnaleziono %d użytkowników"
+
+#: ../src/configuration/e-ews-search-user.c:223
+#, c-format
+msgid "Found more than 100 users, but showing only first %d"
+msgid_plural "Found more than 100 users, but showing only first %d"
+msgstr[0] ""
+"Odnaleziono więcej niż 100 użytkowników, ale wyświetlanie tylko pierwszych %d"
+msgstr[1] ""
+"Odnaleziono więcej niż 100 użytkowników, ale wyświetlanie tylko pierwszych %d"
+msgstr[2] ""
+"Odnaleziono więcej niż 100 użytkowników, ale wyświetlanie tylko pierwszych %d"
+
+#: ../src/configuration/e-ews-search-user.c:356
+#: ../src/configuration/e-ews-search-user.c:539
+msgid "Search for a user"
+msgstr "Wyszukiwanie użytkownika"
+
+#: ../src/configuration/e-ews-search-user.c:436
+msgid "E-mail"
+msgstr "E-mail"
+
+#: ../src/configuration/e-ews-search-user.c:473
+msgid "Choose EWS user..."
+msgstr "Wybierz użytkownika EWS..."
+
+#: ../src/configuration/e-ews-search-user.c:496
+msgid "_Search:"
+msgstr "Wy_szukiwanie:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:97
+#: ../src/server/e-ews-folder.c:632
+#, c-format
+msgid "Cannot add folder, folder already exists as '%s'"
+msgstr "Nie można dodać katalogu. Katalog już istnieje jako \"%s\""
+
+#. Translators: The '%s' is replaced with user name, to whom the foreign mailbox belongs.
+#. * Example result: "Mailbox - John Smith"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:107
+#, c-format
+msgctxt "ForeignFolder"
+msgid "Mailbox - %s"
+msgstr "Skrzynka pocztowa - %s"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:272
+msgid "Cannot test foreign folder availability while in offline mode"
+msgstr "Nie można wykonać testu dostępności obcego katalogu w trybie offline"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:297
+#, c-format
+msgid "User '%s' was not found on the server"
+msgstr "Nie odnaleziono użytkownika \"%s\" na serwerze"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:333
+#, c-format
+msgid "User name '%s' is ambiguous, specify it more precisely, please"
+msgstr ""
+"Nazwa użytkownika \"%s\" jest niejednoznaczna. Proszę określić ją dokładniej"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:355
+#, c-format
+msgid ""
+"Folder '%s' not found. Either it does not exist or you do not have "
+"permission to access it."
+msgstr ""
+"Nie odnaleziono katalogu \"%s\". Nie istnieje lub brak uprawnień do jego "
+"dostępu."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:373
+msgid "Cannot add folder, cannot determine folder's type"
+msgstr "Nie można dodać katalogu, nie można ustalić jego typu"
+
+#. Translators: This is used to name foreign folder.
+#. * The first '%s' is replaced with user name to whom the folder belongs,
+#. * the second '%s' is replaced with folder name.
+#. * Example result: "John Smith - Calendar"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:418
+#, c-format
+msgctxt "ForeignFolder"
+msgid "%s - %s"
+msgstr "%s - %s"
+
+#. convert well-known names to their non-localized form
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:512
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:719
+msgid "Inbox"
+msgstr "Odebrane"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:514
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:720
+msgid "Contacts"
+msgstr "Kontakty"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:516
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:721
+msgid "Calendar"
+msgstr "Kalendarz"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:518
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:722
+msgid "Memos"
+msgstr "Notatki"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:520
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:723
+msgid "Tasks"
+msgstr "Zadania"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:537
+#, c-format
+msgid "Testing availability of folder '%s' of user '%s', please wait..."
+msgstr ""
+"Testowanie dostępności katalogu \"%s\" użytkownika \"%s\", proszę czekać..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:613
+msgid "Subscribe to folder of other EWS user..."
+msgstr "Subskrybuj katalog innego użytkownika EWS..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:664
+msgid "User"
+msgstr "Użytkownik"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:671
+msgid "_User:"
+msgstr "_Użytkownik:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:686
+msgid "C_hoose..."
+msgstr "_Wybierz..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:702
+msgid "_Folder name:"
+msgstr "Nazwa _katalogu:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:732
+msgid "Include _subfolders"
+msgstr "Dołączenie po_dkatalogów"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:129
+msgid "Querying Autodiscover service"
+msgstr "Odpytywanie usługi automatycznego wykrywania"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:212
+msgid "Fetch _URL"
+msgstr "Pobierz adres _URL"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:140
+msgid "Configuration"
+msgstr "Konfiguracja"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:158
+msgid "User_name:"
+msgstr "_Nazwa użytkownika:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:172
+msgid "_Host URL:"
+msgstr "Adres URL _komputera:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:191
+msgid "OAB U_RL:"
+msgstr "Adres U_RL OAB:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:205
+msgid "Open _Mailbox of other user"
+msgstr "Otwórz _skrzynkę pocztową innego użytkownika"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:239
+msgid "S_earch..."
+msgstr "Wysz_ukiwanie..."
+
+#: ../src/configuration/e-mail-config-ews-backend.c:250
+msgid "Authentication"
+msgstr "Uwierzytelnianie"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:500
+msgctxt "PermissionsLevel"
+msgid "Reviewer (can read items)"
+msgstr "Recenzent (może odczytywać elementy)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:501
+msgctxt "PermissionsLevel"
+msgid "Author (can read and create items)"
+msgstr "Autor (może odczytywać i tworzyć elementy)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:502
+msgctxt "PermissionsLevel"
+msgid "Editor (can read, create and modify items)"
+msgstr "Redaktor (może odczytywać, tworzyć i modyfikować elementy)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:605
+msgid "Delegate permissions"
+msgstr "Delegowanie uprawnień"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:623
+msgid "C_alendar"
+msgstr "K_alendarz"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:626
+msgid "_Delegate receives copies of meeting-related messages sent to me"
+msgstr ""
+"_Delegat otrzymuje kopie wiadomości związanych ze spotkaniami wysłanych do "
+"mnie"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:631
+msgid "_Tasks"
+msgstr "_Zadania"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:634
+msgid "_Inbox"
+msgstr "_Odebrane"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:637
+msgid "C_ontacts"
+msgstr "K_ontakty"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:640
+msgid "_Notes"
+msgstr "_Notatki"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:643
+msgid "_Journal"
+msgstr "_Dziennik"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:646
+#, c-format
+msgid "Delegate '%s' has the following permissions"
+msgstr "Delegat \"%s\" posiada poniższe uprawnienia"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:664
+msgid "Delegate can see my _private items"
+msgstr "Delegat może wyświetlać prywatne _elementy"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:987
+msgid "Retrieving current user permissions, please wait..."
+msgstr "Pobieranie obecnych uprawnień użytkowników, proszę czekać..."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1108
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1638
+msgid "Delegates"
+msgstr "Delegaci"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1132
+msgid ""
+"Delegates can send items on your behalf, including creating and responding "
+"to meeting requests. If you want to grant folder permissions without giving "
+"send-on-behalf-of permissions, close this dialog box, right-click the "
+"folder, click Permissions and change the options there."
+msgstr ""
+"Delegaci mogą wysyłać pocztę w Twoim imieniu, w tym tworzyć i odpowiadać na "
+"prośby o spotkania. Aby przekazać uprawnienia do katalogu bez przekazywania "
+"uprawnień do wysyłania w Twoim imieniu, należy zamknąć to okno, kliknąć "
+"prawym przyciskiem myszy na katalogu, kliknąć Uprawnienia i w tym miejscu "
+"zmienić opcje."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1181
+msgid ""
+"Deliver meeting requests addressed to me and responses to meeting requests "
+"where I am the organizer to:"
+msgstr ""
+"Przekazywanie próśb o spotkania wysłanych do mnie i odpowiedzi na prośby, "
+"których jestem organizatorem do:"
+
+#. new-line break, because GtkRadioButton doesn't allow wrapping of the inner label
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1190
+msgid ""
+"My delegates only, but _send a copy of meeting requests\n"
+"and responses to me (recommended)"
+msgstr ""
+"Tylko moich delegatów, ale wy_syłanie kopii prośby o\n"
+"spotkanie i odpowiedzi do mnie (zalecane)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1197
+msgid "My d_elegates only"
+msgstr "Tylko moich d_elegatów"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1204
+msgid "My delegates a_nd me"
+msgstr "_Moich delegatów i mnie"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1713
+msgid "Retrieving \"Delegates\" settings"
+msgstr "Pobieranie ustawień delegatów"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:221
+msgid "Locating offline address books"
+msgstr "Ustalanie położenia książek adresowych w trybie offline"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:301
+msgid "Cache o_ffline address book"
+msgstr ""
+"_Przechowywanie książki adresowej w buforze podczas pracy w trybie offline"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:327
+msgid "Select ad_dress list:"
+msgstr "Wybór listy a_dresów:"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:351
+msgid "Fetch List"
+msgstr "Pobierz listę"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:444
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:923
+msgid "Out of Office"
+msgstr "Poza biurem"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:460
+msgid ""
+"The messages specified below will be automatically sent to each internal and "
+"external person who sends a mail to you."
+msgstr ""
+"Wiadomość wprowadzona poniżej będzie automatycznie wysyłana do każdej osoby, "
+"która przyśle wiadomość podczas nieobecności użytkownika w biurze."
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:468
+msgid "Do _not send Out of Office replies"
+msgstr "_Bez wysyłania odpowiedzi podczas obecności poza biurem"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:476
+msgid "_Send Out of Office replies"
+msgstr "Wy_syłanie odpowiedzi podczas obecności poza biurem"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:484
+msgid "Send Out of Office replies only _during this time period:"
+msgstr ""
+"Wysyłanie odpowiedzi podczas _obecności poza biurem tylko w tym czasie:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:504
+msgid "_From:"
+msgstr "_Od:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:529
+msgid "_To:"
+msgstr "_Do:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:554
+msgid "I_nternal:"
+msgstr "W_ewnętrzna:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:563
+msgid "Message to be sent within the organization"
+msgstr "Wiadomość wysyłana wewnątrz organizacji"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:590
+msgid "E_xternal:"
+msgstr "_Zewnętrzna:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:598
+msgid "Message to be sent outside the organization"
+msgstr "Wiadomość wysyłana poza organizację"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:608
+msgid "Do not reply to senders outside the organization"
+msgstr "Bez odpowiadania nadawcom spoza organizacji"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:611
+msgid "Reply only to known senders outside the organization"
+msgstr "Odpowiadanie tylko znanym nadawcom spoza organizacji"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:614
+msgid "Reply to any sender outside the organization"
+msgstr "Odpowiadanie wszystkim nadawcom spoza organizacji"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:999
+msgid "Retrieving \"Out of Office\" settings"
+msgstr "Pobieranie ustawień obecności poza biurem"
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:1
+msgid "Autodiscovery query failed."
+msgstr "Wykrywanie automatyczne się nie powiodło."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:2
+msgid "The reported error was &quot;{0}&quot;."
+msgstr "Zgłoszony błąd to &quot;{0}&quot;."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:3
+msgid "Failed to locate offline address books."
+msgstr ""
+"Ustalenie położenia książek adresowych w trybie offline się nie powiodło."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:4
+msgid "Failed to retrieve &quot;Out of Office&quot; settings."
+msgstr "Pobrać ustawień obecności poza biurem się nie powiodło."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:5
+msgid "Failed to retrieve &quot;Delegates&quot; settings."
+msgstr "Pobranie ustawień delegatów się nie powiodło."
+
+#: ../src/server/e-ews-connection.c:493
 msgid "Operation Cancelled"
 msgstr "Anulowano działanie"
 
-#: ../src/server/e-ews-connection.c:408
+#: ../src/server/e-ews-connection.c:562
 msgid "Authentication failed"
 msgstr "Uwierzytelnienie się nie powiodło"
 
-#: ../src/server/e-ews-connection.c:416
+#: ../src/server/e-ews-connection.c:573
 #, c-format
 msgid "No response: %s"
 msgstr "Brak odpowiedzi: %s"
 
-#: ../src/server/e-ews-connection.c:1072 ../src/server/e-ews-connection.c:1388
-#: ../src/server/e-ews-connection.c:1625
-#, c-format
-msgid "Code: %d - Unexpected response from server"
-msgstr "Kod: %d - nieoczekiwana odpowiedź od serwera"
-
-#: ../src/server/e-ews-connection.c:1084
+#: ../src/server/e-ews-connection.c:1880
 #, c-format
 msgid "Failed to parse autodiscover response XML"
 msgstr ""
 "Przetworzenie XML odpowiedzi automatycznego wykrywania się nie powiodło"
 
-#: ../src/server/e-ews-connection.c:1092
+#: ../src/server/e-ews-connection.c:1887
 #, c-format
-msgid "Failed to find <Autodiscover> element\n"
-msgstr "Odnalezienie elementu <Autodiscover> się nie powiodło\n"
+msgid "Failed to find <Autodiscover> element"
+msgstr "Odnalezienie elementu <Autodiscover> się nie powiodło"
 
-#: ../src/server/e-ews-connection.c:1104
+#: ../src/server/e-ews-connection.c:1898
 #, c-format
-msgid "Failed to find <Response> element\n"
-msgstr "Odnalezienie elementu <Response> się nie powiodło\n"
+msgid "Failed to find <Response> element"
+msgstr "Odnalezienie elementu <Response> się nie powiodło"
 
-#: ../src/server/e-ews-connection.c:1116
+#: ../src/server/e-ews-connection.c:1909
 #, c-format
-msgid "Failed to find <Account> element\n"
-msgstr "Odnalezienie elementu <Account> się nie powiodło\n"
+msgid "Failed to find <Account> element"
+msgstr "Odnalezienie elementu <Account> się nie powiodło"
 
-#: ../src/server/e-ews-connection.c:1135
+#: ../src/server/e-ews-connection.c:1928
 #, c-format
 msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
 msgstr ""
 "Odnalezienie elementów <ASUrl> i <OABUrl> w odpowiedzi automatycznego "
 "wykrywania się nie powiodło"
 
-#: ../src/server/e-ews-connection.c:1231
-#, c-format
-msgid "Both email and password must be provided"
-msgstr "Należy podać adres e-mail i hasło"
+#: ../src/server/e-ews-connection.c:2010
+msgid "URL cannot be NULL"
+msgstr "Adres URL nie może wynosić NULL"
 
-#: ../src/server/e-ews-connection.c:1238
+#: ../src/server/e-ews-connection.c:2018
 #, c-format
-msgid "Wrong email id"
-msgstr "Błędny identyfikator adresu e-mail"
+msgid "URL '%s' is not valid"
+msgstr "Adres URL \"%s\" nie jest prawidłowy"
 
-#: ../src/server/e-ews-connection.c:1398
-#, c-format
+#: ../src/server/e-ews-connection.c:2120
+msgid "Email address is missing a domain part"
+msgstr "W adresie e-mail brakuje części domeny"
+
+#: ../src/server/e-ews-connection.c:2432
 msgid "Failed to parse oab XML"
 msgstr "Przetworzenie XML oab się nie powiodło"
 
-#: ../src/server/e-ews-connection.c:1405
-#, c-format
+#: ../src/server/e-ews-connection.c:2440
 msgid "Failed to find <OAB> element\n"
 msgstr "Odnalezienie elementu <OAB> się nie powiodło\n"
 
-#: ../src/utils/ews-camel-common.c:139
+#: ../src/server/e-ews-connection.c:3612
+msgid "No items found"
+msgstr "Nie odnaleziono elementów"
+
+#: ../src/server/e-ews-folder.c:587
+msgid "Cannot add folder, unsupported folder type"
+msgstr "Nie można dodać katalogu. Nieobsługiwany typ katalogu"
+
+#: ../src/server/e-ews-folder.c:592
+msgid "Cannot add folder, master source not found"
+msgstr "Nie można dodać katalogu. Nie odnaleziono głównego źródła"
+
+#: ../src/utils/ews-camel-common.c:187
 #, c-format
 msgid "CreateItem call failed to return ID for new message"
 msgstr ""
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/POTFILES.in evolution-ews.sync-with-3.8.2/po/POTFILES.in
--- evolution-ews.git-gnome-3-0/po/POTFILES.in	2013-05-17 14:36:16.325670364 +0200
+++ evolution-ews.sync-with-3.8.2/po/POTFILES.in	2013-05-28 09:27:26.896837391 +0200
@@ -3,6 +3,12 @@
 [encoding: UTF-8]
 src/account-setup-eplugin/exchange-ews-account-listener.c
 src/account-setup-eplugin/exchange-ews-account-setup.c
+src/account-setup-eplugin/e-ews-config-utils.c
+src/account-setup-eplugin/e-ews-edit-folder-permissions.c
+src/account-setup-eplugin/e-ews-search-user.c
+src/account-setup-eplugin/e-ews-subscribe-foreign-folder.c
+src/account-setup-eplugin/e-mail-config-ews-delegates-page.c
+src/account-setup-eplugin/e-mail-config-ews-ooo-page.c
 src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml
 src/addressbook/e-book-backend-ews.c
 src/addressbook/e-book-backend-sqlitedb.c
@@ -13,4 +19,5 @@ src/camel/camel-ews-store.c
 src/camel/camel-ews-transport.c
 src/camel/camel-ews-utils.c
 src/server/e-ews-connection.c
+src/server/e-ews-folder.c
 src/utils/ews-camel-common.c
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/pt_BR.po evolution-ews.sync-with-3.8.2/po/pt_BR.po
--- evolution-ews.git-gnome-3-0/po/pt_BR.po	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/po/pt_BR.po	2013-05-29 08:46:45.648863785 +0200
@@ -0,0 +1,1131 @@
+# Brazilian Portuguese translation for evolution-ews.
+# Copyright (C) 2013 evolution-ews's COPYRIGHT HOLDER
+# This file is distributed under the same license as the evolution-ews package.
+# Gabriel Speckhahn <gabspeck@gmail.com>, 2012.
+# Rafael Ferreira <rafael.f.f1@gmail.com>, 2012.
+# Enrico Nicoletto <liverig@gmail.com>, 2013.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: evolution-ews master\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
+"product=evolution-ews&keywords=I18N+L10N&component=general\n"
+"POT-Creation-Date: 2013-02-07 17:32+0000\n"
+"PO-Revision-Date: 2013-02-04 10:24-0300\n"
+"Last-Translator: Enrico Nicoletto <liverig@gmail.com>\n"
+"Language-Team: Brazilian Portuguese <gnome-pt_br-list@gnome.org>\n"
+"Language: pt_BR\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n > 1);\n"
+"X-Generator: Virtaal 0.7.1\n"
+"X-Project-Style: gnome\n"
+
+#: ../src/addressbook/e-book-backend-ews.c:969
+msgid "The backend does not support bulk additions"
+msgstr "O mecanismo não suporta inclusões em lote"
+
+#: ../src/addressbook/e-book-backend-ews.c:1253
+msgid "The backend does not support bulk modifications"
+msgstr "O mecanismo não suporta modificações em lote"
+
+#: ../src/addressbook/e-book-backend-ews.c:1436
+msgid "Wait till syncing is done"
+msgstr "Aguarde até a conclusão da sincronização"
+
+#: ../src/addressbook/e-book-backend-ews.c:1775
+#, c-format
+msgid "Downloading contacts in %s %d%% completed... "
+msgstr "Baixando contatos em %s %d%% concluídos... "
+
+#: ../src/addressbook/e-book-backend-ews.c:2324
+msgid "Syncing contacts..."
+msgstr "Sincronizando contatos..."
+
+#: ../src/addressbook/e-book-backend-ews.c:2548
+#: ../src/configuration/e-ews-search-user.c:364
+msgid "Searching..."
+msgstr "Pesquisando..."
+
+#: ../src/calendar/e-cal-backend-ews.c:1009
+msgid "EWS does not support bulk removals"
+msgstr "O EWS não suporta remoções em lote"
+
+#: ../src/calendar/e-cal-backend-ews.c:1652
+msgid "EWS does not support bulk additions"
+msgstr "O EWS não suporta inclusões em lote"
+
+#: ../src/calendar/e-cal-backend-ews.c:2231
+msgid "EWS does not support bulk modifications"
+msgstr "O EWS não suporta modificações em lote"
+
+#: ../src/camel/camel-ews-folder.c:268
+#, c-format
+msgid "Unable to open mimecontent temporary file!"
+msgstr "Não foi possível abrir o arquivo temporário de mimecontent!"
+
+#: ../src/camel/camel-ews-folder.c:276
+#, c-format
+msgid "Unable to generate parser from mimecontent!"
+msgstr "Não foi possível gerar o analisador a partir do mimecontent!"
+
+#: ../src/camel/camel-ews-folder.c:285
+#, c-format
+msgid "Unable to parse meeting request mimecontent!"
+msgstr "Não foi possível analisar o mimecontent da solicitação de reunião!"
+
+#: ../src/camel/camel-ews-folder.c:346
+#, c-format
+msgid "Unable to create cache file"
+msgstr "Não foi possível criar o arquivo de cache"
+
+#: ../src/camel/camel-ews-folder.c:451 ../src/camel/camel-ews-folder.c:531
+#, c-format
+msgid "Unable to create cache path"
+msgstr "Não foi possível criar o caminho de cache"
+
+#: ../src/camel/camel-ews-folder.c:541
+#, c-format
+msgid "Failed to move message cache file"
+msgstr "Não foi possível mover o arquivo de cache de mensagens"
+
+#: ../src/camel/camel-ews-folder.c:1188
+#, c-format
+msgid "Could not load summary for %s"
+msgstr "Não foi possível carregar o resumo para %s"
+
+#: ../src/camel/camel-ews-folder.c:1624
+#, c-format
+msgid "Cant perform actions on the folder while in offline mode"
+msgstr "Não é possível executar ações na pasta no modo offline"
+
+#: ../src/camel/camel-ews-provider.c:48
+msgid "Checking for new mail"
+msgstr "Verificando se há novas mensagens"
+
+#: ../src/camel/camel-ews-provider.c:50
+msgid "C_heck for new messages in all folders"
+msgstr "_Verificar se há novas mensagens em todas as pastas"
+
+#: ../src/camel/camel-ews-provider.c:53
+msgid "Options"
+msgstr "Opções"
+
+#: ../src/camel/camel-ews-provider.c:55
+msgid "_Apply filters to new messages in Inbox on this server"
+msgstr "_Aplicar filtros a novas mensagens na Caixa de Entrada nesse servidor"
+
+#: ../src/camel/camel-ews-provider.c:57
+msgid "Check new messages for _Junk contents"
+msgstr "Verificar se há _lixo eletrônico nas novas mensagens"
+
+#: ../src/camel/camel-ews-provider.c:59
+msgid "Only check for Junk messages in the IN_BOX folder"
+msgstr "Verificar se há mensagens de lixo eletrônico apenas na pasta IN_BOX"
+
+#: ../src/camel/camel-ews-provider.c:61
+msgid "Automatically synchroni_ze remote mail locally"
+msgstr "Sincroni_zar localmente as mensagens remotas automaticamente"
+
+#: ../src/camel/camel-ews-provider.c:64
+msgid "Connection"
+msgstr "Conexão"
+
+#. Translators: '%s' is preplaced with a widget, where "
+#. * user can select how long the timeout should be.
+#: ../src/camel/camel-ews-provider.c:68
+#, c-format
+msgid "Connection _timeout (in seconds) %s"
+msgstr "Limite de tempo de espera por conexão (em segundos) %s"
+
+#: ../src/camel/camel-ews-provider.c:76
+msgid "Exchange Web Services"
+msgstr "Web services do Exchange"
+
+#: ../src/camel/camel-ews-provider.c:78
+msgid "For accessing Exchange servers using Web Services"
+msgstr "Para acessar servidores Exchange usando Web services"
+
+#: ../src/camel/camel-ews-provider.c:93
+msgid "NTLM"
+msgstr "NTLM"
+
+#: ../src/camel/camel-ews-provider.c:95
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with NTLM authentication."
+msgstr ""
+"Essa opção conectará ao servidor Exchange usando uma senha em texto simples "
+"com autenticação NTLM."
+
+#: ../src/camel/camel-ews-provider.c:103
+msgid "Basic"
+msgstr "Básico"
+
+#: ../src/camel/camel-ews-provider.c:105
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with Basic authentication."
+msgstr ""
+"Essa opção conectará ao servidor Exchange usando uma senha em texto simples "
+"com autenticação Básica."
+
+#: ../src/camel/camel-ews-store.c:189
+#, c-format
+msgid "Session has no storage path"
+msgstr "A sessão não possui caminho de armazenamento"
+
+#: ../src/camel/camel-ews-store.c:226
+#, c-format
+msgctxt "PublicFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:355
+#, c-format
+msgctxt "ForeignFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:682
+msgid "Updating foreign folder structure"
+msgstr "Atualizando estrutura de pasta externa"
+
+#: ../src/camel/camel-ews-store.c:964
+msgid "Authentication password not available"
+msgstr "Senha de autenticação não disponível"
+
+#: ../src/camel/camel-ews-store.c:1129
+msgid "Query for authentication types is not supported"
+msgstr "Consulta por tipos de autenticação não é suportado"
+
+#: ../src/camel/camel-ews-store.c:1181
+#, c-format
+msgid "No such folder: %s"
+msgstr "Pasta inexistente: %s"
+
+#: ../src/camel/camel-ews-store.c:1492
+msgid "Cannot list EWS public folders in offline mode"
+msgstr "Não é possível listar as pastas EWS públicas no modo offline"
+
+#: ../src/camel/camel-ews-store.c:1565
+msgid "Cannot find any EWS public folders"
+msgstr "Não foi possível encontrar nenhuma pasta EWS pública"
+
+#: ../src/camel/camel-ews-store.c:1670
+#, c-format
+msgid "Cannot create folder '%s', folder already exists"
+msgstr "Não foi possível criar a pasta \"%s\", pois ela já existe"
+
+#: ../src/camel/camel-ews-store.c:1685
+#, c-format
+msgid "Parent folder %s does not exist"
+msgstr "A pasta pai %s não existe"
+
+#: ../src/camel/camel-ews-store.c:1695
+#, c-format
+msgid ""
+"Cannot create folder under '%s', it is used for folders of other users only"
+msgstr ""
+"Não foi possível criar a pasta sob \"%s\", pois ela é usada somente para "
+"pastas de outros usuários"
+
+#: ../src/camel/camel-ews-store.c:1705
+#, c-format
+msgid "Cannot create folder under '%s', it is used for public folders only"
+msgstr ""
+"Não foi possível criar a pasta sob \"%s\", pois ela é usada somente para "
+"pastas públicas"
+
+#: ../src/camel/camel-ews-store.c:1774
+#, c-format
+msgid "Folder does not exist"
+msgstr "A pasta não existe"
+
+#: ../src/camel/camel-ews-store.c:1783
+#, c-format
+msgid "Cannot remove folder '%s', it is used for folders of other users only"
+msgstr ""
+"Não foi possível remover a pasta \"%s\", pois ela é usada somente para "
+"pastas de outros usuários"
+
+#: ../src/camel/camel-ews-store.c:1793
+#, c-format
+msgid "Cannot remove folder '%s', it is used for public folders only"
+msgstr ""
+"Não foi possível remover a pasta \"%s\", pois ela é usada somente para "
+"pastas públicas"
+
+#: ../src/camel/camel-ews-store.c:1901
+#, c-format
+msgid "Folder %s does not exist"
+msgstr "A pasta %s não existe"
+
+#: ../src/camel/camel-ews-store.c:1911
+#, c-format
+msgid "No change key record for folder %s"
+msgstr "Nenhum registro de chave de mudança para a pasta %s"
+
+#: ../src/camel/camel-ews-store.c:1953
+#, c-format
+msgid "Cannot both rename and move a folder at the same time"
+msgstr "Não é possível renomear e mover uma pasta ao mesmo tempo"
+
+#: ../src/camel/camel-ews-store.c:1989
+#, c-format
+msgid "Cannot find folder ID for parent folder %s"
+msgstr "Não foi possível encontrar o ID de pasta para a pasta pai %s"
+
+#: ../src/camel/camel-ews-store.c:2039 ../src/camel/camel-ews-transport.c:69
+#, c-format
+msgid "Exchange server %s"
+msgstr "Servidor Exchange %s"
+
+#: ../src/camel/camel-ews-store.c:2042
+#, c-format
+msgid "Exchange service for %s on %s"
+msgstr "Serviço Exchange para %s em %s"
+
+#: ../src/camel/camel-ews-store.c:2086
+#, c-format
+msgid "Could not locate Trash folder"
+msgstr "Não foi possível localizar a pasta Lixeira"
+
+#: ../src/camel/camel-ews-store.c:2121
+#, c-format
+msgid "Could not locate Junk folder"
+msgstr "Não foi possível localizar a pasta Lixo eletrônico"
+
+#: ../src/camel/camel-ews-store.c:2311
+msgid "Cannot subscribe EWS folders in offline mode"
+msgstr "Não é possível realizar a inscrição das pastas EWS no modo offline"
+
+#: ../src/camel/camel-ews-store.c:2329
+#, c-format
+msgid "Cannot subscribe folder '%s', no public folder available"
+msgstr ""
+"Não foi possível realizar a inscrição da pasta \"%s\", pois não há pasta "
+"pública disponível"
+
+#: ../src/camel/camel-ews-store.c:2339
+#, c-format
+msgid "Cannot subscribe folder '%s', folder not found"
+msgstr ""
+"Não é possível realizar a inscrição da pasta \"%s\", pois ela não foi "
+"encontrada"
+
+#: ../src/camel/camel-ews-store.c:2429
+msgid "Cannot unsubscribe EWS folders in offline mode"
+msgstr ""
+"Não é possível realizar o cancelamento da inscrição das pastas EWS no modo "
+"offline"
+
+#: ../src/camel/camel-ews-store.c:2545
+#, c-format
+msgid "You must be working online to complete this operation"
+msgstr "Você precisa estar trabalhando online para completar essa operação"
+
+#: ../src/camel/camel-ews-transport.c:72
+#, c-format
+msgid "Exchange mail delivery via %s"
+msgstr "Entrega de correio Exchange via %s"
+
+#: ../src/camel/camel-ews-transport.c:119
+msgid "Cannot send message with no From address"
+msgstr "Não é possível enviar uma mensagem sem um endereço de remetente"
+
+#: ../src/camel/camel-ews-transport.c:125
+msgid "Exchange server cannot send message with multiple From addresses"
+msgstr ""
+"O servidor Exchange não pode enviar uma mensagem com múltiplos endereços de "
+"remetente"
+
+#: ../src/camel/camel-ews-transport.c:136
+msgid "Failed to read From address"
+msgstr "Não foi possível ler o endereço do remetente"
+
+#: ../src/camel/camel-ews-transport.c:148
+#, c-format
+msgid ""
+"Exchange server cannot send message as '%s', when the account was configured "
+"for address '%s'"
+msgstr ""
+"O servidor Exchange não pode mandar a mensagem como \"%s\", pois a conta foi "
+"configurada para o endereço \"%s\""
+
+#: ../src/camel/camel-ews-transport.c:162
+#, c-format
+msgid "Service not connected"
+msgstr "Serviço não conectado"
+
+#: ../src/collection/e-ews-backend.c:428
+#: ../src/configuration/e-mail-config-ews-gal.c:274
+msgid "Global Address List"
+msgstr "Lista de endereços global"
+
+#: ../src/collection/e-ews-backend.c:815
+#, c-format
+msgid "Could not determine a suitable folder class for a new folder named '%s'"
+msgstr ""
+"Não foi possível determinar uma classe de pasta apropriada para uma nova "
+"pasta chamada \"%s\""
+
+#: ../src/collection/e-ews-backend.c:904
+#, c-format
+msgid "Data source '%s' does not represent an Exchange Web Services folder"
+msgstr ""
+"Fonte de dados \"%s\" não representa uma pasta de Web Services do Exchange"
+
+#: ../src/configuration/e-ews-config-utils.c:511
+#, c-format
+msgid "Cannot edit permissions of folder '%s', choose other folder."
+msgstr ""
+"Não foi possível editar permissões da pasta \"%s\". Escolha outra pasta."
+
+#: ../src/configuration/e-ews-config-utils.c:589
+msgid "Subscribe to folder of other user..."
+msgstr "Inscrever-se à pasta de outro usuário..."
+
+#: ../src/configuration/e-ews-config-utils.c:598
+#: ../src/configuration/e-ews-config-utils.c:879
+#: ../src/configuration/e-ews-config-utils.c:910
+#: ../src/configuration/e-ews-config-utils.c:941
+#: ../src/configuration/e-ews-config-utils.c:972
+msgid "Permissions..."
+msgstr "Permissões..."
+
+#: ../src/configuration/e-ews-config-utils.c:600
+msgid "Edit EWS folder permissions"
+msgstr "Editar permissões da pasta EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:881
+msgid "Edit EWS calendar permissions"
+msgstr "Editar permissões do calendário EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:912
+msgid "Edit EWS tasks permissions"
+msgstr "Editar permissões das tarefas EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:943
+msgid "Edit EWS memos permissions"
+msgstr "Editar permissões dos lembretes EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:974
+msgid "Edit EWS contacts permissions"
+msgstr "Editar permissões dos contatos EWS"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:87
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:499
+msgctxt "PermissionsLevel"
+msgid "None"
+msgstr "Nenhum"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:88
+msgctxt "PermissionsLevel"
+msgid "Owner"
+msgstr "Dono"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:98
+msgctxt "PermissionsLevel"
+msgid "Publishing Editor"
+msgstr "Editor da publicação"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:107
+msgctxt "PermissionsLevel"
+msgid "Editor"
+msgstr "Editor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:115
+msgctxt "PermissionsLevel"
+msgid "Publishing Author"
+msgstr "Autor da publicação"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:122
+msgctxt "PermissionsLevel"
+msgid "Author"
+msgstr "Autor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:128
+msgctxt "PermissionsLevel"
+msgid "Nonediting Author"
+msgstr "Autor não editor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:133
+msgctxt "PermissionsLevel"
+msgid "Reviewer"
+msgstr "Revisor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:136
+msgctxt "PermissionsLevel"
+msgid "Contributor"
+msgstr "Contribuidor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:139
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time"
+msgstr "Tempo livre/ocupado"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:141
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time, subject, location"
+msgstr "Tempo livre/ocupado, assunto, localização"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:143
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:520
+msgctxt "PermissionsLevel"
+msgid "Custom"
+msgstr "Personalizado"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:267
+msgid "Writing folder permissions, please wait..."
+msgstr "Gravando permissões da pasta, por favor espere..."
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:759
+msgctxt "User"
+msgid "Anonymous"
+msgstr "Anônimo"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:762
+msgctxt "User"
+msgid "Default"
+msgstr "Padrão"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:768
+msgctxt "User"
+msgid "Unknown"
+msgstr "Desconhecido"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:849
+#: ../src/configuration/e-ews-search-user.c:430
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1075
+msgid "Name"
+msgstr "Nome"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:855
+msgid "Permission level"
+msgstr "Nível de permissão"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:907
+msgid "Edit EWS folder permissions..."
+msgstr "Editar permissões de pasta do EWS"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:932
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:633
+msgid "Account:"
+msgstr "Conta:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:960
+msgid "Folder name:"
+msgstr "Nome da pasta:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:983
+msgid "Folder ID:"
+msgstr "ID da pasta:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1047
+msgid "Permissions"
+msgstr "Permissões"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1069
+msgid "Permi_ssion level:"
+msgstr "Nível de permi_ssão:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1103
+msgctxt "Permissions"
+msgid "Read"
+msgstr "Leitura"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1115
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1182
+msgctxt "Permissions"
+msgid "None"
+msgstr "Nenhuma"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1121
+msgctxt "Permissions"
+msgid "Free/Busy time"
+msgstr "Tempo livre/ocupado"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1126
+msgctxt "Permissions"
+msgid "Free/Busy time, subject, location"
+msgstr "Tempo livre/ocupado, assunto, localização"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1132
+msgctxt "Permissions"
+msgid "Full Details"
+msgstr "Detalhes completos"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1138
+msgctxt "Permissions"
+msgid "Write"
+msgstr "Gravação"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1150
+msgctxt "Permissions"
+msgid "Create items"
+msgstr "Criar itens"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1154
+msgctxt "Permissions"
+msgid "Create subfolders"
+msgstr "Criar subpastas"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1158
+msgctxt "Permissions"
+msgid "Edit own"
+msgstr "Editar própria"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1162
+msgctxt "Permissions"
+msgid "Edit all"
+msgstr "Editar tudo"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1170
+msgctxt "Permissions"
+msgid "Delete items"
+msgstr "Excluir itens"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1187
+msgctxt "Permissions"
+msgid "Own"
+msgstr "Próprio"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1192
+msgctxt "Permissions"
+msgid "All"
+msgstr "Tudo"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1198
+msgctxt "Permissions"
+msgid "Other"
+msgstr "Outro"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1210
+msgctxt "Permissions"
+msgid "Folder owner"
+msgstr "Dono da pasta"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1214
+msgctxt "Permissions"
+msgid "Folder contact"
+msgstr "Contato da pasta"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1218
+msgctxt "Permissions"
+msgid "Folder visible"
+msgstr "Pasta visível"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1291
+msgid "Reading folder permissions, please wait..."
+msgstr "Lendo permissões da pasta, por favor espere..."
+
+#: ../src/configuration/e-ews-search-user.c:208
+#, c-format
+msgid "No users found, only one contact"
+msgid_plural "No users found, only %d contacts"
+msgstr[0] "Nenhuma usuário encontrado, somente um contato"
+msgstr[1] "Nenhuma usuário encontrado, somente %d contatos"
+
+#: ../src/configuration/e-ews-search-user.c:213
+msgid "No users found"
+msgstr "Nenhum usuário encontrado"
+
+#: ../src/configuration/e-ews-search-user.c:217
+#, c-format
+msgid "Found one user"
+msgid_plural "Found %d users"
+msgstr[0] "Um usuário encontrado"
+msgstr[1] "%d usuários encontrados"
+
+#: ../src/configuration/e-ews-search-user.c:223
+#, c-format
+msgid "Found more than 100 users, but showing only first %d"
+msgid_plural "Found more than 100 users, but showing only first %d"
+msgstr[0] ""
+"Mais de 100 usuários encontrados, mas mostrando somente os %d primeiros"
+msgstr[1] ""
+"Mais de 100 usuários encontrados, mas mostrando somente os %d primeiros"
+
+#: ../src/configuration/e-ews-search-user.c:356
+#: ../src/configuration/e-ews-search-user.c:539
+msgid "Search for a user"
+msgstr "Pesquisar por um usuário"
+
+#: ../src/configuration/e-ews-search-user.c:436
+msgid "E-mail"
+msgstr "E-mail"
+
+#: ../src/configuration/e-ews-search-user.c:473
+msgid "Choose EWS user..."
+msgstr "Escolher o usuário EWS..."
+
+#: ../src/configuration/e-ews-search-user.c:496
+msgid "_Search:"
+msgstr "_Pesquisar:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:97
+#: ../src/server/e-ews-folder.c:628
+#, c-format
+msgid "Cannot add folder, folder already exists as '%s'"
+msgstr "Não foi possível adicionar a pasta, pois ela já existe como \"%s\""
+
+#. Translators: The '%s' is replaced with user name, to whom the foreign mailbox belongs.
+#. * Example result: "Mailbox - John Smith"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:107
+#, c-format
+msgctxt "ForeignFolder"
+msgid "Mailbox - %s"
+msgstr "Caixa de e-mail - %s"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:272
+msgid "Cannot test foreign folder availability while in offline mode"
+msgstr "Não é possível testar disponibilidade da pasta externa no modo offline"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:297
+#, c-format
+msgid "User '%s' was not found on the server"
+msgstr "O usuário \"%s\" não foi encontrado no servidor"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:333
+#, c-format
+msgid "User name '%s' is ambiguous, specify it more precisely, please"
+msgstr ""
+"O nome do usuário \"%s\" é ambíguo. Por favor, especifique-o de forma mais "
+"precisa."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:355
+#, c-format
+msgid ""
+"Folder '%s' not found. Either it does not exist or you do not have "
+"permission to access it."
+msgstr ""
+"A pasta \"%s\" não foi encontrada. Ou ela não existe ou você não tem "
+"permissões para acessá-la."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:373
+msgid "Cannot add folder, cannot determine folder's type"
+msgstr ""
+"Não foi possível adicionar a pasta, pois não foi possível determinar o tipo "
+"da pasta"
+
+#. Translators: This is used to name foreign folder.
+#. * The first '%s' is replaced with user name to whom the folder belongs,
+#. * the second '%s' is replaced with folder name.
+#. * Example result: "John Smith - Calendar"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:418
+#, c-format
+msgctxt "ForeignFolder"
+msgid "%s - %s"
+msgstr "%s - %s"
+
+#. convert well-known names to their non-localized form
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:511
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:718
+msgid "Inbox"
+msgstr "Caixa de entrada"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:513
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:719
+msgid "Contacts"
+msgstr "Contatos"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:515
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:720
+msgid "Calendar"
+msgstr "Calendário"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:517
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:721
+msgid "Memos"
+msgstr "Lembretes"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:519
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:722
+msgid "Tasks"
+msgstr "Tarefas"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:536
+#, c-format
+msgid "Testing availability of folder '%s' of user '%s', please wait..."
+msgstr ""
+"Testando a disponibilidade da pasta \"%s\" do usuário \"%s\", por favor "
+"espere..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:612
+msgid "Subscribe to folder of other EWS user..."
+msgstr "Inscrever a pasta de outro usuário EWS..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:663
+msgid "User"
+msgstr "Usuário"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:670
+msgid "_User:"
+msgstr "_Usuário:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:685
+msgid "C_hoose..."
+msgstr "Escol_her..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:701
+msgid "_Folder name:"
+msgstr "Nome da _pasta:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:731
+msgid "Include _subfolders"
+msgstr "_Incluir subpastas"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:129
+msgid "Querying Autodiscover service"
+msgstr "Consultando o serviço de descoberta automática"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:212
+msgid "Fetch _URL"
+msgstr "Buscar _URL"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:140
+msgid "Configuration"
+msgstr "Configuração"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:158
+msgid "User_name:"
+msgstr "_Nome do usuário:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:172
+msgid "_Host URL:"
+msgstr "URL do _servidor:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:191
+msgid "OAB U_RL:"
+msgstr "U_RL OAB:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:205
+msgid "Open _Mailbox of other user"
+msgstr "Abre a _caixa de correio de outro usuário"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:239
+msgid "S_earch..."
+msgstr "P_esquisar..."
+
+#: ../src/configuration/e-mail-config-ews-backend.c:250
+msgid "Authentication"
+msgstr "Autenticação"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:500
+msgctxt "PermissionsLevel"
+msgid "Reviewer (can read items)"
+msgstr "Revisor (pode ler itens)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:501
+msgctxt "PermissionsLevel"
+msgid "Author (can read and create items)"
+msgstr "Autor (pode ler e criar itens)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:502
+msgctxt "PermissionsLevel"
+msgid "Editor (can read, create and modify items)"
+msgstr "Editor (pode ler, criar e modificar itens)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:605
+msgid "Delegate permissions"
+msgstr "Delegar permissões"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:623
+msgid "C_alendar"
+msgstr "C_alendário"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:626
+msgid "_Delegate receives copies of meeting-related messages sent to me"
+msgstr ""
+"_Representante recebe cópias de mensagens relacionadas a reuniões enviadas a "
+"mim"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:631
+msgid "_Tasks"
+msgstr "_Tarefas"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:634
+msgid "_Inbox"
+msgstr "_Caixa de entrada"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:637
+msgid "C_ontacts"
+msgstr "C_ontatos"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:640
+msgid "_Notes"
+msgstr "_Notas"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:643
+msgid "_Journal"
+msgstr "_Jornal"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:646
+#, c-format
+msgid "Delegate '%s' has the following permissions"
+msgstr "Representante \"%s\" tem as seguintes permissões"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:664
+msgid "Delegate can see my _private items"
+msgstr "Representante pode ver meus itens _privados"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:987
+msgid "Retrieving current user permissions, please wait..."
+msgstr "Obtendo as permissões de usuário, por favor espere..."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1108
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1638
+msgid "Delegates"
+msgstr "Representantes"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1132
+msgid ""
+"Delegates can send items on your behalf, including creating and responding "
+"to meeting requests. If you want to grant folder permissions without giving "
+"send-on-behalf-of permissions, close this dialog box, right-click the "
+"folder, click Permissions and change the options there."
+msgstr ""
+"Representantes podem enviar itens em seu nome, incluindo criar e responder a "
+"solicitações de reuniões. Se você quiser conceder permissões de pastas sem "
+"conceder permissão de enviar em seu nome, feche essa caixa de diálogo, "
+"clique com botão direito, clique em Permissões e alterar as opções lá."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1181
+msgid ""
+"Deliver meeting requests addressed to me and responses to meeting requests "
+"where I am the organizer to:"
+msgstr ""
+"Entregar solicitações de reunião endereçadas a mim e respostas a "
+"solicitações de reunião, nas quais eu sou organizador, para:"
+
+#. new-line break, because GtkRadioButton doesn't allow wrapping of the inner label
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1190
+msgid ""
+"My delegates only, but _send a copy of meeting requests\n"
+"and responses to me (recommended)"
+msgstr ""
+"Somente meus representantes, mas _enviar uma cópia das \n"
+"solicitações de reuniões e respostas pra mim (recomendado)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1197
+msgid "My d_elegates only"
+msgstr "Somente meus _representantes"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1204
+msgid "My delegates a_nd me"
+msgstr "Meus representantes e e_u"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1713
+msgid "Retrieving \"Delegates\" settings"
+msgstr "Obtendo configurações de \"Representantes\""
+
+#: ../src/configuration/e-mail-config-ews-gal.c:221
+msgid "Locating offline address books"
+msgstr "Localizando o catálogo de endereços offline"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:301
+msgid "Cache o_ffline address book"
+msgstr "Armazenar o catálogo de endereços offline em _cache"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:327
+msgid "Select ad_dress list:"
+msgstr "Selecione a l_ista de endereços:"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:351
+msgid "Fetch List"
+msgstr "Buscar lista"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:444
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:923
+msgid "Out of Office"
+msgstr "Fora do escritório"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:460
+msgid ""
+"The messages specified below will be automatically sent to each internal and "
+"external person who sends a mail to you."
+msgstr ""
+"As mensagens especificadas abaixo serão automaticamente enviadas para cada "
+"pessoa interna ou externa que enviar um e-mail para você."
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:468
+msgid "Do _not send Out of Office replies"
+msgstr "_Não enviar respostas de Fora do escritório"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:476
+msgid "_Send Out of Office replies"
+msgstr "En_viar respostas de Fora do escritório"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:484
+msgid "Send Out of Office replies only _during this time period:"
+msgstr ""
+"En_viar respostas de Fora do escritório somente d_urante este período de "
+"tempo:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:504
+msgid "_From:"
+msgstr "_De:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:529
+msgid "_To:"
+msgstr "_Para:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:554
+msgid "I_nternal:"
+msgstr "I_nterno:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:563
+msgid "Message to be sent within the organization"
+msgstr "Mensagem que deve ser enviada para dentro da organização"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:590
+msgid "E_xternal:"
+msgstr "E_xterna:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:598
+msgid "Message to be sent outside the organization"
+msgstr "Mensagem que deve ser enviada para fora da organização"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:608
+msgid "Do not reply to senders outside the organization"
+msgstr "Não responder remetentes de fora da organização"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:611
+msgid "Reply only to known senders outside the organization"
+msgstr "Responder somente remetentes conhecidos de fora da organização"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:614
+msgid "Reply to any sender outside the organization"
+msgstr "Responder a qualquer remetente de fora da organização"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:999
+msgid "Retrieving \"Out of Office\" settings"
+msgstr "Obtendo configurações de \"Fora do escritório\""
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:1
+msgid "Autodiscovery query failed."
+msgstr "Consulta por descoberta automática falhou."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:2
+msgid "The reported error was &quot;{0}&quot;."
+msgstr "O erro relatado foi &quot;{0}&quot;."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:3
+msgid "Failed to locate offline address books."
+msgstr "Falha ao localizar o catálogo de endereços offline."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:4
+msgid "Failed to retrieve &quot;Out of Office&quot; settings."
+msgstr "Falha ao obter configurações de &quot;Fora do escritório&quot;."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:5
+msgid "Failed to retrieve &quot;Delegates&quot; settings."
+msgstr "Falha ao obter configurações de &quot;Representantes&quot;."
+
+#: ../src/server/e-ews-connection.c:493
+msgid "Operation Cancelled"
+msgstr "Operação cancelada"
+
+#: ../src/server/e-ews-connection.c:562
+msgid "Authentication failed"
+msgstr "Falha na autenticação"
+
+#: ../src/server/e-ews-connection.c:573
+#, c-format
+msgid "No response: %s"
+msgstr "Sem reposta: %s"
+
+#: ../src/server/e-ews-connection.c:1880
+#, c-format
+msgid "Failed to parse autodiscover response XML"
+msgstr "Falha ao analisar XML de resposta da descoberta automática"
+
+#: ../src/server/e-ews-connection.c:1887
+#, c-format
+msgid "Failed to find <Autodiscover> element"
+msgstr "Falha ao localizar o elemento <Autodiscover>"
+
+#: ../src/server/e-ews-connection.c:1898
+#, c-format
+msgid "Failed to find <Response> element"
+msgstr "Falha ao localizar o elemento <Response>"
+
+#: ../src/server/e-ews-connection.c:1909
+#, c-format
+msgid "Failed to find <Account> element"
+msgstr "Falha ao localizar o elemento <Account>"
+
+#: ../src/server/e-ews-connection.c:1928
+#, c-format
+msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
+msgstr ""
+"<ASUrl> e <OABUrl> não foram encontrados na resposta da descoberta automática"
+
+#: ../src/server/e-ews-connection.c:2010
+msgid "URL cannot be NULL"
+msgstr "A URL não pode ser NULL"
+
+#: ../src/server/e-ews-connection.c:2018
+#, c-format
+msgid "URL '%s' is not valid"
+msgstr "A URL \"%s\" não é válida"
+
+#: ../src/server/e-ews-connection.c:2120
+msgid "Email address is missing a domain part"
+msgstr "O endereço de e-mail está sem a parte de domínio"
+
+#: ../src/server/e-ews-connection.c:2432
+msgid "Failed to parse oab XML"
+msgstr "Falha ao analisar o XML oab"
+
+#: ../src/server/e-ews-connection.c:2440
+msgid "Failed to find <OAB> element\n"
+msgstr "O elemento <OAB> não foi encontrado\n"
+
+#: ../src/server/e-ews-connection.c:3612
+msgid "No items found"
+msgstr "Nenhum item encontrado"
+
+#: ../src/server/e-ews-folder.c:583
+msgid "Cannot add folder, unsupported folder type"
+msgstr ""
+"Não foi possível adicionar a pasta, pois o tipo da pasta não é suportado"
+
+#: ../src/server/e-ews-folder.c:588
+msgid "Cannot add folder, master source not found"
+msgstr ""
+"Não foi possível adicionar a pasta, pois a fonte mestra não foi encontrada"
+
+#: ../src/utils/ews-camel-common.c:187
+#, c-format
+msgid "CreateItem call failed to return ID for new message"
+msgstr "A chamada CreateItem não retornou o ID para a mensagem nova"
+
+#~ msgid ""
+#~ "Cannot list folders available for subscription of Exchange Web Services "
+#~ "account, use 'Subscribe to folder of other user' context menu option "
+#~ "above the account node in the folder tree instead."
+#~ msgstr ""
+#~ "Não foi possível listar as pastas disponíveis para inscrição da conta de "
+#~ "Web Services do Exchange. Ao invés disso, use a opção \"Inscrever-se à "
+#~ "pasta de outro usuário\" do menu de contexto em cima do nó da conta na "
+#~ "árvore de pastas."
+
+#~ msgid "Insufficient memory"
+#~ msgstr "Memória insuficiente"
+
+#~ msgid "Enter Password for %s"
+#~ msgstr "Digite a senha para %s"
+
+#~ msgid "Could not get password."
+#~ msgstr "Não foi possível obter a senha."
+
+#~ msgid "Could not fetch oal list: "
+#~ msgstr "Não foi possível buscar a lista oal: "
+
+#~ msgid "Fetching..."
+#~ msgstr "Buscando..."
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/sl.po evolution-ews.sync-with-3.8.2/po/sl.po
--- evolution-ews.git-gnome-3-0/po/sl.po	2013-05-17 14:36:16.329669972 +0200
+++ evolution-ews.sync-with-3.8.2/po/sl.po	2013-05-29 08:46:45.663988785 +0200
@@ -2,169 +2,108 @@
 # Copyright (C) 2011 evolution-ews's COPYRIGHT HOLDER
 # This file is distributed under the same license as the evolution-ews package.
 #
-# Matej Urbančič <mateju@svn.gnome.org>, 2011.
+# Matej Urbančič <mateju@svn.gnome.org>, 2011 - 2013.
 #
 msgid ""
 msgstr ""
 "Project-Id-Version: evolution-ews master\n"
-"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=evolution-ews&keywords=I18N+L10N&component=general\n"
-"POT-Creation-Date: 2011-10-10 07:51+0000\n"
-"PO-Revision-Date: 2011-10-10 19:17+0100\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
+"product=evolution-ews&keywords=I18N+L10N&component=general\n"
+"POT-Creation-Date: 2013-01-28 11:27+0000\n"
+"PO-Revision-Date: 2013-01-28 13:32+0100\n"
 "Last-Translator: Matej Urbančič <mateju@svn.gnome.org>\n"
 "Language-Team: Slovenian GNOME Translation Team <gnome-si@googlegroups.com>\n"
+"Language: sl_SI\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=4; plural=(n%100==1 ? 1 : n%100==2 ? 2 : n%100==3 || n%100==4 ? 3 : 0);\n"
-"X-Poedit-Language: Slovenian\n"
-"X-Poedit-Country: SLOVENIA\n"
 "X-Poedit-SourceCharset: utf-8\n"
+"X-Generator: Poedit 1.5.4\n"
 
-#: ../src/account-setup-eplugin/exchange-ews-account-listener.c:247
-msgid "Global Address list"
-msgstr "Splošni seznam naslovov"
+#: ../src/addressbook/e-book-backend-ews.c:969
+msgid "The backend does not support bulk additions"
+msgstr "Ozadnji program ne podpira množičnega dodajanja"
+
+#: ../src/addressbook/e-book-backend-ews.c:1253
+msgid "The backend does not support bulk modifications"
+msgstr "Ozadnji program ne podpira množičnega spreminjanja"
 
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:114
-#, c-format
-msgid "Autodiscover failed: %s"
-msgstr "Samodejno odkrivanje je spodletelo: %s"
+#: ../src/addressbook/e-book-backend-ews.c:1436
+msgid "Wait till syncing is done"
+msgstr "Počakaj na konec usklajevanja"
 
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:149
+#: ../src/addressbook/e-book-backend-ews.c:1775
 #, c-format
-msgid "Enter Password for %s"
-msgstr "Vnesite geslo za %s"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:158
-msgid "Could not get password."
-msgstr "Ni mogoče pridobiti gesla."
-
-#. OAB url entry
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:262
-msgid "OAB U_RL:"
-msgstr "OAB U_RL:"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:274
-msgid "_Host URL:"
-msgstr "Naslov URL _gostitelja:"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:287
-msgid "Fetch _URL"
-msgstr "Pridobi naslov _URL"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:453
-msgid "Could not fetch oal list: "
-msgstr "Ni mogoče pridobiti seznama OAL:"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:495
-msgid "Fetching..."
-msgstr "Pridobivanje ..."
-
-#. Add cache check box
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:632
-#, fuzzy
-msgid "Cache o_ffline address book"
-msgstr "Ime imenika VCard (GnomeVizitka)"
-
-#. Add label
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:638
-#, fuzzy
-msgid "Select Ad_dress list: "
-msgstr "Izberi mesto iz seznama"
-
-#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:648
-msgid "Fetch _list"
-msgstr "Pridobi _seznam"
-
-#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:1
-#: ../src/camel/camel-ews-provider.c:69
-msgid "Exchange Web Services"
-msgstr "Spletna storitev Exchange"
-
-#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:2
-#, fuzzy
-msgid "Exchange Web Services Plugin"
-msgstr "Vstavek grafičnega vmesnika storitve podatkovne  zbirke"
-
-#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:3
-msgid "GAL settings"
-msgstr "Nastavitve GAL"
-
-#: ../src/addressbook/e-book-backend-ews.c:1436
-#, fuzzy, c-format
 msgid "Downloading contacts in %s %d%% completed... "
-msgstr "Uganko ste rešili v %d sekundah"
+msgstr "Prejemanje stikov v %s: %d%% končano ..."
 
-#: ../src/addressbook/e-book-backend-ews.c:1826
+#: ../src/addressbook/e-book-backend-ews.c:2324
 msgid "Syncing contacts..."
 msgstr "Usklajevanje stikov ..."
 
-#: ../src/addressbook/e-book-backend-ews.c:2023
+#: ../src/addressbook/e-book-backend-ews.c:2548
+#: ../src/configuration/e-ews-search-user.c:364
 msgid "Searching..."
 msgstr "Iskanje ..."
 
-#: ../src/addressbook/e-book-backend-sqlitedb.c:470
-#, c-format
-msgid "Insufficient memory"
-msgstr "Nezadostna količina pomnilnika"
+#: ../src/calendar/e-cal-backend-ews.c:1001
+msgid "EWS does not support bulk removals"
+msgstr "Sistem EWS ne podpira množičnega odstranjevanja"
+
+#: ../src/calendar/e-cal-backend-ews.c:1644
+msgid "EWS does not support bulk additions"
+msgstr "Sistem EWS ne podpira množičnega dodajanja"
+
+#: ../src/calendar/e-cal-backend-ews.c:2223
+msgid "EWS does not support bulk modifications"
+msgstr "Sistem EWS ne podpira množičnega spreminjanja"
 
-#: ../src/calendar/e-cal-backend-ews.c:3793
+#: ../src/camel/camel-ews-folder.c:267
 #, c-format
-msgid "Unknown calendar property '%s'"
-msgstr "Neznana lastnost koledarja '%s'"
-
-#: ../src/camel/camel-ews-folder.c:200
-#, fuzzy, c-format
 msgid "Unable to open mimecontent temporary file!"
-msgstr ""
-"Ni mogoče odpreti trenutne slikovne datoteke '%s'.\n"
-"Ni mogoče poslati slike."
+msgstr "Ni mogoče odpreti začasne datoteke vsebine MIME."
 
-#: ../src/camel/camel-ews-folder.c:207
+#: ../src/camel/camel-ews-folder.c:275
 #, c-format
 msgid "Unable to generate parser from mimecontent!"
-msgstr ""
+msgstr "Ni mogoče ustvariti razčlenjevalnika iz vsebine MIME!"
 
-#: ../src/camel/camel-ews-folder.c:215
+#: ../src/camel/camel-ews-folder.c:284
 #, c-format
 msgid "Unable to parse meeting request mimecontent!"
-msgstr ""
+msgstr "Ni mogoče razčleniti zahtev srečanj vsebine MIME!"
 
-#: ../src/camel/camel-ews-folder.c:272
-#, fuzzy, c-format
+#: ../src/camel/camel-ews-folder.c:344
+#, c-format
 msgid "Unable to create cache file"
-msgstr "Ni mogoče ustvariti datoteke vira"
+msgstr "Ni mogoče ustvariti datoteke predpomnilnika"
 
-#: ../src/camel/camel-ews-folder.c:372
-#: ../src/camel/camel-ews-folder.c:441
-#, fuzzy, c-format
+#: ../src/camel/camel-ews-folder.c:449 ../src/camel/camel-ews-folder.c:529
+#, c-format
 msgid "Unable to create cache path"
 msgstr "Ni mogoče ustvariti poti predpomnilnika"
 
-#: ../src/camel/camel-ews-folder.c:450
-#, fuzzy, c-format
+#: ../src/camel/camel-ews-folder.c:539
+#, c-format
 msgid "Failed to move message cache file"
-msgstr "Ni mogoče premakniti začasne datoteke \"%s\" na končno mesto \"%s\": %s"
+msgstr "Ni mogoče premakniti predpomnilniške datoteke sporočil"
 
-#: ../src/camel/camel-ews-folder.c:798
-#, fuzzy, c-format
+#: ../src/camel/camel-ews-folder.c:1186
+#, c-format
 msgid "Could not load summary for %s"
 msgstr "Ni mogoče naložiti povzetka za %s"
 
-#: ../src/camel/camel-ews-folder.c:1124
-#: ../src/camel/camel-ews-store.c:575
-#: ../src/camel/camel-ews-store.c:632
-#: ../src/camel/camel-ews-store.c:701
+#: ../src/camel/camel-ews-folder.c:1622
 #, c-format
 msgid "Cant perform actions on the folder while in offline mode"
-msgstr ""
+msgstr "Ni mogoče izvesti dejanj v mapah v načinu brez povezave"
 
 #: ../src/camel/camel-ews-provider.c:48
-#, fuzzy
 msgid "Checking for new mail"
 msgstr "Preverjanje za novo pošto"
 
 #: ../src/camel/camel-ews-provider.c:50
-#, fuzzy
 msgid "C_heck for new messages in all folders"
 msgstr "Preveri za _nova sporočila v vseh mapah"
 
@@ -173,182 +112,987 @@ msgid "Options"
 msgstr "Možnosti"
 
 #: ../src/camel/camel-ews-provider.c:55
-#, fuzzy
 msgid "_Apply filters to new messages in Inbox on this server"
-msgstr "Uvelj_avi filtre na novih sporočilih v mapi dohodne pošta na tem strežniku"
+msgstr ""
+"Uvelj_avi filtre na novih sporočilih v mapi dohodne pošte na tem strežniku"
 
 #: ../src/camel/camel-ews-provider.c:57
-#, fuzzy
-msgid "Check new messages for Jun_k contents"
-msgstr "Med novimi sporočili preveri za neželeno pošto"
+msgid "Check new messages for _Junk contents"
+msgstr "Med novimi sporočili preveri za _neželeno pošto"
 
 #: ../src/camel/camel-ews-provider.c:59
-#, fuzzy
 msgid "Only check for Junk messages in the IN_BOX folder"
 msgstr "Neželeno pošto preveri le v mapi _dohodnih sporočil"
 
 #: ../src/camel/camel-ews-provider.c:61
-#, fuzzy
 msgid "Automatically synchroni_ze remote mail locally"
 msgstr "Samodejno _uskladi oddaljeno in krajevno pošto"
 
-#: ../src/camel/camel-ews-provider.c:71
-#, fuzzy
+#: ../src/camel/camel-ews-provider.c:64
+msgid "Connection"
+msgstr "Povezava"
+
+#. Translators: '%s' is preplaced with a widget, where "
+#. * user can select how long the timeout should be.
+#: ../src/camel/camel-ews-provider.c:68
+#, c-format
+msgid "Connection _timeout (in seconds) %s"
+msgstr "Časovna pre_koračitev povezave (v sekundah) %s"
+
+#: ../src/camel/camel-ews-provider.c:76
+msgid "Exchange Web Services"
+msgstr "Spletna storitev Exchange"
+
+#: ../src/camel/camel-ews-provider.c:78
 msgid "For accessing Exchange servers using Web Services"
-msgstr "Za dostop do Microsoft Exchange / OpenChange strežnikov z uporabo MAPI protokola"
+msgstr "Za dostop do strežnikov Exchange preko spletnih storitev"
+
+#: ../src/camel/camel-ews-provider.c:93
+msgid "NTLM"
+msgstr "NTLM"
 
-#: ../src/camel/camel-ews-provider.c:87
-msgid "Password"
-msgstr "Geslo"
-
-#: ../src/camel/camel-ews-provider.c:89
-#, fuzzy
-msgid "This option will connect to the Exchange server using a plaintext password."
-msgstr "Ta možnost bo vzpostavila povezavo s strežnikom Exchange ob uporabi običajne overitve z geslom kot navadnim besedilom."
+#: ../src/camel/camel-ews-provider.c:95
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with NTLM authentication."
+msgstr ""
+"Možnost omogoča vzpostavitev povezave s strežnikom Exchange z besedilnim "
+"geslom z overjanjem NTLM."
+
+#: ../src/camel/camel-ews-provider.c:103
+msgid "Basic"
+msgstr "Osnovno"
+
+#: ../src/camel/camel-ews-provider.c:105
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with Basic authentication."
+msgstr ""
+"Možnost omogoča vzpostavitev povezave s strežnikom Exchange z besedilnim "
+"geslom z osnovnim overjanjem."
 
-#: ../src/camel/camel-ews-store.c:174
+#: ../src/camel/camel-ews-store.c:189
 #, c-format
 msgid "Session has no storage path"
 msgstr "Seja nima določene poti shrambe"
 
-#: ../src/camel/camel-ews-store.c:184
+#: ../src/camel/camel-ews-store.c:226
 #, c-format
-msgid "EWS service has no host URL"
-msgstr ""
+msgctxt "PublicFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:355
+#, c-format
+msgctxt "ForeignFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:678
+msgid "Updating foreign folder structure"
+msgstr "Posodabljanje tuje strukture map"
+
+#: ../src/camel/camel-ews-store.c:957
+msgid "Authentication password not available"
+msgstr "Geslo za overitev ni na voljo."
+
+#: ../src/camel/camel-ews-store.c:1109
+msgid "Query for authentication types is not supported"
+msgstr "Poizvedba po vrstah overjanja ni podprta"
 
-#: ../src/camel/camel-ews-store.c:359
+#: ../src/camel/camel-ews-store.c:1161
 #, c-format
 msgid "No such folder: %s"
 msgstr "Ni takšne mape: %s"
 
-#: ../src/camel/camel-ews-store.c:568
-#, fuzzy, c-format
+#: ../src/camel/camel-ews-store.c:1472
+msgid "Cannot list EWS public folders in offline mode"
+msgstr "V načinu brez povezave ni mogoče izpisati javnih map EWS"
+
+#: ../src/camel/camel-ews-store.c:1545
+msgid "Cannot find any EWS public folders"
+msgstr "Javnih map EWS ni mogoče najti."
+
+#: ../src/camel/camel-ews-store.c:1650
+#, c-format
+msgid "Cannot create folder '%s', folder already exists"
+msgstr "Mape '%s' ni mogoče ustvarite, že obstaja"
+
+#: ../src/camel/camel-ews-store.c:1665
+#, c-format
 msgid "Parent folder %s does not exist"
-msgstr "Nadrejena mapa ne obstaja"
+msgstr "Nadrejena mapa %s ne obstaja"
+
+#: ../src/camel/camel-ews-store.c:1675
+#, c-format
+msgid ""
+"Cannot create folder under '%s', it is used for folders of other users only"
+msgstr ""
+"Mape pod '%s' ni mogoče ustvariti, uporablja se le za mape drugih uporabnikov"
 
-#: ../src/camel/camel-ews-store.c:626
-#, fuzzy, c-format
+#: ../src/camel/camel-ews-store.c:1685
+#, c-format
+msgid "Cannot create folder under '%s', it is used for public folders only"
+msgstr "Mape pod '%s' ni mogoče ustvariti, saj se uporablja le za javne mape"
+
+#: ../src/camel/camel-ews-store.c:1754
+#, c-format
 msgid "Folder does not exist"
 msgstr "Mapa ne obstaja"
 
-#: ../src/camel/camel-ews-store.c:709
-#, fuzzy, c-format
+#: ../src/camel/camel-ews-store.c:1763
+#, c-format
+msgid "Cannot remove folder '%s', it is used for folders of other users only"
+msgstr ""
+"Mape pod '%s' ni mogoče odstraniti, uporablja se le za mape drugih "
+"uporabnikov"
+
+#: ../src/camel/camel-ews-store.c:1773
+#, c-format
+msgid "Cannot remove folder '%s', it is used for public folders only"
+msgstr "Mape pod '%s' ni mogoče odstraniti, saj se uporablja le za javne mape"
+
+#: ../src/camel/camel-ews-store.c:1881
+#, c-format
 msgid "Folder %s does not exist"
-msgstr "Mapa '%s/%s' ne obstaja."
+msgstr "Mapa %s ne obstaja."
 
-#: ../src/camel/camel-ews-store.c:718
+#: ../src/camel/camel-ews-store.c:1891
 #, c-format
 msgid "No change key record for folder %s"
-msgstr ""
+msgstr "Ni zapisa ključa za mapo %s"
 
-#: ../src/camel/camel-ews-store.c:757
+#: ../src/camel/camel-ews-store.c:1933
 #, c-format
 msgid "Cannot both rename and move a folder at the same time"
-msgstr ""
+msgstr "Ni mogoče hkrati preimenovati in premakniti mape"
 
-#: ../src/camel/camel-ews-store.c:788
+#: ../src/camel/camel-ews-store.c:1969
 #, c-format
 msgid "Cannot find folder ID for parent folder %s"
-msgstr ""
+msgstr "Ni mogoče najti ID mape za nadrejeno mapo %s"
 
-#: ../src/camel/camel-ews-store.c:817
-#: ../src/camel/camel-ews-transport.c:61
+#: ../src/camel/camel-ews-store.c:2019 ../src/camel/camel-ews-transport.c:69
 #, c-format
 msgid "Exchange server %s"
 msgstr "Strežnik Exchange %s"
 
-#: ../src/camel/camel-ews-store.c:819
+#: ../src/camel/camel-ews-store.c:2022
 #, c-format
 msgid "Exchange service for %s on %s"
 msgstr "Storitev Exchange za %s na %s"
 
-#: ../src/camel/camel-ews-store.c:856
-#, fuzzy, c-format
+#: ../src/camel/camel-ews-store.c:2066
+#, c-format
+msgid "Could not locate Trash folder"
+msgstr "Mape Smeti ni mogoče najti"
+
+#: ../src/camel/camel-ews-store.c:2101
+#, c-format
+msgid "Could not locate Junk folder"
+msgstr "Mape neželene pošte ni mogoče najti."
+
+#: ../src/camel/camel-ews-store.c:2291
+msgid "Cannot subscribe EWS folders in offline mode"
+msgstr "V načinu brez povezave se ni mogoče naročiti na mape EWS"
+
+#: ../src/camel/camel-ews-store.c:2309
+#, c-format
+msgid "Cannot subscribe folder '%s', no public folder available"
+msgstr "Na mapo '%s' ni mogoče naročiti, ker ustrezne javne mape ni na voljo"
+
+#: ../src/camel/camel-ews-store.c:2319
+#, c-format
+msgid "Cannot subscribe folder '%s', folder not found"
+msgstr "Na mapo '%s' ni mogoče naročiti, ker mape ni mogoče najti"
+
+#: ../src/camel/camel-ews-store.c:2409
+msgid "Cannot unsubscribe EWS folders in offline mode"
+msgstr "V načinu brez povezave ni mogoče preklicati naročil na mape EWS"
+
+#: ../src/camel/camel-ews-store.c:2525
+#, c-format
 msgid "You must be working online to complete this operation"
-msgstr "Za dokončanje tega opravila je treba biti povezan v omrežje"
+msgstr "Za dokončanje tega opravila je treba vzpostaviti povezavo v omrežje"
 
-#: ../src/camel/camel-ews-transport.c:65
-#, fuzzy, c-format
+#: ../src/camel/camel-ews-transport.c:72
+#, c-format
 msgid "Exchange mail delivery via %s"
-msgstr "Dostava pošte s SMTP preko %s"
+msgstr "Dostava pošte Exchange preko %s"
+
+#: ../src/camel/camel-ews-transport.c:119
+msgid "Cannot send message with no From address"
+msgstr "Ni mogoče poslati sporočila brez naslova pošiljatelja"
+
+#: ../src/camel/camel-ews-transport.c:125
+msgid "Exchange server cannot send message with multiple From addresses"
+msgstr ""
+"Strežnik Exchange ne podpira pošiljanja sporočil z več naslovi pošiljateljev"
+
+#: ../src/camel/camel-ews-transport.c:136
+msgid "Failed to read From address"
+msgstr "Branje iz naslova je spodletelo"
 
-#: ../src/camel/camel-ews-transport.c:92
+#: ../src/camel/camel-ews-transport.c:148
+#, c-format
+msgid ""
+"Exchange server cannot send message as '%s', when the account was configured "
+"for address '%s'"
+msgstr ""
+"Strežnik Exchange ne podpira pošiljanja sporočil kot '%s', če je račun "
+"nastavljen za naslov '%s'."
+
+#: ../src/camel/camel-ews-transport.c:162
 #, c-format
 msgid "Service not connected"
 msgstr "Storitev ni povezana"
 
-#: ../src/server/e-ews-connection.c:354
+#: ../src/collection/e-ews-backend.c:406
+#: ../src/configuration/e-mail-config-ews-gal.c:274
+msgid "Global Address List"
+msgstr "Splošni seznam naslovov"
+
+#: ../src/collection/e-ews-backend.c:793
+#, c-format
+msgid "Could not determine a suitable folder class for a new folder named '%s'"
+msgstr "Za novo mapo z imenom '%s' ni mogoče določiti ustreznega razreda mape"
+
+#: ../src/collection/e-ews-backend.c:882
+#, c-format
+msgid "Data source '%s' does not represent an Exchange Web Services folder"
+msgstr "Vir podatkov '%s' ne predstavlja mape spletnih storitev Exchange"
+
+#: ../src/configuration/e-ews-config-utils.c:511
+#, c-format
+msgid "Cannot edit permissions of folder '%s', choose other folder."
+msgstr "Ni mogoče urediti dovoljenj mape '%s'; izberite drugo mapo."
+
+#: ../src/configuration/e-ews-config-utils.c:589
+msgid "Subscribe to folder of other user..."
+msgstr "Naročilo na mapo drugega uporabnika ..."
+
+#: ../src/configuration/e-ews-config-utils.c:598
+#: ../src/configuration/e-ews-config-utils.c:879
+#: ../src/configuration/e-ews-config-utils.c:910
+#: ../src/configuration/e-ews-config-utils.c:941
+#: ../src/configuration/e-ews-config-utils.c:972
+msgid "Permissions..."
+msgstr "Dovoljenja ..."
+
+#: ../src/configuration/e-ews-config-utils.c:600
+msgid "Edit EWS folder permissions"
+msgstr "Uredi dovoljenja map EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:881
+msgid "Edit EWS calendar permissions"
+msgstr "Uredi dovoljenja koledarja EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:912
+msgid "Edit EWS tasks permissions"
+msgstr "Uredi dovoljenja nalog EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:943
+msgid "Edit EWS memos permissions"
+msgstr "Uredi dovoljenja opomnikov EWS"
+
+#: ../src/configuration/e-ews-config-utils.c:974
+msgid "Edit EWS contacts permissions"
+msgstr "Uredi dovoljenja stikov EWS"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:87
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:499
+msgctxt "PermissionsLevel"
+msgid "None"
+msgstr "Brez"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:88
+msgctxt "PermissionsLevel"
+msgid "Owner"
+msgstr "Lastnik"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:98
+msgctxt "PermissionsLevel"
+msgid "Publishing Editor"
+msgstr "Založniški urednik"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:107
+msgctxt "PermissionsLevel"
+msgid "Editor"
+msgstr "Urednik"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:115
+msgctxt "PermissionsLevel"
+msgid "Publishing Author"
+msgstr "Založniški avtor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:122
+msgctxt "PermissionsLevel"
+msgid "Author"
+msgstr "Avtor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:128
+msgctxt "PermissionsLevel"
+msgid "Nonediting Author"
+msgstr "Neurejujoči avtor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:133
+msgctxt "PermissionsLevel"
+msgid "Reviewer"
+msgstr "Pregledovalec"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:136
+msgctxt "PermissionsLevel"
+msgid "Contributor"
+msgstr "Sodelavec"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:139
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time"
+msgstr "Čas zasedenosti"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:141
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time, subject, location"
+msgstr "Čas zasedenosti, zadeva, mesto"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:143
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:520
+msgctxt "PermissionsLevel"
+msgid "Custom"
+msgstr "Po meri"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:267
+msgid "Writing folder permissions, please wait..."
+msgstr "Poteka zapisovanje dovoljenj mape ..."
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:759
+msgctxt "User"
+msgid "Anonymous"
+msgstr "Brezimno"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:762
+msgctxt "User"
+msgid "Default"
+msgstr "Privzeto"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:768
+msgctxt "User"
+msgid "Unknown"
+msgstr "Neznano"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:849
+#: ../src/configuration/e-ews-search-user.c:430
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1075
+msgid "Name"
+msgstr "Ime"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:855
+msgid "Permission level"
+msgstr "Raven dovoljenj"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:907
+msgid "Edit EWS folder permissions..."
+msgstr "Uredi dovoljenja map EWS ..."
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:932
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:633
+msgid "Account:"
+msgstr "Račun:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:960
+msgid "Folder name:"
+msgstr "Ime mape:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:983
+msgid "Folder ID:"
+msgstr "ID mape:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1047
+msgid "Permissions"
+msgstr "Dovoljenja"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1069
+msgid "Permi_ssion level:"
+msgstr "Raven _dovoljenj:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1103
+msgctxt "Permissions"
+msgid "Read"
+msgstr "Preberi"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1115
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1182
+msgctxt "Permissions"
+msgid "None"
+msgstr "Brez"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1121
+msgctxt "Permissions"
+msgid "Free/Busy time"
+msgstr "Čas zasedenosti"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1126
+msgctxt "Permissions"
+msgid "Free/Busy time, subject, location"
+msgstr "Čas zasedenosti, zadeva, mesto"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1132
+msgctxt "Permissions"
+msgid "Full Details"
+msgstr "Polne podrobnosti"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1138
+msgctxt "Permissions"
+msgid "Write"
+msgstr "Zapiši"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1150
+msgctxt "Permissions"
+msgid "Create items"
+msgstr "Ustvari predmete"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1154
+msgctxt "Permissions"
+msgid "Create subfolders"
+msgstr "Ustvari podmape"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1158
+msgctxt "Permissions"
+msgid "Edit own"
+msgstr "Uredi lastne"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1162
+msgctxt "Permissions"
+msgid "Edit all"
+msgstr "Uredi vse"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1170
+msgctxt "Permissions"
+msgid "Delete items"
+msgstr "Izbriši predmete"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1187
+msgctxt "Permissions"
+msgid "Own"
+msgstr "Lastne"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1192
+msgctxt "Permissions"
+msgid "All"
+msgstr "Vse"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1198
+msgctxt "Permissions"
+msgid "Other"
+msgstr "Drugo"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1210
+msgctxt "Permissions"
+msgid "Folder owner"
+msgstr "Lastnik mape"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1214
+msgctxt "Permissions"
+msgid "Folder contact"
+msgstr "Stik mape"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1218
+msgctxt "Permissions"
+msgid "Folder visible"
+msgstr "Mapa je vidna"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1291
+msgid "Reading folder permissions, please wait..."
+msgstr "Poteka branje dovoljenj mape ..."
+
+#: ../src/configuration/e-ews-search-user.c:208
+#, c-format
+msgid "No users found, only one contact"
+msgid_plural "No users found, only %d contacts"
+msgstr[0] "Ni najdenih uporabnikov, le %d stikov"
+msgstr[1] "Ni najdenih uporabnikov, le %d stik"
+msgstr[2] "Ni najdenih uporabnikov, le %d stika"
+msgstr[3] "Ni najdenih uporabnikov, le %d stiki"
+
+#: ../src/configuration/e-ews-search-user.c:213
+msgid "No users found"
+msgstr "Ni najdenih uporabnikov"
+
+#: ../src/configuration/e-ews-search-user.c:217
+#, c-format
+msgid "Found one user"
+msgid_plural "Found %d users"
+msgstr[0] "Najdenih je %d uporabnikov."
+msgstr[1] "Najden je %d uporabnik."
+msgstr[2] "Najdena sta %d uporabnika."
+msgstr[3] "Najdeni so %d uporabniki."
+
+#: ../src/configuration/e-ews-search-user.c:223
+#, c-format
+msgid "Found more than 100 users, but showing only first %d"
+msgid_plural "Found more than 100 users, but showing only first %d"
+msgstr[0] "Najdenih več kot sto uporabnikov, prikazanih je le prvih %d"
+msgstr[1] "Najdenih več kot sto uporabnikov, prikazan je le prvi %d"
+msgstr[2] "Najdenih več kot sto uporabnikov, prikazana sta le prva %d"
+msgstr[3] "Najdenih več kot sto uporabnikov, prikazani so le prvi %d"
+
+#: ../src/configuration/e-ews-search-user.c:356
+#: ../src/configuration/e-ews-search-user.c:539
+msgid "Search for a user"
+msgstr "Iskanje uporabnika"
+
+#: ../src/configuration/e-ews-search-user.c:436
+msgid "E-mail"
+msgstr "Elektronski naslov"
+
+#: ../src/configuration/e-ews-search-user.c:473
+msgid "Choose EWS user..."
+msgstr "Izbor uporabnika EWS ..."
+
+#: ../src/configuration/e-ews-search-user.c:496
+msgid "_Search:"
+msgstr "_Poišči:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:97
+#: ../src/server/e-ews-folder.c:591
+#, c-format
+msgid "Cannot add folder, folder already exists as '%s'"
+msgstr "Mape ni mogoče dodati, ker že obstaja kot '%s'"
+
+#. Translators: The '%s' is replaced with user name, to whom the foreign mailbox belongs.
+#. * Example result: "Mailbox - John Smith"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:107
+#, c-format
+msgctxt "ForeignFolder"
+msgid "Mailbox - %s"
+msgstr "Poštni predal - %s"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:272
+msgid "Cannot test foreign folder availability while in offline mode"
+msgstr "Dosegljivosti tujih map v načinu brez povezave ni mogoče preizkusiti"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:297
+#, c-format
+msgid "User '%s' was not found on the server"
+msgstr "Uporabnika '%s' ni mogoče najti na strežniku"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:333
+#, c-format
+msgid "User name '%s' is ambiguous, specify it more precisely, please"
+msgstr "Uporabniško ime '%s' ni enoznačno, določite ga natančneje"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:355
+#, c-format
+msgid ""
+"Folder '%s' not found. Either it does not exist or you do not have "
+"permission to access it."
+msgstr ""
+"Mape '%s' ni mogoče najti. Ali ne obstaja ali pa ni ustreznih dovoljenj za "
+"dostop."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:373
+msgid "Cannot add folder, cannot determine folder's type"
+msgstr "Mape ni mogoče dodati, ker ni mogoče določiti vrste"
+
+#. Translators: This is used to name foreign folder.
+#. * The first '%s' is replaced with user name to whom the folder belongs,
+#. * the second '%s' is replaced with folder name.
+#. * Example result: "John Smith - Calendar"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:418
+#, c-format
+msgctxt "ForeignFolder"
+msgid "%s - %s"
+msgstr "%s - %s"
+
+#. convert well-known names to their non-localized form
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:511
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:718
+msgid "Inbox"
+msgstr "Prejeto"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:513
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:719
+msgid "Contacts"
+msgstr "Stiki"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:515
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:720
+msgid "Calendar"
+msgstr "Koledar"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:517
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:721
+msgid "Memos"
+msgstr "Opomniki"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:519
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:722
+msgid "Tasks"
+msgstr "Naloge"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:536
+#, c-format
+msgid "Testing availability of folder '%s' of user '%s', please wait..."
+msgstr ""
+"Preizkušanje dosegljivosti mape '%s' uporabnika '%s', počakajte trenutek ..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:612
+msgid "Subscribe to folder of other EWS user..."
+msgstr "Naročilo na mapo drugega uporabnika EWS ..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:663
+msgid "User"
+msgstr "Uporabnik"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:670
+msgid "_User:"
+msgstr "_Uporabnik:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:685
+msgid "C_hoose..."
+msgstr "Iz_beri ..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:701
+msgid "_Folder name:"
+msgstr "I_me mape:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:731
+msgid "Include _subfolders"
+msgstr "_Upoštevaj podmape"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:129
+msgid "Querying Autodiscover service"
+msgstr "Poizvedovanje storitve samodejnega zaznavanja"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:212
+msgid "Fetch _URL"
+msgstr "Pridobi naslov _URL"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:140
+msgid "Configuration"
+msgstr "Nastavitve"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:158
+msgid "User_name:"
+msgstr "Uporab_niško ime:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:172
+msgid "_Host URL:"
+msgstr "Naslov URL _gostitelja:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:191
+msgid "OAB U_RL:"
+msgstr "OAB U_RL:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:205
+msgid "Open _Mailbox of other user"
+msgstr "Odpri _predal elektronske pošte drugega uporabnika"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:239
+msgid "S_earch..."
+msgstr "_Poišči ..."
+
+#: ../src/configuration/e-mail-config-ews-backend.c:250
+msgid "Authentication"
+msgstr "Overitev"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:500
+msgctxt "PermissionsLevel"
+msgid "Reviewer (can read items)"
+msgstr "Pregledovalec (lahko bere vsebine)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:501
+msgctxt "PermissionsLevel"
+msgid "Author (can read and create items)"
+msgstr "Avtor (lahko bere in ustvarja vsebine)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:502
+msgctxt "PermissionsLevel"
+msgid "Editor (can read, create and modify items)"
+msgstr "Urednik (lahko bere, ustvarja in spreminja vsebine)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:605
+msgid "Delegate permissions"
+msgstr "Dovoljenja pooblaščencev"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:623
+msgid "C_alendar"
+msgstr "Koled_ar"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:626
+msgid "_Delegate receives copies of meeting-related messages sent to me"
+msgstr ""
+"_Pooblaščenec prejme kopije meni poslanih sporočil, ki se nanašajo na "
+"sestanek"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:631
+msgid "_Tasks"
+msgstr "_Naloge"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:634
+msgid "_Inbox"
+msgstr "_Dohodni predal:"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:637
+msgid "C_ontacts"
+msgstr "S_tiki"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:640
+msgid "_Notes"
+msgstr "_Opombe"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:643
+msgid "_Journal"
+msgstr "_Dnevnik"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:646
+#, c-format
+msgid "Delegate '%s' has the following permissions"
+msgstr "Pooblaščenec '%s' ima naslednje pravice"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:664
+msgid "Delegate can see my _private items"
+msgstr "Pooblaščenec lahko vidi moje _zasebne vsebine"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:987
+msgid "Retrieving current user permissions, please wait..."
+msgstr "Pridobivanje pravic trenutnega uporabnika, počakajte trenutek ..."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1108
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1638
+msgid "Delegates"
+msgstr "Pooblaščenci"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1132
+msgid ""
+"Delegates can send items on your behalf, including creating and responding "
+"to meeting requests. If you want to grant folder permissions without giving "
+"send-on-behalf-of permissions, close this dialog box, right-click the "
+"folder, click Permissions and change the options there."
+msgstr ""
+"Pooblaščenci lahko pošiljajo vsebine v vašem imenu, vključno z ustvarjanjem "
+"in odgovarjanjem na zahtevke za sestanke. Če želite dodeliti dovoljenja za "
+"mapo brez pravic za pošiljanje-v-imenu, zaprite to pogovorno okno, desno "
+"kliknite mapo, kliknite Dovoljenja in spremenite možnosti."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1181
+msgid ""
+"Deliver meeting requests addressed to me and responses to meeting requests "
+"where I am the organizer to:"
+msgstr ""
+"Dostavi zahteve za sestanek, ki so naslovljene name, in odgovore na zahteve "
+"za sestanke, katerih organizator sem, na naslov:"
+
+#. new-line break, because GtkRadioButton doesn't allow wrapping of the inner label
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1190
+msgid ""
+"My delegates only, but _send a copy of meeting requests\n"
+"and responses to me (recommended)"
+msgstr ""
+"Le moji pooblaščenci, vendar _pošlji kopijo zahtevkov za sestanke\n"
+"in odgovore nanje meni (priporočeno)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1197
+msgid "My d_elegates only"
+msgstr "Le _moji pooblaščenci"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1204
+msgid "My delegates a_nd me"
+msgstr "Moji pooblaščenci i_n jaz"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1713
+msgid "Retrieving \"Delegates\" settings"
+msgstr "Pridobivanje nastavitev o \"Pooblaščencih\""
+
+#: ../src/configuration/e-mail-config-ews-gal.c:221
+msgid "Locating offline address books"
+msgstr "Iskanje krajevnega imenika"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:301
+msgid "Cache o_ffline address book"
+msgstr "Predpomni _oddaljen imenik stikov"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:327
+msgid "Select ad_dress list:"
+msgstr "Izbor seznama _naslovov:"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:351
+msgid "Fetch List"
+msgstr "Pridobi seznam"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:444
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:923
+msgid "Out of Office"
+msgstr "Izven pisarne"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:460
+msgid ""
+"The messages specified below will be automatically sent to each internal and "
+"external person who sends a mail to you."
+msgstr ""
+"Sporočilo, ki je določeno spodaj, bo samodejno poslano vsem notranjim ali "
+"zunanjim stikom, ki vam pošljejo sporočilo."
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:468
+msgid "Do _not send Out of Office replies"
+msgstr "_Ne pošiljaj odgovore o odsotnosti"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:476
+msgid "_Send Out of Office replies"
+msgstr "Pošlji odzive _odsotnosti"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:484
+msgid "Send Out of Office replies only _during this time period:"
+msgstr "Pošlji odzive odsotnosti le v obdobju:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:504
+msgid "_From:"
+msgstr "_Od:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:529
+msgid "_To:"
+msgstr "_Za:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:554
+msgid "I_nternal:"
+msgstr "_Notranji:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:563
+msgid "Message to be sent within the organization"
+msgstr "Sporočilo za prejemnike znotraj organizacije"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:590
+msgid "E_xternal:"
+msgstr "_Zunanji:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:598
+msgid "Message to be sent outside the organization"
+msgstr "Sporočilo za zunanje prejemnike"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:608
+msgid "Do not reply to senders outside the organization"
+msgstr "Ne odgovarjaj pošiljateljem zunaj organizacije"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:611
+msgid "Reply only to known senders outside the organization"
+msgstr "Odgovarjaj le znanim pošiljateljem zunaj organizacije"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:614
+msgid "Reply to any sender outside the organization"
+msgstr "Odgovori vsem pošiljateljem zunaj organizacije"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:999
+msgid "Retrieving \"Out of Office\" settings"
+msgstr "Pridobivanje nastavitev \"Odsoten iz pisarne\" ..."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:1
+msgid "Autodiscovery query failed."
+msgstr "Poizvedba samorazkrivanja je spodletela."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:2
+msgid "The reported error was &quot;{0}&quot;."
+msgstr "Napaka v poročilu je &quot;{0}&quot;."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:3
+msgid "Failed to locate offline address books."
+msgstr "Iskanje nepovezanih imenikov je spodletelo."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:4
+msgid "Failed to retrieve &quot;Out of Office&quot; settings."
+msgstr "Ni mogoče pridobiti nastavitev za sporočila &quot;odsotnosti&quot;"
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:5
+msgid "Failed to retrieve &quot;Delegates&quot; settings."
+msgstr "Pridobivanje nastavitev &quot;Pooblaščencev&quot; je spodletelo."
+
+#: ../src/server/e-ews-connection.c:493
 msgid "Operation Cancelled"
 msgstr "Opravilo je preklicano"
 
-#: ../src/server/e-ews-connection.c:408
+#: ../src/server/e-ews-connection.c:562
 msgid "Authentication failed"
 msgstr "Overitev je spodletela"
 
-#: ../src/server/e-ews-connection.c:416
+#: ../src/server/e-ews-connection.c:573
 #, c-format
 msgid "No response: %s"
 msgstr "Brez odgovora: %s"
 
-#: ../src/server/e-ews-connection.c:1072
-#: ../src/server/e-ews-connection.c:1388
-#: ../src/server/e-ews-connection.c:1625
-#, fuzzy, c-format
-msgid "Code: %d - Unexpected response from server"
-msgstr "Nepričakovan odziv strežnika IMAP: %s"
-
-#: ../src/server/e-ews-connection.c:1084
-#, fuzzy, c-format
+#: ../src/server/e-ews-connection.c:1877
+#, c-format
 msgid "Failed to parse autodiscover response XML"
-msgstr ""
-"Razčlenjevanje odgovora XML-RPC ni uspelo. Sporočilo napake:\n"
-"\n"
-"%s"
-
-#: ../src/server/e-ews-connection.c:1092
-#, fuzzy, c-format
-msgid "Failed to find <Autodiscover> element\n"
-msgstr "Iskanje podvojenih sporočil je spodletelo."
-
-#: ../src/server/e-ews-connection.c:1104
-#, fuzzy, c-format
-msgid "Failed to find <Response> element\n"
-msgstr "Napaka med razčlenjevanjem odgovora strežnika."
-
-#: ../src/server/e-ews-connection.c:1116
-#, fuzzy, c-format
-msgid "Failed to find <Account> element\n"
-msgstr "Iskanje podvojenih sporočil je spodletelo."
+msgstr "Razčlenjevanje samodejnega odgovora XML je spodletelo"
+
+#: ../src/server/e-ews-connection.c:1884
+#, c-format
+msgid "Failed to find <Autodiscover> element"
+msgstr "Iskanje predmeta <samodejnega zaznavanja> je spodletelo."
+
+#: ../src/server/e-ews-connection.c:1895
+#, c-format
+msgid "Failed to find <Response> element"
+msgstr "Iskanje predmeta <odziva> je spodletelo."
+
+#: ../src/server/e-ews-connection.c:1906
+#, c-format
+msgid "Failed to find <Account> element"
+msgstr "Iskanje predmeta <računa> je spodletelo."
 
-#: ../src/server/e-ews-connection.c:1135
+#: ../src/server/e-ews-connection.c:1925
 #, c-format
 msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
-msgstr ""
+msgstr "Samodejno iskanje predmetov odgovora <ASUrl> in <OABUrl> je spodletelo"
+
+#: ../src/server/e-ews-connection.c:2007
+msgid "URL cannot be NULL"
+msgstr "URL ne sme biti NULL"
 
-#: ../src/server/e-ews-connection.c:1231
+#: ../src/server/e-ews-connection.c:2015
 #, c-format
-msgid "Both email and password must be provided"
-msgstr ""
+msgid "URL '%s' is not valid"
+msgstr "URL '%s' ni veljaven"
 
-#: ../src/server/e-ews-connection.c:1238
-#, fuzzy, c-format
-msgid "Wrong email id"
-msgstr ""
-"\n"
-"Veljavnost uporabniškega ID: %s"
+#: ../src/server/e-ews-connection.c:2117
+msgid "Email address is missing a domain part"
+msgstr "V elektronskem naslovu manjka del z domeno"
 
-#: ../src/server/e-ews-connection.c:1398
-#, fuzzy, c-format
+#: ../src/server/e-ews-connection.c:2429
 msgid "Failed to parse oab XML"
-msgstr "Ni mogoče razčleniti datoteke XML \"%s\""
+msgstr "Razčlenjevanje datoteke OAB XML je spodletelo."
 
-#: ../src/server/e-ews-connection.c:1405
-#, fuzzy, c-format
+#: ../src/server/e-ews-connection.c:2437
 msgid "Failed to find <OAB> element\n"
-msgstr "Iskanje podvojenih sporočil je spodletelo."
+msgstr "Iskanje predmeta <OAB> je spodletelo.\n"
+
+#: ../src/server/e-ews-connection.c:3609
+msgid "No items found"
+msgstr "Ni zadetkov"
+
+#: ../src/server/e-ews-folder.c:546
+msgid "Cannot add folder, unsupported folder type"
+msgstr "Mape ni mogoče dodati, ker vrsta mape ni podprta"
 
-#: ../src/utils/ews-camel-common.c:139
+#: ../src/server/e-ews-folder.c:551
+msgid "Cannot add folder, master source not found"
+msgstr "Mape ni mogoče dodati, ker izvornega vira ni mogoče najti"
+
+#: ../src/utils/ews-camel-common.c:187
 #, c-format
 msgid "CreateItem call failed to return ID for new message"
 msgstr ""
+"Klic predmeta CreateItem je spodletel pri iskanju vrednosti ID novega "
+"sporočila"
+
+#~ msgid ""
+#~ "Cannot list folders available for subscription of Exchange Web Services "
+#~ "account, use 'Subscribe to folder of other user' context menu option "
+#~ "above the account node in the folder tree instead."
+#~ msgstr ""
+#~ "Map, ki so na voljo za naročnino na račun spletnih storitev Exchange, ni "
+#~ "mogoče izpisati, raje uporabite ukaz 'Naroči se na mapo drugega "
+#~ "uporabnika' iz vsebinskega menija nad vozliščem računa v drevesu map."
 
+#~ msgid "Insufficient memory"
+#~ msgstr "Nezadostna količina pomnilnika"
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/sr@latin.po evolution-ews.sync-with-3.8.2/po/sr@latin.po
--- evolution-ews.git-gnome-3-0/po/sr@latin.po	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/po/sr@latin.po	2013-05-29 08:46:58.828616787 +0200
@@ -0,0 +1,1097 @@
+# Serbian translation of evolution-ews
+# Courtesy of Prevod.org team (http://prevod.org/) -- 2012.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the ewolution-ews package.
+# Miroslav Nikolić <miroslavnikolic@rocketmail.com>, 2012, 2013.
+msgid ""
+msgstr ""
+"Project-Id-Version: evolution-ews\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product"
+"=evolution-ews&keywords=I18N+L10N&component=general\n"
+"POT-Creation-Date: 2013-02-17 14:38+0000\n"
+"PO-Revision-Date: 2013-02-20 12:13+0200\n"
+"Last-Translator: Miroslav Nikolić <miroslavnikolic@rocketmail.com>\n"
+"Language-Team: Serbian <gnom@prevod.org>\n"
+"Language: sr\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=4; plural=n==1? 3 : n%10==1 && n%100!=11 ? 0 : "
+"n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;\n"
+"X-Project-Style: gnome\n"
+
+#: ../src/addressbook/e-book-backend-ews.c:969
+msgid "The backend does not support bulk additions"
+msgstr "Pozadinac ne podržava grupno dodavanje"
+
+#: ../src/addressbook/e-book-backend-ews.c:1253
+msgid "The backend does not support bulk modifications"
+msgstr "Pozadinac ne podržava grupno uređivanje"
+
+#: ../src/addressbook/e-book-backend-ews.c:1436
+msgid "Wait till syncing is done"
+msgstr "Sačekaj dok se usklađivanje ne obavi"
+
+#: ../src/addressbook/e-book-backend-ews.c:1775
+#, c-format
+msgid "Downloading contacts in %s %d%% completed... "
+msgstr "Preuzimam kontakte u %s, obavljeno je %d%%... "
+
+#: ../src/addressbook/e-book-backend-ews.c:2324
+msgid "Syncing contacts..."
+msgstr "Usaglašavam kontakte..."
+
+#: ../src/addressbook/e-book-backend-ews.c:2548
+#: ../src/configuration/e-ews-search-user.c:364
+msgid "Searching..."
+msgstr "Pretražujem..."
+
+#: ../src/calendar/e-cal-backend-ews.c:1009
+msgid "EWS does not support bulk removals"
+msgstr "VUR ne podržava grupno uklanjanje"
+
+#: ../src/calendar/e-cal-backend-ews.c:1652
+msgid "EWS does not support bulk additions"
+msgstr "VUR ne podržava grupno dodavanje"
+
+#: ../src/calendar/e-cal-backend-ews.c:2231
+msgid "EWS does not support bulk modifications"
+msgstr "VUR ne podržava grupno uređivanje"
+
+#: ../src/camel/camel-ews-folder.c:268
+#, c-format
+msgid "Unable to open mimecontent temporary file!"
+msgstr "Ne mogu da otvorim privremenu datoteku mime sadržaja!"
+
+#: ../src/camel/camel-ews-folder.c:276
+#, c-format
+msgid "Unable to generate parser from mimecontent!"
+msgstr "Ne mogu da stvorim obrađivač iz mime sadržaja!"
+
+#: ../src/camel/camel-ews-folder.c:285
+#, c-format
+msgid "Unable to parse meeting request mimecontent!"
+msgstr "Ne mogu da obradim mime sadržaj zahteva za sastanak!"
+
+#: ../src/camel/camel-ews-folder.c:346
+#, c-format
+msgid "Unable to create cache file"
+msgstr "Ne mogu da napravim datoteku ostave"
+
+#: ../src/camel/camel-ews-folder.c:451 ../src/camel/camel-ews-folder.c:531
+#, c-format
+msgid "Unable to create cache path"
+msgstr "Ne mogu da napravim putanju privremenog čuvanja"
+
+#: ../src/camel/camel-ews-folder.c:541
+#, c-format
+msgid "Failed to move message cache file"
+msgstr "Nisam uspeo da premestim datoteku ostave poruke"
+
+#: ../src/camel/camel-ews-folder.c:1188
+#, c-format
+msgid "Could not load summary for %s"
+msgstr "Ne mogu da učitam pregled za „%s“"
+
+#: ../src/camel/camel-ews-folder.c:1624
+#, c-format
+msgid "Cant perform actions on the folder while in offline mode"
+msgstr "Ne mogu da izvršim radnje nad fasciklama u režimu van mreže"
+
+#: ../src/camel/camel-ews-provider.c:48
+msgid "Checking for new mail"
+msgstr "Proveravam novu poštu"
+
+#: ../src/camel/camel-ews-provider.c:50
+msgid "C_heck for new messages in all folders"
+msgstr "P_otraži nove poruke u svim fasciklama"
+
+#: ../src/camel/camel-ews-provider.c:53
+msgid "Options"
+msgstr "Opcije"
+
+#: ../src/camel/camel-ews-provider.c:55
+msgid "_Apply filters to new messages in Inbox on this server"
+msgstr "_Primeni propusnike na nove poruke u sandučetu ovog servera"
+
+#: ../src/camel/camel-ews-provider.c:57
+msgid "Check new messages for _Junk contents"
+msgstr "Proveri ima li _neželjenih među novim porukama"
+
+#: ../src/camel/camel-ews-provider.c:59
+msgid "Only check for Junk messages in the IN_BOX folder"
+msgstr "Proveri da nema đubreta samo u fascikli SAN_DUČE"
+
+#: ../src/camel/camel-ews-provider.c:61
+msgid "Automatically synchroni_ze remote mail locally"
+msgstr "Sam uskladi _udaljenu poštu sa lokalnom"
+
+#: ../src/camel/camel-ews-provider.c:64
+msgid "Connection"
+msgstr "Veza"
+
+#. Translators: '%s' is preplaced with a widget, where "
+#. * user can select how long the timeout should be.
+#: ../src/camel/camel-ews-provider.c:68
+#, c-format
+msgid "Connection _timeout (in seconds) %s"
+msgstr "Vremenski _istek veze (u sekundama) %s"
+
+#: ../src/camel/camel-ews-provider.c:76
+msgid "Exchange Web Services"
+msgstr "Veb usluge razmene"
+
+#: ../src/camel/camel-ews-provider.c:78
+msgid "For accessing Exchange servers using Web Services"
+msgstr "Za pristupanje serverima razmene upotreboom veb usluga"
+
+#: ../src/camel/camel-ews-provider.c:93
+msgid "NTLM"
+msgstr "NTLM"
+
+#: ../src/camel/camel-ews-provider.c:95
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with NTLM authentication."
+msgstr ""
+"Ova opcija će vas povezati na server razmene koristeći lozinku običnog "
+"teksta sa NTLM potvrdom identiteta."
+
+#: ../src/camel/camel-ews-provider.c:103
+msgid "Basic"
+msgstr "Osnovno"
+
+#: ../src/camel/camel-ews-provider.c:105
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with Basic authentication."
+msgstr ""
+"Ova opcija će vas povezati na server razmene koristeći lozinku običnog "
+"teksta sa osnovnom potvrdom identiteta."
+
+#: ../src/camel/camel-ews-store.c:192
+#, c-format
+msgid "Session has no storage path"
+msgstr "Sesija nema putanju skladišta"
+
+#: ../src/camel/camel-ews-store.c:229
+#, c-format
+#| msgctxt "ForeignFolders"
+#| msgid "%s_%d"
+msgctxt "PublicFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:358
+#, c-format
+msgctxt "ForeignFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:688
+msgid "Updating foreign folder structure"
+msgstr "Osvežavam strukturu strane fascikle"
+
+#: ../src/camel/camel-ews-store.c:973
+msgid "Authentication password not available"
+msgstr "Lozinka potvrde identiteta nije dostupna"
+
+#: ../src/camel/camel-ews-store.c:1138
+msgid "Query for authentication types is not supported"
+msgstr "Propitivanje za vrstama potvrde identiteta nije podržano"
+
+#: ../src/camel/camel-ews-store.c:1190
+#, c-format
+msgid "No such folder: %s"
+msgstr "Nema takve fascikle: %s"
+
+#: ../src/camel/camel-ews-store.c:1502
+#| msgid "Cannot subscribe EWS folders in offline mode"
+msgid "Cannot list EWS public folders in offline mode"
+msgstr "Ne mogu da ispišem VUR javne fascikle u režimu van mreže"
+
+#: ../src/camel/camel-ews-store.c:1575
+#| msgid "Cannot find folder ID for parent folder %s"
+msgid "Cannot find any EWS public folders"
+msgstr "Ne mogu da pronađem VUR javne fascikle"
+
+#: ../src/camel/camel-ews-store.c:1680
+#, c-format
+msgid "Cannot create folder '%s', folder already exists"
+msgstr "Ne mogu da napravim fasciklu „%s“, fascikla već postoji"
+
+#: ../src/camel/camel-ews-store.c:1695
+#, c-format
+msgid "Parent folder %s does not exist"
+msgstr "Ne postoji roditeljska fascikla „%s“"
+
+#: ../src/camel/camel-ews-store.c:1705
+#, c-format
+msgid ""
+"Cannot create folder under '%s', it is used for folders of other users only"
+msgstr ""
+"Ne mogu da napravim fasciklu pod „%s“, koristi se samo za fascikle drugih "
+"korisnika"
+
+#: ../src/camel/camel-ews-store.c:1715
+#, c-format
+#| msgid ""
+#| "Cannot create folder under '%s', it is used for folders of other users "
+#| "only"
+msgid "Cannot create folder under '%s', it is used for public folders only"
+msgstr ""
+"Ne mogu da napravim fasciklu pod „%s“, koristi se samo za javne fascikle"
+
+#: ../src/camel/camel-ews-store.c:1784
+#, c-format
+msgid "Folder does not exist"
+msgstr "Fascikla ne postoji"
+
+#: ../src/camel/camel-ews-store.c:1793
+#, c-format
+msgid "Cannot remove folder '%s', it is used for folders of other users only"
+msgstr ""
+"Ne mogu da uklonim fasciklu „%s“, koristi se samo za fascikle drugih "
+"korisnika"
+
+#: ../src/camel/camel-ews-store.c:1803
+#, c-format
+#| msgid ""
+#| "Cannot remove folder '%s', it is used for folders of other users only"
+msgid "Cannot remove folder '%s', it is used for public folders only"
+msgstr "Ne mogu da uklonim fasciklu „%s“, koristi se samo za javne fascikle"
+
+#: ../src/camel/camel-ews-store.c:1911
+#, c-format
+msgid "Folder %s does not exist"
+msgstr "Ne postoji fascikla „%s“"
+
+#: ../src/camel/camel-ews-store.c:1921
+#, c-format
+msgid "No change key record for folder %s"
+msgstr "Nema zapisa izmene ključa za fasciklu „%s“"
+
+#: ../src/camel/camel-ews-store.c:1963
+#, c-format
+msgid "Cannot both rename and move a folder at the same time"
+msgstr "Ne mogu u isto vreme da preimenujem i da premestim fasciklu"
+
+#: ../src/camel/camel-ews-store.c:1999
+#, c-format
+msgid "Cannot find folder ID for parent folder %s"
+msgstr "Ne mogu da pronađem IB fascikle za roditeljsku fasciklu „%s“"
+
+#: ../src/camel/camel-ews-store.c:2049 ../src/camel/camel-ews-transport.c:69
+#, c-format
+msgid "Exchange server %s"
+msgstr "Server razmene %s"
+
+#: ../src/camel/camel-ews-store.c:2052
+#, c-format
+msgid "Exchange service for %s on %s"
+msgstr "Usluga razmene za „%s“ na „%s“"
+
+#: ../src/camel/camel-ews-store.c:2096
+#, c-format
+msgid "Could not locate Trash folder"
+msgstr "Ne mogu da pronađem fasciklu za smeće"
+
+#: ../src/camel/camel-ews-store.c:2131
+#, c-format
+msgid "Could not locate Junk folder"
+msgstr "Ne mogu da pronađem fasciklu za đubre"
+
+#: ../src/camel/camel-ews-store.c:2321
+msgid "Cannot subscribe EWS folders in offline mode"
+msgstr "Ne mogu da pretplatim VUR fascikle u režimu van mreže"
+
+#: ../src/camel/camel-ews-store.c:2339
+#, c-format
+#| msgid "Cannot create folder '%s', folder already exists"
+msgid "Cannot subscribe folder '%s', no public folder available"
+msgstr "Ne mogu da pretplatim fasciklu „%s“, nema dostupne javne fascikle"
+
+#: ../src/camel/camel-ews-store.c:2349
+#, c-format
+#| msgid "Cannot subscribe EWS folders in offline mode"
+msgid "Cannot subscribe folder '%s', folder not found"
+msgstr "Ne mogu da pretplatim fasciklu „%s“, nisam našao fasciklu"
+
+#: ../src/camel/camel-ews-store.c:2440
+msgid "Cannot unsubscribe EWS folders in offline mode"
+msgstr "Ne mogu da poništim pretplatu VUR fascikli u režimu van mreže"
+
+#: ../src/camel/camel-ews-store.c:2557
+#, c-format
+msgid "You must be working online to complete this operation"
+msgstr "Morate da budete na mreži da biste završili ovu operaciju"
+
+#: ../src/camel/camel-ews-transport.c:72
+#, c-format
+msgid "Exchange mail delivery via %s"
+msgstr "Isporuka pošte razmene putem „%s“"
+
+#: ../src/camel/camel-ews-transport.c:119
+msgid "Cannot send message with no From address"
+msgstr "Ne mogu da pošaljem poruku bez adrese pošiljaoca"
+
+#: ../src/camel/camel-ews-transport.c:125
+msgid "Exchange server cannot send message with multiple From addresses"
+msgstr "Server razmene ne može da pošalje poruku sa nekoliko adresa pošiljaoca"
+
+#: ../src/camel/camel-ews-transport.c:136
+msgid "Failed to read From address"
+msgstr "Nisam uspeo da pročitam adresu pošiljaoca"
+
+#: ../src/camel/camel-ews-transport.c:148
+#, c-format
+msgid ""
+"Exchange server cannot send message as '%s', when the account was configured "
+"for address '%s'"
+msgstr ""
+"Server razmene ne može da pošalje poruku kao „%s“, kada je nalog podešen za "
+"adresu „%s“"
+
+#: ../src/camel/camel-ews-transport.c:162
+#, c-format
+msgid "Service not connected"
+msgstr "Usluga nije povezana"
+
+#: ../src/collection/e-ews-backend.c:428
+#: ../src/configuration/e-mail-config-ews-gal.c:274
+msgid "Global Address List"
+msgstr "Spisak opštih adresa"
+
+#: ../src/collection/e-ews-backend.c:815
+#, c-format
+msgid "Could not determine a suitable folder class for a new folder named '%s'"
+msgstr ""
+"Ne mogu da odredim odgovarajući razred fascikle za novu fasciklu pod nazivom "
+"„%s“"
+
+#: ../src/collection/e-ews-backend.c:904
+#, c-format
+msgid "Data source '%s' does not represent an Exchange Web Services folder"
+msgstr "Izvor podataka „%s“ ne predstavlja fasciklu veb usluge razmene"
+
+#: ../src/configuration/e-ews-config-utils.c:511
+#, c-format
+msgid "Cannot edit permissions of folder '%s', choose other folder."
+msgstr ""
+"Ne mogu da uredim ovlašćenja za fasciklu „%s“, izaberite drugu faljsciklu."
+
+#: ../src/configuration/e-ews-config-utils.c:589
+msgid "Subscribe to folder of other user..."
+msgstr "Prijavi se na fasciklu drugog korisnika..."
+
+#: ../src/configuration/e-ews-config-utils.c:598
+#: ../src/configuration/e-ews-config-utils.c:879
+#: ../src/configuration/e-ews-config-utils.c:910
+#: ../src/configuration/e-ews-config-utils.c:941
+#: ../src/configuration/e-ews-config-utils.c:972
+msgid "Permissions..."
+msgstr "Ovlašćenja..."
+
+#: ../src/configuration/e-ews-config-utils.c:600
+msgid "Edit EWS folder permissions"
+msgstr "Uredi ovlašćenja VUR fascikle"
+
+#: ../src/configuration/e-ews-config-utils.c:881
+msgid "Edit EWS calendar permissions"
+msgstr "Uredi ovlašćenja VUR kalendara"
+
+#: ../src/configuration/e-ews-config-utils.c:912
+msgid "Edit EWS tasks permissions"
+msgstr "Uredi ovlašćenja VUR zadataka"
+
+#: ../src/configuration/e-ews-config-utils.c:943
+msgid "Edit EWS memos permissions"
+msgstr "Uredi ovlašćenja VUR beležaka"
+
+#: ../src/configuration/e-ews-config-utils.c:974
+msgid "Edit EWS contacts permissions"
+msgstr "Uredi ovlašćenja VUR kontakata"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:87
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:499
+msgctxt "PermissionsLevel"
+msgid "None"
+msgstr "Ništa"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:88
+msgctxt "PermissionsLevel"
+msgid "Owner"
+msgstr "Vlasnik"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:98
+msgctxt "PermissionsLevel"
+msgid "Publishing Editor"
+msgstr "Uređivač objavljivanja"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:107
+msgctxt "PermissionsLevel"
+msgid "Editor"
+msgstr "Urednik"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:115
+msgctxt "PermissionsLevel"
+msgid "Publishing Author"
+msgstr "Autor objavljivanja"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:122
+msgctxt "PermissionsLevel"
+msgid "Author"
+msgstr "Autor"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:128
+msgctxt "PermissionsLevel"
+msgid "Nonediting Author"
+msgstr "Autor koji ne uređuje"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:133
+msgctxt "PermissionsLevel"
+msgid "Reviewer"
+msgstr "Pregledač"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:136
+msgctxt "PermissionsLevel"
+msgid "Contributor"
+msgstr "Saradnik"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:139
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time"
+msgstr "Vreme „slobodno/zauzeto“"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:141
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time, subject, location"
+msgstr "Vreme slobodno/zauzeto, subjekat, mesto"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:143
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:520
+msgctxt "PermissionsLevel"
+msgid "Custom"
+msgstr "Proizvoljno"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:267
+msgid "Writing folder permissions, please wait..."
+msgstr "Zapisujem ovlašćenja fascikle, molim sačekajte..."
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:759
+msgctxt "User"
+msgid "Anonymous"
+msgstr "Bezimeni"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:762
+msgctxt "User"
+msgid "Default"
+msgstr "Zadat"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:768
+msgctxt "User"
+msgid "Unknown"
+msgstr "Nepoznat"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:849
+#: ../src/configuration/e-ews-search-user.c:430
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1075
+msgid "Name"
+msgstr "Naziv"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:855
+msgid "Permission level"
+msgstr "Nivo ovlašćenja"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:907
+msgid "Edit EWS folder permissions..."
+msgstr "Uredi ovlašćenja VUR fascikle..."
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:932
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:634
+msgid "Account:"
+msgstr "Nalog:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:960
+msgid "Folder name:"
+msgstr "Naziv fascikle:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:983
+msgid "Folder ID:"
+msgstr "IB fascikle:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1047
+msgid "Permissions"
+msgstr "Ovlašćenja"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1069
+msgid "Permi_ssion level:"
+msgstr "Nivo _ovlašćenja:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1103
+msgctxt "Permissions"
+msgid "Read"
+msgstr "Čitanje"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1115
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1182
+msgctxt "Permissions"
+msgid "None"
+msgstr "Ništa"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1121
+msgctxt "Permissions"
+msgid "Free/Busy time"
+msgstr "Vreme „slobodno/zauzeto“"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1126
+msgctxt "Permissions"
+msgid "Free/Busy time, subject, location"
+msgstr "Vreme slobodno/zauzeto, subjekat, mesto"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1132
+msgctxt "Permissions"
+msgid "Full Details"
+msgstr "Potpuni detalji"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1138
+msgctxt "Permissions"
+msgid "Write"
+msgstr "Pisanje"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1150
+msgctxt "Permissions"
+msgid "Create items"
+msgstr "Pravi stavke"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1154
+msgctxt "Permissions"
+msgid "Create subfolders"
+msgstr "Pravi podfascikle"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1158
+msgctxt "Permissions"
+msgid "Edit own"
+msgstr "Uređuje svoje"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1162
+msgctxt "Permissions"
+msgid "Edit all"
+msgstr "Uređuje sve"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1170
+msgctxt "Permissions"
+msgid "Delete items"
+msgstr "Briše stavke"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1187
+msgctxt "Permissions"
+msgid "Own"
+msgstr "Svoje"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1192
+msgctxt "Permissions"
+msgid "All"
+msgstr "Sve"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1198
+msgctxt "Permissions"
+msgid "Other"
+msgstr "Drugo"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1210
+msgctxt "Permissions"
+msgid "Folder owner"
+msgstr "Vlasnik fascikle"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1214
+msgctxt "Permissions"
+msgid "Folder contact"
+msgstr "Sadržaj fascikle"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1218
+msgctxt "Permissions"
+msgid "Folder visible"
+msgstr "Fascikla je vidljiva"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1291
+msgid "Reading folder permissions, please wait..."
+msgstr "Čitam ovlašćenja fascikle, molim sačekajte..."
+
+#: ../src/configuration/e-ews-search-user.c:208
+#, c-format
+msgid "No users found, only one contact"
+msgid_plural "No users found, only %d contacts"
+msgstr[0] "Nisam pronašao korisnike, samo %d kontakt"
+msgstr[1] "Nisam pronašao korisnike, samo %d kontakta"
+msgstr[2] "Nisam pronašao korisnike, samo %d kontakata"
+msgstr[3] "Nisam pronašao korisnike, samo jedan kontakt"
+
+#: ../src/configuration/e-ews-search-user.c:213
+msgid "No users found"
+msgstr "Nisam pronašao korisnike"
+
+#: ../src/configuration/e-ews-search-user.c:217
+#, c-format
+msgid "Found one user"
+msgid_plural "Found %d users"
+msgstr[0] "Pronađoh %d korisnika"
+msgstr[1] "Pronađoh %d korisnika"
+msgstr[2] "Pronađoh %d korisnika"
+msgstr[3] "Pronađoh jednog korisnika"
+
+#: ../src/configuration/e-ews-search-user.c:223
+#, c-format
+msgid "Found more than 100 users, but showing only first %d"
+msgid_plural "Found more than 100 users, but showing only first %d"
+msgstr[0] "Nađoh više od 100 korisnika, ali prikazujem samo prvih %d"
+msgstr[1] "Nađoh više od 100 korisnika, ali prikazujem samo prva %d"
+msgstr[2] "Nađoh više od 100 korisnika, ali prikazujem samo prvih %d"
+msgstr[3] "Nađoh više od 100 korisnika, ali prikazujem samo prvog"
+
+#: ../src/configuration/e-ews-search-user.c:356
+#: ../src/configuration/e-ews-search-user.c:539
+msgid "Search for a user"
+msgstr "Potražite korisnika"
+
+#: ../src/configuration/e-ews-search-user.c:436
+msgid "E-mail"
+msgstr "El. pošta"
+
+#: ../src/configuration/e-ews-search-user.c:473
+msgid "Choose EWS user..."
+msgstr "Izaberi VUR korisnika..."
+
+#: ../src/configuration/e-ews-search-user.c:496
+msgid "_Search:"
+msgstr "_Potraži:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:97
+#: ../src/server/e-ews-folder.c:632
+#, c-format
+msgid "Cannot add folder, folder already exists as '%s'"
+msgstr "Ne mogu da dodam fasciklu, fascikla već postoji kao „%s“"
+
+#. Translators: The '%s' is replaced with user name, to whom the foreign mailbox belongs.
+#. * Example result: "Mailbox - John Smith"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:107
+#, c-format
+msgctxt "ForeignFolder"
+msgid "Mailbox - %s"
+msgstr "Poštansko sanduče — %s"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:272
+msgid "Cannot test foreign folder availability while in offline mode"
+msgstr ""
+"Ne mogu da isprobam dostupnost strane fascikle dok sam u režimu van mreže"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:297
+#, c-format
+msgid "User '%s' was not found on the server"
+msgstr "Nisam pronašao korisnika „%s“ na serveru"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:333
+#, c-format
+msgid "User name '%s' is ambiguous, specify it more precisely, please"
+msgstr "Korisničko ime „%s“ je nejasno, navedite ga malo tačnije, molim lepo"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:355
+#, c-format
+msgid ""
+"Folder '%s' not found. Either it does not exist or you do not have "
+"permission to access it."
+msgstr ""
+"Nisam pronašao fasciklu „%s“. Ili ne postoji ili vi nemate ovlašćenja da joj "
+"pristupite."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:373
+msgid "Cannot add folder, cannot determine folder's type"
+msgstr "Ne mogu da dodam fasciklu, ne mogu da odredim vrstu datoteke"
+
+#. Translators: This is used to name foreign folder.
+#. * The first '%s' is replaced with user name to whom the folder belongs,
+#. * the second '%s' is replaced with folder name.
+#. * Example result: "John Smith - Calendar"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:418
+#, c-format
+msgctxt "ForeignFolder"
+msgid "%s - %s"
+msgstr "%s — %s"
+
+#. convert well-known names to their non-localized form
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:512
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:719
+msgid "Inbox"
+msgstr "Prijemno sanduče"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:514
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:720
+msgid "Contacts"
+msgstr "Kontakti"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:516
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:721
+msgid "Calendar"
+msgstr "Kalendar"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:518
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:722
+msgid "Memos"
+msgstr "Beleške"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:520
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:723
+msgid "Tasks"
+msgstr "Zadaci"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:537
+#, c-format
+msgid "Testing availability of folder '%s' of user '%s', please wait..."
+msgstr "Isprobavam dostupnost fascikle „%s“ korisnika „%s“, molim sačekajte..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:613
+msgid "Subscribe to folder of other EWS user..."
+msgstr "Prijavi se na fasciklu drugog VUR korisnika..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:664
+msgid "User"
+msgstr "Korisnik"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:671
+msgid "_User:"
+msgstr "_Korisnik:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:686
+msgid "C_hoose..."
+msgstr "Iza_beri..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:702
+msgid "_Folder name:"
+msgstr "Naziv _fascikle:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:732
+msgid "Include _subfolders"
+msgstr "Uključi _podfascikle"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:129
+msgid "Querying Autodiscover service"
+msgstr "Propitujem uslugu samootkrivanja"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:212
+msgid "Fetch _URL"
+msgstr "Dovuci _adresu"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:140
+msgid "Configuration"
+msgstr "Podešavanje"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:158
+msgid "User_name:"
+msgstr "Korisničko _ime:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:172
+msgid "_Host URL:"
+msgstr "Adresa _domaćina:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:191
+msgid "OAB U_RL:"
+msgstr "OAB _adresa:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:205
+msgid "Open _Mailbox of other user"
+msgstr "Otvori _sanduče drugog korisnika"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:239
+msgid "S_earch..."
+msgstr "_Potraži..."
+
+#: ../src/configuration/e-mail-config-ews-backend.c:250
+msgid "Authentication"
+msgstr "Potvrđivanje identiteta"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:500
+msgctxt "PermissionsLevel"
+msgid "Reviewer (can read items)"
+msgstr "Pregledač (može da čita stavke)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:501
+msgctxt "PermissionsLevel"
+msgid "Author (can read and create items)"
+msgstr "Autor (može da čita i da stvara stavke)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:502
+msgctxt "PermissionsLevel"
+msgid "Editor (can read, create and modify items)"
+msgstr "Urednik (može da čita, stvara i menja stavke)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:605
+msgid "Delegate permissions"
+msgstr "Ovlašćenja izaslanika"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:623
+msgid "C_alendar"
+msgstr "_Kalendar"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:626
+msgid "_Delegate receives copies of meeting-related messages sent to me"
+msgstr "_Izaslanik prima primerke poruka sa sastanka poslatih meni"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:631
+msgid "_Tasks"
+msgstr "_Zadaci"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:634
+msgid "_Inbox"
+msgstr "_Sanduče"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:637
+msgid "C_ontacts"
+msgstr "_Kontakti"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:640
+msgid "_Notes"
+msgstr "_Beleške"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:643
+msgid "_Journal"
+msgstr "_Dnevnik"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:646
+#, c-format
+msgid "Delegate '%s' has the following permissions"
+msgstr "Izaslanik „%s“ ima sledeća ovlašćenja"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:664
+msgid "Delegate can see my _private items"
+msgstr "Izaslanik može da vidi moje _lične stavke"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:987
+msgid "Retrieving current user permissions, please wait..."
+msgstr "Dovlačim ovlašćenja tekućeg vlasnika, molim sačekajte..."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1108
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1638
+msgid "Delegates"
+msgstr "Izaslanici"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1132
+msgid ""
+"Delegates can send items on your behalf, including creating and responding "
+"to meeting requests. If you want to grant folder permissions without giving "
+"send-on-behalf-of permissions, close this dialog box, right-click the "
+"folder, click Permissions and change the options there."
+msgstr ""
+"Izaslanici mogu da šalju stavke u vaše ime, uključujući stvaranje i odgovaranje "
+"na pozive za sastanak. Ako želite da odobrite ovlašćenja fascikle a da ne "
+"date ovlašćenje za slanje-na-nečije-ime, zatvorite ovo prozorče, kliknite "
+"desnim tasterom miša na fasciklu, izaberite stavku Ovlašćenja i tu promenite "
+"opcije."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1181
+msgid ""
+"Deliver meeting requests addressed to me and responses to meeting requests "
+"where I am the organizer to:"
+msgstr ""
+"Isporuči zahteve za sastanak upućene meni i odgovore na zahteve za sastanak "
+"gde sam ja organizator:"
+
+#. new-line break, because GtkRadioButton doesn't allow wrapping of the inner label
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1190
+msgid ""
+"My delegates only, but _send a copy of meeting requests\n"
+"and responses to me (recommended)"
+msgstr ""
+"Samo moji izaslanici, ali meni _pošalji primerak zahteva\n"
+"za sastanak i odgovore (preporučeno)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1197
+msgid "My d_elegates only"
+msgstr "Samo _moji izaslanici"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1204
+msgid "My delegates a_nd me"
+msgstr "Moji izaslanici i _ja"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1713
+msgid "Retrieving \"Delegates\" settings"
+msgstr "Dovlačim podešavanja „Izaslanici“"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:221
+msgid "Locating offline address books"
+msgstr "Ubaci u ostavu adresar van mreže"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:301
+msgid "Cache o_ffline address book"
+msgstr "Ubaci u ostavu adresar van _mreže"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:327
+msgid "Select ad_dress list:"
+msgstr "Izaberi spisak _adresa:"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:351
+msgid "Fetch List"
+msgstr "Dovuci spisak"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:444
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:923
+msgid "Out of Office"
+msgstr "Van kancelarije"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:460
+msgid ""
+"The messages specified below will be automatically sent to each internal and "
+"external person who sends a mail to you."
+msgstr ""
+"Dole navedene poruke će biti samostalno poslate svakoj unutrašnjoj i spoljnoj "
+"osobi koja vam pošalje poruku."
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:468
+msgid "Do _not send Out of Office replies"
+msgstr "Ne _šalji odgovore za van kancelarije"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:476
+msgid "_Send Out of Office replies"
+msgstr "_Pošalji odgovore za van kancelarije"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:484
+msgid "Send Out of Office replies only _during this time period:"
+msgstr "Pošalji odgovore za van kancelarije samo za ovo _vreme:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:504
+msgid "_From:"
+msgstr "_Šalje:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:529
+msgid "_To:"
+msgstr "_Prima:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:554
+msgid "I_nternal:"
+msgstr "_Unutrašnja:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:563
+msgid "Message to be sent within the organization"
+msgstr "Poruka koja će biti poslata unutar organizacije"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:590
+msgid "E_xternal:"
+msgstr "_Spoljna:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:598
+msgid "Message to be sent outside the organization"
+msgstr "Poruka koja će biti poslata van organizacije"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:608
+msgid "Do not reply to senders outside the organization"
+msgstr "Ne odgovaraj pošiljaocima van organizacije"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:611
+msgid "Reply only to known senders outside the organization"
+msgstr "Odgovori samo poznatim pošiljaocima van organizacije"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:614
+msgid "Reply to any sender outside the organization"
+msgstr "Odgovori svim pošiljaocima van organizacije"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:999
+msgid "Retrieving \"Out of Office\" settings"
+msgstr "Dovlačim podešavanja za „van kancelarije“"
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:1
+msgid "Autodiscovery query failed."
+msgstr "Upit samootkrivanja nije uspeo."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:2
+msgid "The reported error was &quot;{0}&quot;."
+msgstr "Prijavljena greška beše „{0}“."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:3
+msgid "Failed to locate offline address books."
+msgstr "Nisam uspeo da pronađem adresare z avan mreže."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:4
+msgid "Failed to retrieve &quot;Out of Office&quot; settings."
+msgstr "Nisam uspeo da dovučem podešavanja „Van kancelarije“."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:5
+msgid "Failed to retrieve &quot;Delegates&quot; settings."
+msgstr "Nisam uspeo da dovučem podešavanja „Izaslanici“."
+
+#: ../src/server/e-ews-connection.c:493
+msgid "Operation Cancelled"
+msgstr "Radnja je otkazana"
+
+#: ../src/server/e-ews-connection.c:562
+msgid "Authentication failed"
+msgstr "Neuspešna prijava"
+
+#: ../src/server/e-ews-connection.c:573
+#, c-format
+msgid "No response: %s"
+msgstr "Nema odgovora: %s"
+
+#: ../src/server/e-ews-connection.c:1880
+#, c-format
+msgid "Failed to parse autodiscover response XML"
+msgstr "Nisam uspeo da obradim samootkrivajući odgovor IksML"
+
+#: ../src/server/e-ews-connection.c:1887
+#, c-format
+msgid "Failed to find <Autodiscover> element"
+msgstr "Nisam uspeo da pronađem element <Samootkrivanje>"
+
+#: ../src/server/e-ews-connection.c:1898
+#, c-format
+msgid "Failed to find <Response> element"
+msgstr "Nisam uspeo da pronađem element <Odgovor>"
+
+#: ../src/server/e-ews-connection.c:1909
+#, c-format
+msgid "Failed to find <Account> element"
+msgstr "Nisam uspeo da pronađem element <Nalog>"
+
+#: ../src/server/e-ews-connection.c:1928
+#, c-format
+msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
+msgstr ""
+"Nisam uspeo da pronađem <ASadresu> i <OABadresu> u odgovoru samootkrivanja"
+
+#: ../src/server/e-ews-connection.c:2010
+msgid "URL cannot be NULL"
+msgstr "Adresa ne može biti NIŠTAVNA"
+
+#: ../src/server/e-ews-connection.c:2018
+#, c-format
+msgid "URL '%s' is not valid"
+msgstr "Adresa „%s“ nije ispravna"
+
+#: ../src/server/e-ews-connection.c:2120
+msgid "Email address is missing a domain part"
+msgstr "El. pošti nedostaje deo domena"
+
+#: ../src/server/e-ews-connection.c:2432
+msgid "Failed to parse oab XML"
+msgstr "Nisam uspeo da obradim oab IksML"
+
+#: ../src/server/e-ews-connection.c:2440
+msgid "Failed to find <OAB> element\n"
+msgstr "Nisam uspeo da pronađem element <OAB>\n"
+
+#: ../src/server/e-ews-connection.c:3612
+msgid "No items found"
+msgstr "Nisam pronašao nijednu stavku"
+
+#: ../src/server/e-ews-folder.c:587
+msgid "Cannot add folder, unsupported folder type"
+msgstr "Ne mogu da dodam fasciklu, nepodržana vrsta fascikle"
+
+#: ../src/server/e-ews-folder.c:592
+msgid "Cannot add folder, master source not found"
+msgstr "Ne mogu da dodam fasciklu, nisam pronašao glavni izvor"
+
+#: ../src/utils/ews-camel-common.c:187
+#, c-format
+msgid "CreateItem call failed to return ID for new message"
+msgstr "Poziv „Napravi stavku“ nije uspeo da vrati IB za novu poruku"
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/sr.po evolution-ews.sync-with-3.8.2/po/sr.po
--- evolution-ews.git-gnome-3-0/po/sr.po	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/po/sr.po	2013-05-29 08:46:45.664988876 +0200
@@ -0,0 +1,1097 @@
+# Serbian translation of evolution-ews
+# Courtesy of Prevod.org team (http://prevod.org/) -- 2012.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the ewolution-ews package.
+# Мирослав Николић <miroslavnikolic@rocketmail.com>, 2012, 2013.
+msgid ""
+msgstr ""
+"Project-Id-Version: evolution-ews\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product"
+"=evolution-ews&keywords=I18N+L10N&component=general\n"
+"POT-Creation-Date: 2013-02-17 14:38+0000\n"
+"PO-Revision-Date: 2013-02-20 12:13+0200\n"
+"Last-Translator: Мирослав Николић <miroslavnikolic@rocketmail.com>\n"
+"Language-Team: Serbian <gnom@prevod.org>\n"
+"Language: sr\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=4; plural=n==1? 3 : n%10==1 && n%100!=11 ? 0 : "
+"n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;\n"
+"X-Project-Style: gnome\n"
+
+#: ../src/addressbook/e-book-backend-ews.c:969
+msgid "The backend does not support bulk additions"
+msgstr "Позадинац не подржава групно додавање"
+
+#: ../src/addressbook/e-book-backend-ews.c:1253
+msgid "The backend does not support bulk modifications"
+msgstr "Позадинац не подржава групно уређивање"
+
+#: ../src/addressbook/e-book-backend-ews.c:1436
+msgid "Wait till syncing is done"
+msgstr "Сачекај док се усклађивање не обави"
+
+#: ../src/addressbook/e-book-backend-ews.c:1775
+#, c-format
+msgid "Downloading contacts in %s %d%% completed... "
+msgstr "Преузимам контакте у %s, обављено је %d%%... "
+
+#: ../src/addressbook/e-book-backend-ews.c:2324
+msgid "Syncing contacts..."
+msgstr "Усаглашавам контакте..."
+
+#: ../src/addressbook/e-book-backend-ews.c:2548
+#: ../src/configuration/e-ews-search-user.c:364
+msgid "Searching..."
+msgstr "Претражујем..."
+
+#: ../src/calendar/e-cal-backend-ews.c:1009
+msgid "EWS does not support bulk removals"
+msgstr "ВУР не подржава групно уклањање"
+
+#: ../src/calendar/e-cal-backend-ews.c:1652
+msgid "EWS does not support bulk additions"
+msgstr "ВУР не подржава групно додавање"
+
+#: ../src/calendar/e-cal-backend-ews.c:2231
+msgid "EWS does not support bulk modifications"
+msgstr "ВУР не подржава групно уређивање"
+
+#: ../src/camel/camel-ews-folder.c:268
+#, c-format
+msgid "Unable to open mimecontent temporary file!"
+msgstr "Не могу да отворим привремену датотеку миме садржаја!"
+
+#: ../src/camel/camel-ews-folder.c:276
+#, c-format
+msgid "Unable to generate parser from mimecontent!"
+msgstr "Не могу да створим обрађивач из миме садржаја!"
+
+#: ../src/camel/camel-ews-folder.c:285
+#, c-format
+msgid "Unable to parse meeting request mimecontent!"
+msgstr "Не могу да обрадим миме садржај захтева за састанак!"
+
+#: ../src/camel/camel-ews-folder.c:346
+#, c-format
+msgid "Unable to create cache file"
+msgstr "Не могу да направим датотеку оставе"
+
+#: ../src/camel/camel-ews-folder.c:451 ../src/camel/camel-ews-folder.c:531
+#, c-format
+msgid "Unable to create cache path"
+msgstr "Не могу да направим путању привременог чувања"
+
+#: ../src/camel/camel-ews-folder.c:541
+#, c-format
+msgid "Failed to move message cache file"
+msgstr "Нисам успео да преместим датотеку оставе поруке"
+
+#: ../src/camel/camel-ews-folder.c:1188
+#, c-format
+msgid "Could not load summary for %s"
+msgstr "Не могу да учитам преглед за „%s“"
+
+#: ../src/camel/camel-ews-folder.c:1624
+#, c-format
+msgid "Cant perform actions on the folder while in offline mode"
+msgstr "Не могу да извршим радње над фасциклама у режиму ван мреже"
+
+#: ../src/camel/camel-ews-provider.c:48
+msgid "Checking for new mail"
+msgstr "Проверавам нову пошту"
+
+#: ../src/camel/camel-ews-provider.c:50
+msgid "C_heck for new messages in all folders"
+msgstr "П_отражи нове поруке у свим фасциклама"
+
+#: ../src/camel/camel-ews-provider.c:53
+msgid "Options"
+msgstr "Опције"
+
+#: ../src/camel/camel-ews-provider.c:55
+msgid "_Apply filters to new messages in Inbox on this server"
+msgstr "_Примени пропуснике на нове поруке у сандучету овог сервера"
+
+#: ../src/camel/camel-ews-provider.c:57
+msgid "Check new messages for _Junk contents"
+msgstr "Провери има ли _нежељених међу новим порукама"
+
+#: ../src/camel/camel-ews-provider.c:59
+msgid "Only check for Junk messages in the IN_BOX folder"
+msgstr "Провери да нема ђубрета само у фасцикли САН_ДУЧЕ"
+
+#: ../src/camel/camel-ews-provider.c:61
+msgid "Automatically synchroni_ze remote mail locally"
+msgstr "Сам усклади _удаљену пошту са локалном"
+
+#: ../src/camel/camel-ews-provider.c:64
+msgid "Connection"
+msgstr "Веза"
+
+#. Translators: '%s' is preplaced with a widget, where "
+#. * user can select how long the timeout should be.
+#: ../src/camel/camel-ews-provider.c:68
+#, c-format
+msgid "Connection _timeout (in seconds) %s"
+msgstr "Временски _истек везе (у секундама) %s"
+
+#: ../src/camel/camel-ews-provider.c:76
+msgid "Exchange Web Services"
+msgstr "Веб услуге размене"
+
+#: ../src/camel/camel-ews-provider.c:78
+msgid "For accessing Exchange servers using Web Services"
+msgstr "За приступање серверима размене употребоом веб услуга"
+
+#: ../src/camel/camel-ews-provider.c:93
+msgid "NTLM"
+msgstr "НТЛМ"
+
+#: ../src/camel/camel-ews-provider.c:95
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with NTLM authentication."
+msgstr ""
+"Ова опција ће вас повезати на сервер размене користећи лозинку обичног "
+"текста са НТЛМ потврдом идентитета."
+
+#: ../src/camel/camel-ews-provider.c:103
+msgid "Basic"
+msgstr "Основнo"
+
+#: ../src/camel/camel-ews-provider.c:105
+msgid ""
+"This option will connect to the Exchange server using a plaintext password "
+"with Basic authentication."
+msgstr ""
+"Ова опција ће вас повезати на сервер размене користећи лозинку обичног "
+"текста са основном потврдом идентитета."
+
+#: ../src/camel/camel-ews-store.c:192
+#, c-format
+msgid "Session has no storage path"
+msgstr "Сесија нема путању складишта"
+
+#: ../src/camel/camel-ews-store.c:229
+#, c-format
+#| msgctxt "ForeignFolders"
+#| msgid "%s_%d"
+msgctxt "PublicFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:358
+#, c-format
+msgctxt "ForeignFolders"
+msgid "%s_%d"
+msgstr "%s_%d"
+
+#: ../src/camel/camel-ews-store.c:688
+msgid "Updating foreign folder structure"
+msgstr "Освежавам структуру стране фасцикле"
+
+#: ../src/camel/camel-ews-store.c:973
+msgid "Authentication password not available"
+msgstr "Лозинка потврде идентитета није доступна"
+
+#: ../src/camel/camel-ews-store.c:1138
+msgid "Query for authentication types is not supported"
+msgstr "Пропитивање за врстама потврде идентитета није подржано"
+
+#: ../src/camel/camel-ews-store.c:1190
+#, c-format
+msgid "No such folder: %s"
+msgstr "Нема такве фасцикле: %s"
+
+#: ../src/camel/camel-ews-store.c:1502
+#| msgid "Cannot subscribe EWS folders in offline mode"
+msgid "Cannot list EWS public folders in offline mode"
+msgstr "Не могу да испишем ВУР јавне фасцикле у режиму ван мреже"
+
+#: ../src/camel/camel-ews-store.c:1575
+#| msgid "Cannot find folder ID for parent folder %s"
+msgid "Cannot find any EWS public folders"
+msgstr "Не могу да пронађем ВУР јавне фасцикле"
+
+#: ../src/camel/camel-ews-store.c:1680
+#, c-format
+msgid "Cannot create folder '%s', folder already exists"
+msgstr "Не могу да направим фасциклу „%s“, фасцикла већ постоји"
+
+#: ../src/camel/camel-ews-store.c:1695
+#, c-format
+msgid "Parent folder %s does not exist"
+msgstr "Не постоји родитељска фасцикла „%s“"
+
+#: ../src/camel/camel-ews-store.c:1705
+#, c-format
+msgid ""
+"Cannot create folder under '%s', it is used for folders of other users only"
+msgstr ""
+"Не могу да направим фасциклу под „%s“, користи се само за фасцикле других "
+"корисника"
+
+#: ../src/camel/camel-ews-store.c:1715
+#, c-format
+#| msgid ""
+#| "Cannot create folder under '%s', it is used for folders of other users "
+#| "only"
+msgid "Cannot create folder under '%s', it is used for public folders only"
+msgstr ""
+"Не могу да направим фасциклу под „%s“, користи се само за јавне фасцикле"
+
+#: ../src/camel/camel-ews-store.c:1784
+#, c-format
+msgid "Folder does not exist"
+msgstr "Фасцикла не постоји"
+
+#: ../src/camel/camel-ews-store.c:1793
+#, c-format
+msgid "Cannot remove folder '%s', it is used for folders of other users only"
+msgstr ""
+"Не могу да уклоним фасциклу „%s“, користи се само за фасцикле других "
+"корисника"
+
+#: ../src/camel/camel-ews-store.c:1803
+#, c-format
+#| msgid ""
+#| "Cannot remove folder '%s', it is used for folders of other users only"
+msgid "Cannot remove folder '%s', it is used for public folders only"
+msgstr "Не могу да уклоним фасциклу „%s“, користи се само за јавне фасцикле"
+
+#: ../src/camel/camel-ews-store.c:1911
+#, c-format
+msgid "Folder %s does not exist"
+msgstr "Не постоји фасцикла „%s“"
+
+#: ../src/camel/camel-ews-store.c:1921
+#, c-format
+msgid "No change key record for folder %s"
+msgstr "Нема записа измене кључа за фасциклу „%s“"
+
+#: ../src/camel/camel-ews-store.c:1963
+#, c-format
+msgid "Cannot both rename and move a folder at the same time"
+msgstr "Не могу у исто време да преименујем и да преместим фасциклу"
+
+#: ../src/camel/camel-ews-store.c:1999
+#, c-format
+msgid "Cannot find folder ID for parent folder %s"
+msgstr "Не могу да пронађем ИБ фасцикле за родитељску фасциклу „%s“"
+
+#: ../src/camel/camel-ews-store.c:2049 ../src/camel/camel-ews-transport.c:69
+#, c-format
+msgid "Exchange server %s"
+msgstr "Сервер размене %s"
+
+#: ../src/camel/camel-ews-store.c:2052
+#, c-format
+msgid "Exchange service for %s on %s"
+msgstr "Услуга размене за „%s“ на „%s“"
+
+#: ../src/camel/camel-ews-store.c:2096
+#, c-format
+msgid "Could not locate Trash folder"
+msgstr "Не могу да пронађем фасциклу за смеће"
+
+#: ../src/camel/camel-ews-store.c:2131
+#, c-format
+msgid "Could not locate Junk folder"
+msgstr "Не могу да пронађем фасциклу за ђубре"
+
+#: ../src/camel/camel-ews-store.c:2321
+msgid "Cannot subscribe EWS folders in offline mode"
+msgstr "Не могу да претплатим ВУР фасцикле у режиму ван мреже"
+
+#: ../src/camel/camel-ews-store.c:2339
+#, c-format
+#| msgid "Cannot create folder '%s', folder already exists"
+msgid "Cannot subscribe folder '%s', no public folder available"
+msgstr "Не могу да претплатим фасциклу „%s“, нема доступне јавне фасцикле"
+
+#: ../src/camel/camel-ews-store.c:2349
+#, c-format
+#| msgid "Cannot subscribe EWS folders in offline mode"
+msgid "Cannot subscribe folder '%s', folder not found"
+msgstr "Не могу да претплатим фасциклу „%s“, нисам нашао фасциклу"
+
+#: ../src/camel/camel-ews-store.c:2440
+msgid "Cannot unsubscribe EWS folders in offline mode"
+msgstr "Не могу да поништим претплату ВУР фасцикли у режиму ван мреже"
+
+#: ../src/camel/camel-ews-store.c:2557
+#, c-format
+msgid "You must be working online to complete this operation"
+msgstr "Морате да будете на мрежи да бисте завршили ову операцију"
+
+#: ../src/camel/camel-ews-transport.c:72
+#, c-format
+msgid "Exchange mail delivery via %s"
+msgstr "Испорука поште размене путем „%s“"
+
+#: ../src/camel/camel-ews-transport.c:119
+msgid "Cannot send message with no From address"
+msgstr "Не могу да пошаљем поруку без адресе пошиљаоца"
+
+#: ../src/camel/camel-ews-transport.c:125
+msgid "Exchange server cannot send message with multiple From addresses"
+msgstr "Сервер размене не може да пошаље поруку са неколико адреса пошиљаоца"
+
+#: ../src/camel/camel-ews-transport.c:136
+msgid "Failed to read From address"
+msgstr "Нисам успео да прочитам адресу пошиљаоца"
+
+#: ../src/camel/camel-ews-transport.c:148
+#, c-format
+msgid ""
+"Exchange server cannot send message as '%s', when the account was configured "
+"for address '%s'"
+msgstr ""
+"Сервер размене не може да пошаље поруку као „%s“, када је налог подешен за "
+"адресу „%s“"
+
+#: ../src/camel/camel-ews-transport.c:162
+#, c-format
+msgid "Service not connected"
+msgstr "Услуга није повезана"
+
+#: ../src/collection/e-ews-backend.c:428
+#: ../src/configuration/e-mail-config-ews-gal.c:274
+msgid "Global Address List"
+msgstr "Списак општих адреса"
+
+#: ../src/collection/e-ews-backend.c:815
+#, c-format
+msgid "Could not determine a suitable folder class for a new folder named '%s'"
+msgstr ""
+"Не могу да одредим одговарајући разред фасцикле за нову фасциклу под називом "
+"„%s“"
+
+#: ../src/collection/e-ews-backend.c:904
+#, c-format
+msgid "Data source '%s' does not represent an Exchange Web Services folder"
+msgstr "Извор података „%s“ не представља фасциклу веб услуге размене"
+
+#: ../src/configuration/e-ews-config-utils.c:511
+#, c-format
+msgid "Cannot edit permissions of folder '%s', choose other folder."
+msgstr ""
+"Не могу да уредим овлашћења за фасциклу „%s“, изаберите другу фаљсциклу."
+
+#: ../src/configuration/e-ews-config-utils.c:589
+msgid "Subscribe to folder of other user..."
+msgstr "Пријави се на фасциклу другог корисника..."
+
+#: ../src/configuration/e-ews-config-utils.c:598
+#: ../src/configuration/e-ews-config-utils.c:879
+#: ../src/configuration/e-ews-config-utils.c:910
+#: ../src/configuration/e-ews-config-utils.c:941
+#: ../src/configuration/e-ews-config-utils.c:972
+msgid "Permissions..."
+msgstr "Овлашћења..."
+
+#: ../src/configuration/e-ews-config-utils.c:600
+msgid "Edit EWS folder permissions"
+msgstr "Уреди овлашћења ВУР фасцикле"
+
+#: ../src/configuration/e-ews-config-utils.c:881
+msgid "Edit EWS calendar permissions"
+msgstr "Уреди овлашћења ВУР календара"
+
+#: ../src/configuration/e-ews-config-utils.c:912
+msgid "Edit EWS tasks permissions"
+msgstr "Уреди овлашћења ВУР задатака"
+
+#: ../src/configuration/e-ews-config-utils.c:943
+msgid "Edit EWS memos permissions"
+msgstr "Уреди овлашћења ВУР бележака"
+
+#: ../src/configuration/e-ews-config-utils.c:974
+msgid "Edit EWS contacts permissions"
+msgstr "Уреди овлашћења ВУР контаката"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:87
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:499
+msgctxt "PermissionsLevel"
+msgid "None"
+msgstr "Ништа"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:88
+msgctxt "PermissionsLevel"
+msgid "Owner"
+msgstr "Власник"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:98
+msgctxt "PermissionsLevel"
+msgid "Publishing Editor"
+msgstr "Уређивач објављивања"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:107
+msgctxt "PermissionsLevel"
+msgid "Editor"
+msgstr "Уредник"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:115
+msgctxt "PermissionsLevel"
+msgid "Publishing Author"
+msgstr "Аутор објављивања"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:122
+msgctxt "PermissionsLevel"
+msgid "Author"
+msgstr "Аутор"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:128
+msgctxt "PermissionsLevel"
+msgid "Nonediting Author"
+msgstr "Аутор који не уређује"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:133
+msgctxt "PermissionsLevel"
+msgid "Reviewer"
+msgstr "Прегледач"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:136
+msgctxt "PermissionsLevel"
+msgid "Contributor"
+msgstr "Сарадник"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:139
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time"
+msgstr "Време „слободно/заузето“"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:141
+msgctxt "PermissionsLevel"
+msgid "Free/Busy time, subject, location"
+msgstr "Време слободно/заузето, субјекат, место"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:143
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:520
+msgctxt "PermissionsLevel"
+msgid "Custom"
+msgstr "Произвољно"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:267
+msgid "Writing folder permissions, please wait..."
+msgstr "Записујем овлашћења фасцикле, молим сачекајте..."
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:759
+msgctxt "User"
+msgid "Anonymous"
+msgstr "Безимени"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:762
+msgctxt "User"
+msgid "Default"
+msgstr "Задат"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:768
+msgctxt "User"
+msgid "Unknown"
+msgstr "Непознат"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:849
+#: ../src/configuration/e-ews-search-user.c:430
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1075
+msgid "Name"
+msgstr "Назив"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:855
+msgid "Permission level"
+msgstr "Ниво овлашћења"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:907
+msgid "Edit EWS folder permissions..."
+msgstr "Уреди овлашћења ВУР фасцикле..."
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:932
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:634
+msgid "Account:"
+msgstr "Налог:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:960
+msgid "Folder name:"
+msgstr "Назив фасцикле:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:983
+msgid "Folder ID:"
+msgstr "ИБ фасцикле:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1047
+msgid "Permissions"
+msgstr "Овлашћења"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1069
+msgid "Permi_ssion level:"
+msgstr "Ниво _овлашћења:"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1103
+msgctxt "Permissions"
+msgid "Read"
+msgstr "Читање"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1115
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1182
+msgctxt "Permissions"
+msgid "None"
+msgstr "Ништа"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1121
+msgctxt "Permissions"
+msgid "Free/Busy time"
+msgstr "Време „слободно/заузето“"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1126
+msgctxt "Permissions"
+msgid "Free/Busy time, subject, location"
+msgstr "Време слободно/заузето, субјекат, место"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1132
+msgctxt "Permissions"
+msgid "Full Details"
+msgstr "Потпуни детаљи"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1138
+msgctxt "Permissions"
+msgid "Write"
+msgstr "Писање"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1150
+msgctxt "Permissions"
+msgid "Create items"
+msgstr "Прави ставке"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1154
+msgctxt "Permissions"
+msgid "Create subfolders"
+msgstr "Прави подфасцикле"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1158
+msgctxt "Permissions"
+msgid "Edit own"
+msgstr "Уређује своје"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1162
+msgctxt "Permissions"
+msgid "Edit all"
+msgstr "Уређује све"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1170
+msgctxt "Permissions"
+msgid "Delete items"
+msgstr "Брише ставке"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1187
+msgctxt "Permissions"
+msgid "Own"
+msgstr "Своје"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1192
+msgctxt "Permissions"
+msgid "All"
+msgstr "Све"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1198
+msgctxt "Permissions"
+msgid "Other"
+msgstr "Друго"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1210
+msgctxt "Permissions"
+msgid "Folder owner"
+msgstr "Власник фасцикле"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1214
+msgctxt "Permissions"
+msgid "Folder contact"
+msgstr "Садржај фасцикле"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1218
+msgctxt "Permissions"
+msgid "Folder visible"
+msgstr "Фасцикла је видљива"
+
+#: ../src/configuration/e-ews-edit-folder-permissions.c:1291
+msgid "Reading folder permissions, please wait..."
+msgstr "Читам овлашћења фасцикле, молим сачекајте..."
+
+#: ../src/configuration/e-ews-search-user.c:208
+#, c-format
+msgid "No users found, only one contact"
+msgid_plural "No users found, only %d contacts"
+msgstr[0] "Нисам пронашао кориснике, само %d контакт"
+msgstr[1] "Нисам пронашао кориснике, само %d контакта"
+msgstr[2] "Нисам пронашао кориснике, само %d контаката"
+msgstr[3] "Нисам пронашао кориснике, само један контакт"
+
+#: ../src/configuration/e-ews-search-user.c:213
+msgid "No users found"
+msgstr "Нисам пронашао кориснике"
+
+#: ../src/configuration/e-ews-search-user.c:217
+#, c-format
+msgid "Found one user"
+msgid_plural "Found %d users"
+msgstr[0] "Пронађох %d корисника"
+msgstr[1] "Пронађох %d корисника"
+msgstr[2] "Пронађох %d корисника"
+msgstr[3] "Пронађох једног корисника"
+
+#: ../src/configuration/e-ews-search-user.c:223
+#, c-format
+msgid "Found more than 100 users, but showing only first %d"
+msgid_plural "Found more than 100 users, but showing only first %d"
+msgstr[0] "Нађох више од 100 корисника, али приказујем само првих %d"
+msgstr[1] "Нађох више од 100 корисника, али приказујем само прва %d"
+msgstr[2] "Нађох више од 100 корисника, али приказујем само првих %d"
+msgstr[3] "Нађох више од 100 корисника, али приказујем само првог"
+
+#: ../src/configuration/e-ews-search-user.c:356
+#: ../src/configuration/e-ews-search-user.c:539
+msgid "Search for a user"
+msgstr "Потражите корисника"
+
+#: ../src/configuration/e-ews-search-user.c:436
+msgid "E-mail"
+msgstr "Ел. пошта"
+
+#: ../src/configuration/e-ews-search-user.c:473
+msgid "Choose EWS user..."
+msgstr "Изабери ВУР корисника..."
+
+#: ../src/configuration/e-ews-search-user.c:496
+msgid "_Search:"
+msgstr "_Потражи:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:97
+#: ../src/server/e-ews-folder.c:632
+#, c-format
+msgid "Cannot add folder, folder already exists as '%s'"
+msgstr "Не могу да додам фасциклу, фасцикла већ постоји као „%s“"
+
+#. Translators: The '%s' is replaced with user name, to whom the foreign mailbox belongs.
+#. * Example result: "Mailbox - John Smith"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:107
+#, c-format
+msgctxt "ForeignFolder"
+msgid "Mailbox - %s"
+msgstr "Поштанско сандуче — %s"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:272
+msgid "Cannot test foreign folder availability while in offline mode"
+msgstr ""
+"Не могу да испробам доступност стране фасцикле док сам у режиму ван мреже"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:297
+#, c-format
+msgid "User '%s' was not found on the server"
+msgstr "Нисам пронашао корисника „%s“ на серверу"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:333
+#, c-format
+msgid "User name '%s' is ambiguous, specify it more precisely, please"
+msgstr "Корисничко име „%s“ је нејасно, наведите га мало тачније, молим лепо"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:355
+#, c-format
+msgid ""
+"Folder '%s' not found. Either it does not exist or you do not have "
+"permission to access it."
+msgstr ""
+"Нисам пронашао фасциклу „%s“. Или не постоји или ви немате овлашћења да јој "
+"приступите."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:373
+msgid "Cannot add folder, cannot determine folder's type"
+msgstr "Не могу да додам фасциклу, не могу да одредим врсту датотеке"
+
+#. Translators: This is used to name foreign folder.
+#. * The first '%s' is replaced with user name to whom the folder belongs,
+#. * the second '%s' is replaced with folder name.
+#. * Example result: "John Smith - Calendar"
+#.
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:418
+#, c-format
+msgctxt "ForeignFolder"
+msgid "%s - %s"
+msgstr "%s — %s"
+
+#. convert well-known names to their non-localized form
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:512
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:719
+msgid "Inbox"
+msgstr "Пријемно сандуче"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:514
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:720
+msgid "Contacts"
+msgstr "Контакти"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:516
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:721
+msgid "Calendar"
+msgstr "Календар"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:518
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:722
+msgid "Memos"
+msgstr "Белешке"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:520
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:723
+msgid "Tasks"
+msgstr "Задаци"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:537
+#, c-format
+msgid "Testing availability of folder '%s' of user '%s', please wait..."
+msgstr "Испробавам доступност фасцикле „%s“ корисника „%s“, молим сачекајте..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:613
+msgid "Subscribe to folder of other EWS user..."
+msgstr "Пријави се на фасциклу другог ВУР корисника..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:664
+msgid "User"
+msgstr "Корисник"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:671
+msgid "_User:"
+msgstr "_Корисник:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:686
+msgid "C_hoose..."
+msgstr "Иза_бери..."
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:702
+msgid "_Folder name:"
+msgstr "Назив _фасцикле:"
+
+#: ../src/configuration/e-ews-subscribe-foreign-folder.c:732
+msgid "Include _subfolders"
+msgstr "Укључи _подфасцикле"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:129
+msgid "Querying Autodiscover service"
+msgstr "Пропитујем услугу самооткривања"
+
+#: ../src/configuration/e-mail-config-ews-autodiscover.c:212
+msgid "Fetch _URL"
+msgstr "Довуци _адресу"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:140
+msgid "Configuration"
+msgstr "Подешавање"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:158
+msgid "User_name:"
+msgstr "Корисничко _име:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:172
+msgid "_Host URL:"
+msgstr "Адреса _домаћина:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:191
+msgid "OAB U_RL:"
+msgstr "ОАБ _адреса:"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:205
+msgid "Open _Mailbox of other user"
+msgstr "Отвори _сандуче другог корисника"
+
+#: ../src/configuration/e-mail-config-ews-backend.c:239
+msgid "S_earch..."
+msgstr "_Потражи..."
+
+#: ../src/configuration/e-mail-config-ews-backend.c:250
+msgid "Authentication"
+msgstr "Потврђивање идентитета"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:500
+msgctxt "PermissionsLevel"
+msgid "Reviewer (can read items)"
+msgstr "Прегледач (може да чита ставке)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:501
+msgctxt "PermissionsLevel"
+msgid "Author (can read and create items)"
+msgstr "Аутор (може да чита и да ствара ставке)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:502
+msgctxt "PermissionsLevel"
+msgid "Editor (can read, create and modify items)"
+msgstr "Уредник (може да чита, ствара и мења ставке)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:605
+msgid "Delegate permissions"
+msgstr "Овлашћења изасланика"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:623
+msgid "C_alendar"
+msgstr "_Календар"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:626
+msgid "_Delegate receives copies of meeting-related messages sent to me"
+msgstr "_Изасланик прима примерке порука са састанка послатих мени"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:631
+msgid "_Tasks"
+msgstr "_Задаци"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:634
+msgid "_Inbox"
+msgstr "_Сандуче"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:637
+msgid "C_ontacts"
+msgstr "_Контакти"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:640
+msgid "_Notes"
+msgstr "_Белешке"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:643
+msgid "_Journal"
+msgstr "_Дневник"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:646
+#, c-format
+msgid "Delegate '%s' has the following permissions"
+msgstr "Изасланик „%s“ има следећа овлашћења"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:664
+msgid "Delegate can see my _private items"
+msgstr "Изасланик може да види моје _личне ставке"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:987
+msgid "Retrieving current user permissions, please wait..."
+msgstr "Довлачим овлашћења текућег власника, молим сачекајте..."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1108
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1638
+msgid "Delegates"
+msgstr "Изасланици"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1132
+msgid ""
+"Delegates can send items on your behalf, including creating and responding "
+"to meeting requests. If you want to grant folder permissions without giving "
+"send-on-behalf-of permissions, close this dialog box, right-click the "
+"folder, click Permissions and change the options there."
+msgstr ""
+"Изасланици могу да шаљу ставке у ваше име, укључујући стварање и одговарање "
+"на позиве за састанак. Ако желите да одобрите овлашћења фасцикле а да не "
+"дате овлашћење за слање-на-нечије-име, затворите ово прозорче, кликните "
+"десним тастером миша на фасциклу, изаберите ставку Овлашћења и ту промените "
+"опције."
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1181
+msgid ""
+"Deliver meeting requests addressed to me and responses to meeting requests "
+"where I am the organizer to:"
+msgstr ""
+"Испоручи захтеве за састанак упућене мени и одговоре на захтеве за састанак "
+"где сам ја организатор:"
+
+#. new-line break, because GtkRadioButton doesn't allow wrapping of the inner label
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1190
+msgid ""
+"My delegates only, but _send a copy of meeting requests\n"
+"and responses to me (recommended)"
+msgstr ""
+"Само моји изасланици, али мени _пошаљи примерак захтева\n"
+"за састанак и одговоре (препоручено)"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1197
+msgid "My d_elegates only"
+msgstr "Само _моји изасланици"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1204
+msgid "My delegates a_nd me"
+msgstr "Моји изасланици и _ја"
+
+#: ../src/configuration/e-mail-config-ews-delegates-page.c:1713
+msgid "Retrieving \"Delegates\" settings"
+msgstr "Довлачим подешавања „Изасланици“"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:221
+msgid "Locating offline address books"
+msgstr "Убаци у оставу адресар ван мреже"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:301
+msgid "Cache o_ffline address book"
+msgstr "Убаци у оставу адресар ван _мреже"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:327
+msgid "Select ad_dress list:"
+msgstr "Изабери списак _адреса:"
+
+#: ../src/configuration/e-mail-config-ews-gal.c:351
+msgid "Fetch List"
+msgstr "Довуци списак"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:444
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:923
+msgid "Out of Office"
+msgstr "Ван канцеларије"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:460
+msgid ""
+"The messages specified below will be automatically sent to each internal and "
+"external person who sends a mail to you."
+msgstr ""
+"Доле наведене поруке ће бити самостално послате свакој унутрашњој и спољној "
+"особи која вам пошаље поруку."
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:468
+msgid "Do _not send Out of Office replies"
+msgstr "Не _шаљи одговоре за ван канцеларије"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:476
+msgid "_Send Out of Office replies"
+msgstr "_Пошаљи одговоре за ван канцеларије"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:484
+msgid "Send Out of Office replies only _during this time period:"
+msgstr "Пошаљи одговоре за ван канцеларије само за ово _време:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:504
+msgid "_From:"
+msgstr "_Шаље:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:529
+msgid "_To:"
+msgstr "_Прима:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:554
+msgid "I_nternal:"
+msgstr "_Унутрашња:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:563
+msgid "Message to be sent within the organization"
+msgstr "Порука која ће бити послата унутар организације"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:590
+msgid "E_xternal:"
+msgstr "_Спољна:"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:598
+msgid "Message to be sent outside the organization"
+msgstr "Порука која ће бити послата ван организације"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:608
+msgid "Do not reply to senders outside the organization"
+msgstr "Не одговарај пошиљаоцима ван организације"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:611
+msgid "Reply only to known senders outside the organization"
+msgstr "Одговори само познатим пошиљаоцима ван организације"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:614
+msgid "Reply to any sender outside the organization"
+msgstr "Одговори свим пошиљаоцима ван организације"
+
+#: ../src/configuration/e-mail-config-ews-ooo-page.c:999
+msgid "Retrieving \"Out of Office\" settings"
+msgstr "Довлачим подешавања за „ван канцеларије“"
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:1
+msgid "Autodiscovery query failed."
+msgstr "Упит самооткривања није успео."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:2
+msgid "The reported error was &quot;{0}&quot;."
+msgstr "Пријављена грешка беше „{0}“."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:3
+msgid "Failed to locate offline address books."
+msgstr "Нисам успео да пронађем адресаре з аван мреже."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:4
+msgid "Failed to retrieve &quot;Out of Office&quot; settings."
+msgstr "Нисам успео да довучем подешавања „Ван канцеларије“."
+
+#: ../src/configuration/module-ews-configuration.error.xml.h:5
+msgid "Failed to retrieve &quot;Delegates&quot; settings."
+msgstr "Нисам успео да довучем подешавања „Изасланици“."
+
+#: ../src/server/e-ews-connection.c:493
+msgid "Operation Cancelled"
+msgstr "Радња је отказана"
+
+#: ../src/server/e-ews-connection.c:562
+msgid "Authentication failed"
+msgstr "Неуспешна пријава"
+
+#: ../src/server/e-ews-connection.c:573
+#, c-format
+msgid "No response: %s"
+msgstr "Нема одговора: %s"
+
+#: ../src/server/e-ews-connection.c:1880
+#, c-format
+msgid "Failed to parse autodiscover response XML"
+msgstr "Нисам успео да обрадим самооткривајући одговор ИксМЛ"
+
+#: ../src/server/e-ews-connection.c:1887
+#, c-format
+msgid "Failed to find <Autodiscover> element"
+msgstr "Нисам успео да пронађем елемент <Самооткривање>"
+
+#: ../src/server/e-ews-connection.c:1898
+#, c-format
+msgid "Failed to find <Response> element"
+msgstr "Нисам успео да пронађем елемент <Одговор>"
+
+#: ../src/server/e-ews-connection.c:1909
+#, c-format
+msgid "Failed to find <Account> element"
+msgstr "Нисам успео да пронађем елемент <Налог>"
+
+#: ../src/server/e-ews-connection.c:1928
+#, c-format
+msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
+msgstr ""
+"Нисам успео да пронађем <АСадресу> и <ОАБадресу> у одговору самооткривања"
+
+#: ../src/server/e-ews-connection.c:2010
+msgid "URL cannot be NULL"
+msgstr "Адреса не може бити НИШТАВНА"
+
+#: ../src/server/e-ews-connection.c:2018
+#, c-format
+msgid "URL '%s' is not valid"
+msgstr "Адреса „%s“ није исправна"
+
+#: ../src/server/e-ews-connection.c:2120
+msgid "Email address is missing a domain part"
+msgstr "Ел. пошти недостаје део домена"
+
+#: ../src/server/e-ews-connection.c:2432
+msgid "Failed to parse oab XML"
+msgstr "Нисам успео да обрадим оаб ИксМЛ"
+
+#: ../src/server/e-ews-connection.c:2440
+msgid "Failed to find <OAB> element\n"
+msgstr "Нисам успео да пронађем елемент <ОАБ>\n"
+
+#: ../src/server/e-ews-connection.c:3612
+msgid "No items found"
+msgstr "Нисам пронашао ниједну ставку"
+
+#: ../src/server/e-ews-folder.c:587
+msgid "Cannot add folder, unsupported folder type"
+msgstr "Не могу да додам фасциклу, неподржана врста фасцикле"
+
+#: ../src/server/e-ews-folder.c:592
+msgid "Cannot add folder, master source not found"
+msgstr "Не могу да додам фасциклу, нисам пронашао главни извор"
+
+#: ../src/utils/ews-camel-common.c:187
+#, c-format
+msgid "CreateItem call failed to return ID for new message"
+msgstr "Позив „Направи ставку“ није успео да врати ИБ за нову поруку"
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/sv.po evolution-ews.sync-with-3.8.2/po/sv.po
--- evolution-ews.git-gnome-3-0/po/sv.po	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/po/sv.po	2013-05-29 08:46:45.664988876 +0200
@@ -0,0 +1,435 @@
+# Swedish translation for evolution-ews.
+# Copyright (C) 2012 Free Software Foundation, Inc.
+# This file is distributed under the same license as the evolution-ews package.
+# Daniel Nylander <po@danielnylander.se>, 2012.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: evolution-ews\n"
+"Report-Msgid-Bugs-To: \n"
+"POT-Creation-Date: 2012-02-28 08:48+0100\n"
+"PO-Revision-Date: 2012-02-28 08:51+0100\n"
+"Last-Translator: Daniel Nylander <po@danielnylander.se>\n"
+"Language-Team: Swedish <tp-sv@listor.tp-sv.se>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-listener.c:241
+msgid "Global Address list"
+msgstr "Global adresslista"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:177
+msgid "Select a valid time range"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:286
+#, c-format
+msgid ""
+"Unable to fetch out of office settings: \n"
+"%s"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:318
+msgid ""
+"The messages specified below will be automatically sent to \n"
+" each internal and external personal who sends a mail to you."
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:323
+msgid "Status:"
+msgstr "Status:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:328
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:333
+msgid "I am _out of the office"
+msgstr "Jag är _inte på kontoret"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:329
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:332
+msgid "I am _in the office"
+msgstr "Jag är _på kontoret"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:354
+msgid "_From:"
+msgstr "_Från:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:359
+msgid "_To:"
+msgstr "_Till:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:376
+msgid "I_nternal:"
+msgstr "I_ntern:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:378
+msgid "Message to be sent inside organization"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:385
+msgid "None"
+msgstr "Ingen"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:386
+msgid "Known"
+msgstr "Kända"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:387
+msgid "All"
+msgstr "Alla"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:389
+msgid "Send Message to"
+msgstr "Skicka meddelande till"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:409
+msgid "E_xternal:"
+msgstr "E_xtern:"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:411
+msgid "Message to be sent outside organization"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:575
+msgid "Out of Office"
+msgstr "Inte på kontoret"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-out-of-office.c:581
+msgid "Fetching out of office settings..."
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:111
+#, c-format
+msgid "Autodiscover failed: %s"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:154
+#, c-format
+msgid "Enter Password for %s"
+msgstr "Ange lösenord för %s"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:163
+msgid "Could not get password."
+msgstr ""
+
+#. OAB url entry
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:286
+msgid "OAB U_RL:"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:298
+msgid "_Host URL:"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:313
+msgid "Fetch _URL"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:478
+msgid "Could not fetch oal list: "
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:524
+msgid "Fetching..."
+msgstr "Hämtar..."
+
+#. Add cache check box
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:661
+msgid "Cache o_ffline address book"
+msgstr ""
+
+#. Add label
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:667
+msgid "Select Ad_dress list: "
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:677
+msgid "Fetch _list"
+msgstr ""
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:764
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:3
+msgid "EWS Settings"
+msgstr ""
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:1
+#: ../src/camel/camel-ews-provider.c:69
+msgid "Exchange Web Services"
+msgstr ""
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:2
+msgid "GAL settings"
+msgstr ""
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:4
+msgid "Exchange Web Services Plugin"
+msgstr ""
+
+#: ../src/addressbook/e-book-backend-ews.c:901
+msgid "The backend does not support bulk additions"
+msgstr ""
+
+#: ../src/addressbook/e-book-backend-ews.c:1172
+msgid "The backend does not support bulk modifications"
+msgstr ""
+
+#: ../src/addressbook/e-book-backend-ews.c:1346
+msgid "Wait till syncing is done"
+msgstr ""
+
+#: ../src/addressbook/e-book-backend-ews.c:1665
+#, c-format
+msgid "Downloading contacts in %s %d%% completed... "
+msgstr ""
+
+#: ../src/addressbook/e-book-backend-ews.c:2159
+msgid "Syncing contacts..."
+msgstr "Synkroniserar kontakter..."
+
+#: ../src/addressbook/e-book-backend-ews.c:2358
+msgid "Searching..."
+msgstr "Söker..."
+
+#: ../src/addressbook/e-book-backend-sqlitedb.c:474
+#, c-format
+msgid "Insufficient memory"
+msgstr ""
+
+#: ../src/camel/camel-ews-folder.c:262
+#, c-format
+msgid "Unable to open mimecontent temporary file!"
+msgstr ""
+
+#: ../src/camel/camel-ews-folder.c:269
+#, c-format
+msgid "Unable to generate parser from mimecontent!"
+msgstr ""
+
+#: ../src/camel/camel-ews-folder.c:278
+#, c-format
+msgid "Unable to parse meeting request mimecontent!"
+msgstr ""
+
+#: ../src/camel/camel-ews-folder.c:335
+#, c-format
+msgid "Unable to create cache file"
+msgstr ""
+
+#: ../src/camel/camel-ews-folder.c:436
+#: ../src/camel/camel-ews-folder.c:505
+#, c-format
+msgid "Unable to create cache path"
+msgstr ""
+
+#: ../src/camel/camel-ews-folder.c:514
+#, c-format
+msgid "Failed to move message cache file"
+msgstr ""
+
+#: ../src/camel/camel-ews-folder.c:917
+#, c-format
+msgid "Could not load summary for %s"
+msgstr ""
+
+#: ../src/camel/camel-ews-folder.c:1258
+#: ../src/camel/camel-ews-store.c:757
+#: ../src/camel/camel-ews-store.c:813
+#: ../src/camel/camel-ews-store.c:883
+#, c-format
+msgid "Cant perform actions on the folder while in offline mode"
+msgstr ""
+
+#: ../src/camel/camel-ews-provider.c:48
+msgid "Checking for new mail"
+msgstr ""
+
+#: ../src/camel/camel-ews-provider.c:50
+msgid "C_heck for new messages in all folders"
+msgstr ""
+
+#: ../src/camel/camel-ews-provider.c:53
+msgid "Options"
+msgstr "Alternativ"
+
+#: ../src/camel/camel-ews-provider.c:55
+msgid "_Apply filters to new messages in Inbox on this server"
+msgstr ""
+
+#: ../src/camel/camel-ews-provider.c:57
+msgid "Check new messages for _Junk contents"
+msgstr ""
+
+#: ../src/camel/camel-ews-provider.c:59
+msgid "Only check for Junk messages in the IN_BOX folder"
+msgstr ""
+
+#: ../src/camel/camel-ews-provider.c:61
+msgid "Automatically synchroni_ze remote mail locally"
+msgstr ""
+
+#: ../src/camel/camel-ews-provider.c:71
+msgid "For accessing Exchange servers using Web Services"
+msgstr ""
+
+#: ../src/camel/camel-ews-provider.c:87
+msgid "Password"
+msgstr "Lösenord"
+
+#: ../src/camel/camel-ews-provider.c:89
+msgid "This option will connect to the Exchange server using a plaintext password."
+msgstr ""
+
+#: ../src/camel/camel-ews-store.c:184
+#, c-format
+msgid "Session has no storage path"
+msgstr ""
+
+#: ../src/camel/camel-ews-store.c:554
+#, c-format
+msgid "No such folder: %s"
+msgstr ""
+
+#: ../src/camel/camel-ews-store.c:750
+#, c-format
+msgid "Parent folder %s does not exist"
+msgstr ""
+
+#: ../src/camel/camel-ews-store.c:807
+#, c-format
+msgid "Folder does not exist"
+msgstr ""
+
+#: ../src/camel/camel-ews-store.c:891
+#, c-format
+msgid "Folder %s does not exist"
+msgstr ""
+
+#: ../src/camel/camel-ews-store.c:900
+#, c-format
+msgid "No change key record for folder %s"
+msgstr ""
+
+#: ../src/camel/camel-ews-store.c:939
+#, c-format
+msgid "Cannot both rename and move a folder at the same time"
+msgstr ""
+
+#: ../src/camel/camel-ews-store.c:970
+#, c-format
+msgid "Cannot find folder ID for parent folder %s"
+msgstr ""
+
+#: ../src/camel/camel-ews-store.c:1007
+#: ../src/camel/camel-ews-transport.c:66
+#, c-format
+msgid "Exchange server %s"
+msgstr ""
+
+#: ../src/camel/camel-ews-store.c:1009
+#, c-format
+msgid "Exchange service for %s on %s"
+msgstr ""
+
+#: ../src/camel/camel-ews-store.c:1049
+#, c-format
+msgid "You must be working online to complete this operation"
+msgstr ""
+
+#: ../src/camel/camel-ews-transport.c:69
+#, c-format
+msgid "Exchange mail delivery via %s"
+msgstr ""
+
+#: ../src/camel/camel-ews-transport.c:106
+msgid "Cannot send message with no From address"
+msgstr ""
+
+#: ../src/camel/camel-ews-transport.c:110
+msgid "Exchange server cannot send message with multiple From addresses"
+msgstr ""
+
+#: ../src/camel/camel-ews-transport.c:118
+msgid "Failed to read From address"
+msgstr ""
+
+#: ../src/camel/camel-ews-transport.c:124
+#, c-format
+msgid "Exchange server cannot send message as '%s', when the account was configured for address '%s'"
+msgstr ""
+
+#: ../src/camel/camel-ews-transport.c:135
+#, c-format
+msgid "Service not connected"
+msgstr ""
+
+#: ../src/server/e-ews-connection.c:360
+msgid "Operation Cancelled"
+msgstr ""
+
+#: ../src/server/e-ews-connection.c:422
+msgid "Authentication failed"
+msgstr ""
+
+#: ../src/server/e-ews-connection.c:430
+#, c-format
+msgid "No response: %s"
+msgstr "Inget svar: %s"
+
+#: ../src/server/e-ews-connection.c:1276
+#: ../src/server/e-ews-connection.c:1634
+#: ../src/server/e-ews-connection.c:1873
+#, c-format
+msgid "Code: %d - Unexpected response from server"
+msgstr ""
+
+#: ../src/server/e-ews-connection.c:1288
+#, c-format
+msgid "Failed to parse autodiscover response XML"
+msgstr ""
+
+#: ../src/server/e-ews-connection.c:1296
+#, c-format
+msgid "Failed to find <Autodiscover> element\n"
+msgstr ""
+
+#: ../src/server/e-ews-connection.c:1308
+#, c-format
+msgid "Failed to find <Response> element\n"
+msgstr ""
+
+#: ../src/server/e-ews-connection.c:1320
+#, c-format
+msgid "Failed to find <Account> element\n"
+msgstr ""
+
+#: ../src/server/e-ews-connection.c:1339
+#, c-format
+msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
+msgstr ""
+
+#: ../src/server/e-ews-connection.c:1441
+#, c-format
+msgid "Both email and password must be provided"
+msgstr ""
+
+#: ../src/server/e-ews-connection.c:1448
+#, c-format
+msgid "Wrong email id"
+msgstr ""
+
+#: ../src/server/e-ews-connection.c:1644
+#, c-format
+msgid "Failed to parse oab XML"
+msgstr ""
+
+#: ../src/server/e-ews-connection.c:1651
+#, c-format
+msgid "Failed to find <OAB> element\n"
+msgstr ""
+
+#: ../src/utils/ews-camel-common.c:170
+#, c-format
+msgid "CreateItem call failed to return ID for new message"
+msgstr ""
+
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/po/zh_CN.po evolution-ews.sync-with-3.8.2/po/zh_CN.po
--- evolution-ews.git-gnome-3-0/po/zh_CN.po	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/po/zh_CN.po	2013-05-29 08:46:45.665987863 +0200
@@ -0,0 +1,331 @@
+# Chinese (China) translation for evolution-ews.
+# Copyright (C) 2011 evolution-ews's COPYRIGHT HOLDER
+# This file is distributed under the same license as the evolution-ews package.
+# Wylmer Wang <wantinghard@gmail.com>, 2011.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: evolution-ews master\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
+"product=evolution-ews&keywords=I18N+L10N&component=general\n"
+"POT-Creation-Date: 2011-11-24 11:14+0000\n"
+"PO-Revision-Date: 2011-10-28 10:43+0000\n"
+"Last-Translator: Wylmer Wang <wantinghard@gmail.com>\n"
+"Language-Team: Chinese (China) <i18n-zh@googlegroups.com>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-listener.c:240
+msgid "Global Address list"
+msgstr "全局地址列表"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:104
+#, c-format
+msgid "Autodiscover failed: %s"
+msgstr "自动发现失败：%s"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:147
+#, c-format
+msgid "Enter Password for %s"
+msgstr "输入 %s 的密码"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:156
+msgid "Could not get password."
+msgstr "无法获得密码。"
+
+#. OAB url entry
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:270
+msgid "OAB U_RL:"
+msgstr "OAB U_RL："
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:282
+msgid "_Host URL:"
+msgstr "主机 URL(_H)："
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:297
+msgid "Fetch _URL"
+msgstr "获取 _URL"
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:457
+msgid "Could not fetch oal list: "
+msgstr "无法获取 oal 列表："
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:502
+msgid "Fetching..."
+msgstr "正在获取..."
+
+#. Add cache check box
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:631
+msgid "Cache o_ffline address book"
+msgstr "缓存离线地址薄(oab)(_F)"
+
+#. Add label
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:637
+msgid "Select Ad_dress list: "
+msgstr "选择地址列表(_D)："
+
+#: ../src/account-setup-eplugin/exchange-ews-account-setup.c:647
+msgid "Fetch _list"
+msgstr "获取列表(_L)"
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:1
+#: ../src/camel/camel-ews-provider.c:69
+msgid "Exchange Web Services"
+msgstr "Exchange 网络服务"
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:2
+msgid "Exchange Web Services Plugin"
+msgstr "Exchange 网络服务插件"
+
+#: ../src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml.h:3
+msgid "GAL settings"
+msgstr "GAL 设置"
+
+#: ../src/addressbook/e-book-backend-ews.c:827
+msgid "The backend does not support bulk additions"
+msgstr "后端不支持批量添加"
+
+#: ../src/addressbook/e-book-backend-ews.c:1094
+msgid "The backend does not support bulk modifications"
+msgstr "后端不支持批量修改"
+
+#: ../src/addressbook/e-book-backend-ews.c:1494
+#, c-format
+msgid "Downloading contacts in %s %d%% completed... "
+msgstr "正在下载 %s 中的联系人，已完成 %d%%..."
+
+#: ../src/addressbook/e-book-backend-ews.c:1884
+msgid "Syncing contacts..."
+msgstr "正在同步联系人..."
+
+#: ../src/addressbook/e-book-backend-ews.c:2080
+msgid "Searching..."
+msgstr "正在搜索..."
+
+#: ../src/addressbook/e-book-backend-sqlitedb.c:470
+#, c-format
+msgid "Insufficient memory"
+msgstr "内存不足"
+
+#: ../src/calendar/e-cal-backend-ews.c:3526
+#, c-format
+msgid "Unknown calendar property '%s'"
+msgstr "未知的日历属性“%s”"
+
+#: ../src/camel/camel-ews-folder.c:255
+#, c-format
+msgid "Unable to open mimecontent temporary file!"
+msgstr "无法打开 mimecontent 临时文件！"
+
+#: ../src/camel/camel-ews-folder.c:262
+#, c-format
+msgid "Unable to generate parser from mimecontent!"
+msgstr "无法由 mimecontent 生成解析器！"
+
+#: ../src/camel/camel-ews-folder.c:271
+#, fuzzy, c-format
+msgid "Unable to parse meeting request mimecontent!"
+msgstr "无法解析符合要求的 mimecontent！"
+
+#: ../src/camel/camel-ews-folder.c:328
+#, c-format
+msgid "Unable to create cache file"
+msgstr "无法创建缓存文件"
+
+#: ../src/camel/camel-ews-folder.c:425 ../src/camel/camel-ews-folder.c:494
+#, c-format
+msgid "Unable to create cache path"
+msgstr "无法创建缓存路径"
+
+#: ../src/camel/camel-ews-folder.c:503
+#, c-format
+msgid "Failed to move message cache file"
+msgstr "无法移动信息缓存文件"
+
+#: ../src/camel/camel-ews-folder.c:876
+#, c-format
+msgid "Could not load summary for %s"
+msgstr "无法加载 %s 汇总"
+
+#: ../src/camel/camel-ews-folder.c:1205 ../src/camel/camel-ews-store.c:641
+#: ../src/camel/camel-ews-store.c:697 ../src/camel/camel-ews-store.c:765
+#, c-format
+msgid "Cant perform actions on the folder while in offline mode"
+msgstr "离线模式时不能对该文件夹执行操作"
+
+#: ../src/camel/camel-ews-provider.c:48
+msgid "Checking for new mail"
+msgstr "正在检查新邮件"
+
+#: ../src/camel/camel-ews-provider.c:50
+msgid "C_heck for new messages in all folders"
+msgstr "检查所有文件夹中的新信息(_H)"
+
+#: ../src/camel/camel-ews-provider.c:53
+msgid "Options"
+msgstr "选项"
+
+#: ../src/camel/camel-ews-provider.c:55
+msgid "_Apply filters to new messages in Inbox on this server"
+msgstr "对此服务器上收件箱中的新信息应用过滤器(_A)"
+
+#: ../src/camel/camel-ews-provider.c:57
+msgid "Check new messages for Jun_k contents"
+msgstr "检查新信息中的垃圾内容(_K)"
+
+#: ../src/camel/camel-ews-provider.c:59
+msgid "Only check for Junk messages in the IN_BOX folder"
+msgstr "只在收件箱文件夹中检查垃圾信息(_B)"
+
+#: ../src/camel/camel-ews-provider.c:61
+msgid "Automatically synchroni_ze remote mail locally"
+msgstr "自动将远程邮件同步到本地(_Z)"
+
+#: ../src/camel/camel-ews-provider.c:71
+#, fuzzy
+msgid "For accessing Exchange servers using Web Services"
+msgstr "对于使用网络服务进行的 Exchange 服务器访问"
+
+#: ../src/camel/camel-ews-provider.c:87
+msgid "Password"
+msgstr "密码"
+
+#: ../src/camel/camel-ews-provider.c:89
+msgid ""
+"This option will connect to the Exchange server using a plaintext password."
+msgstr "该选项将使用未加密密码连接 Exchange 服务器。"
+
+#: ../src/camel/camel-ews-store.c:183
+#, c-format
+msgid "Session has no storage path"
+msgstr "会话没有存储路径"
+
+#: ../src/camel/camel-ews-store.c:445
+#, c-format
+msgid "No such folder: %s"
+msgstr "无此文件夹：%s"
+
+#: ../src/camel/camel-ews-store.c:634
+#, c-format
+msgid "Parent folder %s does not exist"
+msgstr "上级文件夹 %s 不存在"
+
+#: ../src/camel/camel-ews-store.c:691
+#, c-format
+msgid "Folder does not exist"
+msgstr "文件夹不存在"
+
+#: ../src/camel/camel-ews-store.c:773
+#, c-format
+msgid "Folder %s does not exist"
+msgstr "文件夹 %s 不存在"
+
+#: ../src/camel/camel-ews-store.c:782
+#, c-format
+msgid "No change key record for folder %s"
+msgstr "没有文件夹 %s 的更改密钥记录"
+
+#: ../src/camel/camel-ews-store.c:821
+#, c-format
+msgid "Cannot both rename and move a folder at the same time"
+msgstr "不能同时重命名和移动一个文件夹"
+
+#: ../src/camel/camel-ews-store.c:852
+#, c-format
+msgid "Cannot find folder ID for parent folder %s"
+msgstr "无法找到上级文件夹 %s 的文件夹 ID"
+
+#: ../src/camel/camel-ews-store.c:888 ../src/camel/camel-ews-transport.c:66
+#, c-format
+msgid "Exchange server %s"
+msgstr "Exchange 服务器 %s"
+
+#: ../src/camel/camel-ews-store.c:890
+#, c-format
+msgid "Exchange service for %s on %s"
+msgstr "位于 %2$s 上的 %1$s Exchange 服务器"
+
+#: ../src/camel/camel-ews-store.c:925
+#, c-format
+msgid "You must be working online to complete this operation"
+msgstr "您必须上线来完成这一操作"
+
+#: ../src/camel/camel-ews-transport.c:69
+#, c-format
+msgid "Exchange mail delivery via %s"
+msgstr "经由 %s 的 Exchange 邮件投递"
+
+#: ../src/camel/camel-ews-transport.c:102
+#, c-format
+msgid "Service not connected"
+msgstr "未连接服务"
+
+#: ../src/server/e-ews-connection.c:354
+msgid "Operation Cancelled"
+msgstr "操作取消"
+
+#: ../src/server/e-ews-connection.c:408
+msgid "Authentication failed"
+msgstr "认证失败"
+
+#: ../src/server/e-ews-connection.c:416
+#, c-format
+msgid "No response: %s"
+msgstr "无响应：%s"
+
+#: ../src/server/e-ews-connection.c:1079 ../src/server/e-ews-connection.c:1395
+#: ../src/server/e-ews-connection.c:1632
+#, c-format
+msgid "Code: %d - Unexpected response from server"
+msgstr "代码：%d - 服务器响应异常"
+
+#: ../src/server/e-ews-connection.c:1091
+#, c-format
+msgid "Failed to parse autodiscover response XML"
+msgstr "解析自动发现响应 XML 失败"
+
+#: ../src/server/e-ews-connection.c:1099
+#, c-format
+msgid "Failed to find <Autodiscover> element\n"
+msgstr "查找 <Autodiscover> 元素失败\n"
+
+#: ../src/server/e-ews-connection.c:1111
+#, c-format
+msgid "Failed to find <Response> element\n"
+msgstr "查找 <Response> 元素失败\n"
+
+#: ../src/server/e-ews-connection.c:1123
+#, c-format
+msgid "Failed to find <Account> element\n"
+msgstr "查找 <Account> 元素失败\n"
+
+#: ../src/server/e-ews-connection.c:1142
+#, c-format
+msgid "Failed to find <ASUrl> and <OABUrl> in autodiscover response"
+msgstr "在自动发现响应中查找 <ASUrl> 和 <OABUrl> 失败"
+
+#: ../src/server/e-ews-connection.c:1238
+#, c-format
+msgid "Both email and password must be provided"
+msgstr "必须同时提供邮箱和密码"
+
+#: ../src/server/e-ews-connection.c:1245
+#, c-format
+msgid "Wrong email id"
+msgstr "错误的邮箱 ID"
+
+#: ../src/server/e-ews-connection.c:1405
+#, c-format
+msgid "Failed to parse oab XML"
+msgstr "无法解析 oab XML"
+
+#: ../src/server/e-ews-connection.c:1412
+#, c-format
+msgid "Failed to find <OAB> element\n"
+msgstr "查找 <OAB> 元素失败\n"
+
+#: ../src/utils/ews-camel-common.c:138
+#, c-format
+msgid "CreateItem call failed to return ID for new message"
+msgstr "CreateItem 调用未能返回新信息的 ID"
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-ews-config-ui-extension.c evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-ews-config-ui-extension.c
--- evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-ews-config-ui-extension.c	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-ews-config-ui-extension.c	2013-05-28 08:59:53.553713375 +0200
@@ -0,0 +1,154 @@
+/*
+ * e-ews-config-ui-extension.c
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) version 3.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the program; if not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <glib/gi18n-lib.h>
+#include <gtk/gtk.h>
+
+#include <shell/e-shell-view.h>
+
+#include "e-ews-config-utils.h"
+
+#include "e-ews-config-ui-extension.h"
+
+G_DEFINE_DYNAMIC_TYPE (
+	EEwsConfigUIExtension,
+	e_ews_config_ui_extension,
+	E_TYPE_EXTENSION)
+
+static void
+e_ews_config_ui_extension_shell_view_toggled_cb (EShellView *shell_view,
+                                                 EEwsConfigUIExtension *ui_ext)
+{
+	EShellViewClass *shell_view_class;
+	EShellWindow *shell_window;
+	GtkUIManager *ui_manager;
+	gpointer key = NULL, value = NULL;
+	const gchar *ui_def;
+	gboolean is_active, need_update;
+
+	g_return_if_fail (E_IS_SHELL_VIEW (shell_view));
+	g_return_if_fail (ui_ext != NULL);
+
+	shell_view_class = E_SHELL_VIEW_GET_CLASS (shell_view);
+	g_return_if_fail (shell_view_class != NULL);
+
+	shell_window = e_shell_view_get_shell_window (shell_view);
+	ui_manager = e_shell_window_get_ui_manager (shell_window);
+
+	need_update = ui_ext->current_ui_id != 0;
+	if (ui_ext->current_ui_id) {
+		gtk_ui_manager_remove_ui (ui_manager, ui_ext->current_ui_id);
+		ui_ext->current_ui_id = 0;
+	}
+
+	is_active = e_shell_view_is_active (shell_view);
+	if (!is_active) {
+		if (need_update)
+			gtk_ui_manager_ensure_update (ui_manager);
+
+		return;
+	}
+
+	if (!g_hash_table_lookup_extended (ui_ext->ui_definitions, shell_view_class->ui_manager_id, &key, &value)) {
+		gchar *ui_definition = NULL;
+
+		e_ews_config_utils_init_ui (shell_view, shell_view_class->ui_manager_id, &ui_definition);
+		g_hash_table_insert (ui_ext->ui_definitions, g_strdup (shell_view_class->ui_manager_id), ui_definition);
+	}
+
+	ui_def = g_hash_table_lookup (ui_ext->ui_definitions, shell_view_class->ui_manager_id);
+	if (ui_def) {
+		GError *error = NULL;
+
+		ui_ext->current_ui_id = gtk_ui_manager_add_ui_from_string (ui_manager, ui_def, -1, &error);
+		need_update = TRUE;
+
+		if (error) {
+			g_warning ("%s: Failed to add ui definition: %s", G_STRFUNC, error->message);
+			g_error_free (error);
+		}
+	}
+
+	if (need_update)
+		gtk_ui_manager_ensure_update (ui_manager);
+}
+
+static void
+e_ews_config_ui_extension_constructed (GObject *object)
+{
+	EExtension *extension;
+	EExtensible *extensible;
+
+	extension = E_EXTENSION (object);
+	extensible = e_extension_get_extensible (extension);
+
+	/* Chain up to parent's constructed() method. */
+	G_OBJECT_CLASS (e_ews_config_ui_extension_parent_class)->constructed (object);
+
+	g_signal_connect (E_SHELL_VIEW (extensible), "toggled", G_CALLBACK (e_ews_config_ui_extension_shell_view_toggled_cb), extension);
+}
+
+static void
+e_ews_config_ui_extension_finalize (GObject *object)
+{
+	EEwsConfigUIExtension *ui_ext = (EEwsConfigUIExtension *) object;
+
+	/* Chain up to parent's finalize() method. */
+	G_OBJECT_CLASS (e_ews_config_ui_extension_parent_class)->finalize (object);
+
+	g_hash_table_destroy (ui_ext->ui_definitions);
+}
+
+static void
+e_ews_config_ui_extension_class_init (EEwsConfigUIExtensionClass *class)
+{
+	GObjectClass *object_class;
+	EExtensionClass *extension_class;
+
+	object_class = G_OBJECT_CLASS (class);
+	object_class->constructed = e_ews_config_ui_extension_constructed;
+	object_class->finalize = e_ews_config_ui_extension_finalize;
+
+	extension_class = E_EXTENSION_CLASS (class);
+	extension_class->extensible_type = E_TYPE_SHELL_VIEW;
+}
+
+static void
+e_ews_config_ui_extension_class_finalize (EEwsConfigUIExtensionClass *class)
+{
+}
+
+static void
+e_ews_config_ui_extension_init (EEwsConfigUIExtension *extension)
+{
+	extension->current_ui_id = 0;
+	extension->ui_definitions = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
+}
+
+void
+e_ews_config_ui_extension_type_register (GTypeModule *type_module)
+{
+	/* XXX G_DEFINE_DYNAMIC_TYPE declares a static type registration
+	 *     function, so we have to wrap it with a public function in
+	 *     order to register types from a separate compilation unit. */
+	e_ews_config_ui_extension_register_type (type_module);
+}
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-ews-config-ui-extension.h evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-ews-config-ui-extension.h
--- evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-ews-config-ui-extension.h	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-ews-config-ui-extension.h	2013-05-28 08:59:53.553713375 +0200
@@ -0,0 +1,47 @@
+/*
+ * e-ews-config-ui-extension.h
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) version 3.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the program; if not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef E_EWS_CONFIG_UI_EXTENSION_H
+#define E_EWS_CONFIG_UI_EXTENSION_H
+
+#include <e-util/e-extension.h>
+
+G_BEGIN_DECLS
+
+typedef struct _EEwsConfigUIExtension EEwsConfigUIExtension;
+typedef struct _EEwsConfigUIExtensionClass EEwsConfigUIExtensionClass;
+
+struct _EEwsConfigUIExtension
+{
+	EExtension parent;
+
+	guint current_ui_id;
+	GHashTable *ui_definitions;
+};
+
+struct _EEwsConfigUIExtensionClass
+{
+	EExtensionClass parent;
+};
+
+GType	e_ews_config_ui_extension_get_type	(void);
+void	e_ews_config_ui_extension_type_register	(GTypeModule *type_module);
+
+G_END_DECLS
+
+#endif /* E_EWS_CONFIG_UI_EXTENSION_H */
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-ews-config-utils.c evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-ews-config-utils.c
--- evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-ews-config-utils.c	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-ews-config-utils.c	2013-05-28 08:59:53.554712297 +0200
@@ -0,0 +1,1063 @@
+/*
+ * e-ews-config-utils.c
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) version 3.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the program; if not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h>
+#include <unistd.h>
+#include <glib/gi18n-lib.h>
+
+#include <gtk/gtk.h>
+
+#include <e-util/e-dialog-utils.h>
+#include <shell/e-shell.h>
+#include <mail/em-folder-tree.h>
+#include <mail/mail-session.h> /* provides global CamelSession * 'session' variable */
+#include <libedataserverui/e-source-selector.h>
+
+#include "server/e-ews-connection.h"
+
+#include "camel/camel-ews-store.h"
+#include "camel/camel-ews-store-summary.h"
+
+#include "e-ews-edit-folder-permissions.h"
+#include "e-ews-subscribe-foreign-folder.h"
+#include "e-ews-config-utils.h"
+
+struct RunWithFeedbackData
+{
+	GtkWindow *parent;
+	GtkWidget *dialog;
+	GCancellable *cancellable;
+	GObject *with_object;
+	EEwsSetupFunc thread_func;
+	EEwsSetupFunc idle_func;
+	gpointer user_data;
+	GDestroyNotify free_user_data;
+	GError *error;
+	gboolean run_modal;
+};
+
+static void
+free_run_with_feedback_data (gpointer ptr)
+{
+	struct RunWithFeedbackData *rfd = ptr;
+
+	if (!rfd)
+		return;
+
+	if (rfd->dialog)
+		gtk_widget_destroy (rfd->dialog);
+
+	g_object_unref (rfd->cancellable);
+	g_object_unref (rfd->with_object);
+
+	if (rfd->free_user_data)
+		rfd->free_user_data (rfd->user_data);
+
+	g_clear_error (&rfd->error);
+
+	g_free (rfd);
+}
+
+static gboolean
+run_with_feedback_idle (gpointer user_data)
+{
+	struct RunWithFeedbackData *rfd = user_data;
+	gboolean was_cancelled = FALSE;
+
+	g_return_val_if_fail (rfd != NULL, FALSE);
+
+	if (!g_cancellable_is_cancelled (rfd->cancellable)) {
+		if (rfd->idle_func && !rfd->error)
+			rfd->idle_func (rfd->with_object, rfd->user_data, rfd->cancellable, &rfd->error);
+
+		was_cancelled = g_cancellable_is_cancelled (rfd->cancellable);
+
+		if (rfd->dialog) {
+			gtk_widget_destroy (rfd->dialog);
+			rfd->dialog = NULL;
+		}
+	} else {
+		was_cancelled = TRUE;
+	}
+
+	if (!was_cancelled) {
+		if (rfd->error) {
+			g_dbus_error_strip_remote_error (rfd->error);
+
+			e_notice (rfd->parent, GTK_MESSAGE_ERROR, "%s", rfd->error->message);
+		}
+	}
+
+	free_run_with_feedback_data (rfd);
+
+	return FALSE;
+}
+
+static gpointer
+run_with_feedback_thread (gpointer user_data)
+{
+	struct RunWithFeedbackData *rfd = user_data;
+
+	g_return_val_if_fail (rfd != NULL, NULL);
+	g_return_val_if_fail (rfd->thread_func != NULL, NULL);
+
+	if (!g_cancellable_is_cancelled (rfd->cancellable))
+		rfd->thread_func (rfd->with_object, rfd->user_data, rfd->cancellable, &rfd->error);
+
+	g_idle_add (run_with_feedback_idle, rfd);
+
+	return NULL;
+}
+
+static void
+run_with_feedback_response_cb (GtkWidget *dialog,
+                               gint resonse_id,
+                               struct RunWithFeedbackData *rfd)
+{
+	g_return_if_fail (rfd != NULL);
+
+	rfd->dialog = NULL;
+
+	g_cancellable_cancel (rfd->cancellable);
+
+	gtk_widget_destroy (dialog);
+}
+
+static void
+e_ews_config_utils_run_in_thread_with_feedback_general (GtkWindow *parent,
+                                                        GObject *with_object,
+                                                        const gchar *description,
+                                                        EEwsSetupFunc thread_func,
+                                                        EEwsSetupFunc idle_func,
+                                                        gpointer user_data,
+                                                        GDestroyNotify free_user_data,
+                                                        gboolean run_modal)
+{
+	GtkWidget *dialog, *label, *content, *spinner, *box;
+	struct RunWithFeedbackData *rfd;
+
+	g_return_if_fail (with_object != NULL);
+	g_return_if_fail (description != NULL);
+	g_return_if_fail (thread_func != NULL);
+
+	dialog = gtk_dialog_new_with_buttons (
+		"",
+		parent,
+		GTK_DIALOG_MODAL,
+		GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+		NULL);
+
+	gtk_dialog_set_has_separator (GTK_DIALOG (dialog), FALSE);
+
+	box = gtk_hbox_new (FALSE, 6);
+
+	spinner = gtk_spinner_new ();
+	gtk_spinner_start (GTK_SPINNER (spinner));
+	gtk_box_pack_start (GTK_BOX (box), spinner, FALSE, FALSE, 0);
+
+	label = gtk_label_new (description);
+	gtk_box_pack_start (GTK_BOX (box), label, TRUE, TRUE, 0);
+
+	gtk_widget_show_all (box);
+
+	content = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
+
+	gtk_container_add (GTK_CONTAINER (content), box);
+	gtk_container_set_border_width (GTK_CONTAINER (content), 12);
+
+	rfd = g_new0 (struct RunWithFeedbackData, 1);
+	rfd->parent = parent;
+	rfd->dialog = dialog;
+	rfd->cancellable = g_cancellable_new ();
+	rfd->with_object = g_object_ref (with_object);
+	rfd->thread_func = thread_func;
+	rfd->idle_func = idle_func;
+	rfd->user_data = user_data;
+	rfd->free_user_data = free_user_data;
+	rfd->error = NULL;
+	rfd->run_modal = run_modal;
+
+	g_signal_connect (dialog, "response", G_CALLBACK (run_with_feedback_response_cb), rfd);
+
+	if (run_modal) {
+		GCancellable *cancellable;
+
+		cancellable = g_object_ref (rfd->cancellable);
+
+		g_thread_create (run_with_feedback_thread, rfd, FALSE, NULL);
+
+		gtk_dialog_run (GTK_DIALOG (dialog));
+
+		g_cancellable_cancel (cancellable);
+		g_object_unref (cancellable);
+	} else {
+		gtk_widget_show (dialog);
+
+		g_thread_create (run_with_feedback_thread, rfd, FALSE, NULL);
+	}
+}
+
+void
+e_ews_config_utils_run_in_thread_with_feedback (GtkWindow *parent,
+                                                GObject *with_object,
+                                                const gchar *description,
+                                                EEwsSetupFunc thread_func,
+                                                EEwsSetupFunc idle_func,
+                                                gpointer user_data,
+                                                GDestroyNotify free_user_data)
+{
+	e_ews_config_utils_run_in_thread_with_feedback_general (parent, with_object, description, thread_func, idle_func, user_data, free_user_data, FALSE);
+}
+
+void
+e_ews_config_utils_run_in_thread_with_feedback_modal (GtkWindow *parent,
+                                                      GObject *with_object,
+                                                      const gchar *description,
+                                                      EEwsSetupFunc thread_func,
+                                                      EEwsSetupFunc idle_func,
+                                                      gpointer user_data,
+                                                      GDestroyNotify free_user_data)
+{
+	e_ews_config_utils_run_in_thread_with_feedback_general (parent, with_object, description, thread_func, idle_func, user_data, free_user_data, TRUE);
+}
+
+static gboolean
+em_folder_tree_get_selected (EMFolderTree *folder_tree,
+                             CamelStore **out_store,
+                             gchar **out_folder_name,
+			     gchar **out_store_display_name)
+{
+	GtkTreeView *tree_view;
+	GtkTreeSelection *selection;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+	CamelStore *store = NULL;
+	gchar *folder_name = NULL;
+
+	g_return_val_if_fail (EM_IS_FOLDER_TREE (folder_tree), FALSE);
+
+	tree_view = GTK_TREE_VIEW (folder_tree);
+	selection = gtk_tree_view_get_selection (tree_view);
+
+	if (!gtk_tree_selection_get_selected (selection, &model, &iter))
+		return FALSE;
+
+	gtk_tree_model_get (
+		model, &iter,
+		COL_POINTER_CAMEL_STORE, &store,
+		COL_STRING_FULL_NAME, &folder_name, -1);
+
+	/* We should always get a valid store. */
+	g_return_val_if_fail (CAMEL_IS_STORE (store), FALSE);
+
+	/* If a store is selected, the folder name will be NULL.
+	 * Treat this as though nothing is selected, so that callers
+	 * can assume a TRUE return value means a folder is selected. */
+	if (folder_name == NULL)
+		return FALSE;
+
+	/* FIXME We really should be storing the CamelStore as a GObject
+	 *       so it gets referenced.  The pointer type is a relic of
+	 *       days before Camel used GObject. */
+	if (out_store != NULL)
+		*out_store = g_object_ref (store);
+
+	if (out_folder_name != NULL)
+		*out_folder_name = folder_name;
+	else
+		g_free (folder_name);
+
+	if (out_store_display_name) {
+		GtkTreeIter last_iter = iter;
+
+		while (gtk_tree_model_iter_parent (model, &iter, &last_iter)) {
+			last_iter = iter;
+		}
+
+		gtk_tree_model_get (
+			model, &last_iter,
+			COL_STRING_DISPLAY_NAME, out_store_display_name,
+			-1);
+	}
+
+	return TRUE;
+}
+
+static gboolean
+em_folder_tree_store_root_selected (EMFolderTree *folder_tree,
+                                    CamelStore **out_store,
+				    gchar **display_name)
+{
+	GtkTreeView *tree_view;
+	GtkTreeSelection *selection;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+	CamelStore *store = NULL;
+	gchar *name = NULL;
+	gboolean is_store = FALSE;
+
+	g_return_val_if_fail (folder_tree != NULL, FALSE);
+	g_return_val_if_fail (EM_IS_FOLDER_TREE (folder_tree), FALSE);
+
+	tree_view = GTK_TREE_VIEW (folder_tree);
+	selection = gtk_tree_view_get_selection (tree_view);
+
+	if (!gtk_tree_selection_get_selected (selection, &model, &iter))
+		return FALSE;
+
+	gtk_tree_model_get (
+		model, &iter,
+		COL_POINTER_CAMEL_STORE, &store,
+		COL_BOOL_IS_STORE, &is_store,
+		COL_STRING_DISPLAY_NAME, &name,
+		-1);
+
+	/* We should always get a valid store. */
+	g_return_val_if_fail (CAMEL_IS_STORE (store), FALSE);
+
+	if (!is_store) {
+		g_free (name);
+		return FALSE;
+	}
+
+	if (out_store != NULL)
+		*out_store = g_object_ref (store);
+	if (display_name)
+		*display_name = name;
+	else
+		g_free (name);
+
+	return TRUE;
+}
+
+static GtkActionGroup *
+e_lookup_action_group (GtkUIManager *ui_manager,
+                       const gchar *group_name)
+{
+	GList *iter;
+
+	g_return_val_if_fail (GTK_IS_UI_MANAGER (ui_manager), NULL);
+	g_return_val_if_fail (group_name != NULL, NULL);
+
+	iter = gtk_ui_manager_get_action_groups (ui_manager);
+
+	while (iter != NULL) {
+		GtkActionGroup *action_group = iter->data;
+		const gchar *name;
+
+		name = gtk_action_group_get_name (action_group);
+		if (strcmp (name, group_name) == 0)
+			return action_group;
+
+		iter = g_list_next (iter);
+	}
+
+	g_critical ("%s: action group '%s' not found", G_STRFUNC, group_name);
+
+	return NULL;
+}
+
+static void
+e_action_group_add_actions_localized (GtkActionGroup *action_group,
+                                      const gchar *translation_domain,
+                                      const GtkActionEntry *entries,
+                                      guint n_entries,
+                                      gpointer user_data)
+{
+	GtkActionGroup *tmp_group;
+	GList *list, *iter;
+	gint ii;
+
+	g_return_if_fail (action_group != NULL);
+	g_return_if_fail (entries != NULL);
+	g_return_if_fail (n_entries > 0);
+	g_return_if_fail (translation_domain != NULL);
+	g_return_if_fail (*translation_domain);
+
+	tmp_group = gtk_action_group_new ("temporary-group");
+	gtk_action_group_set_translation_domain (tmp_group, translation_domain);
+	gtk_action_group_add_actions (tmp_group, entries, n_entries, user_data);
+
+	list = gtk_action_group_list_actions (tmp_group);
+	for (iter = list; iter != NULL; iter = iter->next) {
+		GtkAction *action = GTK_ACTION (iter->data);
+		const gchar *action_name;
+
+		g_object_ref (action);
+
+		action_name = gtk_action_get_name (action);
+
+		for (ii = 0; ii < n_entries; ii++) {
+			if (g_strcmp0 (entries[ii].name, action_name) == 0) {
+				gtk_action_group_remove_action (
+					tmp_group, action);
+				gtk_action_group_add_action_with_accel (
+					action_group, action,
+					entries[ii].accelerator);
+				break;
+			}
+		}
+
+		g_object_unref (action);
+	}
+
+	g_list_free (list);
+	g_object_unref (tmp_group);
+}
+
+static gboolean
+get_ews_store_from_folder_tree (EShellView *shell_view,
+                                gchar **pfolder_path,
+                                CamelStore **pstore,
+				gchar **pdisplay_name)
+{
+	EShellSidebar *shell_sidebar;
+	EMFolderTree *folder_tree;
+	gchar *selected_path = NULL;
+	CamelStore *selected_store = NULL;
+	gboolean found = FALSE;
+
+	/* Get hold of Folder Tree */
+	shell_sidebar = e_shell_view_get_shell_sidebar (shell_view);
+	g_object_get (shell_sidebar, "folder-tree", &folder_tree, NULL);
+	if (em_folder_tree_get_selected (folder_tree, &selected_store, &selected_path, pdisplay_name) ||
+	    em_folder_tree_store_root_selected (folder_tree, &selected_store, pdisplay_name)) {
+		if (selected_store) {
+			CamelProvider *provider = camel_service_get_provider (CAMEL_SERVICE (selected_store));
+
+			if (provider && g_ascii_strcasecmp (provider->protocol, "ews") == 0) {
+				found = TRUE;
+
+				if (pstore)
+					*pstore = g_object_ref (selected_store);
+
+				if (pfolder_path)
+					*pfolder_path = selected_path;
+				else
+					g_free (selected_path);
+
+				selected_path = NULL;
+			}
+
+			g_object_unref (selected_store);
+		}
+
+		g_free (selected_path);
+	}
+
+	g_object_unref (folder_tree);
+
+	return found;
+}
+
+static void
+action_subscribe_foreign_folder_cb (GtkAction *action,
+                                    EShellView *shell_view)
+{
+	GtkWindow *parent;
+	EShell *shell;
+	EShellBackend *backend;
+	CamelStore *store = NULL;
+	gchar *display_name = NULL;
+
+	if (!get_ews_store_from_folder_tree (shell_view, NULL, &store, &display_name)) {
+		g_free (display_name);
+		return;
+	}
+
+	parent = GTK_WINDOW (e_shell_view_get_shell_window (shell_view));
+	backend = e_shell_view_get_shell_backend (shell_view);
+
+	shell = e_shell_backend_get_shell (backend);
+
+	e_ews_subscribe_foreign_folder (parent, session, store, display_name);
+
+	g_free (display_name);
+	g_object_unref (store);
+}
+
+static void
+action_folder_permissions_mail_cb (GtkAction *action,
+                                   EShellView *shell_view)
+{
+	gchar *folder_path = NULL;
+	EShellWindow *shell_window;
+	GtkWindow *parent;
+	CamelStore *store = NULL;
+	CamelEwsStore *ews_store;
+	gchar *str_folder_id;
+	gchar *display_name = NULL;
+
+	if (!get_ews_store_from_folder_tree (shell_view, &folder_path, &store, &display_name)) {
+		g_free (display_name);
+		return;
+	}
+
+	ews_store = CAMEL_EWS_STORE (store);
+	g_return_if_fail (ews_store != NULL);
+	g_return_if_fail (folder_path != NULL);
+
+	shell_window = e_shell_view_get_shell_window (shell_view);
+	parent = GTK_WINDOW (shell_window);
+
+	str_folder_id = camel_ews_store_summary_get_folder_id_from_name (ews_store->summary, folder_path);
+	if (!str_folder_id) {
+		e_notice (parent, GTK_MESSAGE_ERROR, _("Cannot edit permissions of folder '%s', choose other folder."), folder_path);
+	} else {
+		CamelURL *url;
+		EShell *shell;
+		EwsFolderId *folder_id;
+		gchar *str_change_key;
+		const gchar *timeout_str;
+		gchar *password_key;
+
+		url = CAMEL_SERVICE (ews_store)->url;
+		password_key = camel_url_to_string (url, CAMEL_URL_HIDE_PASSWORD | CAMEL_URL_HIDE_PARAMS);
+
+		shell = e_shell_window_get_shell (shell_window);
+
+		str_change_key = camel_ews_store_summary_get_change_key (
+			ews_store->summary, str_folder_id, NULL);
+
+		folder_id = e_ews_folder_id_new (
+			str_folder_id, str_change_key, FALSE);
+		timeout_str = camel_url_get_param (url, "timeout");
+
+		e_ews_edit_folder_permissions (
+			parent,
+			camel_url_get_param (url, "hosturl"),
+			url->user,
+			camel_url_get_param (url, "impersonate_user"),
+			timeout_str ? atoi (timeout_str) : -1,
+			password_key,
+			FALSE,
+			url->host,
+			display_name,
+			folder_path,
+			folder_id,
+			E_EWS_FOLDER_TYPE_MAILBOX);
+
+		g_free (str_folder_id);
+		g_free (str_change_key);
+		e_ews_folder_id_free (folder_id);
+		g_free (password_key);
+	}
+
+	g_object_unref (store);
+	g_free (folder_path);
+	g_free (display_name);
+}
+
+static void
+ews_ui_enable_actions (GtkActionGroup *action_group,
+                       const GtkActionEntry *entries,
+                       guint n_entries,
+                       gboolean can_show,
+                       gboolean is_online)
+{
+	gint ii;
+
+	g_return_if_fail (action_group != NULL);
+	g_return_if_fail (entries != NULL);
+
+	for (ii = 0; ii < n_entries; ii++) {
+		GtkAction *action;
+
+		action = gtk_action_group_get_action (action_group, entries[ii].name);
+		if (!action)
+			continue;
+
+		gtk_action_set_visible (action, can_show);
+		if (can_show)
+			gtk_action_set_sensitive (action, is_online);
+	}
+}
+
+static GtkActionEntry mail_account_context_entries[] = {
+
+	{ "mail-ews-subscribe-foreign-folder",
+	  NULL,
+	  N_("Subscribe to folder of other user..."),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  G_CALLBACK (action_subscribe_foreign_folder_cb) }
+};
+
+static GtkActionEntry mail_folder_context_entries[] = {
+	{ "mail-ews-folder-permissions",
+	  "folder-new",
+	  N_("Permissions..."),
+	  NULL,
+	  N_("Edit EWS folder permissions"),
+	  G_CALLBACK (action_folder_permissions_mail_cb) }
+};
+
+static const gchar *ews_ui_mail_def =
+	"<popup name=\"mail-folder-popup\">\n"
+	"  <placeholder name=\"mail-folder-popup-actions\">\n"
+	"    <menuitem action=\"mail-ews-subscribe-foreign-folder\"/>\n"
+	"    <menuitem action=\"mail-ews-folder-permissions\"/>\n"
+	"  </placeholder>\n"
+	"</popup>\n";
+
+static void
+ews_ui_update_actions_mail_cb (EShellView *shell_view,
+                               GtkActionEntry *entries)
+{
+	EShellWindow *shell_window;
+	GtkActionGroup *action_group;
+	GtkUIManager *ui_manager;
+	EShellSidebar *shell_sidebar;
+	EMFolderTree *folder_tree;
+	CamelStore *selected_store = NULL;
+	gchar *selected_path = NULL;
+	gboolean account_node = FALSE, folder_node = FALSE;
+	gboolean online = FALSE;
+
+	shell_sidebar = e_shell_view_get_shell_sidebar (shell_view);
+	g_object_get (shell_sidebar, "folder-tree", &folder_tree, NULL);
+	if (em_folder_tree_get_selected (folder_tree, &selected_store, &selected_path, NULL) ||
+	    em_folder_tree_store_root_selected (folder_tree, &selected_store, NULL)) {
+		if (selected_store) {
+			CamelProvider *provider = camel_service_get_provider (CAMEL_SERVICE (selected_store));
+
+			if (provider && g_ascii_strcasecmp (provider->protocol, "ews") == 0) {
+				account_node = !selected_path || !*selected_path;
+				folder_node = !account_node;
+			}
+
+			g_object_unref (selected_store);
+		}
+	}
+	g_object_unref (folder_tree);
+
+	g_free (selected_path);
+
+	shell_window = e_shell_view_get_shell_window (shell_view);
+	ui_manager = e_shell_window_get_ui_manager (shell_window);
+	action_group = e_lookup_action_group (ui_manager, "mail");
+
+	if (account_node || folder_node) {
+		online = session && camel_session_get_online (session);
+	}
+
+	ews_ui_enable_actions (action_group, mail_account_context_entries, G_N_ELEMENTS (mail_account_context_entries), account_node, online);
+	ews_ui_enable_actions (action_group, mail_folder_context_entries, G_N_ELEMENTS (mail_folder_context_entries), folder_node, online);
+}
+
+static void
+ews_ui_init_mail (GtkUIManager *ui_manager,
+                  EShellView *shell_view,
+                  gchar **ui_definition)
+{
+	EShellWindow *shell_window;
+	GtkActionGroup *action_group;
+
+	g_return_if_fail (ui_definition != NULL);
+
+	*ui_definition = g_strdup (ews_ui_mail_def);
+
+	shell_window = e_shell_view_get_shell_window (shell_view);
+	action_group = e_shell_window_get_action_group (shell_window, "mail");
+
+	/* Add actions to the "mail" action group. */
+	e_action_group_add_actions_localized (
+		action_group, GETTEXT_PACKAGE,
+		mail_account_context_entries, G_N_ELEMENTS (mail_account_context_entries), shell_view);
+	e_action_group_add_actions_localized (
+		action_group, GETTEXT_PACKAGE,
+		mail_folder_context_entries, G_N_ELEMENTS (mail_folder_context_entries), shell_view);
+
+	/* Decide whether we want this option to be visible or not */
+	g_signal_connect (
+		shell_view, "update-actions",
+		G_CALLBACK (ews_ui_update_actions_mail_cb),
+		shell_view);
+}
+
+static gboolean
+get_selected_ews_source (EShellView *shell_view,
+                         ESource **selected_source)
+{
+	ESource *source;
+	ESourceGroup *group;
+	EShellSidebar *shell_sidebar;
+	ESourceSelector *selector = NULL;
+
+	g_return_val_if_fail (shell_view != NULL, FALSE);
+
+	shell_sidebar = e_shell_view_get_shell_sidebar (shell_view);
+	g_return_val_if_fail (shell_sidebar != NULL, FALSE);
+
+	g_object_get (shell_sidebar, "selector", &selector, NULL);
+	g_return_val_if_fail (selector != NULL, FALSE);
+
+	source = e_source_selector_peek_primary_selection (selector);
+	if (source) {
+		g_object_ref (source);
+
+		group = e_source_peek_group (source);
+		if (!group || !e_source_group_peek_base_uri (group) ||
+		    g_ascii_strcasecmp (e_source_group_peek_base_uri (group), "ews://") != 0) {
+			g_object_unref (source);
+			source = NULL;
+		}
+	}
+
+	g_object_unref (selector);
+
+	if (selected_source)
+		*selected_source = source;
+	else if (source)
+		g_object_unref (source);
+
+	return source != NULL;
+}
+
+/* how many menu entries are defined; all calendar/tasks/memos/contacts
+ * actions should have same count */
+#define EWS_ESOURCE_NUM_ENTRIES 1
+
+static void
+update_ews_source_entries_cb (EShellView *shell_view,
+                              GtkActionEntry *entries)
+{
+	GtkActionGroup *action_group;
+	EShell *shell;
+	EShellWindow *shell_window;
+	const gchar *group;
+	gboolean is_ews_source, is_online;
+
+	g_return_if_fail (E_IS_SHELL_VIEW (shell_view));
+	g_return_if_fail (entries != NULL);
+
+	if (strstr (entries->name, "calendar"))
+		group = "calendar";
+	else if (strstr (entries->name, "tasks"))
+		group = "tasks";
+	else if (strstr (entries->name, "memos"))
+		group = "memos";
+	else if (strstr (entries->name, "contacts"))
+		group = "contacts";
+	else
+		g_return_if_reached ();
+
+	is_ews_source = get_selected_ews_source (shell_view, NULL);
+	shell_window = e_shell_view_get_shell_window (shell_view);
+	shell = e_shell_window_get_shell (shell_window);
+
+	is_online = shell && e_shell_get_online (shell);
+	action_group = e_shell_window_get_action_group (shell_window, group);
+
+	ews_ui_enable_actions (action_group, entries, EWS_ESOURCE_NUM_ENTRIES, is_ews_source, is_online);
+}
+
+static void
+setup_ews_source_actions (EShellView *shell_view,
+                          GtkUIManager *ui_manager,
+                          GtkActionEntry *entries,
+                          guint n_entries)
+{
+	EShellWindow *shell_window;
+	const gchar *group;
+
+	g_return_if_fail (shell_view != NULL);
+	g_return_if_fail (ui_manager != NULL);
+	g_return_if_fail (entries != NULL);
+	g_return_if_fail (n_entries > 0);
+	g_return_if_fail (n_entries == EWS_ESOURCE_NUM_ENTRIES);
+
+	if (strstr (entries->name, "calendar"))
+		group = "calendar";
+	else if (strstr (entries->name, "tasks"))
+		group = "tasks";
+	else if (strstr (entries->name, "memos"))
+		group = "memos";
+	else if (strstr (entries->name, "contacts"))
+		group = "contacts";
+	else
+		g_return_if_reached ();
+
+	shell_window = e_shell_view_get_shell_window (shell_view);
+
+	e_action_group_add_actions_localized (
+		e_shell_window_get_action_group (shell_window, group), GETTEXT_PACKAGE,
+		entries, EWS_ESOURCE_NUM_ENTRIES, shell_view);
+
+	g_signal_connect (shell_view, "update-actions", G_CALLBACK (update_ews_source_entries_cb), entries);
+}
+
+static void
+action_folder_permissions_source_cb (GtkAction *action,
+                                     EShellView *shell_view)
+{
+	ESource *source = NULL;
+	EwsFolderId *folder_id;
+	EEwsFolderType folder_type;
+	const gchar *timeout_str, *remember_password_str;
+	CamelURL *url;
+	gchar *password_key, *password_who_asks, *url_str;
+
+	g_return_if_fail (action != NULL);
+	g_return_if_fail (shell_view != NULL);
+	g_return_if_fail (get_selected_ews_source (shell_view, &source));
+	g_return_if_fail (source != NULL);
+	g_return_if_fail (gtk_action_get_name (action) != NULL);
+
+	g_return_if_fail (e_source_get_property (source, "folder-id") != NULL);
+
+	url_str = g_strconcat ("ews://", e_source_peek_relative_uri (source), NULL);
+	url = camel_url_new (url_str, NULL);
+	g_free (url_str);
+	g_return_if_fail (url != NULL);
+
+	folder_id = e_ews_folder_id_new (
+		e_source_get_property (source, "folder-id"),
+		e_source_get_property (source, "change-key"),
+		FALSE);
+
+	folder_type = E_EWS_FOLDER_TYPE_MAILBOX;
+	if (strstr (gtk_action_get_name (action), "calendar") != NULL)
+		folder_type = E_EWS_FOLDER_TYPE_CALENDAR;
+	else if (strstr (gtk_action_get_name (action), "contacts") != NULL)
+		folder_type = E_EWS_FOLDER_TYPE_CONTACTS;
+	else if (strstr (gtk_action_get_name (action), "tasks") != NULL)
+		folder_type = E_EWS_FOLDER_TYPE_TASKS;
+
+	password_key = camel_url_to_string (url, CAMEL_URL_HIDE_PASSWORD | CAMEL_URL_HIDE_PARAMS);
+	password_who_asks = g_strconcat (url->user ? url->user : "", url->user ? "@" : "", url->host, NULL);
+	timeout_str = e_source_get_property (source, "timeout");
+	remember_password_str = e_source_get_property (source, "remember_password");
+
+	e_ews_edit_folder_permissions (
+		NULL,
+		e_source_get_property (source, "hosturl"),
+		e_source_get_property (source, "username"),
+		e_source_get_property (source, "impersonate_user"),
+		timeout_str ? atoi (timeout_str) : -1,
+		password_key,
+		remember_password_str && g_ascii_strcasecmp (remember_password_str, "true") == 0,
+		password_who_asks,
+		e_source_group_peek_name (e_source_peek_group (source)),
+		e_source_peek_name (source),
+		folder_id,
+		folder_type);
+
+	g_object_unref (source);
+	e_ews_folder_id_free (folder_id);
+	camel_url_free (url);
+	g_free (password_key);
+	g_free (password_who_asks);
+}
+
+static GtkActionEntry calendar_context_entries[] = {
+
+	{ "calendar-ews-folder-permissions",
+	  "folder-new",
+	  N_("Permissions..."),
+	  NULL,
+	  N_("Edit EWS calendar permissions"),
+	  G_CALLBACK (action_folder_permissions_source_cb) }
+};
+
+static const gchar *ews_ui_cal_def =
+	"<popup name=\"calendar-popup\">\n"
+	"  <placeholder name=\"calendar-popup-actions\">\n"
+	"    <menuitem action=\"calendar-ews-folder-permissions\"/>\n"
+	"  </placeholder>\n"
+	"</popup>\n";
+
+static void
+ews_ui_init_calendar (GtkUIManager *ui_manager,
+                      EShellView *shell_view,
+                      gchar **ui_definition)
+{
+	g_return_if_fail (ui_definition != NULL);
+
+	*ui_definition = g_strdup (ews_ui_cal_def);
+
+	setup_ews_source_actions (
+		shell_view, ui_manager,
+		calendar_context_entries, G_N_ELEMENTS (calendar_context_entries));
+}
+
+static GtkActionEntry tasks_context_entries[] = {
+
+	{ "tasks-ews-folder-permissions",
+	  "folder-new",
+	  N_("Permissions..."),
+	  NULL,
+	  N_("Edit EWS tasks permissions"),
+	  G_CALLBACK (action_folder_permissions_source_cb) }
+};
+
+static const gchar *ews_ui_task_def =
+	"<popup name=\"task-list-popup\">\n"
+	"  <placeholder name=\"task-list-popup-actions\">\n"
+	"    <menuitem action=\"tasks-ews-folder-permissions\"/>\n"
+	"  </placeholder>\n"
+	"</popup>\n";
+
+static void
+ews_ui_init_tasks (GtkUIManager *ui_manager,
+                   EShellView *shell_view,
+                   gchar **ui_definition)
+{
+	g_return_if_fail (ui_definition != NULL);
+
+	*ui_definition = g_strdup (ews_ui_task_def);
+
+	setup_ews_source_actions (
+		shell_view, ui_manager,
+		tasks_context_entries, G_N_ELEMENTS (tasks_context_entries));
+}
+
+static GtkActionEntry memos_context_entries[] = {
+
+	{ "memos-ews-folder-permissions",
+	  "folder-new",
+	  N_("Permissions..."),
+	  NULL,
+	  N_("Edit EWS memos permissions"),
+	  G_CALLBACK (action_folder_permissions_source_cb) }
+};
+
+static const gchar *ews_ui_memo_def =
+	"<popup name=\"memo-list-popup\">\n"
+	"  <placeholder name=\"memo-list-popup-actions\">\n"
+	"    <menuitem action=\"memos-ews-folder-permissions\"/>\n"
+	"  </placeholder>\n"
+	"</popup>\n";
+
+static void
+ews_ui_init_memos (GtkUIManager *ui_manager,
+                   EShellView *shell_view,
+                   gchar **ui_definition)
+{
+	g_return_if_fail (ui_definition != NULL);
+
+	*ui_definition = g_strdup (ews_ui_memo_def);
+
+	setup_ews_source_actions (
+		shell_view, ui_manager,
+		memos_context_entries, G_N_ELEMENTS (memos_context_entries));
+}
+
+static GtkActionEntry contacts_context_entries[] = {
+
+	{ "contacts-ews-folder-permissions",
+	  "folder-new",
+	  N_("Permissions..."),
+	  NULL,
+	  N_("Edit EWS contacts permissions"),
+	  G_CALLBACK (action_folder_permissions_source_cb) }
+};
+
+static const gchar *ews_ui_book_def =
+	"<popup name=\"address-book-popup\">\n"
+	"  <placeholder name=\"address-book-popup-actions\">\n"
+	"    <menuitem action=\"contacts-ews-folder-permissions\"/>\n"
+	"  </placeholder>\n"
+	"</popup>\n";
+
+static void
+ews_ui_init_contacts (GtkUIManager *ui_manager,
+                      EShellView *shell_view,
+                      gchar **ui_definition)
+{
+	g_return_if_fail (ui_definition != NULL);
+
+	*ui_definition = g_strdup (ews_ui_book_def);
+
+	setup_ews_source_actions (
+		shell_view, ui_manager,
+		contacts_context_entries, G_N_ELEMENTS (contacts_context_entries));
+}
+
+void
+e_ews_config_utils_init_ui (EShellView *shell_view,
+			    const gchar *ui_manager_id,
+			    gchar **ui_definition)
+{
+	EShellWindow *shell_window;
+	GtkUIManager *ui_manager;
+
+	g_return_if_fail (shell_view != NULL);
+	g_return_if_fail (ui_manager_id != NULL);
+	g_return_if_fail (ui_definition != NULL);
+
+	shell_window = e_shell_view_get_shell_window (shell_view);
+	ui_manager = e_shell_window_get_ui_manager (shell_window);
+
+	if (g_strcmp0 (ui_manager_id, "org.gnome.evolution.mail") == 0)
+		ews_ui_init_mail (ui_manager, shell_view, ui_definition);
+	else if (g_strcmp0 (ui_manager_id, "org.gnome.evolution.calendars") == 0)
+		ews_ui_init_calendar (ui_manager, shell_view, ui_definition);
+	else if (g_strcmp0 (ui_manager_id, "org.gnome.evolution.tasks") == 0)
+		ews_ui_init_tasks (ui_manager, shell_view, ui_definition);
+	else if (g_strcmp0 (ui_manager_id, "org.gnome.evolution.memos") == 0)
+		ews_ui_init_memos (ui_manager, shell_view, ui_definition);
+	else if (g_strcmp0 (ui_manager_id, "org.gnome.evolution.contacts") == 0)
+		ews_ui_init_contacts (ui_manager, shell_view, ui_definition);
+}
+
+gboolean
+e_ews_config_utils_is_online (void)
+{
+	EShell *shell;
+
+	shell = e_shell_get_default ();
+
+	return shell && e_shell_get_online (shell);
+}
+
+GtkWindow *
+e_ews_config_utils_get_widget_toplevel_window (GtkWidget *widget)
+{
+	if (!widget)
+		return NULL;
+
+	if (!GTK_IS_WINDOW (widget))
+		widget = gtk_widget_get_toplevel (widget);
+
+	if (GTK_IS_WINDOW (widget))
+		return GTK_WINDOW (widget);
+
+	return NULL;
+}
+
+static gpointer
+ews_config_utils_unref_in_thread (gpointer user_data)
+{
+	g_object_unref (user_data);
+
+	return NULL;
+}
+
+void
+e_ews_config_utils_unref_in_thread (GObject *object)
+{
+	g_return_if_fail (object != NULL);
+	g_return_if_fail (G_IS_OBJECT (object));
+
+	g_thread_create (ews_config_utils_unref_in_thread, object, FALSE, NULL);
+}
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-ews-config-utils.h evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-ews-config-utils.h
--- evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-ews-config-utils.h	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-ews-config-utils.h	2013-05-28 08:59:53.554712297 +0200
@@ -0,0 +1,58 @@
+/*
+ * e-ews-config-utils.h
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) version 3.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the program; if not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef E_EWS_CONFIG_UTILS_H
+#define E_EWS_CONFIG_UTILS_H
+
+#include <gtk/gtk.h>
+#include <shell/e-shell-view.h>
+
+#include "server/e-ews-connection.h"
+
+typedef void		(* EEwsSetupFunc)					(GObject *with_object,
+										 gpointer user_data,
+										 GCancellable *cancellable,
+										 GError **perror);
+
+void			e_ews_config_utils_run_in_thread_with_feedback		(GtkWindow *parent,
+										 GObject *with_object,
+										 const gchar *description,
+										 EEwsSetupFunc thread_func,
+										 EEwsSetupFunc idle_func,
+										 gpointer user_data,
+										 GDestroyNotify free_user_data);
+
+void			e_ews_config_utils_run_in_thread_with_feedback_modal	(GtkWindow *parent,
+										 GObject *with_object,
+										 const gchar *description,
+										 EEwsSetupFunc thread_func,
+										 EEwsSetupFunc idle_func,
+										 gpointer user_data,
+										 GDestroyNotify free_user_data);
+
+void			e_ews_config_utils_init_ui				(EShellView *shell_view,
+										 const gchar *ui_manager_id,
+										 gchar **ui_definition);
+
+gboolean		e_ews_config_utils_is_online				(void);
+
+GtkWindow *		e_ews_config_utils_get_widget_toplevel_window		(GtkWidget *widget);
+
+void			e_ews_config_utils_unref_in_thread			(GObject *object);
+
+#endif /* E_EWS_CONFIG_UTILS */
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-ews-edit-folder-permissions.c evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-ews-edit-folder-permissions.c
--- evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-ews-edit-folder-permissions.c	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-ews-edit-folder-permissions.c	2013-05-28 08:59:53.554712297 +0200
@@ -0,0 +1,1300 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) version 3.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the program; if not, see <http://www.gnu.org/licenses/>
+ *
+ *
+ * Authors:
+ *    Milan Crha <mcrha@redhat.com>
+ *
+ * Copyright (C) 2012 Red Hat, Inc. (www.redhat.com)
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <glib/gi18n-lib.h>
+#include <gtk/gtk.h>
+
+#include <libedataserverui/e-passwords.h>
+
+#include "e-ews-config-utils.h"
+#include "e-ews-edit-folder-permissions.h"
+#include "e-ews-search-user.h"
+
+#include "server/e-ews-gnome-3-8-compat.h"
+
+#define E_EWS_PERM_DLG_WIDGETS "e-ews-perm-dlg-widgets"
+
+enum {
+	COL_NAME = 0,
+	COL_PERMISSION_LEVEL,
+	COL_E_EWS_PERMISSION,
+	COL_E_EWS_PERMISSION_USER_TYPE,
+	COL_IS_NEW
+};
+
+struct EEwsPermissionsDialogWidgets
+{
+	gchar *uri;
+	gchar *username;
+	gchar *impersonate_user;
+	gint timeout;
+	gchar *password_key;
+	gboolean password_remember;
+	gchar *password_who_asks;
+
+	EwsFolderId *folder_id;
+	EEwsFolderType folder_type;
+
+	EEwsConnection *conn;
+
+	guint updating;
+
+	GtkWidget *dialog;
+	GtkWidget *tree_view;
+
+	GtkWidget *add_button;
+	GtkWidget *remove_button;
+	GtkWidget *level_combo;
+
+	GtkWidget *read_none_radio;
+	GtkWidget *read_full_radio;
+	GtkWidget *read_fb_time_radio;
+	GtkWidget *read_fb_detail_radio;
+
+	GtkWidget *write_create_items_check;
+	GtkWidget *write_create_subfolders_check;
+	GtkWidget *write_edit_own_check;
+	GtkWidget *write_edit_all_check;
+
+	GtkWidget *delete_none_radio;
+	GtkWidget *delete_own_radio;
+	GtkWidget *delete_all_radio;
+
+	GtkWidget *other_folder_owner_check;
+	GtkWidget *other_folder_contact_check;
+	GtkWidget *other_folder_visible_check;
+};
+
+static const struct EEwsPredefinedLevels {
+	const gchar *name;
+	uint32_t rights;
+} predefined_levels[] = {
+	{ NC_("PermissionsLevel", "None"), 0 },
+	{ NC_("PermissionsLevel", "Owner"),	E_EWS_PERMISSION_BIT_READ_ANY |
+						E_EWS_PERMISSION_BIT_CREATE |
+						E_EWS_PERMISSION_BIT_CREATE_SUBFOLDER |
+						E_EWS_PERMISSION_BIT_EDIT_OWNED |
+						E_EWS_PERMISSION_BIT_EDIT_ANY |
+						E_EWS_PERMISSION_BIT_DELETE_OWNED |
+						E_EWS_PERMISSION_BIT_DELETE_ANY |
+						E_EWS_PERMISSION_BIT_FOLDER_OWNER |
+						E_EWS_PERMISSION_BIT_FOLDER_CONTACT |
+						E_EWS_PERMISSION_BIT_FOLDER_VISIBLE },
+	{ NC_("PermissionsLevel", "Publishing Editor"),
+						E_EWS_PERMISSION_BIT_READ_ANY |
+						E_EWS_PERMISSION_BIT_CREATE |
+						E_EWS_PERMISSION_BIT_CREATE_SUBFOLDER |
+						E_EWS_PERMISSION_BIT_EDIT_OWNED |
+						E_EWS_PERMISSION_BIT_EDIT_ANY |
+						E_EWS_PERMISSION_BIT_DELETE_OWNED |
+						E_EWS_PERMISSION_BIT_DELETE_ANY |
+						E_EWS_PERMISSION_BIT_FOLDER_VISIBLE },
+	{ NC_("PermissionsLevel", "Editor"),
+						E_EWS_PERMISSION_BIT_READ_ANY |
+						E_EWS_PERMISSION_BIT_CREATE |
+						E_EWS_PERMISSION_BIT_EDIT_OWNED |
+						E_EWS_PERMISSION_BIT_EDIT_ANY |
+						E_EWS_PERMISSION_BIT_DELETE_OWNED |
+						E_EWS_PERMISSION_BIT_DELETE_ANY |
+						E_EWS_PERMISSION_BIT_FOLDER_VISIBLE },
+	{ NC_("PermissionsLevel", "Publishing Author"),
+						E_EWS_PERMISSION_BIT_READ_ANY |
+						E_EWS_PERMISSION_BIT_CREATE |
+						E_EWS_PERMISSION_BIT_CREATE_SUBFOLDER |
+						E_EWS_PERMISSION_BIT_EDIT_OWNED |
+						E_EWS_PERMISSION_BIT_DELETE_OWNED |
+						E_EWS_PERMISSION_BIT_FOLDER_VISIBLE },
+	{ NC_("PermissionsLevel", "Author"),
+						E_EWS_PERMISSION_BIT_READ_ANY |
+						E_EWS_PERMISSION_BIT_CREATE |
+						E_EWS_PERMISSION_BIT_EDIT_OWNED |
+						E_EWS_PERMISSION_BIT_DELETE_OWNED |
+						E_EWS_PERMISSION_BIT_FOLDER_VISIBLE },
+	{ NC_("PermissionsLevel", "Nonediting Author"),
+						E_EWS_PERMISSION_BIT_READ_ANY |
+						E_EWS_PERMISSION_BIT_CREATE |
+						E_EWS_PERMISSION_BIT_DELETE_OWNED |
+						E_EWS_PERMISSION_BIT_FOLDER_VISIBLE },
+	{ NC_("PermissionsLevel", "Reviewer"),
+						E_EWS_PERMISSION_BIT_READ_ANY |
+						E_EWS_PERMISSION_BIT_FOLDER_VISIBLE },
+	{ NC_("PermissionsLevel", "Contributor"),
+						E_EWS_PERMISSION_BIT_CREATE |
+						E_EWS_PERMISSION_BIT_FOLDER_VISIBLE },
+	{ NC_("PermissionsLevel", "Free/Busy time"),
+						E_EWS_PERMISSION_BIT_FREE_BUSY_SIMPLE },
+	{ NC_("PermissionsLevel", "Free/Busy time, subject, location"),
+						E_EWS_PERMISSION_BIT_FREE_BUSY_DETAILED },
+	{ NC_("PermissionsLevel", "Custom"), ~0 } /* make sure 'Custom' is always the last */
+};
+
+static void
+edit_permissions_widgets_free (gpointer ptr)
+{
+	struct EEwsPermissionsDialogWidgets *widgets = ptr;
+
+	if (!widgets)
+		return;
+
+	e_ews_folder_id_free (widgets->folder_id);
+	if (widgets->conn)
+		e_ews_config_utils_unref_in_thread (G_OBJECT (widgets->conn));
+	g_free (widgets->uri);
+	g_free (widgets->username);
+	g_free (widgets->impersonate_user);
+	g_free (widgets->password_key);
+	g_free (widgets->password_who_asks);
+	g_free (widgets);
+}
+
+static void
+folder_permissions_clear_all_permissions (GObject *dialog)
+{
+	struct EEwsPermissionsDialogWidgets *widgets;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+
+	g_return_if_fail (dialog != NULL);
+
+	widgets = g_object_get_data (dialog, E_EWS_PERM_DLG_WIDGETS);
+	g_return_if_fail (widgets != NULL);
+	g_return_if_fail (widgets->tree_view != NULL);
+
+	model = gtk_tree_view_get_model (GTK_TREE_VIEW (widgets->tree_view));
+	g_return_if_fail (model != NULL);
+
+	if (!gtk_tree_model_get_iter_first (model, &iter))
+		return;
+
+	do {
+		EEwsPermission *perm = NULL;
+
+		gtk_tree_model_get (model, &iter, COL_E_EWS_PERMISSION, &perm, -1);
+
+		e_ews_permission_free (perm);
+	} while (gtk_tree_model_iter_next (model, &iter));
+
+	gtk_list_store_clear (GTK_LIST_STORE (model));
+}
+
+static void
+write_folder_permissions_thread (GObject *dialog,
+                                 gpointer user_data,
+                                 GCancellable *cancellable,
+                                 GError **perror)
+{
+	struct EEwsPermissionsDialogWidgets *widgets;
+	const GSList *permissions = user_data;
+
+	g_return_if_fail (dialog != NULL);
+
+	if (g_cancellable_is_cancelled (cancellable))
+		return;
+
+	widgets = g_object_get_data (dialog, E_EWS_PERM_DLG_WIDGETS);
+	g_return_if_fail (widgets != NULL);
+	g_return_if_fail (widgets->conn != NULL);
+
+	e_ews_connection_set_folder_permissions_sync (
+		widgets->conn,
+		G_PRIORITY_DEFAULT, widgets->folder_id, widgets->folder_type, permissions, cancellable, perror);
+}
+
+static void
+write_folder_permissions_idle (GObject *dialog,
+                               gpointer user_data,
+                               GCancellable *cancellable,
+                               GError **perror)
+{
+	/* does this only if no error was raised from the thread function */
+	folder_permissions_clear_all_permissions (dialog);
+	gtk_widget_destroy (GTK_WIDGET (dialog));
+}
+
+static void
+edit_permissions_response_cb (GObject *dialog,
+                              gint response_id)
+{
+	struct EEwsPermissionsDialogWidgets *widgets;
+	GSList *write_permissions = NULL;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+
+	g_return_if_fail (dialog != NULL);
+
+	if (response_id != GTK_RESPONSE_OK) {
+		folder_permissions_clear_all_permissions (dialog);
+		gtk_widget_destroy (GTK_WIDGET (dialog));
+		return;
+	}
+
+	widgets = g_object_get_data (dialog, E_EWS_PERM_DLG_WIDGETS);
+	g_return_if_fail (widgets != NULL);
+	g_return_if_fail (widgets->tree_view != NULL);
+	g_return_if_fail (widgets->conn != NULL);
+
+	model = gtk_tree_view_get_model (GTK_TREE_VIEW (widgets->tree_view));
+	g_return_if_fail (model != NULL);
+
+	if (gtk_tree_model_get_iter_first (model, &iter)) {
+		do {
+			EEwsPermission *perm = NULL;
+
+			gtk_tree_model_get (model, &iter, COL_E_EWS_PERMISSION, &perm, -1);
+
+			if (perm)
+				write_permissions = g_slist_prepend (write_permissions, perm);
+		} while (gtk_tree_model_iter_next (model, &iter));
+
+		write_permissions = g_slist_reverse (write_permissions);
+	}
+
+	e_ews_config_utils_run_in_thread_with_feedback (
+		GTK_WINDOW (dialog), dialog,
+		_("Writing folder permissions, please wait..."),
+		write_folder_permissions_thread,
+		write_folder_permissions_idle,
+		write_permissions, (GDestroyNotify) g_slist_free);
+}
+
+static void
+enable_all_widgets (struct EEwsPermissionsDialogWidgets *widgets,
+                    gboolean enabled)
+{
+	g_return_if_fail (widgets != NULL);
+
+	gtk_widget_set_sensitive (widgets->add_button, enabled || gtk_widget_get_sensitive (widgets->tree_view));
+	gtk_widget_set_sensitive (widgets->remove_button, enabled);
+	gtk_widget_set_sensitive (widgets->level_combo, enabled);
+	gtk_widget_set_sensitive (widgets->read_none_radio, enabled);
+	gtk_widget_set_sensitive (widgets->read_full_radio, enabled);
+	if (widgets->read_fb_time_radio)
+		gtk_widget_set_sensitive (widgets->read_fb_time_radio, enabled);
+	if (widgets->read_fb_detail_radio)
+		gtk_widget_set_sensitive (widgets->read_fb_detail_radio, enabled);
+	gtk_widget_set_sensitive (widgets->write_create_items_check, enabled);
+	gtk_widget_set_sensitive (widgets->write_create_subfolders_check, enabled);
+	gtk_widget_set_sensitive (widgets->write_edit_own_check, enabled);
+	gtk_widget_set_sensitive (widgets->write_edit_all_check, enabled);
+	gtk_widget_set_sensitive (widgets->delete_none_radio, enabled);
+	gtk_widget_set_sensitive (widgets->delete_own_radio, enabled);
+	gtk_widget_set_sensitive (widgets->delete_all_radio, enabled);
+	gtk_widget_set_sensitive (widgets->other_folder_owner_check, enabled);
+	gtk_widget_set_sensitive (widgets->other_folder_contact_check, enabled);
+	gtk_widget_set_sensitive (widgets->other_folder_visible_check, enabled);
+}
+
+static uint32_t
+folder_permissions_dialog_to_rights (GObject *dialog)
+{
+	struct EEwsPermissionsDialogWidgets *widgets;
+	uint32_t rights;
+
+	g_return_val_if_fail (dialog != NULL, 0);
+
+	widgets = g_object_get_data (dialog, E_EWS_PERM_DLG_WIDGETS);
+	g_return_val_if_fail (widgets != NULL, 0);
+
+	#define set_bit_by_active(x, bt) G_STMT_START {					\
+		if (widgets->x &&							\
+		    gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widgets->x)) &&	\
+		    gtk_widget_get_sensitive (widgets->x)) {				\
+			rights |= bt;							\
+		} } G_STMT_END
+
+	rights = 0;
+
+	set_bit_by_active (read_none_radio, 0);
+	set_bit_by_active (read_full_radio, E_EWS_PERMISSION_BIT_READ_ANY);
+	set_bit_by_active (read_fb_time_radio, E_EWS_PERMISSION_BIT_FREE_BUSY_SIMPLE);
+	set_bit_by_active (read_fb_detail_radio, E_EWS_PERMISSION_BIT_FREE_BUSY_DETAILED);
+	set_bit_by_active (write_create_items_check, E_EWS_PERMISSION_BIT_CREATE);
+	set_bit_by_active (write_create_subfolders_check, E_EWS_PERMISSION_BIT_CREATE_SUBFOLDER);
+	set_bit_by_active (write_edit_own_check, E_EWS_PERMISSION_BIT_EDIT_OWNED);
+	set_bit_by_active (write_edit_all_check, E_EWS_PERMISSION_BIT_EDIT_ANY | E_EWS_PERMISSION_BIT_EDIT_OWNED);
+	set_bit_by_active (delete_none_radio, 0);
+	set_bit_by_active (delete_own_radio, E_EWS_PERMISSION_BIT_DELETE_OWNED);
+	set_bit_by_active (delete_all_radio, E_EWS_PERMISSION_BIT_DELETE_ANY | E_EWS_PERMISSION_BIT_DELETE_OWNED);
+	set_bit_by_active (other_folder_owner_check, E_EWS_PERMISSION_BIT_FOLDER_OWNER);
+	set_bit_by_active (other_folder_contact_check, E_EWS_PERMISSION_BIT_FOLDER_CONTACT);
+	set_bit_by_active (other_folder_visible_check, E_EWS_PERMISSION_BIT_FOLDER_VISIBLE);
+
+	#undef set_bit_by_active
+
+	return rights;
+}
+
+static void
+update_folder_permissions_sensitivity (GObject *dialog,
+                                       gboolean member_valid,
+                                       EEwsPermissionUserType user_type)
+{
+	struct EEwsPermissionsDialogWidgets *widgets;
+
+	g_return_if_fail (dialog != NULL);
+
+	widgets = g_object_get_data (dialog, E_EWS_PERM_DLG_WIDGETS);
+	g_return_if_fail (widgets != NULL);
+
+	enable_all_widgets (widgets, member_valid);
+
+	if (user_type == E_EWS_PERMISSION_USER_TYPE_DEFAULT ||
+	    user_type == E_EWS_PERMISSION_USER_TYPE_ANONYMOUS)
+		gtk_widget_set_sensitive (widgets->other_folder_contact_check, FALSE);
+
+	if (member_valid)
+		gtk_widget_set_sensitive (
+			widgets->remove_button,
+			user_type != E_EWS_PERMISSION_USER_TYPE_DEFAULT &&
+			user_type != E_EWS_PERMISSION_USER_TYPE_ANONYMOUS);
+
+	if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widgets->write_edit_all_check))) {
+		gtk_widget_set_sensitive (widgets->write_edit_own_check, FALSE);
+		gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widgets->write_edit_own_check), TRUE);
+	}
+}
+
+static void
+update_folder_permissions_by_rights (GObject *dialog,
+                                     uint32_t rights)
+{
+	struct EEwsPermissionsDialogWidgets *widgets;
+
+	g_return_if_fail (dialog != NULL);
+
+	widgets = g_object_get_data (dialog, E_EWS_PERM_DLG_WIDGETS);
+	g_return_if_fail (widgets != NULL);
+
+	#define set_active(x, act) G_STMT_START { if (widgets->x) gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widgets->x), act); } G_STMT_END
+	#define set_active_by_bit(x, bt) set_active (x, (rights & (bt)) != 0)
+
+	widgets->updating++;
+
+	set_active (read_none_radio, TRUE);
+	set_active_by_bit (read_full_radio, E_EWS_PERMISSION_BIT_READ_ANY);
+	set_active_by_bit (read_fb_time_radio, E_EWS_PERMISSION_BIT_FREE_BUSY_SIMPLE);
+	set_active_by_bit (read_fb_detail_radio, E_EWS_PERMISSION_BIT_FREE_BUSY_DETAILED);
+	set_active_by_bit (write_create_items_check, E_EWS_PERMISSION_BIT_CREATE);
+	set_active_by_bit (write_create_subfolders_check, E_EWS_PERMISSION_BIT_CREATE_SUBFOLDER);
+	set_active_by_bit (write_edit_own_check, E_EWS_PERMISSION_BIT_EDIT_OWNED | E_EWS_PERMISSION_BIT_EDIT_ANY);
+	set_active_by_bit (write_edit_all_check, E_EWS_PERMISSION_BIT_EDIT_ANY);
+	set_active (delete_none_radio, TRUE);
+	set_active_by_bit (delete_own_radio, E_EWS_PERMISSION_BIT_DELETE_OWNED);
+	set_active_by_bit (delete_all_radio, E_EWS_PERMISSION_BIT_DELETE_ANY);
+	set_active_by_bit (other_folder_owner_check, E_EWS_PERMISSION_BIT_FOLDER_OWNER);
+	set_active_by_bit (other_folder_contact_check, E_EWS_PERMISSION_BIT_FOLDER_CONTACT);
+	set_active_by_bit (other_folder_visible_check, E_EWS_PERMISSION_BIT_FOLDER_VISIBLE);
+
+	if (!gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widgets->write_edit_all_check)) &&
+	    gtk_widget_get_sensitive (widgets->write_edit_all_check)) {
+		gtk_widget_set_sensitive (widgets->write_edit_own_check, TRUE);
+	} else if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widgets->write_edit_all_check))) {
+		gtk_widget_set_sensitive (widgets->write_edit_own_check, FALSE);
+		gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widgets->write_edit_own_check), TRUE);
+	}
+
+	widgets->updating--;
+
+	#undef set_active_by_bit
+	#undef set_active
+}
+
+static void
+update_folder_permissions_tree_view (GObject *dialog,
+                                     struct EEwsPermissionsDialogWidgets *widgets)
+{
+	GtkTreeSelection *selection;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+	uint32_t rights;
+
+	g_return_if_fail (dialog != NULL);
+	g_return_if_fail (widgets != NULL);
+
+	selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (widgets->tree_view));
+	if (selection && gtk_tree_selection_get_selected (selection, &model, &iter)) {
+		gchar *combo_text;
+		EEwsPermission *perm = NULL;
+
+		combo_text = gtk_combo_box_get_active_text (GTK_COMBO_BOX (widgets->level_combo));
+		rights = folder_permissions_dialog_to_rights (dialog);
+
+		gtk_tree_model_get (model, &iter, COL_E_EWS_PERMISSION, &perm, -1);
+
+		if (perm) {
+			if (!widgets->read_fb_time_radio)
+				rights = rights | (perm->rights & (E_EWS_PERMISSION_BIT_FREE_BUSY_DETAILED | E_EWS_PERMISSION_BIT_FREE_BUSY_SIMPLE));
+
+			perm->rights = rights;
+
+			gtk_list_store_set (GTK_LIST_STORE (model), &iter, COL_PERMISSION_LEVEL, combo_text, -1);
+		}
+
+		g_free (combo_text);
+	}
+}
+
+static void
+update_permission_level_combo_by_dialog (GObject *dialog)
+{
+	struct EEwsPermissionsDialogWidgets *widgets;
+	uint32_t rights;
+	gint ii;
+
+	g_return_if_fail (dialog != NULL);
+
+	widgets = g_object_get_data (dialog, E_EWS_PERM_DLG_WIDGETS);
+	g_return_if_fail (widgets != NULL);
+
+	if (widgets->updating)
+		return;
+
+	rights = folder_permissions_dialog_to_rights (dialog);
+	if (!widgets->read_fb_time_radio)
+		rights = rights & ~(E_EWS_PERMISSION_BIT_FREE_BUSY_DETAILED |
+			E_EWS_PERMISSION_BIT_FREE_BUSY_SIMPLE);
+
+	for (ii = 0; ii < G_N_ELEMENTS (predefined_levels) - 1; ii++) {
+		if (predefined_levels[ii].rights == rights) {
+			break;
+		}
+	}
+
+	if (!widgets->read_fb_time_radio && ii > G_N_ELEMENTS (predefined_levels) - 3)
+		ii = G_N_ELEMENTS (predefined_levels) - 3;
+
+	/* ii points to the matched or the last item, which is 'Custom' */
+	widgets->updating++;
+	gtk_combo_box_set_active (GTK_COMBO_BOX (widgets->level_combo), ii);
+
+	if (!gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widgets->write_edit_all_check)) &&
+	    gtk_widget_get_sensitive (widgets->write_edit_all_check)) {
+		gtk_widget_set_sensitive (widgets->write_edit_own_check, TRUE);
+		if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widgets->write_edit_own_check))) {
+			rights |= E_EWS_PERMISSION_BIT_EDIT_OWNED;
+
+			for (ii = 0; ii < G_N_ELEMENTS (predefined_levels) - 1; ii++) {
+				if (predefined_levels[ii].rights == rights) {
+					break;
+				}
+			}
+
+			if (!widgets->read_fb_time_radio && ii > G_N_ELEMENTS (predefined_levels) - 3)
+				ii = G_N_ELEMENTS (predefined_levels) - 3;
+
+			gtk_combo_box_set_active (GTK_COMBO_BOX (widgets->level_combo), ii);
+		}
+	} else if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widgets->write_edit_all_check))) {
+		gtk_widget_set_sensitive (widgets->write_edit_own_check, FALSE);
+		gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widgets->write_edit_own_check), TRUE);
+	}
+
+	update_folder_permissions_tree_view (dialog, widgets);
+
+	widgets->updating--;
+}
+
+static void
+update_permission_dialog_by_level_combo (GObject *dialog)
+{
+	struct EEwsPermissionsDialogWidgets *widgets;
+	uint32_t rights;
+	gint ii;
+
+	g_return_if_fail (dialog != NULL);
+
+	widgets = g_object_get_data (dialog, E_EWS_PERM_DLG_WIDGETS);
+	g_return_if_fail (widgets != NULL);
+
+	if (widgets->updating)
+		return;
+
+	ii = gtk_combo_box_get_active (GTK_COMBO_BOX (widgets->level_combo));
+	/* out of bounds or 'Customs' level, or 'Custom' without free/busy checks */
+	if (ii < 0 || ii >= G_N_ELEMENTS (predefined_levels) - 1 ||
+	    (!widgets->read_fb_time_radio && ii >= G_N_ELEMENTS (predefined_levels) - 3))
+		return;
+
+	rights = folder_permissions_dialog_to_rights (dialog);
+	rights = predefined_levels[ii].rights | (rights & (E_EWS_PERMISSION_BIT_FREE_BUSY_DETAILED |
+		E_EWS_PERMISSION_BIT_FREE_BUSY_SIMPLE));
+
+	widgets->updating++;
+	update_folder_permissions_by_rights (dialog, rights);
+	update_folder_permissions_tree_view (dialog, widgets);
+	widgets->updating--;
+}
+
+static void
+add_button_clicked_cb (GObject *dialog)
+{
+	struct EEwsPermissionsDialogWidgets *widgets;
+	gchar *display_name = NULL;
+	gchar *primary_smtp = NULL;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+
+	g_return_if_fail (dialog != NULL);
+
+	widgets = g_object_get_data (dialog, E_EWS_PERM_DLG_WIDGETS);
+	g_return_if_fail (widgets != NULL);
+
+	if (widgets->updating)
+		return;
+
+	g_return_if_fail (widgets->tree_view != NULL);
+
+	model = gtk_tree_view_get_model (GTK_TREE_VIEW (widgets->tree_view));
+	g_return_if_fail (model != NULL);
+
+	if (e_ews_search_user_modal (GTK_WINDOW (dialog), widgets->conn, NULL, &display_name, &primary_smtp)) {
+		EEwsPermission *perm;
+		GtkTreeSelection *selection;
+		gboolean found = FALSE;
+
+		selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (widgets->tree_view));
+		g_return_if_fail (selection != NULL);
+
+		if (gtk_tree_model_get_iter_first (model, &iter)) {
+			do {
+				EEwsPermissionUserType ut = E_EWS_PERMISSION_USER_TYPE_NONE;
+
+				perm = NULL;
+
+				gtk_tree_model_get (
+					model, &iter,
+					COL_E_EWS_PERMISSION, &perm,
+					COL_E_EWS_PERMISSION_USER_TYPE, &ut,
+					-1);
+
+				if (ut == E_EWS_PERMISSION_USER_TYPE_REGULAR && perm && g_strcmp0 (perm->primary_smtp, primary_smtp)) {
+					gtk_tree_selection_select_iter (selection, &iter);
+					found = TRUE;
+					break;
+				}
+			} while (gtk_tree_model_iter_next (model, &iter));
+		}
+
+		if (!found) {
+			GtkListStore *store = GTK_LIST_STORE (model);
+
+			perm = e_ews_permission_new (
+				E_EWS_PERMISSION_USER_TYPE_REGULAR,
+				display_name, primary_smtp, NULL,
+				widgets->read_fb_time_radio ? E_EWS_PERMISSION_BIT_FREE_BUSY_SIMPLE : 0);
+
+			gtk_list_store_append (store, &iter);
+			gtk_list_store_set (
+				store, &iter,
+				COL_NAME, perm->display_name,
+				COL_PERMISSION_LEVEL, g_dpgettext2 (GETTEXT_PACKAGE, "PermissionsLevel", predefined_levels[0].name),
+				COL_E_EWS_PERMISSION, perm,
+				COL_E_EWS_PERMISSION_USER_TYPE, E_EWS_PERMISSION_USER_TYPE_REGULAR,
+				COL_IS_NEW, TRUE,
+				-1);
+
+			gtk_tree_selection_select_iter (selection, &iter);
+		}
+	}
+
+	g_free (display_name);
+	g_free (primary_smtp);
+}
+
+static void
+remove_button_clicked_cb (GObject *dialog)
+{
+	struct EEwsPermissionsDialogWidgets *widgets;
+	GtkTreeSelection *selection;
+	GtkTreeModel *model = NULL;
+	GtkTreeIter iter;
+
+	g_return_if_fail (dialog != NULL);
+
+	widgets = g_object_get_data (dialog, E_EWS_PERM_DLG_WIDGETS);
+	g_return_if_fail (widgets != NULL);
+
+	if (widgets->updating)
+		return;
+
+	selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (widgets->tree_view));
+	if (selection && gtk_tree_selection_get_selected (selection, &model, &iter)) {
+		GtkTreeIter select;
+		gboolean can_select = FALSE;
+		EEwsPermission *perm = NULL;
+
+		select = iter;
+		can_select = gtk_tree_model_iter_next (model, &select);
+
+		if (can_select)
+			gtk_tree_selection_select_iter (selection, &select);
+
+		gtk_tree_model_get (model, &iter, COL_E_EWS_PERMISSION, &perm, -1);
+
+		if (gtk_list_store_remove (GTK_LIST_STORE (model), &iter))
+			e_ews_permission_free (perm);
+	}
+}
+
+static void
+folder_permissions_free_found_permissions (gpointer ptr)
+{
+	GSList **ppermissions = ptr;
+
+	if (!ppermissions)
+		return;
+
+	e_ews_permissions_free (*ppermissions);
+	*ppermissions = NULL;
+	g_free (ppermissions);
+}
+
+#define EXCHANGE_EWS_PASSWORD_COMPONENT "Exchange Web Services"
+
+static void
+ews_edit_folder_permissions_authenticate_cb (EEwsConnection *cnc,
+					     SoupMessage *msg,
+					     SoupAuth *auth,
+					     gboolean retrying,
+					     gpointer user_data)
+{
+	struct EEwsPermissionsDialogWidgets *widgets = user_data;
+	gchar *password = NULL;
+
+	if (!retrying)
+		password = e_passwords_get_password (EXCHANGE_EWS_PASSWORD_COMPONENT, widgets->password_key);
+	if (!password || !*password) {
+		gboolean remember = widgets->password_remember;
+		gchar *title;
+
+		g_free (password);
+		title = g_strdup_printf (_("Enter Password for %s"), widgets->password_who_asks);
+		password = e_passwords_ask_password (title, EXCHANGE_EWS_PASSWORD_COMPONENT, widgets->password_key, title,
+                                                    E_PASSWORDS_REMEMBER_FOREVER|E_PASSWORDS_SECRET,
+						     &remember, NULL);
+		g_free (title);
+
+		if (password && remember)
+			e_passwords_remember_password (EXCHANGE_EWS_PASSWORD_COMPONENT, widgets->password_key);
+	}
+
+	if (!password || !*password) {
+		e_passwords_forget_password (EXCHANGE_EWS_PASSWORD_COMPONENT, widgets->password_key);
+		g_free (password);
+		password = NULL;
+	}
+
+	e_ews_connection_authenticate (cnc, auth, widgets->username,
+				       password, NULL);
+
+	g_free (password);
+}
+
+static void
+read_folder_permissions_thread (GObject *dialog,
+                                gpointer user_data,
+                                GCancellable *cancellable,
+                                GError **perror)
+{
+	struct EEwsPermissionsDialogWidgets *widgets;
+	GSList **ppermissions = user_data;
+
+	g_return_if_fail (dialog != NULL);
+	g_return_if_fail (ppermissions != NULL);
+
+	if (g_cancellable_is_cancelled (cancellable))
+		return;
+
+	widgets = g_object_get_data (dialog, E_EWS_PERM_DLG_WIDGETS);
+	g_return_if_fail (widgets != NULL);
+	g_return_if_fail (widgets->folder_id != NULL);
+
+	widgets->conn = e_ews_connection_new (
+		widgets->uri,
+		widgets->username,
+		NULL,
+		NULL,
+		widgets->impersonate_user,
+		widgets->timeout,
+		TRUE,
+		G_CALLBACK (ews_edit_folder_permissions_authenticate_cb),
+		widgets,
+		perror);
+
+	if (!widgets->conn)
+		g_cancellable_cancel (cancellable);
+
+	if (g_cancellable_is_cancelled (cancellable))
+		return;
+
+	if (e_ews_connection_get_folder_permissions_sync (
+		widgets->conn,
+		G_PRIORITY_DEFAULT, widgets->folder_id, ppermissions, cancellable, perror)) {
+		EEwsFolder *folder = NULL;
+
+		e_ews_connection_get_folder_info_sync (widgets->conn,
+			G_PRIORITY_DEFAULT, NULL, widgets->folder_id,
+			&folder, cancellable, NULL);
+
+		if (folder) {
+			const EwsFolderId *folder_id = e_ews_folder_get_id (folder);
+
+			if (folder_id) {
+				g_free (widgets->folder_id->change_key);
+				widgets->folder_id->change_key = g_strdup (folder_id->change_key);
+			}
+
+			g_object_unref (folder);
+		}
+	}
+}
+
+static void
+read_folder_permissions_idle (GObject *dialog,
+                              gpointer user_data,
+                              GCancellable *cancellable,
+                              GError **perror)
+{
+	struct EEwsPermissionsDialogWidgets *widgets;
+	GSList **ppermissions = user_data;
+	GSList *permiter;
+	GtkListStore *store;
+	GtkTreeIter iter;
+
+	g_return_if_fail (dialog != NULL);
+	g_return_if_fail (ppermissions != NULL);
+
+	if (g_cancellable_is_cancelled (cancellable))
+		return;
+
+	widgets = g_object_get_data (dialog, E_EWS_PERM_DLG_WIDGETS);
+	g_return_if_fail (widgets != NULL);
+	g_return_if_fail (widgets->tree_view != NULL);
+
+	store = GTK_LIST_STORE (gtk_tree_view_get_model (GTK_TREE_VIEW (widgets->tree_view)));
+	g_return_if_fail (store != NULL);
+
+	for (permiter = *ppermissions; permiter; permiter = permiter->next) {
+		EEwsPermission *perm = permiter->data;
+		const gchar *perm_level;
+		uint32_t rights;
+		gint ii;
+
+		if (!perm)
+			continue;
+
+		/* steal the perm */
+		permiter->data = NULL;
+
+		rights = perm->rights;
+		if (!widgets->read_fb_time_radio) {
+			rights = rights & ~(E_EWS_PERMISSION_BIT_FREE_BUSY_DETAILED |
+				E_EWS_PERMISSION_BIT_FREE_BUSY_SIMPLE);
+		}
+
+		for (ii = 0; ii < G_N_ELEMENTS (predefined_levels) - 1; ii++) {
+			if (predefined_levels[ii].rights == rights) {
+				break;
+			}
+		}
+
+		if (perm->user_type == E_EWS_PERMISSION_USER_TYPE_ANONYMOUS) {
+			g_free (perm->display_name);
+			perm->display_name = g_strdup (C_("User", "Anonymous"));
+		} else if (perm->user_type == E_EWS_PERMISSION_USER_TYPE_DEFAULT) {
+			g_free (perm->display_name);
+			perm->display_name = g_strdup (C_("User", "Default"));
+		} else if (!perm->display_name || !*perm->display_name) {
+			const gchar *display_name;
+
+			display_name = perm->primary_smtp;
+			if (!display_name)
+				display_name = C_("User", "Unknown");
+
+			g_free (perm->display_name);
+			perm->display_name = g_strdup (display_name);
+		}
+
+		perm_level = g_dpgettext2 (GETTEXT_PACKAGE, "PermissionsLevel", predefined_levels[ii].name);
+
+		gtk_list_store_append (store, &iter);
+		gtk_list_store_set (
+			store, &iter,
+			COL_NAME, perm->display_name,
+			COL_PERMISSION_LEVEL, perm_level,
+			COL_E_EWS_PERMISSION, perm,
+			COL_E_EWS_PERMISSION_USER_TYPE, perm->user_type,
+			COL_IS_NEW, FALSE,
+			-1);
+	}
+
+	gtk_widget_set_sensitive (widgets->add_button, TRUE);
+	gtk_dialog_set_response_sensitive (GTK_DIALOG (widgets->dialog), GTK_RESPONSE_OK, TRUE);
+}
+
+static void
+folder_permissions_tree_selection_changed_cb (GtkTreeSelection *selection,
+                                              struct EEwsPermissionsDialogWidgets *widgets)
+{
+	GObject *dialog;
+	GtkTreeModel *model = NULL;
+	GtkTreeIter iter;
+	gboolean has_selected;
+
+	g_return_if_fail (selection != NULL);
+	g_return_if_fail (widgets != NULL);
+	g_return_if_fail (widgets->dialog != NULL);
+	g_return_if_fail (widgets->add_button != NULL);
+	g_return_if_fail (widgets->remove_button != NULL);
+
+	dialog = G_OBJECT (widgets->dialog);
+	has_selected = gtk_tree_selection_get_selected (selection, &model, &iter);
+
+	gtk_widget_set_sensitive (widgets->add_button, TRUE);
+	gtk_widget_set_sensitive (widgets->remove_button, has_selected);
+
+	if (has_selected) {
+		EEwsPermissionUserType user_type = E_EWS_PERMISSION_USER_TYPE_NONE;
+		EEwsPermission *perm = NULL;
+
+		gtk_tree_model_get (
+			model, &iter,
+			COL_E_EWS_PERMISSION, &perm,
+			COL_E_EWS_PERMISSION_USER_TYPE, &user_type,
+			-1);
+
+		update_folder_permissions_sensitivity (dialog, perm != NULL, user_type);
+		update_folder_permissions_by_rights (dialog, perm ? perm->rights : 0);
+	} else {
+		update_folder_permissions_sensitivity (dialog, FALSE, E_EWS_PERMISSION_USER_TYPE_NONE);
+		update_folder_permissions_by_rights (dialog, 0);
+	}
+
+	update_permission_level_combo_by_dialog (dialog);
+}
+
+static GtkWidget *
+create_permissions_tree_view (GObject *dialog,
+                              struct EEwsPermissionsDialogWidgets *widgets)
+{
+	GtkTreeView *tree_view;
+	GtkTreeSelection *selection;
+	GtkCellRenderer *renderer;
+	GtkTreeViewColumn *column;
+	gint pos;
+
+	g_return_val_if_fail (widgets != NULL, NULL);
+
+	tree_view = GTK_TREE_VIEW (gtk_tree_view_new_with_model (
+		GTK_TREE_MODEL (gtk_list_store_new (5, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_POINTER, G_TYPE_UINT, G_TYPE_BOOLEAN))));
+
+	renderer = gtk_cell_renderer_text_new ();
+	g_object_set (renderer, "editable", FALSE, NULL);
+	pos = gtk_tree_view_insert_column_with_attributes (tree_view, -1, _("Name"), renderer, "text", COL_NAME, NULL);
+	column = gtk_tree_view_get_column (tree_view, pos - 1);
+	gtk_tree_view_column_set_expand (column, TRUE);
+
+	renderer = gtk_cell_renderer_text_new ();
+	g_object_set (renderer, "editable", FALSE, NULL);
+	gtk_tree_view_insert_column_with_attributes (tree_view, -1, _("Permission level"), renderer, "text", COL_PERMISSION_LEVEL, NULL);
+
+	selection = gtk_tree_view_get_selection (tree_view);
+	gtk_tree_selection_set_mode (selection, GTK_SELECTION_SINGLE);
+	g_signal_connect (selection, "changed", G_CALLBACK (folder_permissions_tree_selection_changed_cb), widgets);
+
+	widgets->tree_view = GTK_WIDGET (tree_view);
+
+	return widgets->tree_view;
+}
+
+/* Opens dialog to subscribe to folders of other
+ * users in the given store */
+void
+e_ews_edit_folder_permissions (GtkWindow *parent,
+			       const gchar *uri,
+			       const gchar *username,
+			       const gchar *impersonate_user,
+			       gint timeout,
+			       const gchar *password_key,
+			       gboolean password_remember,
+			       const gchar *password_who_asks,
+                               const gchar *account_name,
+                               const gchar *folder_name,
+                               const EwsFolderId *folder_id,
+                               EEwsFolderType folder_type)
+{
+	struct EEwsPermissionsDialogWidgets *widgets;
+	PangoAttrList *attrs;
+	GObject *dialog;
+	GtkWidget *content;
+	GtkWidget *label, *widget, *button, *frame, *hvbox;
+	GtkScrolledWindow *scrolled_window;
+	GtkComboBox *combo_text;
+	GtkTable *table;
+	GSList *radio_group, **found_permissions;
+	gboolean with_freebusy;
+	gint row, ii;
+
+	g_return_if_fail (uri != NULL);
+	g_return_if_fail (username != NULL);
+	g_return_if_fail (account_name != NULL);
+	g_return_if_fail (folder_name != NULL);
+	g_return_if_fail (folder_id != NULL);
+
+	with_freebusy = folder_type == E_EWS_FOLDER_TYPE_CALENDAR;
+
+	widgets = g_new0 (struct EEwsPermissionsDialogWidgets, 1);
+	widgets->uri = g_strdup (uri);
+	widgets->username = g_strdup (username);
+	widgets->impersonate_user = g_strdup (impersonate_user);
+	widgets->timeout = timeout;
+	widgets->password_key = g_strdup (password_key);
+	widgets->password_remember = password_remember;
+	widgets->password_who_asks = g_strdup (password_who_asks);
+	widgets->folder_id = e_ews_folder_id_new (folder_id->id, folder_id->change_key, folder_id->is_distinguished_id);
+	widgets->folder_type = folder_type;
+
+	widgets->dialog = gtk_dialog_new_with_buttons (
+		_("Edit EWS folder permissions..."),
+		parent,
+		GTK_DIALOG_DESTROY_WITH_PARENT,
+		GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+		GTK_STOCK_OK, GTK_RESPONSE_OK,
+		NULL);
+
+	dialog = G_OBJECT (widgets->dialog);
+	gtk_dialog_set_has_separator (GTK_DIALOG (dialog), FALSE);
+	g_signal_connect (dialog, "response", G_CALLBACK (edit_permissions_response_cb), NULL);
+	g_object_set_data_full (dialog, E_EWS_PERM_DLG_WIDGETS, widgets, edit_permissions_widgets_free);
+
+	gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_OK);
+
+	content = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
+
+	table = GTK_TABLE (gtk_table_new (5, 2, FALSE));
+	gtk_table_set_row_spacings (table, 6);
+	gtk_table_set_col_spacings (table, 6);
+	gtk_container_set_border_width (GTK_CONTAINER (table), 12);
+	gtk_container_add (GTK_CONTAINER (content), GTK_WIDGET (table));
+
+	row = 0;
+
+	label = gtk_label_new (_("Account:"));
+	g_object_set (
+		G_OBJECT (label),
+		"xalign", 0.0,
+		NULL);
+
+	attrs = pango_attr_list_new ();
+	pango_attr_list_insert (attrs, pango_attr_weight_new (PANGO_WEIGHT_BOLD));
+	widget = gtk_label_new (account_name);
+	g_object_set (
+		G_OBJECT (widget),
+		"use-underline", FALSE,
+		"attributes", attrs,
+		"xalign", 0.0,
+		NULL);
+	pango_attr_list_unref (attrs);
+
+	gtk_table_attach (table, label, 0, 1, row, row + 1, 0, 0, 0, 0);
+	gtk_table_attach (table, widget, 1, 2, row, row + 1, GTK_EXPAND | GTK_FILL, 0, 0, 0);
+
+	row++;
+
+	label = gtk_label_new (_("Folder name:"));
+	g_object_set (
+		G_OBJECT (label),
+		"xalign", 0.0,
+		NULL);
+
+	widget = gtk_label_new (folder_name);
+	gtk_label_set_ellipsize (GTK_LABEL (widget), PANGO_ELLIPSIZE_MIDDLE);
+	gtk_widget_set_tooltip_text (widget, folder_name);
+	g_object_set (
+		G_OBJECT (widget),
+		"xalign", 0.0,
+		NULL);
+
+	gtk_table_attach (table, label, 0, 1, row, row + 1, 0, 0, 0, 0);
+	gtk_table_attach (table, widget, 1, 2, row, row + 1, GTK_EXPAND | GTK_FILL, 0, 0, 0);
+
+	row++;
+
+	label = gtk_label_new (_("Folder ID:"));
+	g_object_set (
+		G_OBJECT (label),
+		"xalign", 0.0,
+		NULL);
+
+	widget = gtk_entry_new ();
+	g_object_set (
+		G_OBJECT (widget),
+		"xalign", 0.0,
+		"has-frame", FALSE,
+		"editable", FALSE,
+		"can-focus", FALSE,
+		"text", folder_id->id,
+		NULL);
+
+	gtk_table_attach (table, label, 0, 1, row, row + 1, 0, 0, 0, 0);
+	gtk_table_attach (table, widget, 1, 2, row, row + 1, GTK_EXPAND | GTK_FILL, 0, 0, 0);
+
+	row++;
+
+	widget = gtk_scrolled_window_new (NULL, NULL);
+	scrolled_window = GTK_SCROLLED_WINDOW (widget);
+	gtk_widget_set_size_request (widget, 120, 120);
+	gtk_container_add (GTK_CONTAINER (widget), create_permissions_tree_view (dialog, widgets));
+	g_object_set (
+		G_OBJECT (widget),
+		"shadow-type", GTK_SHADOW_IN,
+		"hscrollbar-policy", GTK_POLICY_AUTOMATIC,
+		"vscrollbar-policy", GTK_POLICY_AUTOMATIC,
+		NULL);
+
+	gtk_table_attach (table, widget, 0, 2, row, row + 1, GTK_EXPAND | GTK_FILL, GTK_EXPAND | GTK_FILL, 0, 0);
+
+	row++;
+
+	hvbox = gtk_hbox_new (TRUE, 6);
+
+	button = gtk_button_new_from_stock (GTK_STOCK_ADD);
+	widgets->add_button = button;
+	gtk_box_pack_start (GTK_BOX (hvbox), button, TRUE, FALSE, 0);
+
+	button = gtk_button_new_from_stock (GTK_STOCK_REMOVE);
+	widgets->remove_button = button;
+	gtk_box_pack_start (GTK_BOX (hvbox), button, FALSE, FALSE, 0);
+
+	gtk_table_attach (table, hvbox, 0, 2, row, row + 1, GTK_EXPAND, 0, 0, 0);
+
+	row++;
+
+	widget = gtk_frame_new (_("Permissions"));
+	gtk_table_attach (table, widget, 0, 2, row, row + 1, GTK_EXPAND | GTK_FILL, 0, 0, 0);
+
+	table = GTK_TABLE (gtk_table_new (3, 2, FALSE));
+	gtk_table_set_row_spacings (table, 6);
+	gtk_table_set_col_spacings (table, 6);
+	gtk_container_set_border_width (GTK_CONTAINER (table), 12);
+	gtk_container_add (GTK_CONTAINER (widget), GTK_WIDGET (table));
+
+	row = 0;
+
+	hvbox = gtk_hbox_new (FALSE, 6);
+
+	label = gtk_label_new_with_mnemonic (_("Permi_ssion level:"));
+	g_object_set (
+		G_OBJECT (label),
+		"xalign", 0.0,
+		NULL);
+
+	widget = gtk_combo_box_new_text ();
+	widgets->level_combo = widget;
+
+	combo_text = GTK_COMBO_BOX (widget);
+	for (ii = 0; ii < G_N_ELEMENTS (predefined_levels); ii++) {
+		if (with_freebusy ||
+		    (predefined_levels[ii].rights != E_EWS_PERMISSION_BIT_FREE_BUSY_SIMPLE &&
+		     predefined_levels[ii].rights != E_EWS_PERMISSION_BIT_FREE_BUSY_DETAILED))
+			gtk_combo_box_append_text (combo_text, g_dpgettext2 (GETTEXT_PACKAGE, "PermissionsLevel", predefined_levels[ii].name));
+	}
+	gtk_combo_box_set_active (combo_text, 0);
+
+	gtk_label_set_mnemonic_widget (GTK_LABEL (label), widget);
+	gtk_container_add (GTK_CONTAINER (hvbox), label);
+	gtk_container_add (GTK_CONTAINER (hvbox), widget);
+
+	gtk_table_attach (table, hvbox, 0, 2, row, row + 1, GTK_EXPAND | GTK_FILL, 0, 0, 0);
+
+	row++;
+
+	frame = gtk_frame_new (C_("Permissions", "Read"));
+
+	hvbox = gtk_vbox_new (FALSE, 2);
+	gtk_container_add (GTK_CONTAINER (frame), hvbox);
+
+	widget = gtk_radio_button_new_with_label (NULL, C_("Permissions", "None"));
+	widgets->read_none_radio = widget;
+	radio_group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (widget));
+	gtk_box_pack_start (GTK_BOX (hvbox), widget, FALSE, FALSE, 0);
+
+	if (with_freebusy) {
+		widget = gtk_radio_button_new_with_label (radio_group, C_("Permissions", "Free/Busy time"));
+		widgets->read_fb_time_radio = widget;
+		radio_group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (widget));
+		gtk_box_pack_start (GTK_BOX (hvbox), widget, FALSE, FALSE, 0);
+
+		widget = gtk_radio_button_new_with_label (radio_group, C_("Permissions", "Free/Busy time, subject, location"));
+		widgets->read_fb_detail_radio = widget;
+		radio_group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (widget));
+		gtk_box_pack_start (GTK_BOX (hvbox), widget, FALSE, FALSE, 0);
+	}
+
+	widget = gtk_radio_button_new_with_label (radio_group, C_("Permissions", "Full Details"));
+	widgets->read_full_radio = widget;
+	gtk_box_pack_start (GTK_BOX (hvbox), widget, FALSE, FALSE, 0);
+
+	gtk_table_attach (table, frame, 0, 1, row, row + 1, GTK_EXPAND | GTK_FILL, GTK_EXPAND | GTK_FILL, 0, 0);
+
+	frame = gtk_frame_new (C_("Permissions", "Write"));
+
+	hvbox = gtk_vbox_new (FALSE, 2);
+	gtk_container_add (GTK_CONTAINER (frame), hvbox);
+
+	widget = gtk_check_button_new_with_label (C_("Permissions", "Create items"));
+	widgets->write_create_items_check = widget;
+	gtk_container_add (GTK_CONTAINER (hvbox), widget);
+
+	widget = gtk_check_button_new_with_label (C_("Permissions", "Create subfolders"));
+	widgets->write_create_subfolders_check = widget;
+	gtk_container_add (GTK_CONTAINER (hvbox), widget);
+
+	widget = gtk_check_button_new_with_label (C_("Permissions", "Edit own"));
+	widgets->write_edit_own_check = widget;
+	gtk_container_add (GTK_CONTAINER (hvbox), widget);
+
+	widget = gtk_check_button_new_with_label (C_("Permissions", "Edit all"));
+	widgets->write_edit_all_check = widget;
+	gtk_container_add (GTK_CONTAINER (hvbox), widget);
+
+	gtk_table_attach (table, frame, 1, 2, row, row + 1, GTK_EXPAND | GTK_FILL, GTK_EXPAND | GTK_FILL, 0, 0);
+
+	row++;
+
+	frame = gtk_frame_new (C_("Permissions", "Delete items"));
+
+	hvbox = gtk_vbox_new (FALSE, 2);
+	gtk_container_add (GTK_CONTAINER (frame), hvbox);
+
+	widget = gtk_radio_button_new_with_label (NULL, C_("Permissions", "None"));
+	widgets->delete_none_radio = widget;
+	radio_group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (widget));
+	gtk_container_add (GTK_CONTAINER (hvbox), widget);
+
+	widget = gtk_radio_button_new_with_label (radio_group, C_("Permissions", "Own"));
+	widgets->delete_own_radio = widget;
+	radio_group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (widget));
+	gtk_container_add (GTK_CONTAINER (hvbox), widget);
+
+	widget = gtk_radio_button_new_with_label (radio_group, C_("Permissions", "All"));
+	widgets->delete_all_radio = widget;
+	gtk_container_add (GTK_CONTAINER (hvbox), widget);
+
+	gtk_table_attach (table, frame, 0, 1, row, row + 1, GTK_EXPAND | GTK_FILL, GTK_EXPAND | GTK_FILL, 0, 0);
+
+	frame = gtk_frame_new (C_("Permissions", "Other"));
+
+	hvbox = gtk_vbox_new (FALSE, 2);
+	gtk_container_add (GTK_CONTAINER (frame), hvbox);
+
+	widget = gtk_check_button_new_with_label (C_("Permissions", "Folder owner"));
+	widgets->other_folder_owner_check = widget;
+	gtk_container_add (GTK_CONTAINER (hvbox), widget);
+
+	widget = gtk_check_button_new_with_label (C_("Permissions", "Folder contact"));
+	widgets->other_folder_contact_check = widget;
+	gtk_container_add (GTK_CONTAINER (hvbox), widget);
+
+	widget = gtk_check_button_new_with_label (C_("Permissions", "Folder visible"));
+	widgets->other_folder_visible_check = widget;
+	gtk_container_add (GTK_CONTAINER (hvbox), widget);
+
+	gtk_table_attach (table, frame, 1, 2, row, row + 1, GTK_EXPAND | GTK_FILL, GTK_EXPAND | GTK_FILL, 0, 0);
+
+	row++;
+
+	g_signal_connect_swapped (
+		widgets->add_button,
+		"clicked", G_CALLBACK (add_button_clicked_cb), dialog);
+	g_signal_connect_swapped (
+		widgets->remove_button,
+		"clicked", G_CALLBACK (remove_button_clicked_cb), dialog);
+	g_signal_connect_swapped (
+		widgets->level_combo,
+		"changed", G_CALLBACK (update_permission_dialog_by_level_combo), dialog);
+	g_signal_connect_swapped (
+		widgets->read_none_radio,
+		"toggled", G_CALLBACK (update_permission_level_combo_by_dialog), dialog);
+	g_signal_connect_swapped (
+		widgets->read_full_radio,
+		"toggled", G_CALLBACK (update_permission_level_combo_by_dialog), dialog);
+	if (widgets->read_fb_time_radio)
+		g_signal_connect_swapped (
+			widgets->read_fb_time_radio,
+			"toggled", G_CALLBACK (update_permission_level_combo_by_dialog), dialog);
+	if (widgets->read_fb_detail_radio)
+		g_signal_connect_swapped (
+			widgets->read_fb_detail_radio,
+			"toggled", G_CALLBACK (update_permission_level_combo_by_dialog), dialog);
+	g_signal_connect_swapped (
+		widgets->write_create_items_check,
+		"toggled", G_CALLBACK (update_permission_level_combo_by_dialog), dialog);
+	g_signal_connect_swapped (
+		widgets->write_create_subfolders_check,
+		"toggled", G_CALLBACK (update_permission_level_combo_by_dialog), dialog);
+	g_signal_connect_swapped (
+		widgets->write_edit_own_check,
+		"toggled", G_CALLBACK (update_permission_level_combo_by_dialog), dialog);
+	g_signal_connect_swapped (
+		widgets->write_edit_all_check,
+		"toggled", G_CALLBACK (update_permission_level_combo_by_dialog), dialog);
+	g_signal_connect_swapped (
+		widgets->delete_none_radio,
+		"toggled", G_CALLBACK (update_permission_level_combo_by_dialog), dialog);
+	g_signal_connect_swapped (
+		widgets->delete_own_radio,
+		"toggled", G_CALLBACK (update_permission_level_combo_by_dialog), dialog);
+	g_signal_connect_swapped (
+		widgets->delete_all_radio,
+		"toggled", G_CALLBACK (update_permission_level_combo_by_dialog), dialog);
+	g_signal_connect_swapped (
+		widgets->other_folder_owner_check,
+		"toggled", G_CALLBACK (update_permission_level_combo_by_dialog), dialog);
+	g_signal_connect_swapped (
+		widgets->other_folder_contact_check,
+		"toggled", G_CALLBACK (update_permission_level_combo_by_dialog), dialog);
+	g_signal_connect_swapped (
+		widgets->other_folder_visible_check,
+		"toggled", G_CALLBACK (update_permission_level_combo_by_dialog), dialog);
+
+	enable_all_widgets (widgets, FALSE);
+
+	gtk_dialog_set_response_sensitive (GTK_DIALOG (widgets->dialog), GTK_RESPONSE_OK, FALSE);
+
+	gtk_widget_show_all (content);
+	gtk_widget_show (GTK_WIDGET (dialog));
+
+	found_permissions = g_new0 (GSList *, 1);
+
+	e_ews_config_utils_run_in_thread_with_feedback (
+		GTK_WINDOW (dialog), dialog,
+		_("Reading folder permissions, please wait..."),
+		read_folder_permissions_thread,
+		read_folder_permissions_idle,
+		found_permissions, folder_permissions_free_found_permissions);
+}
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-ews-edit-folder-permissions.h evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-ews-edit-folder-permissions.h
--- evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-ews-edit-folder-permissions.h	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-ews-edit-folder-permissions.h	2013-05-28 08:59:53.555712328 +0200
@@ -0,0 +1,46 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) version 3.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the program; if not, see <http://www.gnu.org/licenses/>
+ *
+ *
+ * Authors:
+ *    Milan Crha <mcrha@redhat.com>
+ *
+ * Copyright (C) 2012 Red Hat, Inc. (www.redhat.com)
+ *
+ */
+
+#ifndef E_EWS_EDIT_FOLDER_PERMISSIONS_H
+#define E_EWS_EDIT_FOLDER_PERMISSIONS_H
+
+#include <gtk/gtk.h>
+#include <camel/camel.h>
+
+#include "server/e-ews-item.h"
+#include "server/e-ews-folder.h"
+
+void	e_ews_edit_folder_permissions	(GtkWindow *parent,
+					 const gchar *uri,
+					 const gchar *username,
+					 const gchar *impersonate_user,
+					 gint timeout,
+					 const gchar *password_key,
+					 gboolean password_remember,
+					 const gchar *password_who_asks,
+					 const gchar *account_name,
+					 const gchar *folder_name,
+					 const EwsFolderId *folder_id,
+					 EEwsFolderType folder_type);
+
+#endif /* E_EWS_EDIT_FOLDER_PERMISSIONS_H */
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-ews-search-user.c evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-ews-search-user.c
--- evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-ews-search-user.c	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-ews-search-user.c	2013-05-28 08:59:53.550713433 +0200
@@ -0,0 +1,568 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) version 3.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the program; if not, see <http://www.gnu.org/licenses/>
+ *
+ *
+ * Authors:
+ *    Milan Crha <mcrha@redhat.com>
+ *
+ * Copyright (C) 2012 Red Hat, Inc. (www.redhat.com)
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <glib/gi18n-lib.h>
+#include <gtk/gtk.h>
+
+#include "e-ews-config-utils.h"
+#include "e-ews-search-user.h"
+
+#include "server/e-ews-gnome-3-8-compat.h"
+
+#define E_EWS_SEARCH_DLG_DATA "e-ews-search-dlg-data"
+
+enum {
+	COL_DISPLAY_NAME = 0,
+	COL_EMAIL
+};
+
+struct EEwsSearchUserData
+{
+	EEwsConnection *conn;
+	GCancellable *cancellable;
+	gchar *search_text;
+	GtkWidget *tree_view;
+	GtkWidget *info_label;
+	guint schedule_search_id;
+};
+
+static void
+e_ews_search_user_data_free (gpointer ptr)
+{
+	struct EEwsSearchUserData *pgu = ptr;
+
+	if (!pgu)
+		return;
+
+	if (pgu->schedule_search_id) {
+		g_source_remove (pgu->schedule_search_id);
+		pgu->schedule_search_id = 0;
+	}
+	if (pgu->cancellable) {
+		g_cancellable_cancel (pgu->cancellable);
+		g_object_unref (pgu->cancellable);
+		pgu->cancellable = NULL;
+	}
+	g_object_unref (pgu->conn);
+	g_free (pgu->search_text);
+	g_free (pgu);
+}
+
+struct EEwsSearchUser
+{
+	gchar *display_name;
+	gchar *email;
+};
+
+static struct EEwsSearchUser *
+e_ews_search_user_new (const gchar *display_name,
+                       const gchar *email)
+{
+	struct EEwsSearchUser *user;
+
+	if (!display_name)
+		display_name = email;
+
+	user = g_new0 (struct EEwsSearchUser, 1);
+	user->display_name = g_strdup (display_name);
+	user->email = g_strdup (email);
+
+	return user;
+}
+
+static void
+e_ews_search_user_free (gpointer ptr)
+{
+	struct EEwsSearchUser *user = ptr;
+
+	if (!user)
+		return;
+
+	g_free (user->display_name);
+	g_free (user->email);
+	g_free (user);
+}
+
+struct EEwsSearchIdleData
+{
+	EEwsConnection *conn;
+	gchar *search_text;
+	GCancellable *cancellable;
+
+	GObject *dialog;
+	GSList *found_users; /* struct EEwsSearchUser *, for 'Mailbox' MailboxType */
+	guint found_contacts; /* how many other than 'Mailbox' were found */
+	gboolean includes_last_item;
+};
+
+static void
+e_ews_search_idle_data_free (gpointer ptr)
+{
+	struct EEwsSearchIdleData *sid = ptr;
+
+	if (!sid)
+		return;
+
+	g_object_unref (sid->conn);
+	g_object_unref (sid->cancellable);
+	g_free (sid->search_text);
+	g_slist_free_full (sid->found_users, e_ews_search_user_free);
+	g_free (sid);
+}
+
+static void
+empty_search_tree_view (GtkWidget *tree_view)
+{
+	GtkListStore *store;
+	GtkTreeModel *model;
+
+	g_return_if_fail (tree_view != NULL);
+
+	model = gtk_tree_view_get_model (GTK_TREE_VIEW (tree_view));
+	g_return_if_fail (model != NULL);
+
+	store = GTK_LIST_STORE (model);
+	g_return_if_fail (store != NULL);
+
+	gtk_list_store_clear (store);
+}
+
+static void
+search_add_user (GtkListStore *store,
+                 const gchar *display_name,
+                 const gchar *email)
+{
+	GtkTreeIter iter;
+
+	g_return_if_fail (store != NULL);
+
+	gtk_list_store_append (store, &iter);
+	gtk_list_store_set (
+		store, &iter,
+		COL_DISPLAY_NAME, display_name,
+		COL_EMAIL, email,
+		-1);
+}
+
+static gboolean
+search_finish_idle (gpointer user_data)
+{
+	struct EEwsSearchIdleData *sid = user_data;
+
+	g_return_val_if_fail (sid != NULL, FALSE);
+	g_return_val_if_fail (sid->dialog != NULL, FALSE);
+
+	if (!g_cancellable_is_cancelled (sid->cancellable)) {
+		struct EEwsSearchUserData *pgu;
+		GtkListStore *store;
+		guint added = 0;
+		GSList *fu;
+
+		pgu = g_object_get_data (sid->dialog, E_EWS_SEARCH_DLG_DATA);
+		g_return_val_if_fail (pgu != NULL, FALSE);
+		g_return_val_if_fail (pgu->tree_view != NULL, FALSE);
+		g_return_val_if_fail (pgu->info_label != NULL, FALSE);
+
+		empty_search_tree_view (pgu->tree_view);
+
+		store = GTK_LIST_STORE (gtk_tree_view_get_model (GTK_TREE_VIEW (pgu->tree_view)));
+		g_return_val_if_fail (store != NULL, FALSE);
+
+		for (fu = sid->found_users; fu; fu = fu->next) {
+			struct EEwsSearchUser *user = fu->data;
+
+			if (!user)
+				continue;
+
+			search_add_user (store, user->display_name, user->email);
+
+			added++;
+		}
+
+		if (!added) {
+			if (sid->found_contacts > 0) {
+				gchar *str;
+				str = g_strdup_printf (
+					dngettext (GETTEXT_PACKAGE, "No users found, only one contact", "No users found, only %d contacts",
+					sid->found_contacts), sid->found_contacts);
+				gtk_label_set_text (GTK_LABEL (pgu->info_label), str);
+				g_free (str);
+			} else {
+				gtk_label_set_text (GTK_LABEL (pgu->info_label), _("No users found"));
+			}
+		} else if (sid->includes_last_item) {
+			gchar *str;
+			str = g_strdup_printf (dngettext (GETTEXT_PACKAGE, "Found one user", "Found %d users", added), added);
+			gtk_label_set_text (GTK_LABEL (pgu->info_label), str);
+			g_free (str);
+		} else {
+			gchar *str;
+			str = g_strdup_printf (dngettext (GETTEXT_PACKAGE,
+				"Found more than 100 users, but showing only first %d",
+				"Found more than 100 users, but showing only first %d", added), added);
+			gtk_label_set_text (GTK_LABEL (pgu->info_label), str);
+			g_free (str);
+		}
+	}
+
+	e_ews_search_idle_data_free (sid);
+
+	return FALSE;
+}
+
+static gpointer
+search_thread (gpointer user_data)
+{
+	struct EEwsSearchIdleData *sid = user_data;
+
+	g_return_val_if_fail (sid != NULL, NULL);
+
+	if (!g_cancellable_is_cancelled (sid->cancellable)) {
+		GSList *mailboxes = NULL;
+		GError *error = NULL;
+
+		if (e_ews_connection_resolve_names_sync (
+			sid->conn, EWS_PRIORITY_MEDIUM, sid->search_text,
+			EWS_SEARCH_AD, NULL, FALSE, &mailboxes, NULL,
+			&sid->includes_last_item, sid->cancellable, &error)) {
+			GSList *iter;
+
+			sid->found_contacts = 0;
+
+			for (iter = mailboxes; iter != NULL; iter = iter->next) {
+				EwsMailbox *mb = iter->data;
+
+				if (!mb || !mb->email || !*mb->email
+				    || g_strcmp0 (mb->mailbox_type, "Mailbox") != 0) {
+					sid->found_contacts++;
+					continue;
+				}
+
+				sid->found_users = g_slist_prepend (
+					sid->found_users,
+					e_ews_search_user_new (mb->name, mb->email));
+			}
+
+			sid->found_users = g_slist_reverse (sid->found_users);
+		}
+
+		g_slist_free_full (mailboxes, (GDestroyNotify) e_ews_mailbox_free);
+
+		if (error && !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED) &&
+		    !g_error_matches (error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_NAMERESOLUTIONNORESULTS))
+			g_warning ("%s: Failed to search user: %s", G_STRFUNC, error->message);
+
+		g_clear_error (&error);
+
+		g_idle_add (search_finish_idle, sid);
+	} else {
+		e_ews_search_idle_data_free (sid);
+	}
+
+	return NULL;
+}
+
+static gboolean
+schedule_search_cb (gpointer user_data)
+{
+	struct EEwsSearchIdleData *sid = user_data;
+
+	g_return_val_if_fail (sid != NULL, FALSE);
+	g_return_val_if_fail (sid->dialog != NULL, FALSE);
+
+	if (!g_cancellable_is_cancelled (sid->cancellable)) {
+		struct EEwsSearchUserData *pgu;
+		GThread *thread;
+		GError *error = NULL;
+
+		pgu = g_object_get_data (sid->dialog, E_EWS_SEARCH_DLG_DATA);
+		g_return_val_if_fail (pgu != NULL, FALSE);
+		g_return_val_if_fail (pgu->tree_view != NULL, FALSE);
+
+		pgu->schedule_search_id = 0;
+		sid->conn = g_object_ref (pgu->conn);
+		sid->search_text = g_strdup (pgu->search_text);
+
+		thread = g_thread_create (search_thread, sid, FALSE, &error);
+		if (thread) {
+			sid = NULL;
+		} else {
+			g_object_unref (sid->conn);
+			g_warning ("%s: Failed to create search thread: %s", G_STRFUNC, error ? error->message : "Unknown error");
+		}
+
+		g_clear_error (&error);
+	}
+
+	e_ews_search_idle_data_free (sid);
+
+	return FALSE;
+}
+
+static void
+search_term_changed_cb (GtkEntry *entry,
+                        GObject *dialog)
+{
+	struct EEwsSearchUserData *pgu;
+
+	g_return_if_fail (dialog != NULL);
+
+	pgu = g_object_get_data (dialog, E_EWS_SEARCH_DLG_DATA);
+	g_return_if_fail (pgu != NULL);
+	g_return_if_fail (pgu->tree_view != NULL);
+
+	if (pgu->schedule_search_id) {
+		g_source_remove (pgu->schedule_search_id);
+		pgu->schedule_search_id = 0;
+	}
+
+	if (pgu->cancellable) {
+		g_cancellable_cancel (pgu->cancellable);
+		g_object_unref (pgu->cancellable);
+	}
+
+	pgu->cancellable = g_cancellable_new ();
+
+	if (entry) {
+		g_free (pgu->search_text);
+		pgu->search_text = g_strdup (gtk_entry_get_text (entry));
+	}
+
+	empty_search_tree_view (pgu->tree_view);
+
+	if (!pgu->search_text || !*pgu->search_text) {
+		gtk_label_set_text (GTK_LABEL (pgu->info_label), _("Search for a user"));
+	} else {
+		struct EEwsSearchIdleData *sid;
+
+		sid = g_new0 (struct EEwsSearchIdleData, 1);
+		sid->cancellable = g_object_ref (pgu->cancellable);
+		sid->dialog = dialog;
+
+		gtk_label_set_text (GTK_LABEL (pgu->info_label), _("Searching..."));
+		pgu->schedule_search_id = g_timeout_add (333, schedule_search_cb, sid);
+	}
+}
+
+static void
+dialog_realized_cb (GObject *dialog)
+{
+	struct EEwsSearchUserData *pgu;
+
+	g_return_if_fail (dialog != NULL);
+
+	pgu = g_object_get_data (dialog, E_EWS_SEARCH_DLG_DATA);
+	g_return_if_fail (pgu != NULL);
+	g_return_if_fail (pgu->tree_view != NULL);
+
+	if (pgu->cancellable)
+		return;
+
+	search_term_changed_cb (NULL, dialog);
+}
+
+static void
+search_user_selection_changed_cb (GtkTreeSelection *selection,
+                                  GtkDialog *dialog)
+{
+	g_return_if_fail (selection != NULL);
+	g_return_if_fail (dialog != NULL);
+
+	gtk_dialog_set_response_sensitive (
+		dialog,
+		GTK_RESPONSE_OK,
+		gtk_tree_selection_get_selected (selection, NULL, NULL));
+}
+
+static void
+search_user_row_activated_cb (GtkTreeView *tree_view,
+                              GtkTreePath *path,
+                              GtkTreeViewColumn *column,
+                              GtkDialog *dialog)
+{
+	g_return_if_fail (tree_view != NULL);
+	g_return_if_fail (dialog != NULL);
+
+	if (path && column)
+		gtk_dialog_response (dialog, GTK_RESPONSE_OK);
+}
+
+static GtkWidget *
+create_users_tree_view (GtkWidget *dialog,
+                        struct EEwsSearchUserData *pgu)
+{
+	GtkTreeView *tree_view;
+	GtkTreeSelection *selection;
+	GtkCellRenderer *renderer;
+	GtkTreeViewColumn *column;
+	gint pos;
+
+	g_return_val_if_fail (dialog != NULL, NULL);
+	g_return_val_if_fail (pgu != NULL, NULL);
+
+	tree_view = GTK_TREE_VIEW (gtk_tree_view_new_with_model (
+		GTK_TREE_MODEL (gtk_list_store_new (5, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_POINTER, G_TYPE_UINT))));
+
+	renderer = gtk_cell_renderer_text_new ();
+	g_object_set (renderer, "editable", FALSE, NULL);
+	pos = gtk_tree_view_insert_column_with_attributes (tree_view, -1, _("Name"), renderer, "text", COL_DISPLAY_NAME, NULL);
+	column = gtk_tree_view_get_column (tree_view, pos - 1);
+	gtk_tree_view_column_set_expand (column, TRUE);
+
+	renderer = gtk_cell_renderer_text_new ();
+	g_object_set (renderer, "editable", FALSE, NULL);
+	gtk_tree_view_insert_column_with_attributes (tree_view, -1, _("E-mail"), renderer, "text", COL_EMAIL, NULL);
+
+	selection = gtk_tree_view_get_selection (tree_view);
+	gtk_tree_selection_set_mode (selection, GTK_SELECTION_SINGLE);
+	search_user_selection_changed_cb (selection, GTK_DIALOG (dialog));
+	g_signal_connect (selection, "changed", G_CALLBACK (search_user_selection_changed_cb), dialog);
+
+	g_signal_connect (tree_view, "row-activated", G_CALLBACK (search_user_row_activated_cb), dialog);
+
+	pgu->tree_view = GTK_WIDGET (tree_view);
+
+	return pgu->tree_view;
+}
+
+/* for non-NULL @info populates also permission levels for given user */
+gboolean
+e_ews_search_user_modal (GtkWindow *parent,
+                         EEwsConnection *conn,
+                         const gchar *search_this,
+                         gchar **display_name,
+                         gchar **email)
+{
+	gboolean res = FALSE;
+	struct EEwsSearchUserData *pgu;
+	GtkWidget *dialog;
+	GtkWidget *content, *label, *widget;
+	GtkTable *table;
+	GtkScrolledWindow *scrolled_window;
+	gint row;
+
+	g_return_val_if_fail (conn != NULL, FALSE);
+	g_return_val_if_fail (display_name || email, FALSE);
+
+	pgu = g_new0 (struct EEwsSearchUserData, 1);
+	pgu->conn = g_object_ref (conn);
+
+	dialog = gtk_dialog_new_with_buttons (
+		_("Choose EWS user..."),
+		parent,
+		GTK_DIALOG_DESTROY_WITH_PARENT,
+		GTK_STOCK_CLOSE, GTK_RESPONSE_CLOSE,
+		GTK_STOCK_OK, GTK_RESPONSE_OK,
+		NULL);
+
+	gtk_dialog_set_has_separator (GTK_DIALOG (dialog), FALSE);
+	g_object_set_data_full (G_OBJECT (dialog), E_EWS_SEARCH_DLG_DATA, pgu, e_ews_search_user_data_free);
+
+	gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_OK);
+
+	content = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
+
+	table = GTK_TABLE (gtk_table_new (3, 2, FALSE));
+	gtk_table_set_homogeneous (table, FALSE);
+	gtk_table_set_row_spacings (table, 6);
+	gtk_table_set_col_spacings (table, 6);
+	gtk_container_set_border_width (GTK_CONTAINER (table), 12);
+	gtk_container_add (GTK_CONTAINER (content), GTK_WIDGET (table));
+
+	row = 0;
+
+	label = gtk_label_new_with_mnemonic (_("_Search:"));
+	g_object_set (
+		G_OBJECT (label),
+		"xalign", 0.0,
+		NULL);
+
+	widget = gtk_entry_new ();
+	gtk_label_set_mnemonic_widget (GTK_LABEL (label), widget);
+	if (search_this && *search_this) {
+		gtk_entry_set_text (GTK_ENTRY (widget), search_this);
+		pgu->search_text = g_strdup (search_this);
+	}
+
+	g_signal_connect (widget, "changed", G_CALLBACK (search_term_changed_cb), dialog);
+
+	gtk_table_attach (table, label, 0, 1, row, row + 1, 0, 0, 0, 0);
+	gtk_table_attach (table, widget, 1, 2, row, row + 1, GTK_FILL | GTK_EXPAND, 0, 0, 0);
+
+	row++;
+
+	widget = gtk_scrolled_window_new (NULL, NULL);
+	scrolled_window = GTK_SCROLLED_WINDOW (widget);
+	gtk_widget_set_size_request (widget, 120, 120);
+	gtk_container_add (GTK_CONTAINER (widget), create_users_tree_view (dialog, pgu));
+	g_object_set (
+		G_OBJECT (widget),
+		"shadow-type", GTK_SHADOW_IN,
+		"hscrollbar-policy", GTK_POLICY_AUTOMATIC,
+		"vscrollbar-policy", GTK_POLICY_AUTOMATIC,
+		NULL);
+
+	gtk_table_attach (table, widget, 0, 2, row, row + 1, GTK_FILL | GTK_EXPAND, GTK_FILL | GTK_EXPAND, 0, 0);
+
+	row++;
+
+	label = gtk_label_new (_("Search for a user"));
+	g_object_set (
+		G_OBJECT (label),
+		"xalign", 0.0,
+		NULL);
+
+	pgu->info_label = label;
+
+	gtk_table_attach (table, label, 0, 2, row, row + 1, GTK_FILL | GTK_EXPAND, 0, 0, 0);
+
+	row++;
+
+	gtk_widget_show_all (content);
+
+	g_signal_connect (dialog, "realize", G_CALLBACK (dialog_realized_cb), NULL);
+
+	if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_OK) {
+		GtkTreeSelection *selection;
+		GtkTreeModel *model = NULL;
+		GtkTreeIter iter;
+
+		selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (pgu->tree_view));
+		if (gtk_tree_selection_get_selected (selection, &model, &iter)) {
+			if (display_name)
+				gtk_tree_model_get (model, &iter, COL_DISPLAY_NAME, display_name, -1);
+			if (email)
+				gtk_tree_model_get (model, &iter, COL_EMAIL, email, -1);
+
+			res = TRUE;
+		}
+	}
+
+	gtk_widget_destroy (dialog);
+
+	return res;
+}
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-ews-search-user.h evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-ews-search-user.h
--- evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-ews-search-user.h	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-ews-search-user.h	2013-05-28 08:59:53.551713463 +0200
@@ -0,0 +1,37 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) version 3.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the program; if not, see <http://www.gnu.org/licenses/>
+ *
+ *
+ * Authors:
+ *    Milan Crha <mcrha@redhat.com>
+ *
+ * Copyright (C) 2012 Red Hat, Inc. (www.redhat.com)
+ *
+ */
+
+#ifndef E_EWS_SEARCH_USER_H
+#define E_EWS_SEARCH_USER_H
+
+#include <gtk/gtk.h>
+#include "server/e-ews-connection.h"
+#include "server/e-ews-item.h"
+
+gboolean	e_ews_search_user_modal	(GtkWindow *parent,
+					 EEwsConnection *conn,
+					 const gchar *search_this,
+					 gchar **display_name,
+					 gchar **email);
+
+#endif /* E_EWS_SEARCH_USER_H */
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-ews-subscribe-foreign-folder.c evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-ews-subscribe-foreign-folder.c
--- evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-ews-subscribe-foreign-folder.c	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-ews-subscribe-foreign-folder.c	2013-05-28 08:59:53.551713463 +0200
@@ -0,0 +1,736 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) version 3.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the program; if not, see <http://www.gnu.org/licenses/>
+ *
+ *
+ * Authors:
+ *    Milan Crha <mcrha@redhat.com>
+ *
+ * Copyright (C) 2012 Red Hat, Inc. (www.redhat.com)
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <glib/gi18n-lib.h>
+#include <gtk/gtk.h>
+
+#include <libedataserverui/e-name-selector.h>
+#include <libebook/e-destination.h>
+
+#include "camel/camel-ews-store.h"
+#include "camel/camel-ews-store-summary.h"
+#include "camel/camel-ews-utils.h"
+
+#include "e-ews-config-utils.h"
+#include "e-ews-search-user.h"
+#include "e-ews-subscribe-foreign-folder.h"
+
+#include "utils/ews-camel-compat.h"
+#include "server/e-ews-gnome-3-8-compat.h"
+
+#define STR_USER_NAME_SELECTOR_ENTRY	"e-ews-name-selector-entry"
+#define STR_FOLDER_NAME_COMBO		"e-ews-folder-name-combo"
+#define STR_SUBFOLDERS_CHECK		"e-ews-subfolders-check"
+#define STR_EWS_CAMEL_SESSION		"e-ews-camel-session"
+#define STR_EWS_CAMEL_STORE		"e-ews-camel-store"
+#define STR_EWS_DIRECT_EMAIL		"e-ews-direct-email"
+#define STR_STORE_DISPLAY_NAME		"e-ews-store-display-name"
+
+static void
+announce_new_folder (CamelEwsStore *ews_store,
+                     const gchar *fid)
+{
+	CamelFolderInfo *fi;
+
+	g_return_if_fail (CAMEL_IS_EWS_STORE (ews_store));
+	g_return_if_fail (fid != NULL);
+	g_return_if_fail (camel_ews_store_summary_has_folder (ews_store->summary, fid));
+
+	fi = camel_ews_utils_build_folder_info (ews_store, fid);
+	camel_store_folder_created (CAMEL_STORE (ews_store), fi);
+	camel_subscribable_folder_subscribed (CAMEL_SUBSCRIBABLE (ews_store), fi);
+	camel_folder_info_free (fi);
+}
+
+static gboolean
+add_foreign_folder_to_camel (CamelEwsStore *ews_store,
+                             const gchar *foreign_email,
+                             EEwsFolder *folder,
+			     gboolean include_subfolders,
+                             const gchar *display_username,
+                             const gchar *display_foldername,
+                             GError **perror)
+{
+	gchar *foreign_mailbox_id;
+	gchar *mailbox, *fullname;
+	const EwsFolderId *fid, *parent_fid;
+
+	g_return_val_if_fail (ews_store != NULL, FALSE);
+	g_return_val_if_fail (ews_store->summary != NULL, FALSE);
+	g_return_val_if_fail (foreign_email != NULL, FALSE);
+	g_return_val_if_fail (folder != NULL, FALSE);
+	g_return_val_if_fail (display_username != NULL, FALSE);
+	g_return_val_if_fail (display_foldername != NULL, FALSE);
+
+	fid = e_ews_folder_get_id (folder);
+	parent_fid = e_ews_folder_get_parent_id (folder);
+
+	g_return_val_if_fail (fid != NULL, FALSE);
+	g_return_val_if_fail (parent_fid != NULL, FALSE);
+	g_return_val_if_fail (g_strcmp0 (fid->id, parent_fid->id) != 0, FALSE);
+
+	if (camel_ews_store_summary_has_folder (ews_store->summary, fid->id)) {
+		gchar *full_name = camel_ews_store_summary_get_folder_full_name (ews_store->summary, fid->id, NULL);
+
+		g_propagate_error (
+			perror,
+			g_error_new (EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_FOLDEREXISTS,
+			_("Cannot add folder, folder already exists as '%s'"), full_name));
+
+		g_free (full_name);
+
+		return FALSE;
+	}
+
+	/* Translators: The '%s' is replaced with user name, to whom the foreign mailbox belongs.
+	 * Example result: "Mailbox - John Smith"
+	*/
+	mailbox = g_strdup_printf (C_("ForeignFolder", "Mailbox - %s"), display_username);
+
+	foreign_mailbox_id = g_strdup_printf ("ForeignMailbox::%s", foreign_email);
+	if (!camel_ews_store_summary_has_folder (ews_store->summary, foreign_mailbox_id)) {
+		camel_ews_store_summary_new_folder (
+			ews_store->summary,
+			foreign_mailbox_id, EWS_FOREIGN_FOLDER_ROOT_ID, NULL,
+			mailbox, E_EWS_FOLDER_TYPE_MAILBOX,
+			CAMEL_FOLDER_SYSTEM | CAMEL_FOLDER_NOSELECT,
+			0, FALSE, FALSE);
+	}
+
+	if (camel_ews_store_summary_has_folder (ews_store->summary, parent_fid->id)) {
+		camel_ews_store_summary_new_folder (
+			ews_store->summary,
+			fid->id, parent_fid->id, fid->change_key,
+			display_foldername, E_EWS_FOLDER_TYPE_MAILBOX,
+			CAMEL_FOLDER_SUBSCRIBED, e_ews_folder_get_total_count (folder), TRUE, FALSE);
+	} else {
+		const gchar *displayname;
+
+		fullname = g_strdup_printf ("%s/%s/%s", EWS_FOREIGN_FOLDER_ROOT_DISPLAY_NAME, mailbox, display_foldername);
+
+		/* make sure the path is unique */
+		camel_ews_store_ensure_unique_path (ews_store, &fullname);
+
+		displayname = strrchr (fullname, '/');
+		displayname++;
+
+		camel_ews_store_summary_new_folder (
+			ews_store->summary,
+			fid->id, foreign_mailbox_id, fid->change_key,
+			displayname, E_EWS_FOLDER_TYPE_MAILBOX,
+			CAMEL_FOLDER_SUBSCRIBED, e_ews_folder_get_total_count (folder), TRUE, FALSE);
+
+		g_free (fullname);
+	}
+
+	camel_ews_store_ensure_virtual_folders (ews_store);
+	camel_ews_store_summary_set_foreign_subfolders (ews_store->summary, fid->id, include_subfolders);
+	camel_ews_store_summary_save (ews_store->summary, perror);
+
+	announce_new_folder (ews_store, EWS_FOREIGN_FOLDER_ROOT_ID);
+	announce_new_folder (ews_store, foreign_mailbox_id);
+	announce_new_folder (ews_store, fid->id);
+
+	g_free (foreign_mailbox_id);
+	g_free (mailbox);
+
+	if (include_subfolders)
+		camel_ews_store_update_foreign_subfolders (ews_store, fid->id);
+
+	return TRUE;
+}
+
+static void
+enable_ok_button_by_data (GObject *dialog)
+{
+	GtkEntry *entry;
+	GtkComboBox *combo;
+	const gchar *entry_text;
+	gchar *combo_text;
+
+	g_return_if_fail (dialog != NULL);
+
+	entry = g_object_get_data (dialog, STR_USER_NAME_SELECTOR_ENTRY);
+	g_return_if_fail (entry != NULL);
+
+	combo = g_object_get_data (dialog, STR_FOLDER_NAME_COMBO);
+	g_return_if_fail (combo != NULL);
+
+	entry_text = gtk_entry_get_text (entry);
+	combo_text = gtk_combo_box_get_active_text (combo);
+
+	gtk_dialog_set_response_sensitive (
+		GTK_DIALOG (dialog), GTK_RESPONSE_OK,
+		entry_text && *entry_text && *entry_text != ' ' && *entry_text != ',' &&
+		combo_text && *combo_text);
+
+	g_free (combo_text);
+}
+
+static void
+name_entry_changed_cb (GObject *dialog)
+{
+	GtkEntry *entry;
+
+	g_return_if_fail (dialog != NULL);
+
+	entry = g_object_get_data (dialog, STR_USER_NAME_SELECTOR_ENTRY);
+	g_return_if_fail (entry != NULL);
+
+	g_object_set_data (G_OBJECT (entry), STR_EWS_DIRECT_EMAIL, NULL);
+
+	enable_ok_button_by_data (dialog);
+}
+
+static void
+folder_name_combo_changed_cb (GObject *dialog,
+			      GtkComboBox *combo)
+{
+	enable_ok_button_by_data (dialog);
+}
+
+struct EEwsCheckForeignFolderData
+{
+	GtkWidget *dialog;
+	gboolean include_subfolders;
+	gchar *email;
+	gchar *direct_email;
+	gchar *user_displayname;
+	gchar *orig_foldername;
+	gchar *use_foldername;
+	gchar *store_display_name;
+	EEwsFolder *folder;
+};
+
+static void
+e_ews_check_foreign_folder_data_free (gpointer ptr)
+{
+	struct EEwsCheckForeignFolderData *cffd = ptr;
+
+	if (!cffd)
+		return;
+
+	g_free (cffd->email);
+	g_free (cffd->direct_email);
+	g_free (cffd->user_displayname);
+	g_free (cffd->orig_foldername);
+	g_free (cffd->use_foldername);
+	g_free (cffd->store_display_name);
+
+	/* folder tells whether successfully finished,
+	 * then the dialog can be destroyed */
+	if (cffd->folder && cffd->dialog)
+		gtk_widget_destroy (cffd->dialog);
+
+	if (cffd->folder)
+		g_object_unref (cffd->folder);
+
+	g_free (cffd);
+}
+
+static void
+check_foreign_folder_thread (GObject *with_object,
+                             gpointer user_data,
+                             GCancellable *cancellable,
+                             GError **perror)
+{
+	struct EEwsCheckForeignFolderData *cffd = user_data;
+	GError *local_error = NULL;
+	EEwsConnection *conn;
+	EwsFolderId fid;
+	EEwsFolder *folder = NULL;
+
+	g_return_if_fail (with_object != NULL);
+	g_return_if_fail (CAMEL_IS_EWS_STORE (with_object));
+	g_return_if_fail (user_data != NULL);
+	g_return_if_fail (cffd->email != NULL);
+
+	if (g_cancellable_set_error_if_cancelled (cancellable, perror))
+		return;
+
+	conn = camel_ews_store_ref_connection (CAMEL_EWS_STORE (with_object));
+	if (!conn) {
+		g_set_error_literal (
+			perror, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_NORESPONSE,
+			_("Cannot test foreign folder availability while in offline mode"));
+		return;
+	}
+
+	if (cffd->direct_email && *cffd->direct_email) {
+		g_return_if_fail (cffd->user_displayname == NULL);
+
+		cffd->user_displayname = cffd->email;
+		cffd->email = g_strdup (cffd->direct_email);
+	} else {
+		GSList *mailboxes = NULL;
+		EwsMailbox *mailbox = NULL;
+		gboolean includes_last_item = FALSE;
+
+		if (!e_ews_connection_resolve_names_sync (conn, G_PRIORITY_DEFAULT,
+			cffd->email, EWS_SEARCH_AD, NULL, FALSE,
+			&mailboxes, NULL, &includes_last_item,
+			cancellable, perror)) {
+			g_object_unref (conn);
+			return;
+		}
+
+		if (!mailboxes) {
+			g_set_error (
+				perror, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_MAILRECIPIENTNOTFOUND,
+				_("User '%s' was not found on the server"), cffd->email);
+			g_object_unref (conn);
+			return;
+		}
+
+		/* is there only one result? */
+		if (mailboxes->next == NULL) {
+			mailbox = mailboxes->data;
+		} else {
+			GSList *iter;
+
+			for (iter = mailboxes; iter; iter = iter->next) {
+				EwsMailbox *mb = iter->data;
+
+				if (!mb)
+					continue;
+
+				if (mb->name && g_utf8_collate (mb->name, cffd->email) == 0) {
+					mailbox = mb;
+					break;
+				}
+			}
+		}
+
+		if (mailbox) {
+			g_free (cffd->user_displayname);
+			cffd->user_displayname = g_strdup (mailbox->name);
+			g_free (cffd->email);
+			cffd->email = g_strdup (mailbox->email);
+		}
+
+		g_slist_free_full (mailboxes, (GDestroyNotify) e_ews_mailbox_free);
+
+		if (!mailbox) {
+			g_set_error (
+				perror, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_ITEMNOTFOUND,
+				_("User name '%s' is ambiguous, specify it more precisely, please"), cffd->email);
+			g_object_unref (conn);
+			return;
+		}
+	}
+
+	if (g_cancellable_set_error_if_cancelled (cancellable, perror)) {
+		g_object_unref (conn);
+		return;
+	}
+
+	fid.id = (gchar *) (cffd->use_foldername ? cffd->use_foldername : cffd->orig_foldername);
+	fid.change_key = NULL;
+	fid.is_distinguished_id = cffd->use_foldername != NULL;
+
+	if (!e_ews_connection_get_folder_info_sync (conn, G_PRIORITY_DEFAULT,
+		cffd->email, &fid, &folder, cancellable, &local_error)) {
+		if (g_error_matches (local_error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_ITEMNOTFOUND) ||
+		    g_error_matches (local_error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_FOLDERNOTFOUND)) {
+			g_clear_error (&local_error);
+			local_error = g_error_new (
+				EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_FOLDERNOTFOUND,
+				_("Folder '%s' not found. Either it does not exist or you do not have permission to access it."),
+				cffd->orig_foldername);
+		}
+
+		g_propagate_error (perror, local_error);
+		g_object_unref (conn);
+		return;
+	}
+
+	if (g_cancellable_set_error_if_cancelled (cancellable, perror)) {
+		g_object_unref (folder);
+		g_object_unref (conn);
+		return;
+	}
+
+	if (e_ews_folder_get_folder_type (folder) == E_EWS_FOLDER_TYPE_UNKNOWN) {
+		g_propagate_error (
+			perror, g_error_new_literal (EWS_CONNECTION_ERROR,
+			EWS_CONNECTION_ERROR_FOLDERNOTFOUND, _("Cannot add folder, cannot determine folder's type")));
+		g_object_unref (folder);
+		g_object_unref (conn);
+		return;
+	}
+
+	e_ews_folder_set_foreign (folder, TRUE);
+
+	cffd->folder = folder;
+	g_object_unref (conn);
+}
+
+static void
+check_foreign_folder_idle (GObject *with_object,
+                           gpointer user_data,
+                           GCancellable *cancellable,
+                           GError **perror)
+{
+	struct EEwsCheckForeignFolderData *cffd = user_data;
+	gchar *folder_name;
+	const gchar *base_username, *base_foldername;
+	CamelEwsStore *ews_store;
+	CamelURL *url;
+	EEwsFolderType folder_type;
+
+	g_return_if_fail (with_object != NULL);
+	g_return_if_fail (CAMEL_IS_EWS_STORE (with_object));
+	g_return_if_fail (user_data != NULL);
+	g_return_if_fail (cffd->email != NULL);
+
+	if (!cffd->folder)
+		return;
+
+	ews_store = CAMEL_EWS_STORE (with_object);
+	url = camel_service_get_camel_url (CAMEL_SERVICE (ews_store));
+	g_return_if_fail (url != NULL);
+
+	folder_type = e_ews_folder_get_folder_type (cffd->folder);
+	base_username = cffd->user_displayname ? cffd->user_displayname : cffd->email;
+	base_foldername = e_ews_folder_get_name (cffd->folder) ? e_ews_folder_get_name (cffd->folder) : cffd->orig_foldername;
+
+	/* Translators: This is used to name foreign folder.
+	 * The first '%s' is replaced with user name to whom the folder belongs,
+	 * the second '%s' is replaced with folder name.
+	 * Example result: "John Smith - Calendar"
+	*/
+	folder_name = g_strdup_printf (C_("ForeignFolder", "%s - %s"), base_username, base_foldername);
+	if (folder_type != E_EWS_FOLDER_TYPE_MAILBOX)
+		e_ews_folder_set_name (cffd->folder, folder_name);
+
+	if ((folder_type == E_EWS_FOLDER_TYPE_MAILBOX &&
+	     !add_foreign_folder_to_camel (ews_store,
+		cffd->email,
+		cffd->folder,
+		cffd->include_subfolders,
+		base_username,
+		base_foldername,
+		perror)) ||
+	    (folder_type != E_EWS_FOLDER_TYPE_MAILBOX && !e_ews_folder_utils_add_as_esource (
+		url,
+		cffd->store_display_name,
+		cffd->folder,
+		(cffd->include_subfolders ? E_EWS_ESOURCE_FLAG_INCLUDE_SUBFOLDERS : 0) | E_EWS_ESOURCE_FLAG_OFFLINE_SYNC,
+		0,
+		cancellable,
+		perror))
+	) {
+		/* to not destroy the dialog on error */
+		g_object_unref (cffd->folder);
+		cffd->folder = NULL;
+	}
+
+	g_free (folder_name);
+}
+
+static void
+subscribe_foreign_response_cb (GObject *dialog,
+                               gint response_id)
+{
+	struct EEwsCheckForeignFolderData *cffd;
+	ENameSelectorEntry *entry;
+	GtkComboBox *combo_text;
+	GtkToggleButton *subfolders_check;
+	EDestinationStore *dest_store;
+	CamelStore *cstore;
+	gchar *description;
+	const gchar *username;
+	gchar *orig_foldername, *use_foldername = NULL, *show_foldername = NULL;
+
+	if (response_id != GTK_RESPONSE_OK) {
+		gtk_widget_destroy (GTK_WIDGET (dialog));
+		return;
+	}
+
+	g_return_if_fail (dialog != NULL);
+
+	entry = g_object_get_data (dialog, STR_USER_NAME_SELECTOR_ENTRY);
+	combo_text = g_object_get_data (dialog, STR_FOLDER_NAME_COMBO);
+	subfolders_check = g_object_get_data (dialog, STR_SUBFOLDERS_CHECK);
+	cstore = g_object_get_data (dialog, STR_EWS_CAMEL_STORE);
+
+	g_return_if_fail (entry != NULL);
+	g_return_if_fail (cstore != NULL);
+
+	username = NULL;
+	dest_store = e_name_selector_entry_peek_destination_store (entry);
+	if (dest_store && e_destination_store_get_destination_count (dest_store) > 0) {
+		EDestination *dest;
+		GList *dests = e_destination_store_list_destinations (dest_store);
+
+		g_return_if_fail (dests != NULL);
+
+		/* pick the first, there is no option to limit to only one destination */
+		dest = dests->data;
+		if (dest) {
+			username = e_destination_get_email (dest);
+			if (!username || !*username)
+				username = e_destination_get_name (dest);
+		}
+
+		g_list_free (dests);
+	}
+
+	if (!username || !*username)
+		username = gtk_entry_get_text (GTK_ENTRY (entry));
+
+	orig_foldername = gtk_combo_box_get_active_text (combo_text);
+	if (!orig_foldername)
+		orig_foldername = g_strdup ("");
+
+	/* convert well-known names to their non-localized form */
+	if (g_strcmp0 (orig_foldername, _("Inbox")) == 0) {
+		use_foldername = g_strdup ("inbox");
+	} else if (g_strcmp0 (orig_foldername, _("Contacts")) == 0) {
+		use_foldername = g_strdup ("contacts");
+	} else if (g_strcmp0 (orig_foldername, _("Calendar")) == 0) {
+		use_foldername = g_strdup ("calendar");
+	} else if (g_strcmp0 (orig_foldername, _("Memos")) == 0) {
+		use_foldername = g_strdup ("notes");
+	} else if (g_strcmp0 (orig_foldername, _("Tasks")) == 0) {
+		use_foldername = g_strdup ("tasks");
+	} else if (strlen (orig_foldername) > 13) {
+		/* if its a folder ID, then show only first 10 letters of it */
+		show_foldername = g_strdup_printf ("%.10s...", orig_foldername);
+	}
+
+	cffd = g_new0 (struct EEwsCheckForeignFolderData, 1);
+	cffd->dialog = GTK_WIDGET (dialog);
+	cffd->email = g_strdup (username ? username : "");
+	cffd->direct_email = g_strdup (g_object_get_data (G_OBJECT (entry), STR_EWS_DIRECT_EMAIL));
+	cffd->orig_foldername = orig_foldername;
+	cffd->use_foldername = use_foldername;
+	cffd->store_display_name = g_strdup (g_object_get_data (G_OBJECT (dialog), STR_STORE_DISPLAY_NAME));
+	cffd->include_subfolders = gtk_toggle_button_get_active (subfolders_check);
+	cffd->folder = NULL;
+
+	description = g_strdup_printf (
+		_("Testing availability of folder '%s' of user '%s', please wait..."),
+		show_foldername ? show_foldername : cffd->orig_foldername, cffd->email);
+
+	e_ews_config_utils_run_in_thread_with_feedback (
+		GTK_WINDOW (dialog),
+		G_OBJECT (cstore),
+		description,
+		check_foreign_folder_thread,
+		check_foreign_folder_idle,
+		cffd,
+		e_ews_check_foreign_folder_data_free);
+
+	g_free (description);
+	g_free (show_foldername);
+}
+
+static void
+pick_gal_user_clicked_cb (GtkButton *button,
+                          GObject *dialog)
+{
+	GtkEntry *entry;
+	CamelEwsStore *ews_store;
+	EEwsConnection *conn;
+	gchar *text, *display_name = NULL, *email = NULL;
+
+	g_return_if_fail (dialog != NULL);
+
+	entry = g_object_get_data (dialog, STR_USER_NAME_SELECTOR_ENTRY);
+	ews_store = g_object_get_data (dialog, STR_EWS_CAMEL_STORE);
+
+	g_return_if_fail (entry != NULL);
+	g_return_if_fail (ews_store != NULL);
+
+	text = g_strstrip (g_strdup (gtk_entry_get_text (entry)));
+	conn = camel_ews_store_ref_connection (ews_store);
+
+	if (e_ews_search_user_modal (GTK_WINDOW (dialog),
+				     conn,
+				     text,
+				     &display_name,
+				     &email)) {
+		if (display_name && email && *email) {
+			gtk_entry_set_text (entry, display_name);
+			g_object_set_data_full (G_OBJECT (entry), STR_EWS_DIRECT_EMAIL, g_strdup (email), g_free);
+		}
+	}
+
+	g_free (text);
+	g_free (display_name);
+	g_free (email);
+	g_object_unref (conn);
+}
+
+/* Opens dialog to subscribe to folders of other
+ * users in the given store */
+void
+e_ews_subscribe_foreign_folder (GtkWindow *parent,
+                                CamelSession *session,
+                                CamelStore *store,
+				const gchar *store_display_name)
+{
+	PangoAttrList *attrs;
+	ENameSelector *name_selector;
+	ENameSelectorModel *name_selector_model;
+	ENameSelectorDialog *name_selector_dialog;
+	GObject *dialog;
+	GtkWidget *content;
+	GtkWidget *label, *widget, *entry, *check;
+	GtkTable *table;
+	GtkComboBox *combo_text;
+	GtkListStore *list_store;
+	gchar *display_name;
+	gint row;
+
+	g_return_if_fail (session != NULL);
+	g_return_if_fail (store != NULL);
+	g_return_if_fail (CAMEL_IS_EWS_STORE (store));
+
+	dialog = G_OBJECT (gtk_dialog_new_with_buttons (
+		_("Subscribe to folder of other EWS user..."),
+		parent,
+		GTK_DIALOG_DESTROY_WITH_PARENT,
+		GTK_STOCK_CLOSE, GTK_RESPONSE_CLOSE,
+		GTK_STOCK_OK, GTK_RESPONSE_OK,
+		NULL));
+
+	gtk_dialog_set_has_separator (GTK_DIALOG (dialog), FALSE);
+	g_signal_connect (dialog, "response", G_CALLBACK (subscribe_foreign_response_cb), NULL);
+
+	content = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
+
+	table = GTK_TABLE (gtk_table_new (4, 3, FALSE));
+	gtk_table_set_row_spacings (table, 6);
+	gtk_table_set_col_spacings (table, 6);
+	gtk_container_set_border_width (GTK_CONTAINER (table), 12);
+	gtk_container_add (GTK_CONTAINER (content), GTK_WIDGET (table));
+
+	row = 0;
+
+	label = gtk_label_new (_("Account:"));
+	g_object_set (
+		G_OBJECT (label),
+		"xalign", 0.0,
+		NULL);
+
+	display_name = camel_service_get_name (CAMEL_SERVICE (store), FALSE);
+	attrs = pango_attr_list_new ();
+	pango_attr_list_insert (attrs, pango_attr_weight_new (PANGO_WEIGHT_BOLD));
+	widget = gtk_label_new (store_display_name ? store_display_name : display_name);
+	g_object_set (
+		G_OBJECT (widget),
+		"use-underline", FALSE,
+		"attributes", attrs,
+		"xalign", 0.0,
+		"ellipsize", PANGO_ELLIPSIZE_END,
+		NULL);
+	pango_attr_list_unref (attrs);
+
+	g_object_set_data_full (dialog, STR_STORE_DISPLAY_NAME, g_strdup (store_display_name ? store_display_name : display_name), g_free);
+
+	g_free (display_name);
+
+	gtk_table_attach (table, label, 0, 1, row, row + 1, 0, 0, 0, 0);
+	gtk_table_attach (table, widget, 1, 3, row, row + 1, GTK_FILL | GTK_EXPAND, 0, 0, 0);
+
+	row++;
+
+	name_selector = e_name_selector_new ();
+	name_selector_model = e_name_selector_peek_model (name_selector);
+	e_name_selector_model_add_section (name_selector_model, "User", _("User"), NULL);
+	name_selector_dialog = e_name_selector_peek_dialog (name_selector);
+	g_signal_connect (name_selector_dialog, "response", G_CALLBACK (gtk_widget_hide), name_selector);
+
+	g_object_set_data_full (dialog, "e-ews-name-selector", name_selector, g_object_unref);
+
+	label = gtk_label_new_with_mnemonic (_("_User:"));
+	g_object_set (
+		G_OBJECT (label),
+		"xalign", 0.0,
+		NULL);
+
+	entry = GTK_WIDGET (e_name_selector_peek_section_entry (name_selector, "User"));
+
+	widget = gtk_button_new_with_mnemonic (_("C_hoose..."));
+	gtk_label_set_mnemonic_widget (GTK_LABEL (label), entry);
+	g_signal_connect (widget, "clicked", G_CALLBACK (pick_gal_user_clicked_cb), dialog);
+
+	gtk_table_attach (table, label, 0, 1, row, row + 1, 0, 0, 0, 0);
+	gtk_table_attach (table, entry, 1, 2, row, row + 1, GTK_EXPAND | GTK_FILL, 0, 0, 0);
+	gtk_table_attach (table, widget, 2, 3, row, row + 1, 0, 0, 0, 0);
+
+	row++;
+
+	label = gtk_label_new_with_mnemonic (_("_Folder name:"));
+	g_object_set (
+		G_OBJECT (label),
+		"xalign", 0.0,
+		NULL);
+
+	list_store = gtk_list_store_new (1, G_TYPE_STRING);
+	widget = GTK_WIDGET (
+		g_object_new (gtk_combo_box_entry_get_type (),
+		"text-column", 0,
+		"model", list_store,
+		NULL));
+	g_object_unref (list_store);
+
+	combo_text = GTK_COMBO_BOX (widget);
+	gtk_combo_box_append_text (combo_text, _("Inbox"));
+	gtk_combo_box_append_text (combo_text, _("Contacts"));
+	gtk_combo_box_append_text (combo_text, _("Calendar"));
+	gtk_combo_box_append_text (combo_text, _("Memos"));
+	gtk_combo_box_append_text (combo_text, _("Tasks"));
+	gtk_combo_box_set_active (combo_text, 0);
+
+	gtk_label_set_mnemonic_widget (GTK_LABEL (label), widget);
+	gtk_table_attach (table, label, 0, 1, row, row + 1, 0, 0, 0, 0);
+	gtk_table_attach (table, widget, 1, 3, row, row + 1, GTK_EXPAND | GTK_FILL, 0, 0, 0);
+
+	row++;
+
+	check = gtk_check_button_new_with_mnemonic (_("Include _subfolders"));
+	gtk_table_attach (table, check, 1, 3, row, row + 1, GTK_EXPAND | GTK_FILL, 0, 0, 0);
+
+	/* remember widgets for later use */
+	g_object_set_data (dialog, STR_USER_NAME_SELECTOR_ENTRY, entry);
+	g_object_set_data (dialog, STR_FOLDER_NAME_COMBO, widget);
+	g_object_set_data (dialog, STR_SUBFOLDERS_CHECK, check);
+
+	g_object_set_data_full (dialog, STR_EWS_CAMEL_SESSION, g_object_ref (session), g_object_unref);
+	g_object_set_data_full (dialog, STR_EWS_CAMEL_STORE, g_object_ref (store), g_object_unref);
+
+	g_signal_connect_swapped (entry, "changed", G_CALLBACK (name_entry_changed_cb), dialog);
+	g_signal_connect_swapped (combo_text, "changed", G_CALLBACK (folder_name_combo_changed_cb), dialog);
+
+	name_entry_changed_cb (dialog);
+
+	gtk_widget_show_all (content);
+	gtk_widget_show (GTK_WIDGET (dialog));
+}
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-ews-subscribe-foreign-folder.h evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-ews-subscribe-foreign-folder.h
--- evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-ews-subscribe-foreign-folder.h	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-ews-subscribe-foreign-folder.h	2013-05-28 08:59:53.552713349 +0200
@@ -0,0 +1,35 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) version 3.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the program; if not, see <http://www.gnu.org/licenses/>
+ *
+ *
+ * Authors:
+ *    Milan Crha <mcrha@redhat.com>
+ *
+ * Copyright (C) 2012 Red Hat, Inc. (www.redhat.com)
+ *
+ */
+
+#ifndef E_EWS_SUBSCRIBE_FOREIGN_FOLDER_H
+#define E_EWS_SUBSCRIBE_FOREIGN_FOLDER_H
+
+#include <gtk/gtk.h>
+#include <camel/camel.h>
+
+void	e_ews_subscribe_foreign_folder	(GtkWindow *parent,
+					 CamelSession *session,
+					 CamelStore *store,
+					 const gchar *store_display_name);
+
+#endif /* E_EWS_SUBSCRIBE_FOREIGN_FOLDER_H */
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-mail-config-ews-delegates-page.c evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-mail-config-ews-delegates-page.c
--- evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-mail-config-ews-delegates-page.c	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-mail-config-ews-delegates-page.c	2013-05-28 08:59:53.553713375 +0200
@@ -0,0 +1,1398 @@
+/*
+ * e-mail-config-ews-delegates-page.c
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) version 3.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the program; if not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h>
+#include <unistd.h>
+
+#include <gtk/gtk.h>
+#include <glib/gi18n-lib.h>
+
+#include <e-util/e-util.h>
+#include <e-util/e-dialog-utils.h>
+
+#include "server/e-ews-connection.h"
+
+#include "e-ews-config-utils.h"
+#include "e-ews-search-user.h"
+#include "e-mail-config-ews-delegates-page.h"
+
+#include "server/e-ews-gnome-3-8-compat.h"
+
+#include "e-ews-config-utils.h"
+
+#define E_MAIL_CONFIG_EWS_DELEGATES_PAGE_GET_PRIVATE(obj) \
+	(G_TYPE_INSTANCE_GET_PRIVATE \
+	((obj), E_TYPE_MAIL_CONFIG_EWS_DELEGATES_PAGE, EMailConfigEwsDelegatesPagePrivate))
+
+struct _EMailConfigEwsDelegatesPagePrivate {
+	EAccount *account;
+	EEwsConnection *connection;
+
+	/* The try_password() method deposits results here.
+	 * This avoids calling GTK+ functions from multiple threads. */
+	GSList *orig_delegates; /* EwsDelegateInfo * */
+	GSList *new_delegates; /* EwsDelegateInfo * */
+	EwsDelegateDeliver deliver_to;
+	GMutex *delegates_lock;
+
+	GtkWidget *users_tree_view;			/* not referenced */
+	GtkWidget *add_button;				/* not referenced */
+	GtkWidget *remove_button;			/* not referenced */
+	GtkWidget *properties_button;			/* not referenced */
+	GtkWidget *deliver_copy_me_radio;		/* not referenced */
+	GtkWidget *deliver_delegates_only_radio;	/* not referenced */
+	GtkWidget *deliver_delegates_and_me_radio;	/* not referenced */
+};
+
+enum {
+	PROP_0,
+	PROP_ACCOUNT
+};
+
+/* Forward Declarations */
+gchar *org_gnome_ews_get_password (EAccount *account, gboolean reask, const GError *error);
+
+static void	add_to_tree_view	(EMailConfigEwsDelegatesPage *page,
+					 EwsDelegateInfo *di,
+					 gboolean select);
+static gboolean	page_contains_user	(EMailConfigEwsDelegatesPage *page,
+					 const gchar *primary_smtp,
+					 GtkTreeIter *piter);
+static gint	sort_by_display_name_cb (gconstpointer a,
+					 gconstpointer b);
+
+G_DEFINE_TYPE (
+	EMailConfigEwsDelegatesPage,
+	e_mail_config_ews_delegates_page,
+	GTK_TYPE_VBOX)
+
+static const gchar *
+mail_config_ews_delegates_page_get_mailbox (EMailConfigEwsDelegatesPage *page)
+{
+	return e_account_get_string (page->priv->account, E_ACCOUNT_ID_ADDRESS);
+}
+
+static void
+enable_delegates_page_widgets (EMailConfigEwsDelegatesPage *page,
+                               gboolean enable)
+{
+	gboolean has_users = FALSE;
+
+	g_return_if_fail (page != NULL);
+
+	if (enable)
+		has_users = page->priv->new_delegates != NULL;
+
+	gtk_widget_set_sensitive (page->priv->users_tree_view, enable && has_users);
+	gtk_widget_set_sensitive (page->priv->add_button, enable);
+	gtk_widget_set_sensitive (page->priv->deliver_copy_me_radio, enable && has_users);
+	gtk_widget_set_sensitive (page->priv->deliver_delegates_only_radio, enable && has_users);
+	gtk_widget_set_sensitive (page->priv->deliver_delegates_and_me_radio, enable && has_users);
+
+	if (enable) {
+		GtkTreeSelection *selection;
+
+		selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (page->priv->users_tree_view));
+		enable = gtk_tree_selection_count_selected_rows (selection) == 1;
+	}
+
+	gtk_widget_set_sensitive (page->priv->remove_button, enable);
+	gtk_widget_set_sensitive (page->priv->properties_button, enable);
+}
+
+static EwsDelegateInfo *
+copy_delegate_info (const EwsDelegateInfo *src)
+{
+	EwsDelegateInfo *di;
+
+	g_return_val_if_fail (src != NULL, NULL);
+
+	di = g_new0 (EwsDelegateInfo, 1);
+	di->user_id = g_new0 (EwsUserId, 1);
+	di->user_id->sid = g_strdup (src->user_id->sid);
+	di->user_id->primary_smtp = g_strdup (src->user_id->primary_smtp);
+	di->user_id->display_name = g_strdup (src->user_id->display_name);
+	di->user_id->distinguished_user = g_strdup (src->user_id->distinguished_user);
+	di->user_id->external_user = g_strdup (src->user_id->external_user);
+	di->calendar = src->calendar;
+	di->tasks = src->tasks;
+	di->inbox = src->inbox;
+	di->contacts = src->contacts;
+	di->notes = src->notes;
+	di->journal = src->journal;
+	di->meetingcopies = src->meetingcopies;
+	di->view_priv_items = src->view_priv_items;
+
+	return di;
+}
+
+static void
+mail_config_ews_delegates_page_refresh_cb (GObject *source_object,
+                                           GAsyncResult *result,
+                                           gpointer user_data)
+{
+	EMailConfigEwsDelegatesPage *page = user_data;
+	EwsDelegateDeliver deliver_to;
+	GSList *delegates = NULL;
+	GError *local_error = NULL;
+
+	if (e_ews_connection_get_delegate_finish (page->priv->connection, result,
+		&deliver_to, &delegates, &local_error) ||
+	    g_error_matches (local_error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_ITEMNOTFOUND)) {
+		GtkWidget *radio = page->priv->deliver_copy_me_radio;
+		GtkTreeModel *model;
+		const GSList *iter;
+
+		if (local_error) {
+			deliver_to = EwsDelegateDeliver_DelegatesAndSendInformationToMe;
+			delegates = NULL;
+			g_clear_error (&local_error);
+		}
+
+		/* The page takes ownership of the settings. */
+		g_mutex_lock (page->priv->delegates_lock);
+		g_slist_free_full (page->priv->orig_delegates, (GDestroyNotify) ews_delegate_info_free);
+
+		page->priv->deliver_to = deliver_to;
+		page->priv->orig_delegates = g_slist_sort (delegates, sort_by_display_name_cb);
+
+		switch (page->priv->deliver_to) {
+		case EwsDelegateDeliver_DelegatesOnly:
+			radio = page->priv->deliver_delegates_only_radio;
+			break;
+		case EwsDelegateDeliver_DelegatesAndMe:
+			radio = page->priv->deliver_delegates_and_me_radio;
+			break;
+		case EwsDelegateDeliver_DelegatesAndSendInformationToMe:
+			radio = page->priv->deliver_copy_me_radio;
+			break;
+		}
+
+		gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (radio), TRUE);
+
+		model = gtk_tree_view_get_model (GTK_TREE_VIEW (page->priv->users_tree_view));
+		gtk_list_store_clear (GTK_LIST_STORE (model));
+
+		for (iter = page->priv->orig_delegates; iter; iter = iter->next) {
+			const EwsDelegateInfo *orig_di = iter->data;
+			EwsDelegateInfo *di;
+
+			if (!orig_di) {
+				g_warn_if_reached ();
+				continue;
+			}
+
+			di = copy_delegate_info (orig_di);
+
+			add_to_tree_view (page, di, FALSE);
+		}
+
+		g_mutex_unlock (page->priv->delegates_lock);
+
+		enable_delegates_page_widgets (page, page->priv->connection != NULL);
+
+	} else if (g_error_matches (local_error, SOUP_HTTP_ERROR, SOUP_STATUS_UNAUTHORIZED)) {
+		g_object_unref (page->priv->connection);
+		page->priv->connection = NULL;
+		e_mail_config_ews_delegates_page_refresh (page, local_error);
+	} else if (local_error) {
+		GtkWindow *parent = e_ews_config_utils_get_widget_toplevel_window (GTK_WIDGET (page));
+
+		e_notice (parent, GTK_MESSAGE_ERROR, _("Retrieving Out of Office settings failed: %s"), local_error->message);
+	}
+
+	g_clear_error (&local_error);
+	g_object_unref (page);
+}
+
+static void
+mail_config_ews_delegates_page_set_account (EMailConfigEwsDelegatesPage *page,
+					    EAccount *account)
+{
+	g_return_if_fail (E_IS_ACCOUNT (account));
+	g_return_if_fail (page->priv->account == NULL);
+
+	page->priv->account = g_object_ref (account);
+}
+
+static void
+mail_config_ews_delegates_page_set_property (GObject *object,
+                                             guint property_id,
+                                             const GValue *value,
+                                             GParamSpec *pspec)
+{
+	switch (property_id) {
+		case PROP_ACCOUNT:
+			mail_config_ews_delegates_page_set_account (
+				E_MAIL_CONFIG_EWS_DELEGATES_PAGE (object),
+				g_value_get_object (value));
+			return;
+	}
+
+	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+}
+
+static void
+mail_config_ews_delegates_page_get_property (GObject *object,
+                                             guint property_id,
+                                             GValue *value,
+                                             GParamSpec *pspec)
+{
+	switch (property_id) {
+		case PROP_ACCOUNT:
+			g_value_set_object (
+				value,
+				e_mail_config_ews_delegates_page_get_account (
+				E_MAIL_CONFIG_EWS_DELEGATES_PAGE (object)));
+			return;
+	}
+
+	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+}
+
+static void
+mail_config_ews_delegates_page_dispose (GObject *object)
+{
+	EMailConfigEwsDelegatesPagePrivate *priv;
+
+	priv = E_MAIL_CONFIG_EWS_DELEGATES_PAGE_GET_PRIVATE (object);
+
+	if (priv->account != NULL) {
+		g_object_unref (priv->account);
+		priv->account = NULL;
+	}
+
+	if (priv->connection) {
+		g_object_unref (priv->connection);
+		priv->connection = NULL;
+	}
+
+	g_slist_free_full (priv->orig_delegates, (GDestroyNotify) ews_delegate_info_free);
+	priv->orig_delegates = NULL;
+
+	g_slist_free_full (priv->new_delegates, (GDestroyNotify) ews_delegate_info_free);
+	priv->new_delegates = NULL;
+
+	/* Chain up to parent's dispose() method. */
+	if (G_OBJECT_CLASS (e_mail_config_ews_delegates_page_parent_class)->dispose)
+		G_OBJECT_CLASS (e_mail_config_ews_delegates_page_parent_class)->dispose (object);
+}
+
+static void
+mail_config_ews_delegates_page_finalize (GObject *object)
+{
+	EMailConfigEwsDelegatesPagePrivate *priv;
+
+	priv = E_MAIL_CONFIG_EWS_DELEGATES_PAGE_GET_PRIVATE (object);
+
+	g_mutex_free (priv->delegates_lock);
+
+	/* Chain up to parent's finalize() method. */
+	if (G_OBJECT_CLASS (e_mail_config_ews_delegates_page_parent_class)->finalize)
+		G_OBJECT_CLASS (e_mail_config_ews_delegates_page_parent_class)->finalize (object);
+}
+
+static void
+delegates_tree_selection_changed_cb (GtkTreeSelection *selection,
+                                     EMailConfigEwsDelegatesPage *page)
+{
+	g_return_if_fail (selection != NULL);
+	g_return_if_fail (page != NULL);
+
+	enable_delegates_page_widgets (page, page->priv->connection != NULL);
+}
+
+static GtkWidget *
+add_permission_level_combo_row (GtkTable *table,
+                                gint row,
+                                const gchar *icon_name,
+                                const gchar *label_text,
+                                EwsPermissionLevel preselect)
+{
+	GtkWidget *image = NULL, *label;
+	GtkComboBox *combo;
+	gint index = 0;
+
+	g_return_val_if_fail (table != NULL, NULL);
+	g_return_val_if_fail (label_text != NULL, NULL);
+	g_return_val_if_fail (preselect != EwsPermissionLevel_Unknown, NULL);
+
+	combo = GTK_COMBO_BOX (gtk_combo_box_new_text ());
+	gtk_combo_box_append_text (combo, C_("PermissionsLevel", "None"));
+	gtk_combo_box_append_text (combo, C_("PermissionsLevel", "Reviewer (can read items)"));
+	gtk_combo_box_append_text (combo, C_("PermissionsLevel", "Author (can read and create items)"));
+	gtk_combo_box_append_text (combo, C_("PermissionsLevel", "Editor (can read, create and modify items)"));
+
+	switch (preselect) {
+	case EwsPermissionLevel_Unknown:
+		break;
+	case EwsPermissionLevel_None:
+		index = 0;
+		break;
+	case EwsPermissionLevel_Reviewer:
+		index = 1;
+		break;
+	case EwsPermissionLevel_Author:
+		index = 2;
+		break;
+	case EwsPermissionLevel_Editor:
+		index = 3;
+		break;
+	case EwsPermissionLevel_Custom:
+		gtk_combo_box_append_text (combo, C_("PermissionsLevel", "Custom"));
+		index = 4;
+		break;
+	}
+
+	gtk_combo_box_set_active (GTK_COMBO_BOX (combo), index);
+
+	if (icon_name)
+		image = gtk_image_new_from_icon_name (icon_name, GTK_ICON_SIZE_BUTTON);
+	label = gtk_label_new_with_mnemonic (label_text);
+	gtk_label_set_mnemonic_widget (GTK_LABEL (label), GTK_WIDGET (combo));
+	gtk_misc_set_alignment (GTK_MISC (label), 0.0, 0.5);
+
+	if (image)
+		gtk_table_attach (table, image, 0, 1, row, row + 1, 0, 0, 0, 0);
+	gtk_table_attach (table, label, 1, 2, row, row + 1, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (table, GTK_WIDGET (combo), 2, 3, row, row + 1, GTK_EXPAND | GTK_FILL, 0, 0, 0);
+
+	return GTK_WIDGET (combo);
+}
+
+static EwsPermissionLevel
+get_permission_level_from_combo (GtkWidget *combo)
+{
+	EwsPermissionLevel res = EwsPermissionLevel_Unknown;
+
+	g_return_val_if_fail (GTK_IS_COMBO_BOX (combo), res);
+
+	switch (gtk_combo_box_get_active (GTK_COMBO_BOX (combo))) {
+	case 0:
+		res = EwsPermissionLevel_None;
+		break;
+	case 1:
+		res = EwsPermissionLevel_Reviewer;
+		break;
+	case 2:
+		res = EwsPermissionLevel_Author;
+		break;
+	case 3:
+		res = EwsPermissionLevel_Editor;
+		break;
+	case 4:
+		res = EwsPermissionLevel_Custom;
+		break;
+	default:
+		g_warn_if_reached ();
+		break;
+	}
+
+	return res;
+}
+
+static void
+enable_cal_copies_by_combo_index (GtkComboBox *combo,
+                                  GtkWidget *check)
+{
+	gtk_widget_set_sensitive (check, gtk_combo_box_get_active (combo) >= 3);
+}
+
+static void
+show_delegate_properties_modal (EMailConfigEwsDelegatesPage *page,
+                                EwsDelegateInfo *di)
+{
+	GtkWidget *dialog, *widget, *content_area;
+	GtkTable *table;
+	GtkWidget *lev_calendar, *lev_tasks, *lev_inbox, *lev_contacts, *lev_notes, *lev_journal;
+	GtkWidget *check_cal_copies, *check_see_private_items;
+	GtkWindow *parent;
+	const gchar *name;
+	gchar *text;
+	gint row = 0;
+
+	g_return_if_fail (page != NULL);
+	g_return_if_fail (di != NULL);
+
+	name = di->user_id->display_name;
+	if (!name)
+		name = di->user_id->primary_smtp;
+
+	parent = e_ews_config_utils_get_widget_toplevel_window (GTK_WIDGET (page));
+	dialog = gtk_dialog_new_with_buttons (
+		_("Delegate permissions"), parent,
+		GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,
+		GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+		GTK_STOCK_OK, GTK_RESPONSE_OK,
+		NULL);
+	gtk_dialog_set_has_separator (GTK_DIALOG (dialog), FALSE);
+
+	widget = gtk_table_new (7, 3, FALSE);
+	table = GTK_TABLE (widget);
+	gtk_table_set_row_spacings (table, 6);
+	gtk_table_set_col_spacings (table, 6);
+	g_object_set (
+		G_OBJECT (table),
+		"border-width", 12,
+		NULL);
+
+	row = 0;
+
+	lev_calendar = add_permission_level_combo_row (table, row, "x-office-calendar", _("C_alendar"), di->calendar);
+	row++;
+
+	check_cal_copies = gtk_check_button_new_with_mnemonic (_("_Delegate receives copies of meeting-related messages sent to me"));
+	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (check_cal_copies), di->meetingcopies);
+	gtk_table_attach (table, check_cal_copies, 1, 3, row, row + 1, GTK_FILL, 0, 0, 0);
+	row++;
+
+	lev_tasks = add_permission_level_combo_row (table, row, "evolution-tasks", _("_Tasks"), di->tasks);
+	row++;
+
+	lev_inbox = add_permission_level_combo_row (table, row, "mail-inbox", _("_Inbox"), di->inbox);
+	row++;
+
+	lev_contacts = add_permission_level_combo_row (table, row, "x-office-address-book", _("C_ontacts"), di->contacts);
+	row++;
+
+	lev_notes = add_permission_level_combo_row (table, row, "evolution-memos", _("_Notes"), di->notes);
+	row++;
+
+	lev_journal = add_permission_level_combo_row (table, row, NULL, _("_Journal"), di->journal);
+	row++;
+
+	text = g_strdup_printf (_("Delegate '%s' has the following permissions"), name);
+	widget = gtk_frame_new (text);
+	gtk_container_add (GTK_CONTAINER (widget), GTK_WIDGET (table));
+	g_free (text);
+
+	table = GTK_TABLE (gtk_table_new (1, 2, FALSE));
+	gtk_table_set_row_spacings (table, 6);
+	g_object_set (
+		G_OBJECT (table),
+		"border-width", 12,
+		NULL);
+
+	row = 0;
+
+	gtk_table_attach (table, widget, 0, 1, row, row + 1, GTK_EXPAND | GTK_FILL, GTK_EXPAND | GTK_FILL, 0, 0);
+	row++;
+
+	check_see_private_items = gtk_check_button_new_with_mnemonic (_("Delegate can see my _private items"));
+	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (check_see_private_items), di->view_priv_items);
+	gtk_table_attach (table, check_see_private_items, 0, 1, row, row + 1, GTK_EXPAND | GTK_FILL, 0, 0, 0);
+	row++;
+
+	gtk_widget_show_all (GTK_WIDGET (table));
+
+	content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
+	gtk_container_add (GTK_CONTAINER (content_area), GTK_WIDGET (table));
+
+	g_signal_connect (lev_calendar, "changed", G_CALLBACK (enable_cal_copies_by_combo_index), check_cal_copies);
+	enable_cal_copies_by_combo_index (GTK_COMBO_BOX (lev_calendar), check_cal_copies);
+
+	if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_OK) {
+		di->meetingcopies = gtk_widget_get_sensitive (check_cal_copies) &&
+			gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (check_cal_copies));
+
+		di->view_priv_items = gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (check_see_private_items));
+
+		#define update_perm_level(_member, _combo) {			\
+			EwsPermissionLevel level;				\
+										\
+			level = get_permission_level_from_combo (_combo);	\
+			if (di->_member != level) {				\
+				di->_member = level;				\
+			}							\
+		}
+
+		update_perm_level (calendar, lev_calendar);
+		update_perm_level (tasks, lev_tasks);
+		update_perm_level (inbox, lev_inbox);
+		update_perm_level (contacts, lev_contacts);
+		update_perm_level (notes, lev_notes);
+		update_perm_level (journal, lev_journal);
+
+		#undef update_perm_level
+
+		if (!page_contains_user (page, di->user_id->primary_smtp, NULL))
+			add_to_tree_view (page, copy_delegate_info (di), TRUE);
+	}
+
+	gtk_widget_destroy (dialog);
+}
+
+static void
+retrieve_user_permissions_idle_cb (GObject *ppage,
+                                   gpointer pdi,
+                                   GCancellable *cancellable,
+                                   GError **perror)
+{
+	EMailConfigEwsDelegatesPage *page = E_MAIL_CONFIG_EWS_DELEGATES_PAGE (ppage);
+	EwsDelegateInfo *di = pdi;
+
+	g_return_if_fail (page != NULL);
+	g_return_if_fail (di != NULL);
+
+	show_delegate_properties_modal (page, di);
+}
+
+static EwsPermissionLevel
+get_level_from_permissions (const GSList *permissions,
+                            const gchar *primary_smtp)
+{
+	EwsPermissionLevel level = EwsPermissionLevel_None;
+	const GSList *iter;
+
+	g_return_val_if_fail (primary_smtp != NULL, level);
+
+	for (iter = permissions; iter; iter = iter->next) {
+		EEwsPermission *perm = iter->data;
+
+		if (!perm || !perm->primary_smtp)
+			continue;
+
+		if (g_ascii_strcasecmp (primary_smtp, perm->primary_smtp) == 0) {
+			const gchar *level_name = e_ews_permission_rights_to_level_name (perm->rights);
+
+			if (g_strcmp0 (level_name, "None") == 0)
+				level = EwsPermissionLevel_None;
+			else if (g_strcmp0 (level_name, "Reviewer") == 0)
+				level = EwsPermissionLevel_Reviewer;
+			else if (g_strcmp0 (level_name, "Author") == 0)
+				level = EwsPermissionLevel_Author;
+			else if (g_strcmp0 (level_name, "Editor") == 0)
+				level = EwsPermissionLevel_Editor;
+			else
+				level = EwsPermissionLevel_Custom;
+			break;
+		}
+	}
+
+	return level;
+}
+
+static gboolean
+get_folder_permissions_sync (EEwsConnection *conn,
+                             const gchar *distinguished_folder_name,
+                             GSList **permissions,
+                             GCancellable *cancellable,
+                             GError **error)
+{
+	gboolean res;
+	EwsFolderId *folder_id;
+
+	if (g_strcmp0 (distinguished_folder_name, "calendar") == 0) {
+	} else if (g_strcmp0 (distinguished_folder_name, "tasks") == 0) {
+	} else if (g_strcmp0 (distinguished_folder_name, "inbox") == 0) {
+	} else if (g_strcmp0 (distinguished_folder_name, "contacts") == 0) {
+	} else if (g_strcmp0 (distinguished_folder_name, "notes") == 0) {
+	} else if (g_strcmp0 (distinguished_folder_name, "journal") == 0) {
+	} else {
+		g_return_val_if_reached (FALSE);
+	}
+
+	folder_id = e_ews_folder_id_new (distinguished_folder_name, NULL, TRUE);
+
+	res = e_ews_connection_get_folder_permissions_sync (
+		conn, G_PRIORITY_DEFAULT, folder_id, permissions, cancellable, error);
+
+	e_ews_folder_id_free (folder_id);
+
+	return res;
+}
+
+static void
+retrieve_user_permissions_thread_cb (GObject *ppage,
+                                     gpointer pdi,
+                                     GCancellable *cancellable,
+                                     GError **perror)
+{
+	EMailConfigEwsDelegatesPage *page = E_MAIL_CONFIG_EWS_DELEGATES_PAGE (ppage);
+	EwsDelegateInfo *di = pdi;
+	GSList *permissions;
+	GError *local_error = NULL;
+
+	g_return_if_fail (page != NULL);
+	g_return_if_fail (di != NULL);
+	g_return_if_fail (page->priv->connection != NULL);
+
+	permissions = NULL;
+
+	#define get_permissions_for(_member, _folder_name)							\
+		if (!local_error && !g_cancellable_is_cancelled (cancellable) &&				\
+		    get_folder_permissions_sync (page->priv->connection, _folder_name,				\
+			&permissions, cancellable, &local_error)) {						\
+			di->_member = get_level_from_permissions (permissions, di->user_id->primary_smtp);	\
+														\
+			g_slist_free_full (permissions, (GDestroyNotify) e_ews_permission_free);		\
+			permissions = NULL;									\
+		} else {											\
+			di->_member = EwsPermissionLevel_None;							\
+		}
+
+	get_permissions_for (calendar, "calendar");
+	get_permissions_for (tasks, "tasks");
+	get_permissions_for (inbox, "inbox");
+	get_permissions_for (contacts, "contacts");
+	get_permissions_for (notes, "notes");
+	get_permissions_for (journal, "journal");
+
+	#undef get_permissions_for
+
+	if (local_error)
+		g_propagate_error (perror, local_error);
+
+	if (di->calendar == EwsPermissionLevel_None)
+		di->calendar = EwsPermissionLevel_Editor;
+
+	if (di->tasks == EwsPermissionLevel_None)
+		di->tasks = EwsPermissionLevel_Editor;
+}
+
+enum {
+	COL_NAME,
+	COL_DELEGATE_INFO
+};
+
+static gboolean
+page_contains_user (EMailConfigEwsDelegatesPage *page,
+                    const gchar *primary_smtp,
+                    GtkTreeIter *piter)
+{
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+	gboolean found = FALSE;
+
+	g_return_val_if_fail (page != NULL, FALSE);
+	g_return_val_if_fail (primary_smtp != NULL, FALSE);
+
+	model = gtk_tree_view_get_model (GTK_TREE_VIEW (page->priv->users_tree_view));
+	if (gtk_tree_model_get_iter_first (model, &iter)) {
+		do {
+			EwsDelegateInfo *info = NULL;
+
+			gtk_tree_model_get (model, &iter, COL_DELEGATE_INFO, &info, -1);
+
+			found = info &&
+				g_ascii_strcasecmp (info->user_id->primary_smtp, primary_smtp) == 0;
+		} while (!found && gtk_tree_model_iter_next (model, &iter));
+	}
+
+	if (piter)
+		*piter = iter;
+
+	return found;
+}
+
+static void
+add_to_tree_view (EMailConfigEwsDelegatesPage *page,
+                  EwsDelegateInfo *di,
+                  gboolean select)
+{
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+
+	g_return_if_fail (page != NULL);
+	g_return_if_fail (di != NULL);
+
+	model = gtk_tree_view_get_model (GTK_TREE_VIEW (page->priv->users_tree_view));
+	if (page_contains_user (page, di->user_id->primary_smtp, &iter)) {
+		ews_delegate_info_free (di);
+	} else {
+		const gchar *name;
+
+		name = di->user_id->display_name;
+		if (!name)
+			name = di->user_id->primary_smtp;
+
+		gtk_list_store_append (GTK_LIST_STORE (model), &iter);
+		gtk_list_store_set (
+			GTK_LIST_STORE (model), &iter,
+			COL_NAME, name,
+			COL_DELEGATE_INFO, di,
+			-1);
+
+		page->priv->new_delegates = g_slist_append (page->priv->new_delegates, di);
+	}
+
+	if (select) {
+		GtkTreeSelection *selection;
+
+		selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (page->priv->users_tree_view));
+		gtk_tree_selection_select_iter (selection, &iter);
+	}
+}
+
+static void
+add_button_clicked_cb (EMailConfigEwsDelegatesPage *page)
+{
+	GtkWindow *parent;
+	gchar *display_name = NULL, *email = NULL;
+
+	g_return_if_fail (page != NULL);
+
+	parent = e_ews_config_utils_get_widget_toplevel_window (GTK_WIDGET (page));
+
+	if (e_ews_search_user_modal (parent, page->priv->connection, NULL, &display_name, &email)) {
+		if (email && *email) {
+			EwsDelegateInfo *di;
+
+			di = g_new0 (EwsDelegateInfo, 1);
+			di->user_id = g_new0 (EwsUserId, 1);
+			di->user_id->display_name = display_name;
+			di->user_id->primary_smtp = email;
+			di->meetingcopies = TRUE;
+			di->view_priv_items = FALSE;
+
+			if (page_contains_user (page, email, NULL))
+				add_to_tree_view (page, di, TRUE);
+			else
+				e_ews_config_utils_run_in_thread_with_feedback_modal (
+					parent, G_OBJECT (page),
+					_("Retrieving current user permissions, please wait..."),
+					retrieve_user_permissions_thread_cb,
+					retrieve_user_permissions_idle_cb,
+					di, (GDestroyNotify) ews_delegate_info_free);
+
+			display_name = NULL;
+			email = NULL;
+		}
+	}
+
+	g_free (display_name);
+	g_free (email);
+}
+
+static void
+remove_button_clicked_cb (EMailConfigEwsDelegatesPage *page)
+{
+	GtkTreeSelection *selection;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+
+	g_return_if_fail (page != NULL);
+
+	selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (page->priv->users_tree_view));
+	if (selection && gtk_tree_selection_get_selected (selection, &model, &iter)) {
+		GtkTreeIter select;
+		gboolean can_select = FALSE;
+		EwsDelegateInfo *di = NULL;
+
+		select = iter;
+		can_select = gtk_tree_model_iter_next (model, &select);
+
+		if (can_select)
+			gtk_tree_selection_select_iter (selection, &select);
+
+		gtk_tree_model_get (model, &iter, COL_DELEGATE_INFO, &di, -1);
+		gtk_list_store_remove (GTK_LIST_STORE (model), &iter);
+
+		page->priv->new_delegates = g_slist_remove (page->priv->new_delegates, di);
+		ews_delegate_info_free (di);
+
+		enable_delegates_page_widgets (page, page->priv->connection != NULL);
+	}
+}
+
+static void
+properties_button_clicked_cb (EMailConfigEwsDelegatesPage *page)
+{
+	GtkTreeSelection *selection;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+
+	g_return_if_fail (page != NULL);
+	selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (page->priv->users_tree_view));
+	if (selection && gtk_tree_selection_get_selected (selection, &model, &iter)) {
+		EwsDelegateInfo *di = NULL;
+
+		gtk_tree_model_get (model, &iter, COL_DELEGATE_INFO, &di, -1);
+
+		if (di) {
+			g_return_if_fail (di->calendar != EwsPermissionLevel_Unknown);
+
+			show_delegate_properties_modal (page, di);
+		}
+	}
+}
+
+static GtkWidget *
+create_users_tree_view (EMailConfigEwsDelegatesPage *page)
+{
+	GtkTreeView *tree_view;
+	GtkTreeSelection *selection;
+	GtkCellRenderer *renderer;
+	GtkTreeViewColumn *column;
+	gint pos;
+
+	g_return_val_if_fail (page != NULL, NULL);
+
+	tree_view = GTK_TREE_VIEW (gtk_tree_view_new_with_model (
+		GTK_TREE_MODEL (gtk_list_store_new (2, G_TYPE_STRING, G_TYPE_POINTER))));
+	gtk_tree_view_set_headers_visible (tree_view, FALSE);
+
+	renderer = gtk_cell_renderer_text_new ();
+	g_object_set (renderer, "editable", FALSE, NULL);
+	pos = gtk_tree_view_insert_column_with_attributes (tree_view, -1, _("Name"), renderer, "text", COL_NAME, NULL);
+	column = gtk_tree_view_get_column (tree_view, pos - 1);
+	gtk_tree_view_column_set_expand (column, TRUE);
+
+	selection = gtk_tree_view_get_selection (tree_view);
+	gtk_tree_selection_set_mode (selection, GTK_SELECTION_SINGLE);
+	g_signal_connect (selection, "changed", G_CALLBACK (delegates_tree_selection_changed_cb), page);
+
+	g_signal_connect_swapped (tree_view, "row-activated", G_CALLBACK (properties_button_clicked_cb), page);
+
+	page->priv->users_tree_view = GTK_WIDGET (tree_view);
+
+	return page->priv->users_tree_view;
+}
+
+static void
+mail_config_ews_delegates_page_constructed (GObject *object)
+{
+	EMailConfigEwsDelegatesPage *page;
+	GtkTable *table;
+	GtkWidget *widget, *button, *hvbox;
+	GSList *radio_group;
+	gchar *markup;
+	gint row = 0;
+
+	page = E_MAIL_CONFIG_EWS_DELEGATES_PAGE (object);
+
+	/* Chain up to parent's constructed() method. */
+	if (G_OBJECT_CLASS (e_mail_config_ews_delegates_page_parent_class)->constructed)
+		G_OBJECT_CLASS (e_mail_config_ews_delegates_page_parent_class)->constructed (object);
+
+	gtk_box_set_spacing (GTK_BOX (page), 12);
+	gtk_container_set_border_width (GTK_CONTAINER (page), 12);
+
+	widget = gtk_table_new (7, 2, FALSE);
+	gtk_box_pack_start (GTK_BOX (page), widget, FALSE, FALSE, 0);
+
+	table = GTK_TABLE (widget);
+	gtk_table_set_row_spacings (table, 6);
+	gtk_table_set_col_spacings (table, 6);
+
+	markup = g_markup_printf_escaped ("<b>%s</b>", _("Delegates"));
+	widget = gtk_label_new (markup);
+	gtk_label_set_use_markup (GTK_LABEL (widget), TRUE);
+	gtk_misc_set_alignment (GTK_MISC (widget), 0.0, 0.5);
+	gtk_table_attach (table, widget, 0, 2, row, row + 1, GTK_EXPAND | GTK_FILL, GTK_FILL, 0, 0);
+	gtk_widget_show (widget);
+	g_free (markup);
+
+	row++;
+
+	widget = gtk_label_new (
+		_("Delegates can send items on your behalf, including creating and "
+		"responding to meeting requests. If you want to grant folder "
+		"permissions without giving send-on-behalf-of permissions, close this "
+		"dialog box, right-click the folder, click Permissions and change the options there."));
+	gtk_label_set_line_wrap (GTK_LABEL (widget), TRUE);
+	gtk_misc_set_alignment (GTK_MISC (widget), 0.0, 0.5);
+	gtk_table_attach (table, widget, 0, 2, row, row + 1, GTK_EXPAND | GTK_FILL, GTK_FILL, 12, 0);
+
+	row++;
+
+	widget = gtk_scrolled_window_new (NULL, NULL);
+	gtk_container_add (GTK_CONTAINER (widget), create_users_tree_view (page));
+	g_object_set (
+		G_OBJECT (widget),
+		"shadow-type", GTK_SHADOW_IN,
+		"hscrollbar-policy", GTK_POLICY_AUTOMATIC,
+		"vscrollbar-policy", GTK_POLICY_AUTOMATIC,
+		NULL);
+
+	gtk_table_attach (table, widget, 0, 1, row, row + 1, GTK_EXPAND | GTK_FILL, GTK_FILL, 12, 0);
+
+	hvbox = gtk_vbox_new (6, TRUE);
+
+	button = gtk_button_new_from_stock (GTK_STOCK_ADD);
+	page->priv->add_button = button;
+	gtk_container_add (GTK_CONTAINER (hvbox), button);
+
+	button = gtk_button_new_from_stock (GTK_STOCK_REMOVE);
+	page->priv->remove_button = button;
+	gtk_container_add (GTK_CONTAINER (hvbox), button);
+
+	button = gtk_button_new_from_stock (GTK_STOCK_PROPERTIES);
+	page->priv->properties_button = button;
+	gtk_container_add (GTK_CONTAINER (hvbox), button);
+
+	gtk_table_attach (table, hvbox, 1, 2, row, row + 1, 0, 0, 0, 0);
+
+	row++;
+
+	widget = gtk_label_new (
+		_("Deliver meeting requests addressed to me and responses to meeting "
+		"requests where I am the organizer to:"));
+	gtk_label_set_line_wrap (GTK_LABEL (widget), TRUE);
+	gtk_misc_set_alignment (GTK_MISC (widget), 0.0, 0.5);
+	gtk_table_attach (table, widget, 0, 2, row, row + 1, GTK_FILL, 0, 12, 0);
+
+	row++;
+
+	/* new-line break, because GtkRadioButton doesn't allow wrapping of the inner label */
+	widget = gtk_radio_button_new_with_mnemonic (NULL, _("My delegates only, but _send a copy of meeting requests\nand responses to me (recommended)"));
+	page->priv->deliver_copy_me_radio = widget;
+	radio_group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (widget));
+	gtk_table_attach (table, widget, 0, 2, row, row + 1, GTK_FILL, 0, 12, 0);
+
+	row++;
+
+	widget = gtk_radio_button_new_with_mnemonic (radio_group, _("My d_elegates only"));
+	page->priv->deliver_delegates_only_radio = widget;
+	radio_group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (widget));
+	gtk_table_attach (table, widget, 0, 2, row, row + 1, GTK_FILL, 0, 12, 0);
+
+	row++;
+
+	widget = gtk_radio_button_new_with_mnemonic (radio_group, _("My delegates a_nd me"));
+	page->priv->deliver_delegates_and_me_radio = widget;
+	radio_group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (widget));
+	gtk_table_attach (table, widget, 0, 2, row, row + 1, GTK_FILL, 0, 12, 0);
+
+	g_signal_connect_swapped (
+		page->priv->add_button,
+		"clicked", G_CALLBACK (add_button_clicked_cb), page);
+	g_signal_connect_swapped (
+		page->priv->remove_button,
+		"clicked", G_CALLBACK (remove_button_clicked_cb), page);
+	g_signal_connect_swapped (
+		page->priv->properties_button,
+		"clicked", G_CALLBACK (properties_button_clicked_cb), page);
+
+	enable_delegates_page_widgets (page, FALSE);
+
+	gtk_widget_show_all (GTK_WIDGET (table));
+
+	if (e_ews_config_utils_is_online ())
+		e_mail_config_ews_delegates_page_refresh (page, NULL);
+}
+
+#define REMOVED_SLIST_KEY	"ews-delegate-removed-slist"
+#define ADDED_SLIST_KEY		"ews-delegate-added-slist"
+#define CANCELLABLE_KEY		"ews-delegate-cancellable"
+
+static void
+mail_config_ews_delegates_page_add_delegate_cb (GObject *source_object,
+                                                GAsyncResult *result,
+                                                gpointer user_data)
+{
+	GSimpleAsyncResult *simple;
+	GError *error = NULL;
+
+	simple = G_SIMPLE_ASYNC_RESULT (user_data);
+
+	e_ews_connection_add_delegate_finish (
+		E_EWS_CONNECTION (source_object), result, &error);
+
+	if (error != NULL)
+		g_simple_async_result_take_error (simple, error);
+
+	g_simple_async_result_complete (simple);
+
+	g_object_unref (simple);
+}
+
+static void
+mail_config_ews_delegates_page_remove_delegate_cb (GObject *source_object,
+                                                   GAsyncResult *result,
+                                                   gpointer user_data)
+{
+	GSimpleAsyncResult *simple;
+	GError *error = NULL;
+
+	simple = G_SIMPLE_ASYNC_RESULT (user_data);
+
+	e_ews_connection_remove_delegate_finish (
+		E_EWS_CONNECTION (source_object), result, &error);
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		g_simple_async_result_complete (simple);
+	} else {
+		GCancellable *cancellable;
+		GSList *list;
+
+		cancellable = g_object_get_data (G_OBJECT (simple), CANCELLABLE_KEY);
+		list = g_object_get_data (G_OBJECT (simple), ADDED_SLIST_KEY);
+		if (list) {
+			e_ews_connection_add_delegate (
+				E_EWS_CONNECTION (source_object), G_PRIORITY_DEFAULT, NULL, list,
+				cancellable, mail_config_ews_delegates_page_add_delegate_cb, g_object_ref (simple));
+		} else {
+			g_simple_async_result_complete (simple);
+		}
+	}
+
+	g_object_unref (simple);
+}
+
+static void
+mail_config_ews_delegates_page_update_delegate_cb (GObject *source_object,
+                                                   GAsyncResult *result,
+                                                   gpointer user_data)
+{
+	GSimpleAsyncResult *simple;
+	GError *error = NULL;
+
+	simple = G_SIMPLE_ASYNC_RESULT (user_data);
+
+	e_ews_connection_update_delegate_finish (
+		E_EWS_CONNECTION (source_object), result, &error);
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		g_simple_async_result_complete (simple);
+	} else {
+		GCancellable *cancellable;
+		GSList *list;
+
+		cancellable = g_object_get_data (G_OBJECT (simple), CANCELLABLE_KEY);
+		list = g_object_get_data (G_OBJECT (simple), REMOVED_SLIST_KEY);
+		if (list) {
+			e_ews_connection_remove_delegate (
+				E_EWS_CONNECTION (source_object), G_PRIORITY_DEFAULT, NULL, list,
+				cancellable, mail_config_ews_delegates_page_remove_delegate_cb, g_object_ref (simple));
+		} else {
+			list = g_object_get_data (G_OBJECT (simple), ADDED_SLIST_KEY);
+			if (list) {
+				e_ews_connection_add_delegate (
+					E_EWS_CONNECTION (source_object), G_PRIORITY_DEFAULT, NULL, list,
+					cancellable, mail_config_ews_delegates_page_add_delegate_cb, g_object_ref (simple));
+			} else {
+				g_simple_async_result_complete (simple);
+			}
+		}
+	}
+
+	g_object_unref (simple);
+}
+
+static gboolean
+delegate_infos_equal (const EwsDelegateInfo *di1,
+                       const EwsDelegateInfo *di2)
+{
+	if (!di1 || !di2)
+		return di1 == di2;
+
+	return g_strcmp0 (di1->user_id->primary_smtp, di2->user_id->primary_smtp) == 0 &&
+		di1->calendar == di2->calendar &&
+		di1->tasks == di2->tasks &&
+		di1->inbox == di2->inbox &&
+		di1->contacts == di2->contacts &&
+		di1->notes == di2->notes &&
+		di1->journal == di2->journal &&
+		(di1->meetingcopies ? 1 : 0) == (di2->meetingcopies ? 1 : 0) &&
+		(di1->view_priv_items ? 1 : 0) == (di2->view_priv_items ? 1 : 0);
+}
+
+static void
+mail_config_ews_delegates_page_submit (EMailConfigEwsDelegatesPage *page,
+                                       GCancellable *cancellable,
+                                       GAsyncReadyCallback callback,
+                                       gpointer user_data)
+{
+	EMailConfigEwsDelegatesPagePrivate *priv;
+	GSimpleAsyncResult *simple;
+	EwsDelegateDeliver deliver_to;
+	GSList *added = NULL, *updated = NULL, *removed = NULL, *iter;
+	GHashTable *oldies;
+	GHashTableIter titer;
+	gpointer key, value;
+
+	priv = E_MAIL_CONFIG_EWS_DELEGATES_PAGE_GET_PRIVATE (page);
+
+	g_mutex_lock (priv->delegates_lock);
+
+	if (!priv->connection) {
+		g_mutex_unlock (priv->delegates_lock);
+
+		simple = g_simple_async_result_new (
+			G_OBJECT (page), callback, user_data,
+			mail_config_ews_delegates_page_submit);
+		g_simple_async_result_complete_in_idle (simple);
+		g_object_unref (simple);
+
+		return;
+	}
+
+	oldies = g_hash_table_new (g_str_hash, g_str_equal);
+	for (iter = priv->orig_delegates; iter; iter = iter->next) {
+		EwsDelegateInfo *di = iter->data;
+
+		if (!di) {
+			g_warn_if_reached ();
+			continue;
+		}
+
+		g_hash_table_insert (oldies, di->user_id->primary_smtp, di);
+	}
+
+	for (iter = priv->new_delegates; iter; iter = iter->next) {
+		EwsDelegateInfo *di = iter->data;
+		EwsDelegateInfo *orig_di;
+
+		if (!di) {
+			g_warn_if_reached ();
+			continue;
+		}
+
+		orig_di = g_hash_table_lookup (oldies, di->user_id->primary_smtp);
+		if (!orig_di) {
+			added = g_slist_prepend (added, di);
+		} else {
+			if (!delegate_infos_equal (orig_di, di))
+				updated = g_slist_prepend (updated, di);
+			g_hash_table_remove (oldies, di->user_id->primary_smtp);
+		}
+	}
+
+	g_hash_table_iter_init (&titer, oldies);
+	while (g_hash_table_iter_next (&titer, &key, &value)) {
+		EwsDelegateInfo *di = value;
+
+		removed = g_slist_prepend (removed, di->user_id);
+	}
+
+	g_hash_table_destroy (oldies);
+
+	if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (priv->deliver_copy_me_radio)))
+		deliver_to = EwsDelegateDeliver_DelegatesAndSendInformationToMe;
+	else if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (priv->deliver_delegates_only_radio)))
+		deliver_to = EwsDelegateDeliver_DelegatesOnly;
+	else if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (priv->deliver_delegates_and_me_radio)))
+		deliver_to = EwsDelegateDeliver_DelegatesAndMe;
+	else
+		deliver_to = EwsDelegateDeliver_DelegatesAndSendInformationToMe;
+
+	if (deliver_to == priv->deliver_to && !added && !updated && !removed) {
+		/* nothing changed, bye bye */
+		g_mutex_unlock (priv->delegates_lock);
+
+		simple = g_simple_async_result_new (
+			G_OBJECT (page), callback, user_data,
+			mail_config_ews_delegates_page_submit);
+		g_simple_async_result_complete_in_idle (simple);
+		g_object_unref (simple);
+
+		return;
+	}
+
+	simple = g_simple_async_result_new (
+		G_OBJECT (page), callback, user_data,
+		mail_config_ews_delegates_page_submit);
+
+	g_simple_async_result_set_check_cancellable (simple, cancellable);
+
+	g_object_set_data_full (G_OBJECT (simple), REMOVED_SLIST_KEY, removed, (GDestroyNotify) g_slist_free);
+	g_object_set_data_full (G_OBJECT (simple), ADDED_SLIST_KEY, added, (GDestroyNotify) g_slist_free);
+	if (cancellable)
+		g_object_set_data_full (G_OBJECT (simple), CANCELLABLE_KEY, g_object_ref (cancellable), g_object_unref);
+
+	if (deliver_to != priv->deliver_to || updated) {
+		e_ews_connection_update_delegate (
+			priv->connection, G_PRIORITY_DEFAULT, NULL, deliver_to, updated,
+			cancellable, mail_config_ews_delegates_page_update_delegate_cb, g_object_ref (simple));
+	} else if (removed) {
+		e_ews_connection_remove_delegate (
+			priv->connection, G_PRIORITY_DEFAULT, NULL, removed,
+			cancellable, mail_config_ews_delegates_page_remove_delegate_cb, g_object_ref (simple));
+	} else {
+		g_warn_if_fail (added != NULL);
+
+		e_ews_connection_add_delegate (
+			priv->connection, G_PRIORITY_DEFAULT, NULL, added,
+			cancellable, mail_config_ews_delegates_page_add_delegate_cb, g_object_ref (simple));
+	}
+
+	g_object_unref (simple);
+
+	g_mutex_unlock (priv->delegates_lock);
+}
+
+static gboolean
+mail_config_ews_delegates_page_submit_finish (EMailConfigEwsDelegatesPage *page,
+                                              GAsyncResult *result,
+                                              GError **error)
+{
+	GSimpleAsyncResult *simple;
+
+	g_return_val_if_fail (
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (page),
+		mail_config_ews_delegates_page_submit), FALSE);
+
+	simple = G_SIMPLE_ASYNC_RESULT (result);
+
+	/* Assume success unless a GError is set. */
+	return !g_simple_async_result_propagate_error (simple, error);
+}
+
+static gint
+sort_by_display_name_cb (gconstpointer a,
+                         gconstpointer b)
+{
+	const EwsDelegateInfo *dia, *dib;
+	const gchar *aname, *bname;
+
+	if (!a || !b)
+		return GPOINTER_TO_INT (a) - GPOINTER_TO_INT (b);
+
+	dia = a;
+	dib = b;
+
+	aname = dia->user_id->display_name;
+	if (!aname)
+		aname = dia->user_id->primary_smtp;
+
+	bname = dib->user_id->display_name;
+	if (!bname)
+		bname = dib->user_id->primary_smtp;
+
+	if (!aname || !bname)
+		return GPOINTER_TO_INT (aname) - GPOINTER_TO_INT (bname);
+
+	return g_utf8_collate (aname, bname);
+}
+
+static void
+e_mail_config_ews_delegates_page_class_init (EMailConfigEwsDelegatesPageClass *class)
+{
+	GObjectClass *object_class;
+
+	g_type_class_add_private (
+		class, sizeof (EMailConfigEwsDelegatesPagePrivate));
+
+	object_class = G_OBJECT_CLASS (class);
+	object_class->set_property = mail_config_ews_delegates_page_set_property;
+	object_class->get_property = mail_config_ews_delegates_page_get_property;
+	object_class->dispose = mail_config_ews_delegates_page_dispose;
+	object_class->finalize = mail_config_ews_delegates_page_finalize;
+	object_class->constructed = mail_config_ews_delegates_page_constructed;
+
+	g_object_class_install_property (
+		object_class,
+		PROP_ACCOUNT,
+		g_param_spec_object (
+			"account",
+			"Account",
+			"Mail account being edited",
+			E_TYPE_ACCOUNT,
+			G_PARAM_READWRITE |
+			G_PARAM_CONSTRUCT_ONLY));
+}
+
+static void
+e_mail_config_ews_delegates_page_init (EMailConfigEwsDelegatesPage *page)
+{
+	page->priv = E_MAIL_CONFIG_EWS_DELEGATES_PAGE_GET_PRIVATE (page);
+
+	page->priv->delegates_lock = g_mutex_new ();
+}
+
+GtkWidget *
+e_mail_config_ews_delegates_page_new (EAccount *account)
+{
+	g_return_val_if_fail (E_IS_ACCOUNT (account), NULL);
+
+	return g_object_new (
+		E_TYPE_MAIL_CONFIG_EWS_DELEGATES_PAGE,
+		"account", account,
+		NULL);
+}
+
+void
+e_mail_config_ews_delegates_page_refresh (EMailConfigEwsDelegatesPage *page,
+					  const GError *with_error)
+{
+	EEwsConnection *connection;
+	const gchar *timeout_str;
+	gchar *password;
+	CamelURL *url;
+
+	g_return_if_fail (E_IS_MAIL_CONFIG_EWS_DELEGATES_PAGE (page));
+	g_return_if_fail (page->priv->account != NULL);
+	
+	password = org_gnome_ews_get_password (page->priv->account, with_error != NULL, with_error);
+	if (!password)
+		return;
+
+	url = camel_url_new (e_account_get_string (page->priv->account, E_ACCOUNT_SOURCE_URL), NULL);
+	timeout_str = camel_url_get_param (url, "timeout");
+	connection = e_ews_connection_new (camel_url_get_param (url, "hosturl"),
+		url->user,
+		password,
+		mail_config_ews_delegates_page_get_mailbox (page),
+		camel_url_get_param (url, "impersonate_user"),
+		timeout_str ? atoi (timeout_str) : -1,
+		TRUE,
+		NULL, NULL, NULL);
+
+	g_free (password);
+	password = NULL;
+
+	if (connection) {
+		page->priv->connection = connection;
+
+		e_ews_connection_get_delegate (connection,
+			G_PRIORITY_DEFAULT,
+			mail_config_ews_delegates_page_get_mailbox (page),
+			TRUE,
+			NULL,
+			mail_config_ews_delegates_page_refresh_cb,
+			g_object_ref (page));
+	}
+
+	camel_url_free (url);
+}
+
+EAccount *
+e_mail_config_ews_delegates_page_get_account (EMailConfigEwsDelegatesPage *page)
+{
+	g_return_val_if_fail (E_IS_MAIL_CONFIG_EWS_DELEGATES_PAGE (page), NULL);
+
+	return page->priv->account;
+}
+
+void
+e_mail_config_ews_delegates_page_commit (EMailConfigEwsDelegatesPage *page,
+					 GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+
+	g_return_if_fail (E_IS_MAIL_CONFIG_EWS_DELEGATES_PAGE (page));
+
+	closure = e_async_closure_new ();
+
+	mail_config_ews_delegates_page_submit (page, NULL, e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	mail_config_ews_delegates_page_submit_finish (page, result, error);
+
+	e_async_closure_free (closure);
+}
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-mail-config-ews-delegates-page.h evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-mail-config-ews-delegates-page.h
--- evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-mail-config-ews-delegates-page.h	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-mail-config-ews-delegates-page.h	2013-05-28 08:59:53.554712297 +0200
@@ -0,0 +1,71 @@
+/*
+ * e-mail-config-ews-delegates-page.h
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) version 3.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the program; if not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef E_MAIL_CONFIG_EWS_DELEGATES_PAGE_H
+#define E_MAIL_CONFIG_EWS_DELEGATES_PAGE_H
+
+#include <gtk/gtk.h>
+#include <libedataserver/e-account.h>
+
+/* Standard GObject macros */
+#define E_TYPE_MAIL_CONFIG_EWS_DELEGATES_PAGE \
+	(e_mail_config_ews_delegates_page_get_type ())
+#define E_MAIL_CONFIG_EWS_DELEGATES_PAGE(obj) \
+	(G_TYPE_CHECK_INSTANCE_CAST \
+	((obj), E_TYPE_MAIL_CONFIG_EWS_DELEGATES_PAGE, EMailConfigEwsDelegatesPage))
+#define E_MAIL_CONFIG_EWS_DELEGATES_PAGE_CLASS(cls) \
+	(G_TYPE_CHECK_CLASS_CAST \
+	((cls), E_TYPE_MAIL_CONFIG_EWS_DELEGATES_PAGE, EMailConfigEwsDelegatesPageClass))
+#define E_IS_MAIL_CONFIG_EWS_DELEGATES_PAGE(obj) \
+	(G_TYPE_CHECK_INSTANCE_TYPE \
+	((obj), E_TYPE_MAIL_CONFIG_EWS_DELEGATES_PAGE))
+#define E_IS_MAIL_CONFIG_EWS_DELEGATES_PAGE_CLASS(cls) \
+	(G_TYPE_CHECK_CLASS_TYPE \
+	((cls), E_TYPE_MAIL_CONFIG_EWS_DELEGATES_PAGE))
+#define E_MAIL_CONFIG_EWS_DELEGATES_PAGE_GET_CLASS(obj) \
+	(G_TYPE_INSTANCE_GET_CLASS \
+	((obj), E_TYPE_MAIL_CONFIG_EWS_DELEGATES_PAGE, EMailConfigEwsDelegatesPageClass))
+
+#define E_MAIL_CONFIG_EWS_DELEGATES_PAGE_SORT_ORDER (551)
+
+G_BEGIN_DECLS
+
+typedef struct _EMailConfigEwsDelegatesPage EMailConfigEwsDelegatesPage;
+typedef struct _EMailConfigEwsDelegatesPageClass EMailConfigEwsDelegatesPageClass;
+typedef struct _EMailConfigEwsDelegatesPagePrivate EMailConfigEwsDelegatesPagePrivate;
+
+struct _EMailConfigEwsDelegatesPage {
+	GtkVBox parent;
+	EMailConfigEwsDelegatesPagePrivate *priv;
+};
+
+struct _EMailConfigEwsDelegatesPageClass {
+	GtkVBoxClass parent_class;
+};
+
+GType		e_mail_config_ews_delegates_page_get_type	(void) G_GNUC_CONST;
+GtkWidget *	e_mail_config_ews_delegates_page_new		(EAccount *account);
+void		e_mail_config_ews_delegates_page_refresh	(EMailConfigEwsDelegatesPage *page,
+								 const GError *with_error);
+EAccount *	e_mail_config_ews_delegates_page_get_account	(EMailConfigEwsDelegatesPage *page);
+void		e_mail_config_ews_delegates_page_commit		(EMailConfigEwsDelegatesPage *page,
+								 GError **error);
+
+G_END_DECLS
+
+#endif /* E_MAIL_CONFIG_EWS_DELEGATES_PAGE_H */
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-mail-config-ews-ooo-page.c evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-mail-config-ews-ooo-page.c
--- evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-mail-config-ews-ooo-page.c	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-mail-config-ews-ooo-page.c	2013-05-28 08:59:53.553713375 +0200
@@ -0,0 +1,763 @@
+/*
+ * e-mail-config-ews-ooo-page.c
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) version 3.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the program; if not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "e-mail-config-ews-ooo-page.h"
+
+#include <string.h>
+#include <unistd.h>
+
+#include <gtk/gtk.h>
+#include <glib/gi18n-lib.h>
+
+#include <e-util/e-util.h>
+#include <e-util/e-dialog-utils.h>
+#include <misc/e-dateedit.h>
+
+#include "server/e-ews-connection.h"
+#include "server/e-ews-oof-settings.h"
+
+#include "server/e-ews-gnome-3-8-compat.h"
+
+#include "e-ews-config-utils.h"
+
+#define E_MAIL_CONFIG_EWS_OOO_PAGE_GET_PRIVATE(obj) \
+	(G_TYPE_INSTANCE_GET_PRIVATE \
+	((obj), E_TYPE_MAIL_CONFIG_EWS_OOO_PAGE, EMailConfigEwsOooPagePrivate))
+
+struct _EMailConfigEwsOooPagePrivate {
+	EAccount *account;
+
+	/* The try_password() method deposits results here.
+	 * This avoids calling GTK+ functions from multiple threads. */
+	EEwsOofSettings *oof_settings;
+	GMutex *oof_settings_lock;
+
+	/* to not save unchanged state */
+	gboolean changed;
+
+	GtkWidget *enabled_radio_button;	/* not referenced */
+	GtkWidget *disabled_radio_button;	/* not referenced */
+	GtkWidget *scheduled_radio_button;	/* not referenced */
+	GtkWidget *start_time;			/* not referenced */
+	GtkWidget *end_time;			/* not referenced */
+	GtkWidget *external_audience;		/* not referenced */
+	GtkTextBuffer *internal_reply;		/* not referenced */
+	GtkTextBuffer *external_reply;		/* not referenced */
+};
+
+enum {
+	PROP_0,
+	PROP_ACCOUNT
+};
+
+gchar *org_gnome_ews_get_password (EAccount *account, gboolean reask, const GError *error);
+
+G_DEFINE_TYPE (
+	EMailConfigEwsOooPage,
+	e_mail_config_ews_ooo_page,
+	GTK_TYPE_VBOX)
+
+static const gchar *
+mail_config_ews_ooo_page_get_mailbox (EMailConfigEwsOooPage *page)
+{
+	return e_account_get_string (page->priv->account, E_ACCOUNT_ID_ADDRESS);
+}
+
+static void
+mail_config_ews_ooo_page_display_settings (EMailConfigEwsOooPage *page,
+                                           EEwsOofSettings *oof_settings)
+{
+	GtkWidget *button;
+	GDateTime *date_time;
+
+	switch (e_ews_oof_settings_get_state (oof_settings)) {
+		default:
+			/* fall through */
+		case E_EWS_OOF_STATE_DISABLED:
+			button = page->priv->disabled_radio_button;
+			break;
+		case E_EWS_OOF_STATE_ENABLED:
+			button = page->priv->enabled_radio_button;
+			break;
+		case E_EWS_OOF_STATE_SCHEDULED:
+			button = page->priv->scheduled_radio_button;
+			break;
+	}
+
+	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (button), TRUE);
+
+	gtk_combo_box_set_active (
+		GTK_COMBO_BOX (page->priv->external_audience),
+		e_ews_oof_settings_get_external_audience (oof_settings));
+
+	date_time = e_ews_oof_settings_ref_start_time (oof_settings);
+	e_date_edit_set_time (
+		E_DATE_EDIT (page->priv->start_time),
+		(time_t) g_date_time_to_unix (date_time));
+	g_date_time_unref (date_time);
+
+	date_time = e_ews_oof_settings_ref_end_time (oof_settings);
+	e_date_edit_set_time (
+		E_DATE_EDIT (page->priv->end_time),
+		(time_t) g_date_time_to_unix (date_time));
+	g_date_time_unref (date_time);
+
+	gtk_text_buffer_set_text (
+		page->priv->internal_reply,
+		e_ews_oof_settings_get_internal_reply (oof_settings), -1);
+
+	gtk_text_buffer_set_text (
+		page->priv->external_reply,
+		e_ews_oof_settings_get_external_reply (oof_settings), -1);
+
+	gtk_widget_set_sensitive (page->priv->enabled_radio_button, TRUE);
+	gtk_widget_set_sensitive (page->priv->disabled_radio_button, TRUE);
+	gtk_widget_set_sensitive (page->priv->scheduled_radio_button, TRUE);
+}
+
+static void
+mail_config_ews_ooo_page_refresh_cb (GObject *source_object,
+                                     GAsyncResult *result,
+                                     gpointer user_data)
+{
+	EMailConfigEwsOooPage *page = user_data;
+	EEwsOofSettings *oof_settings;
+	GError *local_error = NULL;
+
+	g_return_if_fail (E_IS_MAIL_CONFIG_EWS_OOO_PAGE (page));
+
+	oof_settings = e_ews_oof_settings_new_finish (result, &local_error);
+
+	if (oof_settings != NULL) {
+		g_warn_if_fail (local_error == NULL);
+
+		/* The page takes ownership of the settings. */
+		g_mutex_lock (page->priv->oof_settings_lock);
+		if (page->priv->oof_settings != NULL)
+			g_object_unref (page->priv->oof_settings);
+		page->priv->oof_settings = oof_settings;
+		page->priv->changed = FALSE;
+		mail_config_ews_ooo_page_display_settings (
+			page, page->priv->oof_settings);
+		g_mutex_unlock (page->priv->oof_settings_lock);
+
+	} else if (g_error_matches (local_error, SOUP_HTTP_ERROR, SOUP_STATUS_UNAUTHORIZED)) {
+		e_mail_config_ews_ooo_page_refresh (page, local_error);
+	} else if (local_error) {
+		GtkWindow *parent = e_ews_config_utils_get_widget_toplevel_window (GTK_WIDGET (page));
+
+		e_notice (parent, GTK_MESSAGE_ERROR, _("Retrieving Out of Office settings failed: %s"), local_error->message);
+	}
+
+	g_clear_error (&local_error);
+	g_object_unref (page);
+}
+
+static void
+mail_config_ews_ooo_page_set_account (EMailConfigEwsOooPage *page,
+				      EAccount *account)
+{
+	g_return_if_fail (E_IS_ACCOUNT (account));
+	g_return_if_fail (page->priv->account == NULL);
+
+	page->priv->account = g_object_ref (account);
+}
+
+static void
+mail_config_ews_ooo_page_set_property (GObject *object,
+                                       guint property_id,
+                                       const GValue *value,
+                                       GParamSpec *pspec)
+{
+	switch (property_id) {
+		case PROP_ACCOUNT:
+			mail_config_ews_ooo_page_set_account (
+				E_MAIL_CONFIG_EWS_OOO_PAGE (object),
+				g_value_get_object (value));
+			return;
+	}
+
+	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+}
+
+static void
+mail_config_ews_ooo_page_get_property (GObject *object,
+                                       guint property_id,
+                                       GValue *value,
+                                       GParamSpec *pspec)
+{
+	switch (property_id) {
+		case PROP_ACCOUNT:
+			g_value_set_object (
+				value,
+				e_mail_config_ews_ooo_page_get_account (
+				E_MAIL_CONFIG_EWS_OOO_PAGE (object)));
+			return;
+	}
+
+	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+}
+
+static void
+mail_config_ews_ooo_page_dispose (GObject *object)
+{
+	EMailConfigEwsOooPagePrivate *priv;
+
+	priv = E_MAIL_CONFIG_EWS_OOO_PAGE_GET_PRIVATE (object);
+
+	if (priv->account != NULL) {
+		g_object_unref (priv->account);
+		priv->account = NULL;
+	}
+
+	if (priv->oof_settings != NULL) {
+		g_object_unref (priv->oof_settings);
+		priv->oof_settings = NULL;
+	}
+
+	/* Chain up to parent's dispose() method. */
+	if (G_OBJECT_CLASS (e_mail_config_ews_ooo_page_parent_class)->dispose)
+		G_OBJECT_CLASS (e_mail_config_ews_ooo_page_parent_class)->dispose (object);
+}
+
+static void
+mail_config_ews_ooo_page_finalize (GObject *object)
+{
+	EMailConfigEwsOooPagePrivate *priv;
+
+	priv = E_MAIL_CONFIG_EWS_OOO_PAGE_GET_PRIVATE (object);
+
+	g_mutex_free (priv->oof_settings_lock);
+
+	/* Chain up to parent's finalize() method. */
+	if (G_OBJECT_CLASS (e_mail_config_ews_ooo_page_parent_class)->finalize)
+		G_OBJECT_CLASS (e_mail_config_ews_ooo_page_parent_class)->finalize (object);
+}
+
+static void
+mail_config_ews_ooo_page_constructed (GObject *object)
+{
+	EMailConfigEwsOooPage *page;
+	GtkLabel *label;
+	GtkTable *table;
+	GtkWidget *widget;
+	GtkWidget *container;
+	GtkSizeGroup *size_group;
+	GtkTextBuffer *text_buffer;
+	GSList *group = NULL;
+	const gchar *text;
+	gchar *markup;
+	gint row = 0;
+
+	page = E_MAIL_CONFIG_EWS_OOO_PAGE (object);
+
+	/* Chain up to parent's constructed() method. */
+	if (G_OBJECT_CLASS (e_mail_config_ews_ooo_page_parent_class)->constructed)
+		G_OBJECT_CLASS (e_mail_config_ews_ooo_page_parent_class)->constructed (object);
+
+	size_group = gtk_size_group_new (GTK_SIZE_GROUP_HORIZONTAL);
+
+	gtk_box_set_spacing (GTK_BOX (page), 12);
+	gtk_container_set_border_width (GTK_CONTAINER (page), 12);
+
+	widget = gtk_table_new (5, 2, FALSE);
+	gtk_box_pack_start (GTK_BOX (page), widget, FALSE, TRUE, 0);
+	gtk_widget_show (widget);
+
+	table = GTK_TABLE (widget);
+
+	gtk_table_set_row_spacings (table, 6);
+	gtk_table_set_col_spacings (table, 6);
+
+	text = _("Out of Office");
+	markup = g_markup_printf_escaped ("<b>%s</b>", text);
+	widget = gtk_label_new (markup);
+	gtk_label_set_use_markup (GTK_LABEL (widget), TRUE);
+	gtk_misc_set_alignment (GTK_MISC (widget), 0.0, 0.5);
+	gtk_table_attach (table, widget, 0, 2, row, row + 1, GTK_EXPAND | GTK_FILL, 0, 0, 0);
+	gtk_widget_show (widget);
+	g_free (markup);
+
+	row++;
+
+	text = _("The messages specified below will be automatically sent to "
+		 "each internal and external person who sends a mail to you.");
+	widget = gtk_label_new (text);
+	gtk_label_set_line_wrap (GTK_LABEL (widget), TRUE);
+	gtk_misc_set_alignment (GTK_MISC (widget), 0.0, 0.5);
+	gtk_table_attach (table, widget, 0, 2, row, row + 1, GTK_EXPAND | GTK_FILL, 0, 12, 0);
+	gtk_widget_show (widget);
+
+	row++;
+
+	text = _("Do _not send Out of Office replies");
+	widget = gtk_radio_button_new_with_mnemonic (group, text);
+	gtk_table_attach (table, widget, 0, 2, row, row + 1, GTK_EXPAND | GTK_FILL, 0, 12, 0);
+	page->priv->disabled_radio_button = widget;  /* do not reference */
+	gtk_widget_show (widget);
+
+	row++;
+
+	group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (widget));
+
+	text = _("_Send Out of Office replies");
+	widget = gtk_radio_button_new_with_mnemonic (group, text);
+	gtk_table_attach (table, widget, 0, 2, row, row + 1, GTK_EXPAND | GTK_FILL, 0, 12, 0);
+	page->priv->enabled_radio_button = widget;  /* do not reference */
+	gtk_widget_show (widget);
+
+	row++;
+
+	group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (widget));
+
+	text = _("Send Out of Office replies only _during this time period:");
+	widget = gtk_radio_button_new_with_mnemonic (group, text);
+	gtk_table_attach (table, widget, 0, 2, row, row + 1, GTK_EXPAND | GTK_FILL, 0, 12, 0);
+	page->priv->scheduled_radio_button = widget;  /* do not reference */
+	gtk_widget_show (widget);
+
+	widget = gtk_table_new (5, 2, FALSE);
+	gtk_box_pack_start (GTK_BOX (page), widget, TRUE, TRUE, 0);
+	gtk_widget_show (widget);
+
+	table = GTK_TABLE (widget);
+	row = 0;
+
+	gtk_table_set_row_spacings (table, 6);
+	gtk_table_set_col_spacings (table, 6);
+
+	g_object_bind_property (
+		page->priv->disabled_radio_button, "active",
+		widget, "sensitive",
+		G_BINDING_SYNC_CREATE |
+		G_BINDING_INVERT_BOOLEAN);
+
+	widget = gtk_label_new_with_mnemonic (_("_From:"));
+	gtk_misc_set_alignment (GTK_MISC (widget), 1.0, 0.5);
+	gtk_table_attach (table, widget, 0, 1, row, row + 1, GTK_FILL, 0, 0, 0);
+	gtk_size_group_add_widget (size_group, widget);
+	gtk_widget_show (widget);
+
+	g_object_bind_property (
+		page->priv->scheduled_radio_button, "active",
+		widget, "sensitive",
+		G_BINDING_SYNC_CREATE);
+
+	label = GTK_LABEL (widget);
+
+	widget = e_date_edit_new ();
+	gtk_label_set_mnemonic_widget (label, widget);
+	gtk_table_attach (table, widget, 1, 2, row, row + 1, GTK_EXPAND | GTK_FILL, 0, 0, 0);
+	page->priv->start_time = widget;  /* do not reference */
+	gtk_widget_show (widget);
+
+	row++;
+
+	g_object_bind_property (
+		page->priv->scheduled_radio_button, "active",
+		widget, "sensitive",
+		G_BINDING_SYNC_CREATE);
+
+	widget = gtk_label_new_with_mnemonic (_("_To:"));
+	gtk_misc_set_alignment (GTK_MISC (widget), 1.0, 0.5);
+	gtk_table_attach (table, widget, 0, 1, row, row + 1, GTK_FILL, 0, 0, 0);
+	gtk_size_group_add_widget (size_group, widget);
+	gtk_widget_show (widget);
+
+	g_object_bind_property (
+		page->priv->scheduled_radio_button, "active",
+		widget, "sensitive",
+		G_BINDING_SYNC_CREATE);
+
+	label = GTK_LABEL (widget);
+
+	widget = e_date_edit_new ();
+	gtk_label_set_mnemonic_widget (label, widget);
+	gtk_table_attach (table, widget, 1, 2, row, row + 1, GTK_EXPAND | GTK_FILL, 0, 0, 0);
+	page->priv->end_time = widget;  /* do not reference */
+	gtk_widget_show (widget);
+
+	g_object_bind_property (
+		page->priv->scheduled_radio_button, "active",
+		widget, "sensitive",
+		G_BINDING_SYNC_CREATE);
+
+	row++;
+
+	widget = gtk_label_new_with_mnemonic (_("I_nternal:"));
+	gtk_misc_set_alignment (GTK_MISC (widget), 1.0, 0.0);
+	gtk_table_attach (table, widget, 0, 1, row, row + 1, GTK_FILL, GTK_FILL, 0, 0);
+	gtk_size_group_add_widget (size_group, widget);
+	gtk_widget_show (widget);
+
+	text = _("Message to be sent within the organization");
+	gtk_widget_set_tooltip_text (widget, text);
+
+	label = GTK_LABEL (widget);
+
+	widget = gtk_scrolled_window_new (NULL, NULL);
+	gtk_scrolled_window_set_policy (
+		GTK_SCROLLED_WINDOW (widget),
+		GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
+	gtk_scrolled_window_set_shadow_type (
+		GTK_SCROLLED_WINDOW (widget), GTK_SHADOW_IN);
+	gtk_table_attach (table, widget, 1, 2, row, row + 1, GTK_EXPAND | GTK_FILL, GTK_EXPAND | GTK_FILL, 0, 0);
+	gtk_widget_show (widget);
+
+	container = widget;
+
+	widget = gtk_text_view_new ();
+	gtk_label_set_mnemonic_widget (label, widget);
+	gtk_text_view_set_wrap_mode (GTK_TEXT_VIEW (widget), GTK_WRAP_WORD);
+	gtk_container_add (GTK_CONTAINER (container), widget);
+	text_buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (widget));
+	page->priv->internal_reply = text_buffer;  /* do not reference */
+	gtk_widget_show (widget);
+
+	row++;
+
+	widget = gtk_label_new_with_mnemonic (_("E_xternal:"));
+	gtk_misc_set_alignment (GTK_MISC (widget), 1.0, 0.5);
+	gtk_table_attach (table, widget, 0, 1, row, row + 1, GTK_FILL, 0, 0, 0);
+	gtk_size_group_add_widget (size_group, widget);
+	gtk_widget_show (widget);
+
+	text = _("Message to be sent outside the organization");
+	gtk_widget_set_tooltip_text (widget, text);
+
+	label = GTK_LABEL (widget);
+
+	/* The order of the combo box items needs to stay
+	 * syncrhonized with the EEwsExternalAudience enum. */
+	widget = gtk_combo_box_new_text ();
+	gtk_combo_box_append_text (
+		GTK_COMBO_BOX (widget),
+		_("Do not reply to senders outside the organization"));
+	gtk_combo_box_append_text (
+		GTK_COMBO_BOX (widget),
+		_("Reply only to known senders outside the organization"));
+	gtk_combo_box_append_text (
+		GTK_COMBO_BOX (widget),
+		_("Reply to any sender outside the organization"));
+	gtk_table_attach (table, widget, 1, 2, row, row + 1, GTK_EXPAND | GTK_FILL, 0, 0, 0);
+	page->priv->external_audience = widget;  /* do not reference */
+	gtk_widget_show (widget);
+
+	row++;
+
+	widget = gtk_scrolled_window_new (NULL, NULL);
+	gtk_scrolled_window_set_policy (
+		GTK_SCROLLED_WINDOW (widget),
+		GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
+	gtk_scrolled_window_set_shadow_type (
+		GTK_SCROLLED_WINDOW (widget), GTK_SHADOW_IN);
+	gtk_table_attach (table, widget, 1, 2, row, row + 1, GTK_EXPAND | GTK_FILL, GTK_EXPAND | GTK_FILL, 0, 0);
+	gtk_widget_show (widget);
+
+	container = widget;
+
+	widget = gtk_text_view_new ();
+	gtk_label_set_mnemonic_widget (label, widget);
+	gtk_text_view_set_wrap_mode (GTK_TEXT_VIEW (widget), GTK_WRAP_WORD);
+	gtk_container_add (GTK_CONTAINER (container), widget);
+	text_buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (widget));
+	page->priv->external_reply = text_buffer;  /* do not reference */
+	gtk_widget_show (widget);
+
+	/* XXX Bit of a hack.  Since the enum value for "none" is zero,
+	 *     sensitize the text view if the combo box has a non-zero
+	 *     "active" value (in other words, anything but "none"). */
+	g_object_bind_property (
+		page->priv->external_audience, "active",
+		widget, "sensitive",
+		G_BINDING_SYNC_CREATE);
+
+	g_object_unref (size_group);
+
+	gtk_widget_set_sensitive (page->priv->enabled_radio_button, FALSE);
+	gtk_widget_set_sensitive (page->priv->disabled_radio_button, FALSE);
+	gtk_widget_set_sensitive (page->priv->scheduled_radio_button, FALSE);
+
+	if (e_ews_config_utils_is_online ())
+		e_mail_config_ews_ooo_page_refresh (page, NULL);
+}
+
+/* Helper for mail_config_ews_ooo_page_submit() */
+static void
+mail_config_ews_ooo_page_submit_cb (GObject *source_object,
+                                    GAsyncResult *result,
+                                    gpointer user_data)
+{
+	GSimpleAsyncResult *simple;
+	GError *error = NULL;
+
+	simple = G_SIMPLE_ASYNC_RESULT (user_data);
+
+	e_ews_oof_settings_submit_finish (
+		E_EWS_OOF_SETTINGS (source_object), result, &error);
+
+	if (error != NULL)
+		g_simple_async_result_take_error (simple, error);
+
+	g_simple_async_result_complete (simple);
+
+	g_object_unref (simple);
+}
+
+static void
+ews_oof_settings_changed (gboolean *pchanged)
+{
+	g_return_if_fail (pchanged != NULL);
+
+	*pchanged = TRUE;
+}
+
+static void
+mail_config_ews_ooo_page_submit (EMailConfigEwsOooPage *page,
+                                 GCancellable *cancellable,
+                                 GAsyncReadyCallback callback,
+                                 gpointer user_data)
+{
+	EMailConfigEwsOooPagePrivate *priv;
+	GSimpleAsyncResult *simple;
+	GtkToggleButton *toggle_button;
+	GtkTextBuffer *text_buffer;
+	GtkTextIter start, end;
+	GDateTime *date_time;
+	gchar *text;
+	time_t tm;
+	gulong signal_id;
+
+	priv = E_MAIL_CONFIG_EWS_OOO_PAGE_GET_PRIVATE (page);
+
+	g_mutex_lock (priv->oof_settings_lock);
+
+	/* It may be that the Out of Office settings are still
+	 * loading or have failed to load, in which case there
+	 * are obviously no changes to submit. */
+	if (priv->oof_settings == NULL) {
+		g_mutex_unlock (priv->oof_settings_lock);
+
+		simple = g_simple_async_result_new (
+			G_OBJECT (page), callback, user_data,
+			mail_config_ews_ooo_page_submit);
+		g_simple_async_result_complete_in_idle (simple);
+		g_object_unref (simple);
+
+		return;
+	}
+
+	signal_id = g_signal_connect_swapped (
+		priv->oof_settings, "notify",
+		G_CALLBACK (ews_oof_settings_changed), &priv->changed);
+
+	toggle_button = GTK_TOGGLE_BUTTON (priv->enabled_radio_button);
+	if (gtk_toggle_button_get_active (toggle_button))
+		e_ews_oof_settings_set_state (
+			priv->oof_settings,
+			E_EWS_OOF_STATE_ENABLED);
+
+	toggle_button = GTK_TOGGLE_BUTTON (priv->disabled_radio_button);
+	if (gtk_toggle_button_get_active (toggle_button))
+		e_ews_oof_settings_set_state (
+			priv->oof_settings,
+			E_EWS_OOF_STATE_DISABLED);
+
+	toggle_button = GTK_TOGGLE_BUTTON (priv->scheduled_radio_button);
+	if (gtk_toggle_button_get_active (toggle_button))
+		e_ews_oof_settings_set_state (
+			priv->oof_settings,
+			E_EWS_OOF_STATE_SCHEDULED);
+
+	tm = e_date_edit_get_time (E_DATE_EDIT (priv->start_time));
+	date_time = g_date_time_new_from_unix_utc ((gint64) tm);
+	e_ews_oof_settings_set_start_time (priv->oof_settings, date_time);
+	g_date_time_unref (date_time);
+
+	tm = e_date_edit_get_time (E_DATE_EDIT (priv->end_time));
+	date_time = g_date_time_new_from_unix_utc ((gint64) tm);
+	e_ews_oof_settings_set_end_time (priv->oof_settings, date_time);
+	g_date_time_unref (date_time);
+
+	text_buffer = priv->internal_reply;
+	gtk_text_buffer_get_bounds (text_buffer, &start, &end);
+	text = gtk_text_buffer_get_text (text_buffer, &start, &end, FALSE);
+	e_ews_oof_settings_set_internal_reply (priv->oof_settings, text);
+	g_free (text);
+
+	text_buffer = priv->external_reply;
+	gtk_text_buffer_get_bounds (text_buffer, &start, &end);
+	text = gtk_text_buffer_get_text (text_buffer, &start, &end, FALSE);
+	e_ews_oof_settings_set_external_reply (priv->oof_settings, text);
+	g_free (text);
+
+	simple = g_simple_async_result_new (
+		G_OBJECT (page), callback, user_data,
+		mail_config_ews_ooo_page_submit);
+
+	g_signal_handler_disconnect (priv->oof_settings, signal_id);
+
+	if (priv->changed) {
+		g_simple_async_result_set_check_cancellable (simple, cancellable);
+
+		e_ews_oof_settings_submit (
+			priv->oof_settings, cancellable,
+			mail_config_ews_ooo_page_submit_cb,
+			g_object_ref (simple));
+	} else {
+		g_simple_async_result_complete_in_idle (simple);
+	}
+
+	g_object_unref (simple);
+
+	g_mutex_unlock (priv->oof_settings_lock);
+}
+
+static gboolean
+mail_config_ews_ooo_page_submit_finish (EMailConfigEwsOooPage *page,
+                                        GAsyncResult *result,
+                                        GError **error)
+{
+	GSimpleAsyncResult *simple;
+
+	g_return_val_if_fail (
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (page),
+		mail_config_ews_ooo_page_submit), FALSE);
+
+	simple = G_SIMPLE_ASYNC_RESULT (result);
+
+	/* Assume success unless a GError is set. */
+	return !g_simple_async_result_propagate_error (simple, error);
+}
+
+static void
+e_mail_config_ews_ooo_page_class_init (EMailConfigEwsOooPageClass *class)
+{
+	GObjectClass *object_class;
+
+	g_type_class_add_private (
+		class, sizeof (EMailConfigEwsOooPagePrivate));
+
+	object_class = G_OBJECT_CLASS (class);
+	object_class->set_property = mail_config_ews_ooo_page_set_property;
+	object_class->get_property = mail_config_ews_ooo_page_get_property;
+	object_class->dispose = mail_config_ews_ooo_page_dispose;
+	object_class->finalize = mail_config_ews_ooo_page_finalize;
+	object_class->constructed = mail_config_ews_ooo_page_constructed;
+
+	g_object_class_install_property (
+		object_class,
+		PROP_ACCOUNT,
+		g_param_spec_object (
+			"account",
+			"Account",
+			"Mail account being edited",
+			E_TYPE_ACCOUNT,
+			G_PARAM_READWRITE |
+			G_PARAM_CONSTRUCT_ONLY));
+}
+
+static void
+e_mail_config_ews_ooo_page_init (EMailConfigEwsOooPage *page)
+{
+	page->priv = E_MAIL_CONFIG_EWS_OOO_PAGE_GET_PRIVATE (page);
+
+	page->priv->oof_settings_lock = g_mutex_new ();
+}
+
+GtkWidget *
+e_mail_config_ews_ooo_page_new (EAccount *account)
+{
+	g_return_val_if_fail (E_IS_ACCOUNT (account), NULL);
+
+	return g_object_new (
+		E_TYPE_MAIL_CONFIG_EWS_OOO_PAGE,
+		"account", account,
+		NULL);
+}
+
+void
+e_mail_config_ews_ooo_page_refresh (EMailConfigEwsOooPage *page,
+				    const GError *with_error)
+{
+	EEwsConnection *connection;
+	const gchar *timeout_str;
+	gchar *password;
+	CamelURL *url;
+
+	g_return_if_fail (E_IS_MAIL_CONFIG_EWS_OOO_PAGE (page));
+	g_return_if_fail (page->priv->account != NULL);
+	
+	password = org_gnome_ews_get_password (page->priv->account, with_error != NULL, with_error);
+	if (!password)
+		return;
+
+	url = camel_url_new (e_account_get_string (page->priv->account, E_ACCOUNT_SOURCE_URL), NULL);
+	timeout_str = camel_url_get_param (url, "timeout");
+	connection = e_ews_connection_new (camel_url_get_param (url, "hosturl"),
+		url->user,
+		password,
+		mail_config_ews_ooo_page_get_mailbox (page),
+		camel_url_get_param (url, "impersonate_user"),
+		timeout_str ? atoi (timeout_str) : -1,
+		TRUE,
+		NULL, NULL, NULL);
+
+	g_free (password);
+	password = NULL;
+
+	if (connection) {
+		e_ews_oof_settings_new (connection, G_PRIORITY_DEFAULT, NULL, mail_config_ews_ooo_page_refresh_cb, g_object_ref (page));
+		g_object_unref (connection);
+	}
+
+	camel_url_free (url);
+}
+
+EAccount *
+e_mail_config_ews_ooo_page_get_account (EMailConfigEwsOooPage *page)
+{
+	g_return_val_if_fail (E_IS_MAIL_CONFIG_EWS_OOO_PAGE (page), NULL);
+
+	return page->priv->account;
+}
+
+void
+e_mail_config_ews_ooo_page_commit (EMailConfigEwsOooPage *page,
+				   GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+
+	g_return_if_fail (E_IS_MAIL_CONFIG_EWS_OOO_PAGE (page));
+
+	closure = e_async_closure_new ();
+
+	mail_config_ews_ooo_page_submit (page, NULL, e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	mail_config_ews_ooo_page_submit_finish (page, result, error);
+
+	e_async_closure_free (closure);
+}
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-mail-config-ews-ooo-page.h evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-mail-config-ews-ooo-page.h
--- evolution-ews.git-gnome-3-0/src/account-setup-eplugin/e-mail-config-ews-ooo-page.h	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/e-mail-config-ews-ooo-page.h	2013-05-28 08:59:53.553713375 +0200
@@ -0,0 +1,79 @@
+/*
+ * e-mail-config-ews-ooo-page.h
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) version 3.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the program; if not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+/* "OOO" = "Out of Office" */
+
+#ifndef E_MAIL_CONFIG_EWS_OOO_PAGE_H
+#define E_MAIL_CONFIG_EWS_OOO_PAGE_H
+
+#include <gtk/gtk.h>
+#include <libedataserver/e-account.h>
+
+/* Standard GObject macros */
+#define E_TYPE_MAIL_CONFIG_EWS_OOO_PAGE \
+	(e_mail_config_ews_ooo_page_get_type ())
+#define E_MAIL_CONFIG_EWS_OOO_PAGE(obj) \
+	(G_TYPE_CHECK_INSTANCE_CAST \
+	((obj), E_TYPE_MAIL_CONFIG_EWS_OOO_PAGE, EMailConfigEwsOooPage))
+#define E_MAIL_CONFIG_EWS_OOO_PAGE_CLASS(cls) \
+	(G_TYPE_CHECK_CLASS_CAST \
+	((cls), E_TYPE_MAIL_CONFIG_EWS_OOO_PAGE, EMailConfigEwsOooPageClass))
+#define E_IS_MAIL_CONFIG_EWS_OOO_PAGE(obj) \
+	(G_TYPE_CHECK_INSTANCE_TYPE \
+	((obj), E_TYPE_MAIL_CONFIG_EWS_OOO_PAGE))
+#define E_IS_MAIL_CONFIG_EWS_OOO_PAGE_CLASS(cls) \
+	(G_TYPE_CHECK_CLASS_TYPE \
+	((cls), E_TYPE_MAIL_CONFIG_EWS_OOO_PAGE))
+#define E_MAIL_CONFIG_EWS_OOO_PAGE_GET_CLASS(obj) \
+	(G_TYPE_INSTANCE_GET_CLASS \
+	((obj), E_TYPE_MAIL_CONFIG_EWS_OOO_PAGE, EMailConfigEwsOooPageClass))
+
+#define E_MAIL_CONFIG_EWS_OOO_PAGE_SORT_ORDER (550)
+
+G_BEGIN_DECLS
+
+typedef struct _EMailConfigEwsOooPage EMailConfigEwsOooPage;
+typedef struct _EMailConfigEwsOooPageClass EMailConfigEwsOooPageClass;
+typedef struct _EMailConfigEwsOooPagePrivate EMailConfigEwsOooPagePrivate;
+
+struct _EMailConfigEwsOooPage {
+	GtkVBox parent;
+	EMailConfigEwsOooPagePrivate *priv;
+};
+
+struct _EMailConfigEwsOooPageClass {
+	GtkVBoxClass parent_class;
+};
+
+GType		e_mail_config_ews_ooo_page_get_type
+						(void) G_GNUC_CONST;
+GtkWidget *
+		e_mail_config_ews_ooo_page_new	(EAccount *account);
+void		e_mail_config_ews_ooo_page_refresh
+						(EMailConfigEwsOooPage *page,
+						 const GError *with_error);
+EAccount *	e_mail_config_ews_ooo_page_get_account
+						(EMailConfigEwsOooPage *page);
+void		e_mail_config_ews_ooo_page_commit
+						(EMailConfigEwsOooPage *page,
+						 GError **error);
+
+G_END_DECLS
+
+#endif /* E_MAIL_CONFIG_EWS_OOO_PAGE_H */
+
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/account-setup-eplugin/exchange-ews-account-listener.c evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/exchange-ews-account-listener.c
--- evolution-ews.git-gnome-3-0/src/account-setup-eplugin/exchange-ews-account-listener.c	2013-05-17 14:36:16.329669972 +0200
+++ evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/exchange-ews-account-listener.c	2013-05-28 08:59:53.555712328 +0200
@@ -43,11 +43,18 @@
 #include "exchange-ews-account-listener.h"
 #include "exchange-ews-account-setup.h"
 #include "camel-ews-store-summary.h"
-#include "ews-esource-utils.h"
 #include "ews-camel-compat.h"
 
+#include "e-ews-config-utils.h"
+#include "server/e-ews-folder.h"
+#include "server/e-ews-gnome-3-8-compat.h"
+
 #define d(x) x
 
+#define EWS_BASE_URI "ews://"
+
+gchar *	org_gnome_ews_get_password (EAccount *account, gboolean reask, const GError *error);
+
 G_DEFINE_TYPE (ExchangeEWSAccountListener, exchange_ews_account_listener, G_TYPE_OBJECT)
 
 static GObjectClass *parent_class = NULL;
@@ -118,6 +125,66 @@ ews_account_info_free (EwsAccountInfo *i
 	}
 }
 
+static gboolean
+remove_group_in_source_list (const gchar *master_hosturl,
+			     const gchar *master_username,
+			     ESourceList *source_list)
+{
+	GSList *giter;
+
+	g_return_val_if_fail (master_hosturl != NULL, FALSE);
+	g_return_val_if_fail (master_username != NULL, FALSE);
+
+	if (!source_list)
+		return FALSE;
+
+	for (giter = e_source_list_peek_groups (source_list); giter; giter = giter->next) {
+		ESourceGroup *group = giter->data;
+
+		if (group) {
+			GSList *sources;
+
+			sources = e_source_group_peek_sources (group);
+			if (sources && sources->data &&
+			    e_ews_folder_utils_source_is_for_account (sources->data, master_hosturl, master_username)) {
+				return e_source_list_remove_group (source_list, group);
+			}
+		}
+	}
+
+	return FALSE;
+}
+
+static void
+remove_groups_for_account (const gchar *setup_url)
+{
+	CamelURL *url;
+	ESourceList *contacts = NULL, *events = NULL, *memos = NULL, *tasks = NULL;
+	const gchar *master_hosturl, *master_username;
+	gboolean changed = FALSE;
+
+	g_return_if_fail (setup_url != NULL);
+	g_return_if_fail (g_ascii_strncasecmp (setup_url, "ews://", 6) == 0);
+
+	url = camel_url_new (setup_url, NULL);
+	g_return_if_fail (url != NULL);
+
+	e_ews_folder_utils_manage_source_lists (&contacts, &events, &memos, &tasks, FALSE);
+
+	master_hosturl = camel_url_get_param (url, "hosturl");
+	master_username = url->user;
+
+	changed = remove_group_in_source_list (master_hosturl, master_username, contacts) || changed;
+	changed = remove_group_in_source_list (master_hosturl, master_username, events) || changed;
+	changed = remove_group_in_source_list (master_hosturl, master_username, memos) || changed;
+	changed = remove_group_in_source_list (master_hosturl, master_username, tasks) || changed;
+
+	if (changed)
+		e_ews_folder_utils_manage_source_lists (NULL, NULL, NULL, NULL, TRUE);
+
+	camel_url_free (url);
+}
+
 EVO2 (CamelSession *session;)
 
 static void
@@ -129,7 +196,6 @@ ews_account_removed (EAccountList *accou
 	EwsAccountInfo *info = NULL;
 	CamelService *service;
 	gchar *summary_file, *storage_path;
-	
 
 	if (!is_ews_account (account))
 		return;
@@ -138,7 +204,7 @@ ews_account_removed (EAccountList *accou
 	if (!info)
 		return;
 
-	ews_esource_utils_remove_groups (account->id->address);
+	remove_groups_for_account (e_account_get_string (account, E_ACCOUNT_SOURCE_URL));
 	ews_accounts = g_list_remove (ews_accounts, info);
 
 	EVO3(shell = e_shell_get_default ();)
@@ -148,7 +214,7 @@ ews_account_removed (EAccountList *accou
 
 	/* FIXME  Use this until CamelStore gets camel_store_remove_storage API which would be available eds 3.2 onwards */
 	storage_path = camel_session_get_storage_path (session, service, NULL);
-	summary_file = g_build_filename (storage_path, "folder-tree-v2", NULL);
+	summary_file = g_build_filename (storage_path, "folder-tree", NULL);
 	g_unlink (summary_file);
 	
 	d(g_print ("Removed ews store summary: %s \n", summary_file);)
@@ -162,6 +228,253 @@ ews_account_removed (EAccountList *accou
 #endif	
 }
 
+static void ews_update_folder_hierarchy (EAccount *account, const GError *with_error);
+
+static void
+ews_account_listener_folder_hierarchy_cb (GObject *cnc_object,
+					  GAsyncResult *result,
+					  gpointer user_data)
+{
+	EEwsConnection *connection;
+	EAccount *account = user_data;
+	GSList *folders_created = NULL;
+	GSList *folders_updated = NULL;
+	GSList *folders_deleted = NULL;
+	gboolean includes_last_folder = FALSE;
+	gchar *new_sync_state = NULL;
+	gboolean success;
+	GError *local_error = NULL;
+
+	g_return_if_fail (account != NULL);
+	g_return_if_fail (E_IS_EWS_CONNECTION (cnc_object));
+
+	connection = E_EWS_CONNECTION (cnc_object);
+
+	success = e_ews_connection_sync_folder_hierarchy_finish (
+		connection,
+		result,
+		&new_sync_state,
+		&includes_last_folder,
+		&folders_created,
+		&folders_updated,
+		&folders_deleted,
+		&local_error);
+
+	if (success) {
+		CamelURL *url;
+
+		url = camel_url_new (e_account_get_string (account, E_ACCOUNT_SOURCE_URL), NULL);
+		if (url) {
+			gint ii;
+			GSList *iter;
+			GList *old_sources, *liter;
+			GHashTable *old_sources_hash;
+			GHashTableIter hiter;
+			gpointer key, value;
+			const gchar *master_hosturl, *master_username;
+
+			master_hosturl = camel_url_get_param (url, "hosturl");
+			master_username = url->user;
+
+			old_sources_hash = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref);
+			old_sources = e_ews_folder_utils_get_esources (master_hosturl, master_username, NULL, NULL);
+			for (liter = old_sources; liter; liter = liter->next) {
+				ESource *source = liter->data;
+				const gchar *folder_id, *gal;
+
+				if (!source)
+					continue;
+
+				folder_id = e_source_get_property (source, "folder-id");
+				if (!folder_id || !*folder_id)
+					continue;
+
+				gal = e_source_get_property (source, "gal");
+				if (gal && g_str_equal (gal, "1"))
+					continue;
+
+				g_hash_table_insert (old_sources_hash, g_strdup (folder_id), g_object_ref (source));
+			}
+
+			for (iter = folders_deleted; iter; iter = iter->next) {
+				const gchar *folder_id = iter->data;
+
+				if (folder_id && *folder_id) {
+					g_hash_table_remove (old_sources_hash, folder_id);
+
+					e_ews_folder_utils_remove_as_esource (
+						master_hosturl, master_username,
+						folder_id, NULL, NULL);
+				}
+			}
+
+			for (ii = 0, iter = folders_created; iter; iter = iter->next, ii++) {
+				EEwsFolder *folder = iter->data;
+				EEwsFolderType folder_type;
+				const EwsFolderId *folder_id;
+
+				if (!folder)
+					continue;
+
+				folder_id = e_ews_folder_get_id (folder);
+				if (!folder_id || !folder_id->id)
+					continue;
+
+				g_hash_table_remove (old_sources_hash, folder_id->id);
+
+				folder_type = e_ews_folder_get_folder_type (folder);
+				if (folder_type != E_EWS_FOLDER_TYPE_CALENDAR &&
+				    folder_type != E_EWS_FOLDER_TYPE_CONTACTS &&
+				    folder_type != E_EWS_FOLDER_TYPE_TASKS &&
+				    folder_type != E_EWS_FOLDER_TYPE_MEMOS)
+					continue;
+
+				e_ews_folder_utils_add_as_esource (url, account->name,
+					folder, 0, ii, NULL, NULL);
+			}
+
+			/* this might be always empty */
+			for (iter = folders_updated; iter; iter = iter->next) {
+				EEwsFolder *folder = iter->data;
+				const EwsFolderId *folder_id;
+
+				if (!folder)
+					continue;
+
+				folder_id = e_ews_folder_get_id (folder);
+				if (!folder_id || !folder_id->id)
+					continue;
+
+				g_hash_table_remove (old_sources_hash, folder_id->id);
+			}
+
+			g_hash_table_iter_init (&hiter, old_sources_hash);
+			while (g_hash_table_iter_next (&hiter, &key, &value)) {
+				ESource *source = value;
+				const gchar *tmp;
+
+				if (!source)
+					continue;
+
+				/* keep foreign folders */
+				tmp = e_source_get_property (source, "foreign");
+				if (tmp && g_str_equal (tmp, "1"))
+					continue;
+
+				/* keep public folders */
+				tmp = e_source_get_property (source, "public");
+				if (tmp && g_str_equal (tmp, "1"))
+					continue;
+
+				tmp = e_source_get_property (source, "folder-id");
+				if (!tmp || !*tmp)
+					continue;
+
+				/* drop all other untouched folders */
+				e_ews_folder_utils_remove_as_esource (master_hosturl, master_username, tmp, NULL, NULL);
+			}
+
+			g_hash_table_destroy (old_sources_hash);
+			g_list_free_full (old_sources, g_object_unref);
+			camel_url_free (url);
+		}
+
+		/* List of EEwsFolder instances. */
+		g_slist_free_full (folders_created, g_object_unref);
+		/* List of folder ID strings. */
+		g_slist_free_full (folders_deleted, g_free);
+		/* List of EEwsFolder instances. */
+		g_slist_free_full (folders_updated, g_object_unref);
+
+	} else if (g_error_matches (local_error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_INVALIDSYNCSTATEDATA)) {
+		g_clear_error (&local_error);
+
+		remove_groups_for_account (e_account_get_string (account, E_ACCOUNT_SOURCE_URL));
+
+		e_ews_connection_sync_folder_hierarchy (
+			connection,
+			G_PRIORITY_DEFAULT,
+			NULL,
+			NULL,
+			ews_account_listener_folder_hierarchy_cb,
+			g_object_ref (account));
+	} else if (g_error_matches (local_error, SOUP_HTTP_ERROR, SOUP_STATUS_UNAUTHORIZED) && account->enabled) {
+		ews_update_folder_hierarchy (account, local_error);
+	} else if (local_error) {
+		g_warning ("%s: Failed with error: %s", G_STRFUNC, local_error->message);
+	}
+
+	g_clear_error (&local_error);
+	g_object_unref (account);
+}
+
+static void
+ews_update_folder_hierarchy (EAccount *account,
+			     const GError *with_error)
+{
+	EwsAccountInfo *info;
+	const gchar *timeout_str;
+	gchar *password;
+	CamelURL *url;
+	EEwsConnection *connection;
+
+	g_return_if_fail (account != NULL);
+
+	if (!account->enabled ||
+	    !e_ews_config_utils_is_online ())
+		return;
+
+	info = lookup_account_info (account->uid);
+	if (!info)
+		return;
+
+	password = org_gnome_ews_get_password (account, with_error != NULL, with_error);
+	if (!password)
+		return;
+
+	url = camel_url_new (e_account_get_string (account, E_ACCOUNT_SOURCE_URL), NULL);
+	timeout_str = camel_url_get_param (url, "timeout");
+	connection = e_ews_connection_new (camel_url_get_param (url, "hosturl"),
+		url->user,
+		password,
+		camel_url_get_param (url, "email"),
+		camel_url_get_param (url, "impersonate_user"),
+		timeout_str ? atoi (timeout_str) : -1,
+		TRUE,
+		NULL, NULL, NULL);
+
+	g_free (password);
+	password = NULL;
+
+	camel_url_free (url);
+
+	if (connection) {
+		e_ews_connection_sync_folder_hierarchy (
+			connection,
+			G_PRIORITY_DEFAULT,
+			NULL,
+			NULL,
+			ews_account_listener_folder_hierarchy_cb,
+			g_object_ref (account));
+		g_object_unref (connection);
+	} else
+		g_warning ("%s: Failed to create EWS connection for account '%s'", G_STRFUNC, account->name);
+}
+
+static gboolean
+run_account_sources_update_cb (gpointer user_data)
+{
+	EAccount *account = user_data;
+
+	g_return_val_if_fail (account != NULL, FALSE);
+
+	ews_update_folder_hierarchy (account, NULL);
+
+	g_object_unref (account);
+
+	return FALSE;
+}
+
 static gboolean
 ews_is_str_equal (const gchar *str1, const gchar *str2)
 {
@@ -173,68 +486,35 @@ ews_is_str_equal (const gchar *str1, con
 		return FALSE;
 }
 
-static gboolean
-remove_gal_esource (const gchar *account_name)
+static void
+remove_gal_esource (CamelURL *setup_url)
 {
-	ESourceList *source_list;
-	ESourceGroup *group;
-	ESource *source;
-	GConfClient* client;
-	const gchar *conf_key;
-	GSList *sources;
-	gboolean ret = TRUE;
-	EBook *book;
 	GError *error = NULL;
 
-	conf_key = CONTACT_SOURCES;
-	client = gconf_client_get_default ();
-	source_list = e_source_list_new_for_gconf (client, conf_key);
-	group = ews_esource_utils_ensure_group (source_list, account_name);
-
-	sources = e_source_group_peek_sources (group);
-	if (!(source = ews_find_source_by_matched_prop (sources, "gal", "1"))) {
-		ret = FALSE;
-		goto exit;
-	}
-
-	book = e_book_new (source, &error);
-	if (book) {
-		e_book_remove (book, &error);
-		g_object_unref (book);
-	}
-
-	e_source_group_remove_source (group, source);
-	e_source_list_sync (source_list, NULL);
-
-exit:
-	g_object_unref (group);
-	g_object_unref (source_list);
-	g_object_unref (client);
+	e_ews_folder_utils_remove_as_esource (camel_url_get_param (setup_url, "hosturl"),
+		setup_url->user, "global-address-list", NULL, &error);
 
 	if (error) {
-		g_warning ("Unable to remove GAL cache : %s \n", error->message);
+		g_warning ("Unable to remove GAL cache: %s \n", error->message);
 		g_clear_error (&error);
 	}
-
-	return ret;
 }
 
 /* add gal esource. If oal is not selected, gal will be just used for auto-completion */
 static void
-add_gal_esource (CamelURL *url)
+add_gal_esource (const gchar *account_name,
+		 CamelURL *url)
 {
-	ESourceList *source_list;
+	ESourceList *contacts = NULL;
 	ESourceGroup *group;
 	ESource *source;
-	GConfClient* client;
-	const gchar *conf_key, *email_id;
+	const gchar *email_id;
 	const gchar *oal_sel, *tmp, *oal_name;
 	gchar *oal_id = NULL;
 	gchar *account_uri, *source_uri;
+	GSList *giter;
 
-	conf_key = CONTACT_SOURCES;
-	client = gconf_client_get_default ();
-	source_list = e_source_list_new_for_gconf (client, conf_key);
+	e_ews_folder_utils_manage_source_lists (&contacts, NULL, NULL, NULL, FALSE);
 	email_id = camel_url_get_param (url, "email");
 	oal_sel = camel_url_get_param (url, "oal_selected");
 
@@ -242,6 +522,9 @@ add_gal_esource (CamelURL *url)
 	if (oal_sel) {
 		tmp = strrchr (oal_sel, ':');
 		oal_name = tmp + 1;
+		if (*oal_name == '\\')
+			oal_name++;
+			
 		oal_id = g_strndup (oal_sel, (tmp - oal_sel));
 	} else
 		oal_name = _("Global Address list");
@@ -257,7 +540,7 @@ add_gal_esource (CamelURL *url)
 	e_source_set_property (source, "gal", "1");
 	e_source_set_property (source, "hosturl", camel_url_get_param (url, "hosturl"));
 	e_source_set_property (source, "delete", "no");
-	e_source_set_color_spec (source, "#EEBC60");
+	e_source_set_property (source, "folder-id", "global-address-list");
 
 	/* If oal_id is present it means the GAL is marked for offline usage, we do not check for offline_sync property */
 	if (oal_sel) {
@@ -269,14 +552,33 @@ add_gal_esource (CamelURL *url)
 	e_source_set_property (source, "completion", "true");
 
 	/* add the source to group and sync */
-	group = ews_esource_utils_ensure_group (source_list, email_id);
+	for (giter = e_source_list_peek_groups (contacts); giter; giter = giter->next) {
+		group = giter->data;
+
+		if (group && e_source_group_peek_base_uri (group) &&
+		    g_ascii_strcasecmp (e_source_group_peek_base_uri (group), EWS_BASE_URI) == 0 &&
+		    e_source_group_peek_name (group) &&
+		    g_str_equal (e_source_group_peek_name (group), account_name)) {
+			g_object_ref (group);
+			break;
+		}
+
+		group = NULL;
+	}
+
+	if (!group) {
+		group = e_source_group_new (account_name, EWS_BASE_URI);
+		e_source_group_set_property (group, "create_source", "no");
+
+		e_source_list_add_group (contacts, group, -1);
+	}
+
 	e_source_group_add_source (group, source, -1);
-	e_source_list_sync (source_list, NULL);
+
+	e_source_list_sync (contacts, NULL);
 
 	g_object_unref (source);
 	g_object_unref (group);
-	g_object_unref (source_list);
-	g_object_unref (client);
 	g_free (oal_id);
 	g_free (account_uri);
 	g_free (source_uri);
@@ -314,13 +616,11 @@ ews_account_changed (EAccountList *accou
 			n_oal_sel = camel_url_get_param (new_url, "oal_selected");
 
 			if (!ews_is_str_equal (o_oal_sel, n_oal_sel)) {
-				const gchar *account_name = camel_url_get_param (new_url, "email");
-				
 				/* remove gal esource and cache associated with it */
-				remove_gal_esource (account_name);
-			
+				remove_gal_esource (old_url);
+
 				/* add gal esource */
-				add_gal_esource (new_url);
+				add_gal_esource (account->name, new_url);
 			}
 			
 			g_free (existing_account_info->name);
@@ -349,7 +649,8 @@ ews_account_added (EAccountList *account
 		url = camel_url_new (account->source->url, NULL);
 		
 		/* add gal esource */
-		add_gal_esource (url);
+		add_gal_esource (account->name, url);
+		ews_update_folder_hierarchy (account, NULL);
 
 		camel_url_free (url);
 	}
@@ -371,6 +672,8 @@ exchange_ews_account_listener_construct 
 
 			info = ews_account_info_from_eaccount (account);
 			ews_accounts = g_list_append (ews_accounts, info);
+
+			g_idle_add (run_account_sources_update_cb, g_object_ref (account));
 		}
 	}
 
@@ -406,6 +709,7 @@ finalize (GObject *object)
 	}
 
 	g_list_free (ews_accounts);
+	ews_accounts = NULL;
 
 	G_OBJECT_CLASS (parent_class)->finalize (object);
 }
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/account-setup-eplugin/exchange-ews-account-setup.c evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/exchange-ews-account-setup.c
--- evolution-ews.git-gnome-3-0/src/account-setup-eplugin/exchange-ews-account-setup.c	2013-05-17 14:36:16.330555377 +0200
+++ evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/exchange-ews-account-setup.c	2013-05-28 08:59:53.552713349 +0200
@@ -42,6 +42,12 @@
 #include <camel-ews-utils.h>
 #include <shell/e-shell.h>
 
+#include "e-ews-config-utils.h"
+#include "e-ews-search-user.h"
+
+#include "e-mail-config-ews-ooo-page.h"
+#include "e-mail-config-ews-delegates-page.h"
+
 #define d(x) x
 
 #if GTK_CHECK_VERSION(2,24,0)
@@ -62,6 +68,13 @@ gboolean org_gnome_exchange_ews_check_op
 /* OAB receiving options */
 GtkWidget * org_gnome_ews_oab_settings (EPlugin *epl, EConfigHookItemFactoryData *data);
 
+/* extra mail pages */
+GtkWidget *org_gnome_ews_ooo_page (EPlugin *epl, EConfigHookItemFactoryData *data);
+GtkWidget *org_gnome_ews_delegates_page (EPlugin *epl, EConfigHookItemFactoryData *data);
+void org_gnome_ews_commit_config_pages (EPlugin *efp, EConfigHookItemFactoryData *data);
+
+gchar *org_gnome_ews_get_password (EAccount *account, gboolean reask, const GError *error);
+
 static ExchangeEWSAccountListener *config_listener = NULL;
 
 static void
@@ -103,50 +116,59 @@ struct _AutoDiscCallBackData {
 	EConfig *config;
 	GtkWidget *host_entry;
 	GtkWidget *oab_entry;
+	GtkWidget *impersonate_user_entry;
 };
 
-static void autodiscover_callback (EwsUrls *urls, gpointer user_data, GError *error)
+static void
+autodiscover_callback (GObject *source,
+		       GAsyncResult *result,
+		       gpointer user_data)
 {
 	struct _AutoDiscCallBackData *cbdata = (struct _AutoDiscCallBackData *) user_data;
-	
+	gchar *as_url = NULL, *oab_url = NULL;
+	GError *error = NULL;
+
+	e_ews_autodiscover_ws_url_finish (source, result, &as_url, &oab_url, &error);
+
 	if (error) {
 		g_warning ("Autodiscover failed: %s", error->message);
 		e_notice (NULL, GTK_MESSAGE_ERROR, _("Autodiscover failed: %s"), error->message);
 		g_clear_error (&error);
+	} else {
+		if (as_url)
+			gtk_entry_set_text (GTK_ENTRY (cbdata->host_entry), as_url);
+		if (oab_url)
+			gtk_entry_set_text (GTK_ENTRY (cbdata->oab_entry), oab_url);
 	}
-	if (urls) {
-		char *oab_url;
-		
-		gtk_entry_set_text (GTK_ENTRY (cbdata->host_entry), urls->as_url);
 
-		oab_url = g_strconcat (urls->oab_url, "oab.xml", NULL);
-		gtk_entry_set_text (GTK_ENTRY (cbdata->oab_entry), oab_url);
-		g_free (oab_url);
-		
-		g_free (urls->as_url);
-		g_free (urls->oab_url);
-		g_free (urls);
-	}
+	g_free (as_url);
+	g_free (oab_url);
 }
 
-static char *
-get_password (EMConfigTargetAccount *target_account)
+gchar *
+org_gnome_ews_get_password (EAccount *account,
+			    gboolean reask,
+			    const GError *error)
 {
 	gchar *key, *password = NULL;
 	CamelURL *url;
-	EAccount *account;
 
-	account = get_modified_account (target_account);
 	url = camel_url_new (e_account_get_string (account, E_ACCOUNT_SOURCE_URL), NULL);
 
 	key = camel_url_to_string (url, CAMEL_URL_HIDE_PASSWORD | CAMEL_URL_HIDE_PARAMS);
-	password = e_passwords_get_password (EXCHANGE_EWS_PASSWORD_COMPONENT, key);
+	if (!reask)
+		password = e_passwords_get_password (EXCHANGE_EWS_PASSWORD_COMPONENT, key);
 	if (!password || !*password) {
 		gboolean remember = e_account_get_bool (account, E_ACCOUNT_SOURCE_SAVE_PASSWD);
 		gchar *title;
 
 		g_free (password);
-		title = g_strdup_printf (_("Enter Password for %s"), account->id->address);
+
+		if (error) {
+			title = g_strdup_printf (_("Enter Password for %s\n\nReported error was: %s"), account->id->address, error->message);
+		} else {
+			title = g_strdup_printf (_("Enter Password for %s"), account->id->address);
+		}
 		password = e_passwords_ask_password (title, EXCHANGE_EWS_PASSWORD_COMPONENT, key, title,
                                                     E_PASSWORDS_REMEMBER_FOREVER|E_PASSWORDS_SECRET,
 						     &remember, NULL);
@@ -164,21 +186,46 @@ get_password (EMConfigTargetAccount *tar
 	return password;
 }
 
+static gchar *
+get_password (EMConfigTargetAccount *target_account)
+{
+	return org_gnome_ews_get_password (get_modified_account (target_account), FALSE, NULL);
+}
+
 static void
 validate_credentials (GtkWidget *widget, struct _AutoDiscCallBackData *cbdata)
 {
 	EConfig *config = cbdata->config;
 	EMConfigTargetAccount *target_account = (EMConfigTargetAccount *)(config->target);
 	gchar *password = NULL;
+	EAccount *account;
+	CamelURL *url;
+
+	account = get_modified_account (target_account);
+	g_return_if_fail (account != NULL);
+
+	url = camel_url_new (e_account_get_string (account, E_ACCOUNT_SOURCE_URL), NULL);
+	if (!url) {
+		g_warning ("%s: Failed to pars url '%s'", G_STRFUNC, e_account_get_string (account, E_ACCOUNT_SOURCE_URL));
+		return;
+	}
 
 	password = get_password (target_account);
 	/*Can there be a account without password ?*/
 	if (password && *password) {
-		e_ews_autodiscover_ws_url (autodiscover_callback, cbdata,
-					   (get_modified_account (target_account))->id->address,
-					   password);
+		e_ews_autodiscover_ws_url (G_OBJECT (widget),
+			camel_url_get_param (url, "hosturl"),
+			url->user,
+			account->id->address,
+			password,
+			90,
+			TRUE,
+			NULL,
+			autodiscover_callback,
+			cbdata);
 	}
 	g_free (password);
+	camel_url_free (url);
 }
 
 static void
@@ -215,6 +262,101 @@ oab_url_changed (GtkWidget *entry, EConf
 	url_changed (entry, config, "oaburl");
 }
 
+static void
+ews_impersonate_toggled_cb (GtkToggleButton *button,
+			    struct _AutoDiscCallBackData *cbdata)
+{
+	EMConfigTargetAccount *target = (EMConfigTargetAccount *)(cbdata->config->target);
+	CamelURL *url = NULL;
+	gchar *url_string = NULL;
+	const gchar *impersonate_user;
+	EAccount *account;
+
+	impersonate_user = gtk_entry_get_text (GTK_ENTRY (cbdata->impersonate_user_entry));
+	if (impersonate_user && !*impersonate_user)
+		impersonate_user = NULL;
+
+	account = get_modified_account (target);
+	url = camel_url_new (e_account_get_string(account, E_ACCOUNT_SOURCE_URL), NULL);
+
+	if (impersonate_user && gtk_toggle_button_get_active (button))
+		camel_url_set_param (url, "impersonate_user", impersonate_user);
+	else
+		camel_url_set_param (url, "impersonate_user", NULL);
+
+	url_string = camel_url_to_string (url, 0);
+	e_account_set_string (account, E_ACCOUNT_SOURCE_URL, url_string);
+	e_account_set_string (account, E_ACCOUNT_TRANSPORT_URL, url_string);
+	g_free (url_string);
+
+	camel_url_free (url);
+}
+
+static void
+ews_impersonate_user_changed_cb (GtkEntry *entry,
+				 struct _AutoDiscCallBackData *cbdata)
+{
+	EMConfigTargetAccount *target = (EMConfigTargetAccount *)(cbdata->config->target);
+	CamelURL *url = NULL;
+	gchar *url_string = NULL;
+	const gchar *impersonate_user;
+	EAccount *account;
+
+	account = get_modified_account (target);
+	url = camel_url_new (e_account_get_string(account, E_ACCOUNT_SOURCE_URL), NULL);
+
+	impersonate_user = gtk_entry_get_text (GTK_ENTRY (cbdata->impersonate_user_entry));
+	if (impersonate_user && *impersonate_user)
+		camel_url_set_param (url, "impersonate_user", impersonate_user);
+	else
+		camel_url_set_param (url, "impersonate_user", NULL);
+
+	url_string = camel_url_to_string (url, 0);
+	e_account_set_string (account, E_ACCOUNT_SOURCE_URL, url_string);
+	e_account_set_string (account, E_ACCOUNT_TRANSPORT_URL, url_string);
+	g_free (url_string);
+
+	camel_url_free (url);
+}
+
+static void
+ews_impersonate_search_clicked_cb (GtkButton *button,
+				   struct _AutoDiscCallBackData *cbdata)
+{
+	EMConfigTargetAccount *target = (EMConfigTargetAccount *)(cbdata->config->target);
+	EEwsConnection *conn;
+	GtkWindow *parent;
+	gchar *email = NULL, *password;
+	const gchar *timeout_str;
+	CamelURL *url;
+
+	url = camel_url_new (e_account_get_string(get_modified_account (target), E_ACCOUNT_SOURCE_URL), NULL);
+
+	/* Fetch the oab lists from server */
+	timeout_str = camel_url_get_param (url, "timeout");
+	password = get_password (target);
+
+	conn = e_ews_connection_new (camel_url_get_param (url, "hosturl"),
+		url->user,
+		password,
+		NULL,
+		NULL,
+		timeout_str ? atoi (timeout_str) : -1,
+		TRUE,
+		NULL, NULL, NULL);
+
+	parent = e_ews_config_utils_get_widget_toplevel_window (GTK_WIDGET (button));
+
+	if (e_ews_search_user_modal (parent, conn, NULL, NULL, &email)) {
+		gtk_entry_set_text (GTK_ENTRY (cbdata->impersonate_user_entry), email);
+	}
+
+	g_object_unref (conn);
+	camel_url_free (url);
+	g_free (password);
+	g_free (email);
+}
+
 GtkWidget *
 org_gnome_exchange_ews_account_setup (EPlugin *epl, EConfigHookItemFactoryData *data)
 {
@@ -234,6 +376,7 @@ org_gnome_exchange_ews_account_setup (EP
 		GtkWidget *label, *oab_label;
 		GtkWidget *host_url, *oab_url;
 		GtkWidget *auto_discover;
+		GtkWidget *impersonate_check, *impersonate_user_entry, *impersonate_search_button, *impersonate_table_line;
 		const gchar *host_url_val = camel_url_get_param (url, "hosturl");
 		const gchar *oab_url_val = camel_url_get_param (url, "oaburl");
 		const gchar *temp, *email_id;
@@ -249,9 +392,11 @@ org_gnome_exchange_ews_account_setup (EP
 		email_id = account->id->address;
 		camel_url_set_param (url, "email", email_id);
 		temp = g_strstr_len (email_id, -1, "@");
+		if (temp)
+			temp++;
 		/* Don't overwrite the URL if it's already been set */
 		if (!url->host || !url->host[0])
-			camel_url_set_host (url, g_strdup (temp + 1));
+			camel_url_set_host (url, g_strdup (temp));
 
 		url_string = camel_url_to_string (url, 0);
 		e_account_set_string (account, E_ACCOUNT_SOURCE_URL, url_string);
@@ -276,8 +421,17 @@ org_gnome_exchange_ews_account_setup (EP
 
 		host_url = gtk_entry_new ();
 		gtk_label_set_mnemonic_widget (GTK_LABEL (label), host_url);
-		if (host_url_val && *host_url_val)
+		if (host_url_val && *host_url_val) {
 			gtk_entry_set_text (GTK_ENTRY (host_url), host_url_val);
+		} else if (temp && *temp) {
+			gchar *hosturl_str;
+
+			hosturl_str = g_strdup_printf ("https://exchange.%s/EWS/Exchange.asmx", temp);
+			gtk_entry_set_text (GTK_ENTRY (host_url), hosturl_str);
+			g_free (hosturl_str);
+
+			host_url_changed (host_url, data->config);
+		}
 		gtk_box_pack_start (GTK_BOX (hbox), host_url, TRUE, TRUE, 0);
 		g_signal_connect (host_url, "changed", G_CALLBACK(host_url_changed), data->config);
 
@@ -298,6 +452,42 @@ org_gnome_exchange_ews_account_setup (EP
 		gtk_table_attach (GTK_TABLE (data->parent), oab_label, 0, 1, row, row+1, 0, 0, 0, 0);
 		gtk_table_attach (GTK_TABLE (data->parent), oab_url, 1, 2, row, row+1, GTK_FILL|GTK_EXPAND, GTK_FILL, 0, 0);
 		row++;
+
+		temp = camel_url_get_param (url, "impersonate_user");
+		impersonate_check = gtk_check_button_new_with_mnemonic (_("Open _Mailbox of other user"));
+		gtk_table_attach (GTK_TABLE (data->parent), impersonate_check, 1, 2, row, row + 1, GTK_FILL, 0, 0, 0);
+		gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (impersonate_check), temp && *temp);
+		gtk_widget_show (impersonate_check);
+		row++;
+
+		impersonate_table_line = gtk_table_new (1, 2, FALSE);
+		impersonate_user_entry = gtk_entry_new ();
+		gtk_table_attach (GTK_TABLE (impersonate_table_line), impersonate_user_entry, 0, 1, 0, 1, GTK_EXPAND | GTK_FILL, 0, 0, 0);
+		gtk_entry_set_text (GTK_ENTRY (impersonate_user_entry), temp ? temp : "");
+		gtk_widget_show (impersonate_user_entry);
+		cbdata->impersonate_user_entry = impersonate_user_entry;
+
+		impersonate_search_button = gtk_button_new_with_mnemonic (_("S_earch..."));
+		gtk_table_attach (GTK_TABLE (impersonate_table_line), impersonate_search_button, 1, 2, 0, 1, 0, 0, 6, 0);
+		gtk_widget_show (impersonate_search_button);
+
+		gtk_table_attach (GTK_TABLE (data->parent), impersonate_table_line, 1, 2, row, row + 1, GTK_EXPAND | GTK_FILL, 0, 0, 0);
+		gtk_widget_show (impersonate_table_line);
+		row++;
+
+		g_object_bind_property (
+			impersonate_check, "active",
+			impersonate_user_entry, "sensitive",
+			G_BINDING_SYNC_CREATE);
+
+		g_object_bind_property (
+			impersonate_check, "active",
+			impersonate_search_button, "sensitive",
+			G_BINDING_SYNC_CREATE);
+
+		g_signal_connect (impersonate_check, "toggled", G_CALLBACK (ews_impersonate_toggled_cb), cbdata);
+		g_signal_connect (impersonate_user_entry, "changed", G_CALLBACK (ews_impersonate_user_changed_cb), cbdata);
+		g_signal_connect (impersonate_search_button, "clicked", G_CALLBACK (ews_impersonate_search_clicked_cb), cbdata);
 	}
 
 	camel_url_free (url);
@@ -481,7 +671,7 @@ fetch_button_clicked_cb (GtkButton *butt
 	GCancellable *cancellable;
 	EEwsConnection *cnc;
 	CamelURL *url;
-	const gchar *oab_url;
+	const gchar *oab_url, *timeout_str;
 	gchar *password;
 	
 	url = camel_url_new (e_account_get_string(get_modified_account (target), E_ACCOUNT_SOURCE_URL), NULL);
@@ -501,28 +691,19 @@ fetch_button_clicked_cb (GtkButton *butt
 
 	/* Fetch the oab lists from server */
 	oab_url = camel_url_get_param (url, "oaburl");
+	timeout_str = camel_url_get_param (url, "timeout");
 	password = get_password (target);
 
 	/* pass user name while creating connection  to fetch oals */
-	cnc = e_ews_connection_new (oab_url, url->user, password, NULL, NULL, NULL);
+	cnc = e_ews_connection_new (oab_url, url->user, password,
+		NULL, NULL, timeout_str ? atoi (timeout_str) : -1, TRUE, NULL, NULL, NULL);
 	cbdata->cancellable = cancellable;
-	e_ews_connection_get_oal_list_start (cnc, ews_oal_list_ready, cancellable, cbdata);
+	e_ews_connection_get_oal_list (cnc, cancellable, ews_oal_list_ready, cbdata);
 
 	camel_url_free (url);
 	g_free (password);
 }
 
-static void
-ews_oal_free (gpointer data, gpointer user_data)
-{
-	EwsOAL *oal = (EwsOAL *) data;
-
-	g_free (oal->id);
-	g_free (oal->dn);
-	g_free (oal->name);
-	g_free (oal);
-}
-
 static gboolean
 table_deleted_cb (GtkWidget *widget, gpointer user_data)
 {
@@ -690,3 +871,84 @@ org_gnome_ews_oab_settings (EPlugin *epl
 	camel_url_free (url);
 	return NULL;
 }
+
+GtkWidget *
+org_gnome_ews_ooo_page (EPlugin *epl, EConfigHookItemFactoryData *data)
+{
+	EMConfigTargetAccount *target_account;
+	EAccount *account;
+	GtkWidget *page;
+
+	target_account = (EMConfigTargetAccount *) data->config->target;
+	account = target_account->account;
+
+	if (!g_str_has_prefix (account->source->url, "ews://"))
+		return NULL;
+
+	page = e_mail_config_ews_ooo_page_new (account);
+
+	g_object_set_data (G_OBJECT (account), "ews-ooo-page", page);
+
+	gtk_notebook_append_page ((GtkNotebook *) (data->parent), page, gtk_label_new (_("Out of Office")));
+
+	return page;
+}
+
+GtkWidget *
+org_gnome_ews_delegates_page (EPlugin *epl, EConfigHookItemFactoryData *data)
+{
+	EMConfigTargetAccount *target_account;
+	EAccount *account;
+	GtkWidget *page;
+
+	target_account = (EMConfigTargetAccount *) data->config->target;
+	account = target_account->account;
+
+	if (!g_str_has_prefix (account->source->url, "ews://"))
+		return NULL;
+
+	page = e_mail_config_ews_delegates_page_new (account);
+
+	g_object_set_data (G_OBJECT (account), "ews-delegates-page", page);
+
+	gtk_notebook_append_page ((GtkNotebook *) (data->parent), page, gtk_label_new (_("Delegates")));
+
+	return page;
+}
+
+void
+org_gnome_ews_commit_config_pages (EPlugin *efp, EConfigHookItemFactoryData *data)
+{
+	EMConfigTargetAccount *target_account;
+	EAccount *account;
+	EMailConfigEwsOooPage *ooo_page;
+	EMailConfigEwsDelegatesPage *delegates_page;
+	GtkWindow *parent;
+	GError *error = NULL;
+
+	target_account = (EMConfigTargetAccount *) data->config->target;
+	account = target_account->account;
+
+	if (!g_str_has_prefix (account->source->url, "ews://"))
+		return;
+
+	parent = e_ews_config_utils_get_widget_toplevel_window (data->config->window);
+
+	ooo_page = g_object_get_data (G_OBJECT (account), "ews-ooo-page");
+	if (ooo_page) {
+		e_mail_config_ews_ooo_page_commit (ooo_page, &error);
+		if (error) {
+			e_notice (parent, GTK_MESSAGE_ERROR, _("Failed to save Out of Office settings: %s"), error->message);
+			g_clear_error (&error);
+		}
+	}
+
+	delegates_page = g_object_get_data (G_OBJECT (account), "ews-delegates-page");
+	if (delegates_page) {
+		e_mail_config_ews_delegates_page_commit (delegates_page, &error);
+		if (error) {
+			e_notice (parent, GTK_MESSAGE_ERROR, _("Failed to save Delegates settings: %s"), error->message);
+			g_clear_error (&error);
+		}
+	}
+}
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/account-setup-eplugin/Makefile.am evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/Makefile.am
--- evolution-ews.git-gnome-3-0/src/account-setup-eplugin/Makefile.am	2013-05-17 14:36:16.329669972 +0200
+++ evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/Makefile.am	2013-05-28 08:59:53.554712297 +0200
@@ -26,8 +26,20 @@ plugin_DATA = org-gnome-exchange-ews.epl
 plugin_LTLIBRARIES = liborg-gnome-exchange-ews.la
 
 liborg_gnome_exchange_ews_la_SOURCES = 		\
-	exchange-ews-account-setup.c			\
-	exchange-ews-account-setup.h			\
+	e-ews-config-utils.c			\
+	e-ews-config-utils.h			\
+	e-ews-search-user.c			\
+	e-ews-search-user.h			\
+	e-ews-subscribe-foreign-folder.c	\
+	e-ews-subscribe-foreign-folder.h	\
+	e-ews-edit-folder-permissions.c		\
+	e-ews-edit-folder-permissions.h		\
+	e-mail-config-ews-ooo-page.h		\
+	e-mail-config-ews-ooo-page.c		\
+	e-mail-config-ews-delegates-page.h	\
+	e-mail-config-ews-delegates-page.c	\
+	exchange-ews-account-setup.c		\
+	exchange-ews-account-setup.h		\
 	exchange-ews-account-listener.c		\
 	exchange-ews-account-listener.h
 
@@ -45,6 +57,8 @@ liborg_gnome_exchange_ews_la_CFLAGS = \
 	$(AM_CPPFLAGS)					\
 	-I$(top_srcdir)					\
 	-I$(top_builddir)				\
+	-I$(top_srcdir)/src				\
+	-I$(top_builddir)/src				\
 	-I$(top_srcdir)/src/camel			\
 	-I$(top_builddir)/src/camel			\
 	-I$(top_srcdir)/src/server			\
@@ -59,5 +73,41 @@ BUILT_SOURCES = org-gnome-exchange-ews.e
 
 CLEANFILES = $(BUILT_SOURCES)
 
+evo_module_LTLIBRARIES = module-ews-ui-config.la
+
+module_ews_ui_config_la_CPPFLAGS = \
+	$(AM_CPPFLAGS) \
+	-DEXCHANGE_EWS_LOCALEDIR=\"$(localedir)\" \
+	-I$(top_srcdir) \
+	-I$(top_srcdir)/src \
+	-I$(top_srcdir)/src/server \
+	$(EVOLUTION_PLUGIN_CFLAGS) \
+	$(EVOLUTION_SHELL_CFLAGS) \
+	$(CAMEL_CFLAGS)	\
+	$(NULL)
+
+module_ews_ui_config_la_SOURCES = \
+	module-ews-configuration.c \
+	e-ews-config-utils.c			\
+	e-ews-config-utils.h			\
+	e-ews-search-user.c			\
+	e-ews-search-user.h			\
+	e-ews-subscribe-foreign-folder.c	\
+	e-ews-subscribe-foreign-folder.h	\
+	e-ews-edit-folder-permissions.c		\
+	e-ews-edit-folder-permissions.h		\
+	e-ews-config-ui-extension.c \
+	e-ews-config-ui-extension.h
+
+module_ews_ui_config_la_LIBADD = \
+	$(top_builddir)/src/server/libeews-1.2.la	\
+	$(top_builddir)/src/utils/libewsutils.la 	\
+	$(top_builddir)/src/camel/libcamelews.la 	\
+	$(EVOLUTION_PLUGIN_LIBS) \
+	$(EVOLUTION_SHELL_LIBS) \
+	$(CAMEL_LIBS) \
+	$(NULL)
+
+module_ews_ui_config_la_LDFLAGS = -module -avoid-version $(NO_UNDEFINED)
 
 -include $(top_srcdir)/git.mk
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/account-setup-eplugin/module-ews-configuration.c evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/module-ews-configuration.c
--- evolution-ews.git-gnome-3-0/src/account-setup-eplugin/module-ews-configuration.c	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/module-ews-configuration.c	2013-05-28 08:59:53.554712297 +0200
@@ -0,0 +1,45 @@
+/*
+ * module-ews-mail-config.c
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) version 3.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the program; if not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <glib/gi18n-lib.h>
+#include <gmodule.h>
+
+#include "e-ews-config-ui-extension.h"
+
+/* Module Entry Points */
+void e_module_load (GTypeModule *type_module);
+void e_module_unload (GTypeModule *type_module);
+
+G_MODULE_EXPORT void
+e_module_load (GTypeModule *type_module)
+{
+	bindtextdomain (GETTEXT_PACKAGE, EXCHANGE_EWS_LOCALEDIR);
+	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
+
+	e_ews_config_ui_extension_type_register (type_module);
+}
+
+G_MODULE_EXPORT void
+e_module_unload (GTypeModule *type_module)
+{
+}
+
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml
--- evolution-ews.git-gnome-3-0/src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml	2013-05-17 14:36:16.330555377 +0200
+++ evolution-ews.sync-with-3.8.2/src/account-setup-eplugin/org-gnome-exchange-ews.eplug.xml	2013-05-28 08:59:53.550713433 +0200
@@ -35,10 +35,13 @@
 	<hook class="org.gnome.evolution.mail.config:1.0">
 		<group 	target="account" 
 			id="org.gnome.evolution.mail.config.accountEditor" 
-			check="org_gnome_exchange_ews_check_options">
+			check="org_gnome_exchange_ews_check_options"
+			commit="org_gnome_ews_commit_config_pages">
 			<item type="item_table" path="10.receive/15.config/30.ews" factory="org_gnome_exchange_ews_account_setup"/>
 			<item type="section_table" path="20.receive_options/20.gal" _label="GAL settings"/>
 			<item type="item_table" path="20.receive_options/20.gal/10.oab" factory="org_gnome_ews_oab_settings"/>
+			<item type="page" path="41.EWS_OOO" _label="Out of Office" factory="org_gnome_ews_ooo_page"/>
+			<item type="page" path="42.EWS_Delegates" _label="Delegates" factory="org_gnome_ews_delegates_page"/>
 		</group>
 	</hook>
   </e-plugin>
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/addressbook/e-book-backend-ews.c evolution-ews.sync-with-3.8.2/src/addressbook/e-book-backend-ews.c
--- evolution-ews.git-gnome-3-0/src/addressbook/e-book-backend-ews.c	2013-05-17 14:36:16.333671343 +0200
+++ evolution-ews.sync-with-3.8.2/src/addressbook/e-book-backend-ews.c	2013-05-28 08:59:53.043838505 +0200
@@ -20,7 +20,10 @@
  *
  */
 
+#ifdef HAVE_CONFIG_H
 #include <config.h>
+#endif
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -45,26 +48,40 @@
 #include "libedata-book/e-book-backend-sexp.h"
 #include "libedata-book/e-data-book.h"
 #include "libedata-book/e-data-book-view.h"
+
 #include "e-book-backend-ews.h"
 #include "e-book-backend-sqlitedb.h"
 #include "e-book-backend-ews-utils.h"
+
 #include "lzx/ews-oal-decompress.h"
+
+#include "server/e-ews-item-change.h"
+#include "server/e-ews-message.h"
+#include "server/e-ews-connection.h"
+#include "server/e-ews-item.h"
+
+#include "utils/e-ews-query-to-restriction.h"
+
+#include "e-book-backend-ews.h"
 #include "ews-oab-decoder.h"
-#include "e-ews-item-change.h"
 #include "libedata-book-compat.h"
 
-#include "e-ews-message.h"
-#include "e-ews-connection.h"
-#include "e-ews-item.h"
+#include "server/e-ews-gnome-3-8-compat.h"
+
+#define d(x) x
+
+#define EDB_ERROR(_code) e_data_book_create_error (E_DATA_BOOK_STATUS_ ## _code, NULL)
+#define EDB_ERROR_EX(_code,_msg) e_data_book_create_error (E_DATA_BOOK_STATUS_ ## _code, _msg)
 
 #define d(x) x
 
 #define EDB_ERROR(_code) e_data_book_create_error (E_DATA_BOOK_STATUS_ ## _code, NULL)
 #define EDB_ERROR_EX(_code,_msg) e_data_book_create_error (E_DATA_BOOK_STATUS_ ## _code, _msg)
-#define EDB_ERROR_FAILED_STATUS(_code, _status) e_data_book_create_error_fmt (E_DATA_BOOK_STATUS_ ## _code, "Failed with status 0x%x", _status)
 
 G_DEFINE_TYPE (EBookBackendEws, e_book_backend_ews, E_TYPE_BOOK_BACKEND)
 
+static gboolean ebews_fetch_items (EBookBackendEws *ebews,  GSList *items, gboolean store_to_cache, GSList **vcards, GCancellable *cancellable, GError **error);
+
 typedef struct {
 	GCond *cond;
 	GMutex *mutex;
@@ -80,7 +97,7 @@ struct _EBookBackendEwsPrivate {
 	gchar *username;
 	gchar *password;
 	
-	EBookBackendSqliteDB *ebsdb;
+	EBookBackendSqliteDB *summary;
 
 	gboolean only_if_exists;
 	gboolean is_writable;
@@ -98,6 +115,8 @@ struct _EBookBackendEwsPrivate {
 	GThread *dthread;
 	SyncDelta *dlock;
 
+	GCancellable *cancellable;
+
 #if EDS_CHECK_VERSION (3,1,0)
 	ECredentials *credentials;
 #endif
@@ -123,6 +142,14 @@ enum {
 #define PRIV_LOCK(p)   (g_static_rec_mutex_lock (&(p)->rec_mutex))
 #define PRIV_UNLOCK(p) (g_static_rec_mutex_unlock (&(p)->rec_mutex))
 
+static gboolean
+e_book_backend_ews_get_online (EBookBackendEws *ews_backend)
+{
+	g_return_val_if_fail (E_IS_BOOK_BACKEND_EWS (ews_backend), FALSE);
+
+	return ews_backend->priv && ews_backend->priv->mode != MODE_LOCAL;
+}
+
 static void
 ews_auth_required (EBookBackend *backend)
 {
@@ -134,11 +161,69 @@ ews_auth_required (EBookBackend *backend
 #endif	
 }
 
+static void
+convert_error_to_edb_error (GError **perror)
+{
+	GError *error = NULL;
+
+	g_return_if_fail (perror != NULL);
+
+	if (!*perror || (*perror)->domain == E_DATA_BOOK_ERROR)
+		return;
+
+	if ((*perror)->domain == EWS_CONNECTION_ERROR) {
+		switch ((*perror)->code) {
+		case EWS_CONNECTION_ERROR_AUTHENTICATION_FAILED:
+			error = EDB_ERROR_EX (AUTHENTICATION_FAILED, (*perror)->message);
+			break;
+		case EWS_CONNECTION_ERROR_CANCELLED:
+			break;
+		case EWS_CONNECTION_ERROR_FOLDERNOTFOUND:
+		case EWS_CONNECTION_ERROR_MANAGEDFOLDERNOTFOUND:
+		case EWS_CONNECTION_ERROR_PARENTFOLDERNOTFOUND:
+		case EWS_CONNECTION_ERROR_PUBLICFOLDERSERVERNOTFOUND:
+			error = EDB_ERROR_EX (NO_SUCH_BOOK, (*perror)->message);
+			break;
+		case EWS_CONNECTION_ERROR_EVENTNOTFOUND:
+		case EWS_CONNECTION_ERROR_ITEMNOTFOUND:
+			error = EDB_ERROR_EX (CONTACT_NOT_FOUND, (*perror)->message);
+			break;
+		}
+	}
+
+	if (!error)
+		error = EDB_ERROR_EX (OTHER_ERROR, (*perror)->message);
+
+	g_error_free (*perror);
+	*perror = error;
+}
+
+static gboolean
+book_backend_ews_ensure_connected (EBookBackendEws *bbews,
+				   GCancellable *cancellable,
+				   GError **perror)
+{
+	g_return_val_if_fail (E_IS_BOOK_BACKEND_EWS (bbews), FALSE);
+
+	PRIV_LOCK (bbews->priv);
+
+	if (bbews->priv->cnc) {
+		PRIV_UNLOCK (bbews->priv);
+		return TRUE;
+	}
+
+	PRIV_UNLOCK (bbews->priv);
+
+	g_propagate_error (perror, EDB_ERROR (REPOSITORY_OFFLINE));
+
+	return FALSE;
+}
+
 static gboolean
 ews_remove_attachments (const gchar *attachment_dir)
 {
 	GDir *dir;
-	
+
 	dir = g_dir_open (attachment_dir, 0, NULL);
 	if (dir) {
 		const gchar *fname;
@@ -165,7 +250,7 @@ ews_remove_attachments (const gchar *att
 static const struct phone_field_mapping {
 	EContactField field;
 	const gchar *element;
-} phone_field_map [] = {
+} phone_field_map[] = {
 	{E_CONTACT_PHONE_ASSISTANT, "AssistantPhone"},
 	{E_CONTACT_PHONE_BUSINESS_FAX, "BusinessFax"},
 	{E_CONTACT_PHONE_BUSINESS, "BusinessPhone"},
@@ -187,35 +272,43 @@ static const struct phone_field_mapping 
 };
 
 static void
-ebews_populate_uid	(EContact *contact, EEwsItem *item)
+ebews_populate_uid (EContact *contact,
+                    EEwsItem *item)
 {
 	const EwsId *id;
 
 	id = e_ews_item_get_id (item);
-	e_contact_set (contact, E_CONTACT_UID, id->id);
-	e_contact_set (contact, E_CONTACT_REV, id->change_key);
+	if (id) {
+		e_contact_set (contact, E_CONTACT_UID, id->id);
+		e_contact_set (contact, E_CONTACT_REV, id->change_key);
+	}
 }
 
 static void
-ebews_populate_full_name	(EContact *contact, EEwsItem *item)
+ebews_populate_full_name (EContact *contact,
+                          EEwsItem *item)
 {
 	const EwsCompleteName *cn;
 
 	cn = e_ews_item_get_complete_name (item);
-	e_contact_set (contact, E_CONTACT_FULL_NAME, cn->full_name);
+	if (cn)
+		e_contact_set (contact, E_CONTACT_FULL_NAME, cn->full_name);
 }
 
 static void
-ebews_populate_nick_name	(EContact *contact, EEwsItem *item)
+ebews_populate_nick_name (EContact *contact,
+                          EEwsItem *item)
 {
 	const EwsCompleteName *cn;
 
 	cn = e_ews_item_get_complete_name (item);
-	e_contact_set (contact, E_CONTACT_NICKNAME, cn->nick_name);
+	if (cn)
+		e_contact_set (contact, E_CONTACT_NICKNAME, cn->nick_name);
 }
 
 static void
-ebews_populate_birth_date	(EContact *contact, EEwsItem *item)
+ebews_populate_birth_date (EContact *contact,
+                           EEwsItem *item)
 {
 	time_t bdate;
 	GDate date;
@@ -226,7 +319,7 @@ ebews_populate_birth_date	(EContact *con
 	if (bdate) {
 		g_date_clear (&date, 1);
 		g_date_set_time_t (&date, bdate);
-	
+
 		edate.year = date.year;
 		edate.month = date.month;
 		edate.day = date.day;
@@ -237,7 +330,8 @@ ebews_populate_birth_date	(EContact *con
 }
 
 static void
-ebews_populate_anniversary	(EContact *contact, EEwsItem *item)
+ebews_populate_anniversary (EContact *contact,
+                            EEwsItem *item)
 {
 	time_t bdate;
 	GDate date;
@@ -248,7 +342,7 @@ ebews_populate_anniversary	(EContact *co
 	if (bdate) {
 		g_date_clear (&date, 1);
 		g_date_set_time_t (&date, bdate);
-	
+
 		edate.year = date.year;
 		edate.month = date.month;
 		edate.day = date.day;
@@ -259,26 +353,31 @@ ebews_populate_anniversary	(EContact *co
 }
 
 static void
-set_phone_number (EContact *contact, EContactField field, EEwsItem *item, const gchar *item_field)
+set_phone_number (EContact *contact,
+                  EContactField field,
+                  EEwsItem *item,
+                  const gchar *item_field)
 {
 	const gchar *pn;
-	
+
 	pn = e_ews_item_get_phone_number (item, item_field);
 	if (pn && *pn)
 		e_contact_set (contact, field, pn);
 }
 
 static void
-ebews_populate_phone_numbers	(EContact *contact, EEwsItem *item)
+ebews_populate_phone_numbers (EContact *contact,
+                              EEwsItem *item)
 {
 	gint i;
-	
+
 	for (i = 0; i < G_N_ELEMENTS (phone_field_map); i++)
 		set_phone_number (contact, phone_field_map[i].field, item, phone_field_map[i].element);
 }
 
 static void
-copy_ews_address_to_contact_address ( EContactAddress *contact_addr, const EwsAddress *address)
+copy_ews_address_to_contact_address (EContactAddress *contact_addr,
+                                     const EwsAddress *address)
 {
 	contact_addr->address_format = NULL;
 	contact_addr->po = NULL;
@@ -290,14 +389,17 @@ copy_ews_address_to_contact_address ( EC
 	contact_addr->country = g_strdup (address->country);
 }
 static void
-set_address (EContact *contact, EContactField field, EEwsItem *item, const gchar *item_field)
+set_address (EContact *contact,
+             EContactField field,
+             EEwsItem *item,
+             const gchar *item_field)
 {
 	const EwsAddress *address;
-	
+
 	address = e_ews_item_get_physical_address (item, item_field);
 	if (address) {
 		EContactAddress *addr;
-	
+
 		addr = g_new0 (EContactAddress, 1);
 		copy_ews_address_to_contact_address (addr, address);
 		e_contact_set (contact, field, addr);
@@ -306,33 +408,50 @@ set_address (EContact *contact, EContact
 }
 
 static void
-ebews_populate_address		(EContact *contact, EEwsItem *item)
+ebews_populate_address (EContact *contact,
+                        EEwsItem *item)
 {
-	
+
 	set_address (contact, E_CONTACT_ADDRESS_WORK, item, "Business");
 	set_address (contact, E_CONTACT_ADDRESS_HOME, item, "Home");
 	set_address (contact, E_CONTACT_ADDRESS_OTHER, item, "Other");
 }
 
 static void
-ebews_populate_ims		(EContact *contact, EEwsItem *item)
+ebews_populate_ims (EContact *contact,
+                    EEwsItem *item)
 {
 	/* TODO : The fields returned by server does not match with the EContact fields
-	   for the IMS, handle it later */
+	 * for the IMS, handle it later */
+}
+
+static void
+ebews_populate_notes (EContact *contact,
+                      EEwsItem *item)
+{
+	const gchar *notes = e_ews_item_get_notes (item);
+	if (!notes)
+		return;
+
+	e_contact_set (contact, E_CONTACT_NOTE, notes);
 }
 
 static void
-set_email_address (EContact *contact, EContactField field, EEwsItem *item, const gchar *item_field)
+set_email_address (EContact *contact,
+                   EContactField field,
+                   EEwsItem *item,
+                   const gchar *item_field)
 {
 	const gchar *ea;
-	
+
 	ea = e_ews_item_get_email_address (item, item_field);
 	if (ea && *ea)
 		e_contact_set (contact, field, ea);
 }
 
 static void
-ebews_populate_emails		(EContact *contact, EEwsItem *item)
+ebews_populate_emails (EContact *contact,
+                       EEwsItem *item)
 {
 	set_email_address (contact, E_CONTACT_EMAIL_1, item, "EmailAddress1");
 	set_email_address (contact, E_CONTACT_EMAIL_2, item, "EmailAddress2");
@@ -340,54 +459,78 @@ ebews_populate_emails		(EContact *contac
 }
 
 static void
-ebews_set_item_id		(ESoapMessage *message, EContact *contact)
+ebews_set_item_id (ESoapMessage *message,
+                   EContact *contact)
 {
-	
+
 }
 
 static void
-ebews_set_full_name		(ESoapMessage *msg, EContact *contact)
+ebews_set_full_name (ESoapMessage *msg,
+                     EContact *contact)
 {
 	EContactName *name;
 
 	name = e_contact_get (contact, E_CONTACT_NAME);
 	if (!name)
 		return;
-	
+
 	if (name->given)
-		e_ews_message_write_string_parameter(msg, "GivenName", NULL, name->given);
-	
+		e_ews_message_write_string_parameter (msg, "GivenName", NULL, name->given);
+
 	if (name->additional && *name->additional)
-		e_ews_message_write_string_parameter(msg, "MiddleName", NULL, name->additional);
+		e_ews_message_write_string_parameter (msg, "MiddleName", NULL, name->additional);
 
 	e_contact_name_free (name);
 }
+
 /* TODO Set birth and anniversary dates */
 static void
-ebews_set_birth_date		(ESoapMessage *message, EContact *contact)
+ebews_set_birth_date (ESoapMessage *message,
+                      EContact *contact)
 {
-	
+	EContactDate *date;
+	gchar *birthday;
+
+	date = e_contact_get (contact, E_CONTACT_BIRTH_DATE);
+
+	if (!date)
+		return;
+
+	birthday = g_strdup_printf (
+		"%04d-%02d-%02dT00:00:00",
+		date->year, date->month, date->day);
+
+	e_ews_message_write_string_parameter (message, "Birthday", NULL, birthday);
+
+	g_free (birthday);
+
 }
 
 static void
-ebews_set_anniversary		(ESoapMessage *message, EContact *contact)
+ebews_set_anniversary (ESoapMessage *message,
+                       EContact *contact)
 {
-	
+
 }
 
 static gboolean
-add_entry (ESoapMessage *msg, EContact *contact, EContactField field, const gchar *entry_name, const gchar *include_hdr)
+add_entry (ESoapMessage *msg,
+           EContact *contact,
+           EContactField field,
+           const gchar *entry_name,
+           const gchar *include_hdr)
 {
 	gchar *entry_val;
 
 	entry_val = e_contact_get (contact, field);
-	
-	if (entry_val && *entry_val){
+
+	if (entry_val && *entry_val) {
 		if (include_hdr)
-			e_soap_message_start_element(msg, include_hdr, NULL, NULL);
+			e_soap_message_start_element (msg, include_hdr, NULL, NULL);
+
+		e_ews_message_write_string_parameter_with_attribute (msg, "Entry", NULL, entry_val, "Key", entry_name);
 
-		e_ews_message_write_string_parameter_with_attribute(msg, "Entry", NULL, entry_val, "Key", entry_name);
-		
 		g_free (entry_val);
 		return TRUE;
 	}
@@ -397,22 +540,27 @@ add_entry (ESoapMessage *msg, EContact *
 }
 
 static void
-ebews_set_phone_numbers		(ESoapMessage *msg, EContact *contact)
+ebews_set_phone_numbers (ESoapMessage *msg,
+                         EContact *contact)
 {
 	gint i;
 	const gchar *include_hdr = "PhoneNumbers";
-	
+
 	for (i = 0; i < G_N_ELEMENTS (phone_field_map); i++) {
 		if (add_entry (msg, contact, phone_field_map[i].field, phone_field_map[i].element, include_hdr))
 			include_hdr = NULL;
 	}
 
 	if (!include_hdr)
-		e_soap_message_end_element(msg);
+		e_soap_message_end_element (msg);
 }
 
 static gboolean
-add_physical_address (ESoapMessage *msg, EContact *contact, EContactField field, const gchar *entry_name, gboolean include_start_hdr)
+add_physical_address (ESoapMessage *msg,
+                      EContact *contact,
+                      EContactField field,
+                      const gchar *entry_name,
+                      gboolean include_start_hdr)
 {
 	EContactAddress *contact_addr;
 
@@ -424,7 +572,7 @@ add_physical_address (ESoapMessage *msg,
 		e_soap_message_start_element (msg, "PhysicalAddresses", NULL, NULL);
 
 	e_soap_message_start_element (msg, "Entry", NULL, NULL);
-	
+
 	e_soap_message_add_attribute (msg, "Key", entry_name, NULL, NULL);
 	e_ews_message_write_string_parameter (msg, "Street", NULL, contact_addr->street);
 	e_ews_message_write_string_parameter (msg, "City", NULL, contact_addr->locality);
@@ -438,7 +586,8 @@ add_physical_address (ESoapMessage *msg,
 }
 
 static void
-ebews_set_address	(ESoapMessage *msg, EContact *contact)
+ebews_set_address (ESoapMessage *msg,
+                   EContact *contact)
 {
 	gboolean include_hdr = TRUE;
 
@@ -450,20 +599,35 @@ ebews_set_address	(ESoapMessage *msg, EC
 		include_hdr = FALSE;
 
 	if (!include_hdr)
-		e_soap_message_end_element(msg);
+		e_soap_message_end_element (msg);
 }
 
 static void
-ebews_set_ims			(ESoapMessage *message, EContact *contact)
+ebews_set_ims (ESoapMessage *message,
+               EContact *contact)
 {
-	
+
 }
 
 static void
-ebews_set_emails		(ESoapMessage *msg, EContact *contact)
+ebews_set_notes (ESoapMessage *msg,
+                 EContact *contact)
+{
+	gchar *notes = e_contact_get (contact, E_CONTACT_NOTE);
+	if (!notes)
+		return;
+
+	e_ews_message_write_string_parameter_with_attribute (msg, "Body", NULL, notes, "BodyType", "Text");
+
+	g_free (notes);
+}
+
+static void
+ebews_set_emails (ESoapMessage *msg,
+                  EContact *contact)
 {
 	const gchar *include_hdr = "EmailAddresses";
-	
+
 	if (add_entry (msg, contact, E_CONTACT_EMAIL_1, "EmailAddress1", include_hdr))
 		include_hdr = NULL;
 	if (add_entry (msg, contact, E_CONTACT_EMAIL_2, "EmailAddress2", include_hdr))
@@ -472,11 +636,16 @@ ebews_set_emails		(ESoapMessage *msg, EC
 		include_hdr = NULL;
 
 	if (!include_hdr)
-		e_soap_message_end_element(msg);
+		e_soap_message_end_element (msg);
 }
 
 static void
-convert_contact_property_to_updatexml (ESoapMessage *msg, const gchar *name, const gchar *value, const gchar * prefix, const gchar *attr_name, const gchar *attr_value)
+convert_contact_property_to_updatexml (ESoapMessage *msg,
+                                       const gchar *name,
+                                       const gchar *value,
+                                       const gchar *prefix,
+                                       const gchar *attr_name,
+                                       const gchar *attr_value)
 {
 	e_ews_message_start_set_item_field (msg, name, prefix, "Contact");
 	e_ews_message_write_string_parameter_with_attribute (msg, name, NULL, value, attr_name, attr_value);
@@ -484,26 +653,32 @@ convert_contact_property_to_updatexml (E
 }
 
 static void
-convert_indexed_contact_property_to_updatexml (ESoapMessage *message, const gchar *name, const gchar *value, const gchar * prefix, const gchar *element_name, const gchar *key)
+convert_indexed_contact_property_to_updatexml (ESoapMessage *message,
+                                               const gchar *name,
+                                               const gchar *value,
+                                               const gchar *prefix,
+                                               const gchar *element_name,
+                                               const gchar *key)
 {
 	gboolean delete_field = FALSE;
 
-	if(!value || !g_strcmp0(value, ""))
+	if (!value || g_strcmp0 (value, "") == 0)
 		delete_field = TRUE;
 	e_ews_message_start_set_indexed_item_field (message, name , prefix, "Contact", key, delete_field);
-	
-	if(!delete_field)
+
+	if (!delete_field)
 	{
-		e_soap_message_start_element(message, element_name, NULL, NULL);
-		e_ews_message_write_string_parameter_with_attribute(message, "Entry", NULL, value, "Key", key);
-		e_soap_message_end_element(message);
+		e_soap_message_start_element (message, element_name, NULL, NULL);
+		e_ews_message_write_string_parameter_with_attribute (message, "Entry", NULL, value, "Key", key);
+		e_soap_message_end_element (message);
 	}
 	e_ews_message_end_set_indexed_item_field (message, delete_field);
 }
 
-
 static void
-ebews_set_full_name_changes	(ESoapMessage *message, EContact *new, EContact *old)
+ebews_set_full_name_changes (ESoapMessage *message,
+                             EContact *new,
+                             EContact *old)
 {
 	EContactName *name, *old_name;
 
@@ -511,154 +686,203 @@ ebews_set_full_name_changes	(ESoapMessag
 	old_name = e_contact_get (old, E_CONTACT_NAME);
 	if (!name && !old_name)
 		return;
-	
-	if (g_ascii_strcasecmp(name->given, old_name->given))
-		convert_contact_property_to_updatexml(message, "GivenName", name->given, "contacts", NULL, NULL);
-	
-	if (g_ascii_strcasecmp(name->additional, old_name->additional))
-		convert_contact_property_to_updatexml(message, "MiddleName", name->additional, "contacts", NULL, NULL);
+
+	if (g_strcmp0 (name->given, old_name->given) != 0)
+		convert_contact_property_to_updatexml (message, "GivenName", name->given, "contacts", NULL, NULL);
+
+	if (g_strcmp0 (name->additional, old_name->additional) != 0)
+		convert_contact_property_to_updatexml (message, "MiddleName", name->additional, "contacts", NULL, NULL);
 
 	e_contact_name_free (name);
 	e_contact_name_free (old_name);
-	
+
 }
 
 static void
-ebews_set_birth_date_changes	(ESoapMessage *message, EContact *new, EContact *old)
+ebews_set_birth_date_changes (ESoapMessage *message,
+                              EContact *new,
+                              EContact *old)
 {
+	EContactDate *new_date, *old_date;
+	gchar *birthday;
 
+	new_date = e_contact_get (new, E_CONTACT_BIRTH_DATE);
+	old_date = e_contact_get (old, E_CONTACT_BIRTH_DATE);
+
+	if (e_contact_date_equal (new_date, old_date))
+		return;
+
+	birthday = g_strdup_printf (
+		"%04d-%02d-%02dT00:00:00",
+		new_date->year, new_date->month, new_date->day);
+
+	convert_contact_property_to_updatexml (message, "Birthday", birthday, "contacts", NULL, NULL);
+	g_free (birthday);
 }
 
 static void
-ebews_set_anniversary_changes	(ESoapMessage *message, EContact *new, EContact *old)
+ebews_set_anniversary_changes (ESoapMessage *message,
+                               EContact *new,
+                               EContact *old)
 {
 
 }
 
 static void
-ebews_set_phone_number_changes	(ESoapMessage *message, EContact *new, EContact *old)
+ebews_set_phone_number_changes (ESoapMessage *message,
+                                EContact *new,
+                                EContact *old)
 {
 	gint i;
 	gchar *new_value, *old_value;
-	
+
 	for (i = 0; i < G_N_ELEMENTS (phone_field_map); i++) {
 		new_value = e_contact_get (new, phone_field_map[i].field);
 		old_value = e_contact_get (old, phone_field_map[i].field);
-		if((new_value && !old_value) || (!new_value && old_value) ||(new_value && old_value && g_ascii_strcasecmp(new_value, old_value)))
+
+		if (g_strcmp0 (new_value, old_value) != 0)
 			convert_indexed_contact_property_to_updatexml (message, "PhoneNumber", new_value, "contacts", "PhoneNumbers", phone_field_map[i].element);
-		if(new_value)
-			g_free(new_value);
-		
-		if(old_value)
-			g_free(old_value);
+
+		g_free (new_value);
+		g_free (old_value);
 	}
 }
 
 static void
-convert_indexed_contact_property_to_updatexml_physical_address (ESoapMessage *message, const gchar *name, const gchar *uri_element, const gchar *value, const gchar * prefix, const gchar *element_name, const gchar *key)
+convert_indexed_contact_property_to_updatexml_physical_address (ESoapMessage *message,
+                                                                const gchar *name,
+                                                                const gchar *uri_element,
+                                                                const gchar *value,
+                                                                const gchar *prefix,
+                                                                const gchar *element_name,
+                                                                const gchar *key)
 {
 	gchar * fielduri = NULL;
 	gboolean delete_field = FALSE;
 
-	if(!value || !g_strcmp0(value, ""))
+	if (!value || g_strcmp0 (value, "") == 0)
 		delete_field = TRUE;
 
 	fielduri = g_strconcat (name, ":", uri_element, NULL);
 
 	e_ews_message_start_set_indexed_item_field (message, fielduri , prefix, "Contact", key, delete_field);
-	
-	if(!delete_field)
+
+	if (!delete_field)
 	{
-		e_soap_message_start_element(message, element_name, NULL, NULL);
+		e_soap_message_start_element (message, element_name, NULL, NULL);
 
 		e_soap_message_start_element (message, "Entry", NULL, NULL);
 		e_soap_message_add_attribute (message, "Key", key, NULL, NULL);
 		e_ews_message_write_string_parameter (message, uri_element, NULL, value);
-		e_soap_message_end_element(message);
+		e_soap_message_end_element (message);
 
-		e_soap_message_end_element(message);
+		e_soap_message_end_element (message);
 	}
 	e_ews_message_end_set_indexed_item_field (message, delete_field);
 }
 
-static void compare_address(ESoapMessage *message, EContact *new, EContact *old, EContactField field, const char *key)
+static void
+compare_address (ESoapMessage *message,
+                 EContact *new,
+                 EContact *old,
+                 EContactField field,
+                 const gchar *key)
 {
 	EContactAddress *new_address, *old_address;
 	gboolean set = FALSE;
 
-	new_address = e_contact_get(new, field);
-	old_address = e_contact_get(old, field);
+	new_address = e_contact_get (new, field);
+	old_address = e_contact_get (old, field);
 
-	if(!new_address && !old_address)
+	if (!new_address && !old_address)
 		return;
 
-	if(!old_address && new_address)
+	if (!old_address && new_address)
 		set = TRUE;
 
-	if(!new_address && old_address)
+	if (!new_address && old_address)
 	{
 		set = TRUE;
-		new_address = g_new0(EContactAddress, 1);
+		new_address = g_new0 (EContactAddress, 1);
 	}
 
-	if (set || g_ascii_strcasecmp(new_address->street, old_address->street))
+	if (set || g_strcmp0 (new_address->street, old_address->street) != 0)
 		convert_indexed_contact_property_to_updatexml_physical_address (message, "PhysicalAddress", "Street", new_address->street, "contacts", "PhysicalAddresses", key);
-	if (set || g_ascii_strcasecmp(new_address->locality, old_address->locality))
+	if (set || g_strcmp0 (new_address->locality, old_address->locality) != 0)
 		convert_indexed_contact_property_to_updatexml_physical_address (message, "PhysicalAddress", "City", new_address->locality, "contacts", "PhysicalAddresses", key);
-	if (set || g_ascii_strcasecmp(new_address->region, old_address->region))
+	if (set || g_strcmp0 (new_address->region, old_address->region) != 0)
 		convert_indexed_contact_property_to_updatexml_physical_address (message, "PhysicalAddress", "State", new_address->region, "contacts", "PhysicalAddresses", key);
-	if (set || g_ascii_strcasecmp(new_address->code, old_address->code))
+	if (set || g_strcmp0 (new_address->code, old_address->code) != 0)
 		convert_indexed_contact_property_to_updatexml_physical_address (message, "PhysicalAddress", "PostalCode", new_address->code, "contacts", "PhysicalAddresses", key);
 
-	e_contact_address_free(old_address);
-	e_contact_address_free(new_address);
+	e_contact_address_free (old_address);
+	e_contact_address_free (new_address);
 }
 
 static void
-ebews_set_address_changes	(ESoapMessage *message, EContact *new, EContact *old)
+ebews_set_address_changes (ESoapMessage *message,
+                           EContact *new,
+                           EContact *old)
 {
-	compare_address(message, new, old, E_CONTACT_ADDRESS_WORK, "Business");
-	compare_address(message, new, old, E_CONTACT_ADDRESS_HOME, "Home");
-	compare_address(message, new, old, E_CONTACT_ADDRESS_OTHER, "Other");
+	compare_address (message, new, old, E_CONTACT_ADDRESS_WORK, "Business");
+	compare_address (message, new, old, E_CONTACT_ADDRESS_HOME, "Home");
+	compare_address (message, new, old, E_CONTACT_ADDRESS_OTHER, "Other");
 }
 
 static void
-ebews_set_im_changes		(ESoapMessage *message, EContact *new, EContact *old)
+ebews_set_im_changes (ESoapMessage *message,
+                      EContact *new,
+                      EContact *old)
 {
-	
+
+}
+
+static void
+ebews_set_notes_changes (ESoapMessage *message,
+                         EContact *new,
+                         EContact *old)
+{
+	gchar *old_notes, *new_notes;
+
+	old_notes = e_contact_get (old, E_CONTACT_NOTE);
+	new_notes = e_contact_get (new, E_CONTACT_NOTE);
+
+	if (g_strcmp0 (old_notes, new_notes) != 0) {
+		convert_contact_property_to_updatexml (
+				message, "Body", new_notes ?: "", "item", "BodyType", "Text");
+	}
+
+	g_free (old_notes);
+	g_free (new_notes);
 }
 
 static void
-ebews_set_email_changes		(ESoapMessage *message, EContact *new, EContact *old)
+ebews_set_email_changes (ESoapMessage *message,
+                         EContact *new,
+                         EContact *old)
 {
 	gchar *new_value, *old_value;
-		
+
 	new_value = e_contact_get (new, E_CONTACT_EMAIL_1);
 	old_value = e_contact_get (old, E_CONTACT_EMAIL_1);
-	if((new_value && !old_value) || (!new_value && old_value) ||(new_value && old_value && g_ascii_strcasecmp(new_value, old_value)))
+	if (g_strcmp0 (new_value, old_value) != 0)
 		convert_indexed_contact_property_to_updatexml (message, "EmailAddress", new_value, "contacts", "EmailAddresses", "EmailAddress1");
-	if(new_value)
-		g_free(new_value);
-	if (old_value)
-		g_free(old_value);
+	g_free (new_value);
+	g_free (old_value);
 
 	new_value = e_contact_get (new, E_CONTACT_EMAIL_2);
 	old_value = e_contact_get (old, E_CONTACT_EMAIL_2);
-	if((new_value && !old_value) || (!new_value && old_value) ||(new_value && old_value && g_ascii_strcasecmp(new_value, old_value)))
+	if (g_strcmp0 (new_value, old_value) != 0)
 		convert_indexed_contact_property_to_updatexml (message, "EmailAddress", new_value, "contacts", "EmailAddresses", "EmailAddress2");
-	if(new_value)
-		g_free(new_value);
-	if (old_value)
-		g_free(old_value);
+	g_free (new_value);
+	g_free (old_value);
 
 	new_value = e_contact_get (new, E_CONTACT_EMAIL_3);
 	old_value = e_contact_get (old, E_CONTACT_EMAIL_3);
-	if((new_value && !old_value) || (!new_value && old_value) ||(new_value && old_value && g_ascii_strcasecmp(new_value, old_value)))
+	if (g_strcmp0 (new_value, old_value) != 0)
 		convert_indexed_contact_property_to_updatexml (message, "EmailAddress", new_value, "contacts", "EmailAddresses", "EmailAddress3");
-	if(new_value)
-		g_free(new_value);
-	if (old_value)
-		g_free(old_value);
+	g_free (new_value);
+	g_free (old_value);
 }
 
 static const struct field_element_mapping {
@@ -673,6 +897,7 @@ static const struct field_element_mappin
 
 } mappings[] = {
 	/* The order should be maintained for create contacts to work */
+	{ E_CONTACT_NOTE, ELEMENT_TYPE_COMPLEX, "Notes", NULL, ebews_populate_notes, ebews_set_notes, ebews_set_notes_changes },
 	{ E_CONTACT_FILE_AS, ELEMENT_TYPE_SIMPLE, "FileAs", e_ews_item_get_fileas},
 	{ E_CONTACT_FULL_NAME, ELEMENT_TYPE_COMPLEX, "CompleteName", NULL, ebews_populate_full_name, ebews_set_full_name, ebews_set_full_name_changes},
 	{ E_CONTACT_NICKNAME, ELEMENT_TYPE_SIMPLE, "Nickname", NULL, ebews_populate_nick_name},
@@ -701,7 +926,6 @@ static const struct field_element_mappin
 	{ E_CONTACT_UID, ELEMENT_TYPE_COMPLEX, "ItemId", NULL,  ebews_populate_uid, ebews_set_item_id},
 };
 
-
 typedef struct {
 	EBookBackendEws *ebews;
 	EDataBook *book;
@@ -710,37 +934,40 @@ typedef struct {
 } EwsCreateContact;
 
 static void
-convert_contact_to_xml (ESoapMessage *msg, gpointer user_data)
+convert_contact_to_xml (ESoapMessage *msg,
+                        gpointer user_data)
 {
-	EContact *contact = (EContact*)user_data;
+	EContact *contact = (EContact *) user_data;
 	gint i, element_type;
 
 	/* Prepare Contact node in the SOAP message */
-	e_soap_message_start_element(msg, "Contact", NULL, NULL);
+	e_soap_message_start_element (msg, "Contact", NULL, NULL);
 
 	for (i = 0; i < G_N_ELEMENTS (mappings); i++) {
 		element_type = mappings[i].element_type;
 
 		if (element_type == ELEMENT_TYPE_SIMPLE) {
-			char *val = e_contact_get (contact, mappings [i].field_id);
+			gchar *val = e_contact_get (contact, mappings[i].field_id);
 
 			/* skip uid while creating contacts */
-			if (mappings [i].field_id == E_CONTACT_UID)
+			if (mappings[i].field_id == E_CONTACT_UID)
 				continue;
 
 			if (val && *val)
-				e_ews_message_write_string_parameter(msg, mappings[i].element_name, NULL, val);
+				e_ews_message_write_string_parameter (msg, mappings[i].element_name, NULL, val);
 			g_free (val);
 		} else
 			mappings[i].set_value_in_soap_message (msg, contact);
 	}
 
 	// end of "Contact"
-	e_soap_message_end_element(msg);
+	e_soap_message_end_element (msg);
 }
 
 static void
-ews_create_contact_cb(GObject *object, GAsyncResult *res, gpointer user_data)
+ews_create_contact_cb (GObject *object,
+                       GAsyncResult *res,
+                       gpointer user_data)
 {
 	EEwsConnection *cnc = E_EWS_CONNECTION (object);
 	EwsCreateContact *create_contact = user_data;
@@ -750,17 +977,19 @@ ews_create_contact_cb(GObject *object, G
 	const EwsId *item_id;
 
 	/* get a list of ids from server (single item) */
-	e_ews_connection_create_items_finish(cnc, res, &items, &error);
+	e_ews_connection_create_items_finish (cnc, res, &items, &error);
+
+	g_return_if_fail (ebews->priv->summary != NULL);
 
 	if (error == NULL) {
 		EEwsItem *item = (EEwsItem *) items->data;
 
 		/* set item id */
-		item_id = e_ews_item_get_id((EEwsItem *)items->data);
+		item_id = e_ews_item_get_id ((EEwsItem *) items->data);
 
 		e_contact_set (create_contact->contact, E_CONTACT_UID, item_id->id);
 		e_contact_set (create_contact->contact, E_CONTACT_REV, item_id->change_key);
-		e_book_backend_sqlitedb_add_contact (ebews->priv->ebsdb, ebews->priv->folder_id, create_contact->contact, FALSE, &error);
+		e_book_backend_sqlitedb_add_contact (ebews->priv->summary, ebews->priv->folder_id, create_contact->contact, FALSE, &error);
 
 		if (error == NULL)
 			e_data_book_respond_create (create_contact->book, create_contact->opid, EDB_ERROR (SUCCESS), create_contact->contact);
@@ -768,84 +997,86 @@ ews_create_contact_cb(GObject *object, G
 		g_object_unref (item);
 		g_slist_free (items);
 	}
-	
+
 	if (error) {
-		g_warning("Error while Creating contact: %s", error->message);
-		e_data_book_respond_create (create_contact->book, create_contact->opid, EDB_ERROR_EX (OTHER_ERROR, error->message), create_contact->contact);
+		g_warning ("Error while Creating contact: %s", error->message);
+		e_data_book_respond_create (create_contact->book, create_contact->opid, EDB_ERROR_EX (OTHER_ERROR, error->message), NULL);
 	}
 
 	/* free memory allocated for create_contact & unref contained objects */
-	g_object_unref(create_contact->ebews);
-	g_object_unref(create_contact->contact);
-	g_free(create_contact);
+	g_object_unref (create_contact->ebews);
+	g_object_unref (create_contact->contact);
+	g_free (create_contact);
 	g_clear_error (&error);
 }
 
 static void
-e_book_backend_ews_create_contact	(EBookBackend *backend,
-					 EDataBook *book,
-					 guint32 opid,
-					 GCancellable *cancellable,
-					 const gchar *vcard )
+e_book_backend_ews_create_contact (EBookBackend *backend,
+				   EDataBook *book,
+				   guint32 opid,
+				   GCancellable *cancellable,
+				   const gchar *vcard)
 {
 	EContact *contact = NULL;
 	EBookBackendEws *ebews;
 	EwsCreateContact *create_contact;
+	EwsFolderId *fid;
 	EBookBackendEwsPrivate *priv;
+	GError *error = NULL;
  
 	ebews = E_BOOK_BACKEND_EWS (backend);
 	priv = ebews->priv;
 
-	switch (ebews->priv->mode) {
-	case MODE_LOCAL :
+	if (!e_book_backend_ews_get_online (E_BOOK_BACKEND_EWS (backend))) {
 		if (!priv->is_writable) {
-			e_data_book_respond_modify (book, opid, EDB_ERROR (PERMISSION_DENIED), NULL);
+			e_data_book_respond_create (book, opid, EDB_ERROR (PERMISSION_DENIED), NULL);
 			return;
 		}
 
 		e_data_book_respond_create (book, opid, EDB_ERROR (REPOSITORY_OFFLINE), NULL);
 		return;
+	}
 
-	case  MODE_REMOTE :
-
-		if (ebews->priv->cnc == NULL) {
-			e_data_book_respond_create (book, opid, EDB_ERROR (AUTHENTICATION_REQUIRED), NULL);
-			return;
-		}
+	if (!book_backend_ews_ensure_connected (ebews, cancellable, &error)) {
+		convert_error_to_edb_error (&error);
+		e_data_book_respond_create (book, opid, error, NULL);
+		return;
+	}
 
-		if (!ebews->priv->is_writable) {
-			e_data_book_respond_create (book, opid, EDB_ERROR (PERMISSION_DENIED), NULL);
-			return;
-		}
+	if (!ebews->priv->is_writable) {
+		e_data_book_respond_create (book, opid, EDB_ERROR (PERMISSION_DENIED), NULL);
+		return;
+	}
 
-		contact = e_contact_new_from_vcard (vcard);
-		
-		if (e_contact_get (contact, E_CONTACT_IS_LIST)) {
-			g_object_unref (contact);
-			e_data_book_respond_create (book, opid, EDB_ERROR (NOT_SUPPORTED), NULL);
-			return;
-		}
+	contact = e_contact_new_from_vcard (vcard);
 
-		create_contact = g_new0(EwsCreateContact, 1);
-		create_contact->ebews = g_object_ref(ebews);
-		create_contact->book = g_object_ref(book);
-		create_contact->opid = opid;
-		create_contact->contact = g_object_ref(contact);
-
-		/* pass new contact component data to the exchange server and expect response in the callback */
-		e_ews_connection_create_items_start (priv->cnc,
-						     EWS_PRIORITY_MEDIUM, NULL,
-						     NULL,
-						     priv->folder_id,
-						     convert_contact_to_xml,
-						     contact,
-						     ews_create_contact_cb,
-						     cancellable,
-						     create_contact);
+	if (e_contact_get (contact, E_CONTACT_IS_LIST)) {
+		g_object_unref (contact);
+		e_data_book_respond_create (book, opid, EDB_ERROR (NOT_SUPPORTED), NULL);
 		return;
-	default:
-		break;
 	}
+
+	create_contact = g_new0 (EwsCreateContact, 1);
+	create_contact->ebews = g_object_ref (ebews);
+	create_contact->book = g_object_ref (book);
+	create_contact->opid = opid;
+	create_contact->contact = g_object_ref (contact);
+
+	fid = e_ews_folder_id_new (priv->folder_id, NULL, FALSE);
+
+	/* pass new contact component data to the exchange server and expect response in the callback */
+	e_ews_connection_create_items (
+		priv->cnc,
+		EWS_PRIORITY_MEDIUM, NULL,
+		NULL,
+		fid,
+		convert_contact_to_xml,
+		contact,
+		cancellable,
+		ews_create_contact_cb,
+		create_contact);
+
+	e_ews_folder_id_free (fid);
 }
 
 typedef struct {
@@ -856,7 +1087,9 @@ typedef struct {
 } EwsRemoveContact;
 
 static void
-ews_book_remove_contact_cb (GObject *object, GAsyncResult *res, gpointer user_data)
+ews_book_remove_contact_cb (GObject *object,
+                            GAsyncResult *res,
+                            gpointer user_data)
 {
 	EwsRemoveContact *remove_contact = user_data;
 	EBookBackendEws *ebews = remove_contact->ebews;
@@ -867,14 +1100,16 @@ ews_book_remove_contact_cb (GObject *obj
 
 	simple = G_SIMPLE_ASYNC_RESULT (res);
 
-	if (!g_simple_async_result_propagate_error(simple, &error))
-		deleted = e_book_backend_sqlitedb_remove_contacts (priv->ebsdb, priv->folder_id, remove_contact->sl_ids, &error);
+	g_return_if_fail (priv->summary != NULL);
+
+	if (!g_simple_async_result_propagate_error (simple, &error))
+		deleted = e_book_backend_sqlitedb_remove_contacts (priv->summary, priv->folder_id, remove_contact->sl_ids, &error);
 
 	if (deleted)
 		e_data_book_respond_remove_contacts_compat (remove_contact->book, remove_contact->opid, EDB_ERROR (SUCCESS),  remove_contact->sl_ids);
 	else {
 		e_data_book_respond_remove_contacts_compat (remove_contact->book, remove_contact->opid, EDB_ERROR_EX (OTHER_ERROR, error->message), NULL);
-		
+
 		g_warning ("\nError removing contact %s \n", error->message);
 	}
 
@@ -887,55 +1122,59 @@ ews_book_remove_contact_cb (GObject *obj
 }
 
 static void
-e_book_backend_ews_remove_contacts	(EBookBackend *backend,
-					 EDataBook    *book,
-					 guint32 opid,
-					 GCancellable *cancellable,
-					 const GSList *id_list)
+e_book_backend_ews_remove_contacts (EBookBackend *backend,
+                                    EDataBook *book,
+                                    guint32 opid,
+                                    GCancellable *cancellable,
+                                    const GSList *id_list)
 {
 	EBookBackendEws *ebews;
 	EwsRemoveContact *remove_contact;
 	EBookBackendEwsPrivate *priv;
- 
+	GSList *l, *copy = NULL;
+	GError *error = NULL;
+
 	ebews = E_BOOK_BACKEND_EWS (backend);
- 
+
 	priv = ebews->priv;
 
-	switch (ebews->priv->mode) {
-	case MODE_LOCAL :
+	if (!e_book_backend_ews_get_online (E_BOOK_BACKEND_EWS (backend))) {
 		if (!priv->is_writable) {
-			e_data_book_respond_modify (book, opid, EDB_ERROR (PERMISSION_DENIED), NULL);
+			e_data_book_respond_remove_contacts (book, opid, EDB_ERROR (PERMISSION_DENIED), NULL);
 			return;
 		}
 
 		e_data_book_respond_remove_contacts (book, opid, EDB_ERROR (REPOSITORY_OFFLINE), NULL);
 		return;
+	}
 
-	case MODE_REMOTE :
-		if (ebews->priv->cnc == NULL) {
-			e_data_book_respond_remove_contacts (book, opid, EDB_ERROR (AUTHENTICATION_REQUIRED), NULL);
-			return;
-		}
-
-		if (!ebews->priv->is_writable) {
-			e_data_book_respond_remove_contacts (book, opid, EDB_ERROR (PERMISSION_DENIED), NULL);
-			return;
-		}
+	if (!book_backend_ews_ensure_connected (ebews, cancellable, &error)) {
+		convert_error_to_edb_error (&error);
+		e_data_book_respond_remove_contacts (book, opid, error, NULL);
+		return;
+	}
 
-		remove_contact = g_new0(EwsRemoveContact, 1);
-		remove_contact->ebews = g_object_ref(ebews);
-		remove_contact->book = g_object_ref(book);
-		remove_contact->opid = opid;
-		remove_contact->sl_ids = (GSList *) id_list;
-
-		e_ews_connection_delete_items_start (priv->cnc, EWS_PRIORITY_MEDIUM, (GSList *) id_list,
-						     EWS_HARD_DELETE, 0 , FALSE,
-						     ews_book_remove_contact_cb, cancellable,
-						     remove_contact);
+	if (!ebews->priv->is_writable) {
+		e_data_book_respond_remove_contacts (book, opid, EDB_ERROR (PERMISSION_DENIED), NULL);
 		return;
-	default :
-		break;
 	}
+
+	for (l = (GSList *) id_list; l != NULL; l = g_slist_next (id_list))
+		copy = g_slist_prepend (copy, g_strdup ((gchar *) l->data));
+	copy = g_slist_reverse (copy);
+
+	remove_contact = g_new0 (EwsRemoveContact, 1);
+	remove_contact->ebews = g_object_ref (ebews);
+	remove_contact->book = g_object_ref (book);
+	remove_contact->opid = opid;
+	remove_contact->sl_ids = copy;
+
+	e_ews_connection_delete_items (
+		priv->cnc, EWS_PRIORITY_MEDIUM, (GSList *) id_list,
+		EWS_HARD_DELETE, 0 , FALSE,
+		cancellable,
+		ews_book_remove_contact_cb,
+		remove_contact);
 }
 
 typedef struct {
@@ -947,7 +1186,9 @@ typedef struct {
 } EwsModifyContact;
 
 static void
-ews_modify_contact_cb (GObject *object, GAsyncResult *res, gpointer user_data)
+ews_modify_contact_cb (GObject *object,
+                       GAsyncResult *res,
+                       gpointer user_data)
 {
 	EEwsConnection *cnc = E_EWS_CONNECTION (object);
 	EwsModifyContact *modify_contact = user_data;
@@ -961,59 +1202,64 @@ ews_modify_contact_cb (GObject *object, 
 	g_object_ref (modify_contact->new_contact);
 	g_object_ref (modify_contact->old_contact);
 
+	e_ews_connection_update_items_finish (cnc, res, &items, &error);
 
-	e_ews_connection_update_items_finish(cnc, res, &items, &error);
+	g_return_if_fail (priv->summary != NULL);
 
 	if (error == NULL) {
 		EEwsItem *item = (EEwsItem *) items->data;
 
 		/* set item id */
-		item_id = e_ews_item_get_id((EEwsItem *)items->data);
+		item_id = e_ews_item_get_id ((EEwsItem *) items->data);
 
 		e_contact_set (modify_contact->new_contact, E_CONTACT_UID, item_id->id);
 		e_contact_set (modify_contact->new_contact, E_CONTACT_REV, item_id->change_key);
 
 		id = e_contact_get (modify_contact->old_contact, E_CONTACT_UID);
 
-		e_book_backend_sqlitedb_remove_contact (priv->ebsdb, priv->folder_id, id, &error);
-		e_book_backend_sqlitedb_add_contact (ebews->priv->ebsdb, ebews->priv->folder_id, modify_contact->new_contact, FALSE, &error);
+		e_book_backend_sqlitedb_remove_contact (priv->summary, priv->folder_id, id, &error);
+		e_book_backend_sqlitedb_add_contact (ebews->priv->summary, ebews->priv->folder_id, modify_contact->new_contact, TRUE, &error);
 
-		if (error == NULL)
+		if (error == NULL) {
 			e_data_book_respond_modify (modify_contact->book, modify_contact->opid, EDB_ERROR (SUCCESS), modify_contact->new_contact);
+		}
 
 		g_object_unref (item);
 		g_slist_free (items);
 	}
-	
+
 	if (error) {
-		g_warning("Error while Modifying contact: %s", error->message);
-		e_data_book_respond_modify (modify_contact->book, modify_contact->opid, EDB_ERROR_EX (OTHER_ERROR, error->message), modify_contact->new_contact);
+		g_warning ("Error while Modifying contact: %s", error->message);
+
+		e_data_book_respond_modify (modify_contact->book, modify_contact->opid, EDB_ERROR_EX (OTHER_ERROR, error->message), NULL);
 	}
 
 	/* free memory allocated for create_contact & unref contained objects */
-	g_object_unref(modify_contact->ebews);
-	g_object_unref(modify_contact->new_contact);
-	g_object_unref(modify_contact->old_contact);
-	g_free(modify_contact);
+	g_object_unref (modify_contact->ebews);
+	g_object_unref (modify_contact->new_contact);
+	g_object_unref (modify_contact->old_contact);
+	g_free (modify_contact);
 	g_clear_error (&error);
 }
 
 static void
-convert_contact_to_updatexml (ESoapMessage *msg, gpointer user_data)
+convert_contact_to_updatexml (ESoapMessage *msg,
+                              gpointer user_data)
 {
 	EwsModifyContact *modify_contact = user_data;
 	EwsId *id;
 	EContact *old_contact = modify_contact->old_contact;
 	EContact *new_contact = modify_contact->new_contact;
-	gchar *value = NULL, *old_value = NULL ;
+	gchar *value = NULL, *old_value = NULL;
 	gint i, element_type;
 
 	id = g_new0 (EwsId, 1);
 	id->id = e_contact_get (old_contact, E_CONTACT_UID);
 	id->change_key = e_contact_get (old_contact, E_CONTACT_REV);
 
-	e_ews_message_start_item_change (msg, E_EWS_ITEMCHANGE_TYPE_ITEM,
-                                         id->id, id->change_key, 0);
+	e_ews_message_start_item_change (
+		msg, E_EWS_ITEMCHANGE_TYPE_ITEM,
+		id->id, id->change_key, 0);
 
 	/*Iterate for each field in contact*/
 
@@ -1022,30 +1268,28 @@ convert_contact_to_updatexml (ESoapMessa
 		if (element_type == ELEMENT_TYPE_SIMPLE)  {
 			value =  e_contact_get (new_contact, mappings[i].field_id);
 			old_value =  e_contact_get (old_contact, mappings[i].field_id);
+			if (g_strcmp0 (value, old_value) != 0)
+				convert_contact_property_to_updatexml (msg, mappings[i].element_name, value, "contacts", NULL, NULL);
 			if (value)
-			{
-				if(( *value && !old_value) || g_ascii_strcasecmp (value, old_value))
-					convert_contact_property_to_updatexml(msg, mappings[i].element_name, value, "contacts", NULL, NULL);
-				g_free(value);
-			}
-			if(old_value)
-				g_free(old_value);
+				g_free (value);
+			if (old_value)
+				g_free (old_value);
 		} else if (element_type == ELEMENT_TYPE_COMPLEX) {
-			if(mappings [i].field_id == E_CONTACT_UID)
+			if (mappings[i].field_id == E_CONTACT_UID)
 				continue;
 			mappings[i].set_changes (msg, new_contact, old_contact);
 		}
 	}
-	
+
 	e_ews_message_end_item_change (msg);
 }
 
 static void
-e_book_backend_ews_modify_contact	(EBookBackend *backend,
-					 EDataBook    *book,
-					 guint32       opid,
-					 GCancellable *cancellable,
-					 const gchar   *vcard)
+e_book_backend_ews_modify_contact (EBookBackend *backend,
+				   EDataBook *book,
+				   guint32 opid,
+				   GCancellable *cancellable,
+				   const gchar *vcard)
 {
 	EContact *contact = NULL, *old_contact;
 	EwsModifyContact *modify_contact;
@@ -1054,13 +1298,10 @@ e_book_backend_ews_modify_contact	(EBook
 	EBookBackendEwsPrivate *priv;
 	GError *error;
 
-
 	ebews = E_BOOK_BACKEND_EWS (backend);
 	priv = ebews->priv;
 
-	switch (priv->mode) {
-
-	case MODE_LOCAL :
+	if (!e_book_backend_ews_get_online (E_BOOK_BACKEND_EWS (backend))) {
 		if (!priv->is_writable) {
 			e_data_book_respond_modify (book, opid, EDB_ERROR (PERMISSION_DENIED), NULL);
 			return;
@@ -1068,121 +1309,180 @@ e_book_backend_ews_modify_contact	(EBook
 
 		e_data_book_respond_modify (book, opid, EDB_ERROR (REPOSITORY_OFFLINE), NULL);
 		return;
-	case MODE_REMOTE :
+	}
 
-		if (priv->cnc == NULL) {
-			e_data_book_respond_modify (book, opid, EDB_ERROR (AUTHENTICATION_REQUIRED), NULL);
-			return;
-		}
-		
-		if (!priv->is_writable) {
-			e_data_book_respond_modify (book, opid, EDB_ERROR (PERMISSION_DENIED), NULL);
-			return;
-		}
-		
-		contact = e_contact_new_from_vcard (vcard);
+	if (!book_backend_ews_ensure_connected (ebews, cancellable, &error)) {
+		convert_error_to_edb_error (&error);
+		e_data_book_respond_modify (book, opid, error, NULL);
+		return;
+	}
 
-		id = g_new0 (EwsId, 1);
-		id->id = e_contact_get (contact, E_CONTACT_UID);
-		id->change_key = e_contact_get (contact, E_CONTACT_REV);
-
-		/*get item id and change key from contact and fetch old contact and assign.*/
-
-		if (e_contact_get (contact, E_CONTACT_IS_LIST)) {
-			g_object_unref (contact);
-			e_data_book_respond_modify (book, opid, EDB_ERROR (NOT_SUPPORTED), NULL);
-			return;
-		}
+	if (!priv->is_writable) {
+		e_data_book_respond_modify (book, opid, EDB_ERROR (PERMISSION_DENIED), NULL);
+		return;
+	}
 
-		old_contact = e_book_backend_sqlitedb_get_contact ( priv->ebsdb, priv->folder_id,
-					 id->id, NULL, NULL, &error); 
-		if (!old_contact) {
-			g_object_unref (contact);
-			e_data_book_respond_modify (book, opid, EDB_ERROR (NOT_SUPPORTED), NULL);
-			return;
-		}
+	g_return_if_fail (priv->summary != NULL);
+
+	contact = e_contact_new_from_vcard (vcard);
 
-		/* TODO implement */
-		modify_contact = g_new0 (EwsModifyContact, 1);
-		modify_contact->ebews = g_object_ref(ebews);
-		modify_contact->book = g_object_ref(book);
-		modify_contact->opid = opid;
-		modify_contact->old_contact = g_object_ref(old_contact);
-		modify_contact->new_contact = g_object_ref(contact);
-		e_ews_connection_update_items_start (priv->cnc, EWS_PRIORITY_MEDIUM,
-							"AlwaysOverwrite", "SendAndSaveCopy",
-							"SendToAllAndSaveCopy", priv->folder_id,
-							convert_contact_to_updatexml, modify_contact,
-							ews_modify_contact_cb, cancellable,
-							modify_contact);
+	id = g_new0 (EwsId, 1);
+	id->id = e_contact_get (contact, E_CONTACT_UID);
+	id->change_key = e_contact_get (contact, E_CONTACT_REV);
+
+	/*get item id and change key from contact and fetch old contact and assign.*/
+
+	if (e_contact_get (contact, E_CONTACT_IS_LIST)) {
+		g_object_unref (contact);
+		e_data_book_respond_modify (book, opid, EDB_ERROR (NOT_SUPPORTED), NULL);
+		return;
+	}
+
+	old_contact = e_book_backend_sqlitedb_get_contact (
+		priv->summary, priv->folder_id,
+		id->id, NULL, NULL, &error);
+	if (!old_contact) {
+		g_object_unref (contact);
+		e_data_book_respond_modify (book, opid, EDB_ERROR (NOT_SUPPORTED), NULL);
 		return;
-	default :
-		break;
 	}
+
+	/* TODO implement */
+	modify_contact = g_new0 (EwsModifyContact, 1);
+	modify_contact->ebews = g_object_ref (ebews);
+	modify_contact->book = g_object_ref (book);
+	modify_contact->opid = opid;
+	modify_contact->old_contact = g_object_ref (old_contact);
+	modify_contact->new_contact = g_object_ref (contact);
+	e_ews_connection_update_items (
+		priv->cnc, EWS_PRIORITY_MEDIUM,
+		"AlwaysOverwrite", "SendAndSaveCopy",
+		"SendToAllAndSaveCopy", priv->folder_id,
+		convert_contact_to_updatexml, modify_contact,
+		cancellable,
+		ews_modify_contact_cb,
+		modify_contact);
 }
 
 static void
-e_book_backend_ews_get_contact	(EBookBackend *backend,
-				 EDataBook    *book,
-				 guint32       opid,
-				 GCancellable *cancellable,
-				 const gchar   *id)
+e_book_backend_ews_get_contact (EBookBackend *backend,
+                                EDataBook *book,
+                                guint32 opid,
+                                GCancellable *cancellable,
+                                const gchar *id)
 {
-	EBookBackendEws *gwb;
-
-	gwb =  E_BOOK_BACKEND_EWS (backend);
+	EBookBackendEws *ebews;
+	GError *error = NULL;
 
-	switch (gwb->priv->mode) {
+	ebews =  E_BOOK_BACKEND_EWS (backend);
 
-	case MODE_LOCAL :
-		e_data_book_respond_get_contact (book, opid, EDB_ERROR (CONTACT_NOT_FOUND), "");
+	if (!e_book_backend_ews_get_online (E_BOOK_BACKEND_EWS (backend))) {
+		e_data_book_respond_get_contact (book, opid, EDB_ERROR (REPOSITORY_OFFLINE), NULL);
 		return;
+	}
 
-	case MODE_REMOTE :
-		if (gwb->priv->cnc == NULL) {
-			e_data_book_respond_get_contact (book, opid, e_data_book_create_error_fmt (E_DATA_BOOK_STATUS_OTHER_ERROR, "Not connected"), NULL);
-			return;
-		}
-		e_data_book_respond_get_contact (book, opid, EDB_ERROR (CONTACT_NOT_FOUND), "");
+	if (!book_backend_ews_ensure_connected (ebews, cancellable, &error)) {
+		convert_error_to_edb_error (&error);
+		e_data_book_respond_get_contact (book, opid, error, NULL);
 		return;
-	default :
-		break;
 	}
+
+	e_data_book_respond_get_contact (book, opid, EDB_ERROR (CONTACT_NOT_FOUND), "");
 }
 
 static void
-e_book_backend_ews_get_contact_list	(EBookBackend *backend,
-					 EDataBook    *book,
-					 guint32       opid,
-					 GCancellable *cancellable,
-					 const gchar   *query )
+e_book_backend_ews_get_contact_list (EBookBackend *backend,
+                                     EDataBook *book,
+                                     guint32 opid,
+                                     GCancellable *cancellable,
+                                     const gchar *query)
 {
-	GSList *vcard_list;
-	EBookBackendEws *egwb;
+	GSList *vcard_list = NULL;
+	GSList *list, *l;
+	GError *error = NULL;
+	EBookBackendEws *ebews;
+	EBookBackendEwsPrivate *priv;
 
-	egwb = E_BOOK_BACKEND_EWS (backend);
-	vcard_list = NULL;
+	ebews = E_BOOK_BACKEND_EWS (backend);
+	priv = ebews->priv;
 
-	switch (egwb->priv->mode) {
+	if (!e_book_backend_ews_get_online (E_BOOK_BACKEND_EWS (backend))) {
+		if (priv->summary && e_book_backend_sqlitedb_get_is_populated (priv->summary, priv->folder_id, NULL)) {
+			list = e_book_backend_sqlitedb_search (priv->summary, priv->folder_id, query, NULL, NULL, NULL, &error);
+			l = list;
+			while (l) {
+				EbSdbSearchData *s_data = (EbSdbSearchData *) l->data;
+
+				vcard_list = g_slist_append (vcard_list, g_strdup (s_data->vcard));
+				e_book_backend_sqlitedb_search_data_free (s_data);
+				l = l->next;
+			}
+			convert_error_to_edb_error (&error);
+			e_data_book_respond_get_contact_list_compat (book, opid, error, vcard_list);
 
-	case MODE_LOCAL :
+			g_slist_free (list);
+			g_slist_foreach (vcard_list, (GFunc) g_free, NULL);
+			g_slist_free (vcard_list);
+			return;
+		} else
+			e_data_book_respond_get_contact_list_compat (book, opid, EDB_ERROR (OFFLINE_UNAVAILABLE), vcard_list);
+			return;
+	}
 
-		e_data_book_respond_get_contact_list_compat (book, opid, EDB_ERROR (SUCCESS), vcard_list);
+	if (!book_backend_ews_ensure_connected (ebews, cancellable, &error)) {
+		convert_error_to_edb_error (&error);
+		e_data_book_respond_get_contact_list (book, opid, error, NULL);
 		return;
+	}
 
-	case MODE_REMOTE:
+	if (priv->summary && e_book_backend_sqlitedb_get_is_populated (priv->summary, priv->folder_id, NULL)) {
+		list = e_book_backend_sqlitedb_search (priv->summary, priv->folder_id, query, NULL, NULL, NULL, &error);
+		l = list;
+		while (l) {
+			EbSdbSearchData *s_data = (EbSdbSearchData *) l->data;
+
+			vcard_list = g_slist_append (vcard_list, g_strdup (s_data->vcard));
+			e_book_backend_sqlitedb_search_data_free (s_data);
+			l = l->next;
+		}
+
+		convert_error_to_edb_error (&error);
+		e_data_book_respond_get_contact_list_compat (book, opid, error, vcard_list);
+
+		g_slist_free (list);
+		g_slist_foreach (vcard_list, (GFunc) g_free, NULL);
+		g_slist_free (vcard_list);
+		return;
 
-		if (egwb->priv->cnc == NULL) {
-			e_data_book_respond_get_contact_list_compat (book, opid, EDB_ERROR (AUTHENTICATION_REQUIRED), NULL);
-			return;
-		}
+	} else if (!priv->marked_for_offline) {
+		GSList *items = NULL;
+		EwsFolderId *fid = NULL;
+		gboolean includes_last_item;
 
-		e_data_book_respond_get_contact_list_compat (book, opid, EDB_ERROR (SUCCESS), vcard_list);
-		return;
-	default :
-		break;
+		fid = g_new0 (EwsFolderId, 1);
+		fid->id = g_strdup (priv->folder_id);
+		fid->is_distinguished_id = FALSE;
 
-	}
+		e_ews_connection_find_folder_items_sync (
+			priv->cnc, EWS_PRIORITY_MEDIUM,
+			fid, "IdOnly", NULL, NULL, query,
+			E_EWS_FOLDER_TYPE_CONTACTS,
+			&includes_last_item,
+			&items, (EwsConvertQueryCallback) (e_ews_query_to_restriction),
+			cancellable, &error);
+
+		/*we have got Id for items lets fetch them using getitem operation*/
+		ebews_fetch_items (ebews, items, FALSE, &vcard_list, cancellable, &error);
+		convert_error_to_edb_error (&error);
+		e_data_book_respond_get_contact_list_compat (book, opid, error, vcard_list);
+
+		e_ews_folder_id_free (fid);
+		g_slist_foreach (vcard_list, (GFunc) g_free, NULL);
+		g_slist_free (vcard_list);
+		return;
+	} else
+		e_data_book_respond_get_contact_list_compat (book, opid, EDB_ERROR_EX (OTHER_ERROR, _("Wait till syncing is done")), vcard_list);
+		return;
 }
 
 typedef struct {
@@ -1195,7 +1495,10 @@ typedef struct {
 } EBookBackendEwsSExpData;
 
 static ESExpResult *
-func_not (ESExp *f, gint argc, ESExpResult **argv, gpointer data)
+func_not (ESExp *f,
+          gint argc,
+          ESExpResult **argv,
+          gpointer data)
 {
 	ESExpResult *r;
 
@@ -1211,7 +1514,10 @@ func_not (ESExp *f, gint argc, ESExpResu
 }
 
 static ESExpResult *
-func_and_or (ESExp *f, gint argc, ESExpResult **argv, gpointer and)
+func_and_or (ESExp *f,
+             gint argc,
+             ESExpResult **argv,
+             gpointer and)
 {
 	ESExpResult *r;
 
@@ -1223,7 +1529,10 @@ func_and_or (ESExp *f, gint argc, ESExpR
 
 /* TODO implement */
 static ESExpResult *
-func_is (struct _ESExp *f, gint argc, struct _ESExpResult **argv, gpointer data)
+func_is (struct _ESExp *f,
+         gint argc,
+         struct _ESExpResult **argv,
+         gpointer data)
 {
 	ESExpResult *r;
 	EBookBackendEwsSExpData *sdata = data;
@@ -1244,7 +1553,10 @@ func_is (struct _ESExp *f, gint argc, st
 
 /* TODO implement */
 static ESExpResult *
-func_endswith (struct _ESExp *f, gint argc, struct _ESExpResult **argv, gpointer data)
+func_endswith (struct _ESExp *f,
+               gint argc,
+               struct _ESExpResult **argv,
+               gpointer data)
 {
 	ESExpResult *r;
 	EBookBackendEwsSExpData *sdata = data;
@@ -1266,7 +1578,10 @@ func_endswith (struct _ESExp *f, gint ar
 
 /* TODO implement */
 static ESExpResult *
-func_contains (struct _ESExp *f, gint argc, struct _ESExpResult **argv, gpointer data)
+func_contains (struct _ESExp *f,
+               gint argc,
+               struct _ESExpResult **argv,
+               gpointer data)
 {
 	ESExpResult *r;
 	EBookBackendEwsSExpData *sdata = data;
@@ -1287,9 +1602,12 @@ func_contains (struct _ESExp *f, gint ar
 }
 
 /* We are just handling for autocompletion now. We need to support other fields after implementing
-   Restrictions and find_items request */
+ * Restrictions and find_items request */
 static ESExpResult *
-func_beginswith (struct _ESExp *f, gint argc, struct _ESExpResult **argv, gpointer data)
+func_beginswith (struct _ESExp *f,
+                 gint argc,
+                 struct _ESExpResult **argv,
+                 gpointer data)
 {
 	ESExpResult *r;
 	gchar *propname, *str;
@@ -1333,7 +1651,9 @@ static struct {
 
 /* FIXME  build a complete filter from the query that can be used by find_items */
 static gpointer
-e_book_backend_ews_build_restriction (const gchar *query, gboolean *autocompletion, gchar **auto_comp_str)
+e_book_backend_ews_build_restriction (const gchar *query,
+                                      gboolean *autocompletion,
+                                      gchar **auto_comp_str)
 {
 	ESExpResult *r;
 	ESExp *sexp;
@@ -1346,9 +1666,10 @@ e_book_backend_ews_build_restriction (co
 	sdata->is_query_handled = TRUE;
 
 	for (i = 0; i < G_N_ELEMENTS (symbols); i++) {
-		e_sexp_add_function (sexp, 0, (gchar *) symbols[i].name,
-				     symbols[i].func,
-				     sdata);
+		e_sexp_add_function (
+			sexp, 0, (gchar *) symbols[i].name,
+			symbols[i].func,
+			sdata);
 	}
 
 	e_sexp_input_text (sexp, query, strlen (query));
@@ -1368,47 +1689,68 @@ e_book_backend_ews_build_restriction (co
 }
 
 /************* GAL sync ***********************/
-
-
 static gboolean
-ews_gal_needs_update (EBookBackendEws *cbews, EwsOALDetails *full, GError **error)
+ews_gal_needs_update (EBookBackendEws *cbews,
+                      EwsOALDetails *full,
+                      GError **error)
 {
 	EBookBackendEwsPrivate *priv = cbews->priv;
 	guint32 seq;
 	gboolean ret = FALSE;
 	gchar *tmp;
 
-	tmp = e_book_backend_sqlitedb_get_key_value (priv->ebsdb, priv->folder_id, "seq", error);
-	if (error)
+	if (!priv->summary)
+		return FALSE;
+
+	tmp = e_book_backend_sqlitedb_get_key_value (priv->summary, priv->folder_id, "seq", error);
+	if (!tmp)
 		goto exit;
 
 	sscanf (tmp, "%"G_GUINT32_FORMAT, &seq);
 	if (seq < full->seq)
 		ret = TRUE;
-	
-	d(printf ("Gal needs update: %d \n", ret);)
+
+	d (printf ("Gal needs update: %d (local: %d, remote: %d)\n",
+		   ret, seq, full->seq);)
 exit:
 	g_free (tmp);
-	return ret;	
+	return ret;
 }
 
 static gchar *
-ews_download_full_gal (EBookBackendEws *cbews, EwsOALDetails *full, GCancellable *cancellable, GError **error)
+ews_download_full_gal (EBookBackendEws *cbews,
+                       EwsOALDetails *full,
+                       GCancellable *cancellable,
+                       GError **error)
 {
 	EBookBackendEwsPrivate *priv = cbews->priv;
 	EEwsConnection *oab_cnc;
 	gchar *full_url, *oab_url, *cache_file = NULL;
-	const gchar *cache_dir;
+	const gchar *cache_dir, *timeout_str;
 	gchar *comp_cache_file = NULL, *uncompress_file = NULL;
+	gchar *password;
+	ESource *esource = e_book_backend_get_source (E_BOOK_BACKEND (cbews));
 
 	/* oab url with oab.xml removed from the suffix */
 	oab_url = g_strndup (priv->oab_url, strlen (priv->oab_url) - 7);
 	full_url = g_strconcat (oab_url, full->filename, NULL);
 	cache_dir = e_book_backend_get_cache_dir (E_BOOK_BACKEND (cbews));
 	comp_cache_file = g_build_filename (cache_dir, full->filename, NULL);
+	timeout_str = e_source_get_property (esource, "timeout");
 
-	oab_cnc = e_ews_connection_new (full_url, priv->username, priv->password, NULL, NULL, NULL);
-	if (!e_ews_connection_download_oal_file (oab_cnc, comp_cache_file, NULL, NULL, cancellable, error))
+	oab_cnc = e_ews_connection_new (full_url, priv->username, priv->password,
+		e_source_get_property (esource, "email"),
+		e_source_get_property (esource, "impersonate_user"),
+		timeout_str ? atoi (timeout_str) : -1,
+		TRUE,
+		NULL, NULL, NULL);
+
+	password = e_ews_connection_dup_password (priv->cnc);
+	e_ews_connection_set_password (oab_cnc, password);
+	g_free (password);
+
+	if (!e_ews_connection_download_oal_file_sync (
+		oab_cnc, comp_cache_file, NULL, NULL, cancellable, error))
 		goto exit;
 
 	cache_file = g_strdup_printf ("%s-%d.oab", priv->folder_name, full->seq);
@@ -1419,9 +1761,9 @@ ews_download_full_gal (EBookBackendEws *
 		goto exit;
 	}
 
-	d(g_print ("OAL file decompressed %s \n", uncompress_file);)
+	d (g_print ("OAL file decompressed %s \n", uncompress_file);)
 
-exit:	
+exit:
 	if (comp_cache_file)
 		g_unlink (comp_cache_file);
 	g_object_unref (oab_cnc);
@@ -1434,18 +1776,23 @@ exit:	
 }
 
 static gboolean
-ews_remove_old_gal_file (EBookBackendEws *cbews, GError **error)
+ews_remove_old_gal_file (EBookBackendEws *cbews,
+                         GError **error)
 {
 	EBookBackendEwsPrivate *priv = cbews->priv;
 	gchar *filename;
 
-	filename = e_book_backend_sqlitedb_get_key_value (priv->ebsdb, priv->folder_id, "oab-filename", error);
+	if (!priv->summary)
+		return FALSE;
+
+	filename = e_book_backend_sqlitedb_get_key_value (priv->summary, priv->folder_id, "oab-filename", error);
 	if (*error)
 		return FALSE;
 
 	if (filename)
 		g_unlink (filename);
-	
+	g_free (filename);
+
 	return TRUE;
 }
 
@@ -1456,35 +1803,40 @@ struct _db_data {
 };
 
 static void
-ews_gal_store_contact (EContact *contact, goffset offset, guint percent, gpointer user_data, GError **error)
+ews_gal_store_contact (EContact *contact,
+                       goffset offset,
+                       guint percent,
+                       gpointer user_data,
+                       GError **error)
 {
 	struct _db_data *data = (struct _db_data *) user_data;
 	EBookBackendEwsPrivate *priv = data->cbews->priv;
 
+	g_return_if_fail (priv->summary != NULL);
+
 	data->contact_collector = g_slist_prepend (data->contact_collector, g_object_ref (contact));
 	data->collected_length += 1;
 
 	if (data->collected_length == 1000 || percent >= 100) {
 		GSList *l;
-		gchar *status_message=NULL;
-		EDataBookView *book_view = e_book_backend_ews_utils_get_book_view (E_BOOK_BACKEND (data->cbews));
+		GList *list, *link;
+		gchar *status_message = NULL;
 
-		d(g_print ("GAL adding contacts, percent complete : %d \n", percent);)
+		d (g_print ("GAL adding contacts, percent complete : %d \n", percent);)
 
 		status_message = g_strdup_printf (_("Downloading contacts in %s %d%% completed... "), priv->folder_name, percent);
-		if (book_view)
-			e_data_book_view_notify_progress (book_view, -1, status_message);
+		list = e_book_backend_list_views (E_BOOK_BACKEND (data->cbews));
+		for (link = list; link != NULL; link = g_list_next (link))
+			e_data_book_view_notify_progress (E_DATA_BOOK_VIEW (link->data), -1, status_message);
+		g_list_free_full (list, (GDestroyNotify) g_object_unref);
+		g_free (status_message);
 
 		data->contact_collector = g_slist_reverse (data->contact_collector);
-		e_book_backend_sqlitedb_add_contacts (priv->ebsdb, priv->folder_id, data->contact_collector, FALSE, error);
+		e_book_backend_sqlitedb_add_contacts (priv->summary, priv->folder_id, data->contact_collector, TRUE, error);
 
 		for (l = data->contact_collector; l != NULL; l = g_slist_next (l))
 			e_book_backend_notify_update (E_BOOK_BACKEND (data->cbews), E_CONTACT (l->data));
 
-		/* reset data */
-		if (book_view)
-			e_data_book_view_unref (book_view);
-		g_free (status_message);
 		g_slist_foreach (data->contact_collector, (GFunc) g_object_unref, NULL);
 		g_slist_free (data->contact_collector);
 		data->contact_collector = NULL;
@@ -1496,19 +1848,29 @@ ews_gal_store_contact (EContact *contact
 }
 
 static gboolean
-ews_replace_gal_in_db (EBookBackendEws *cbews, const gchar *filename, GCancellable *cancellable, GError **error)
+ews_replace_gal_in_db (EBookBackendEws *cbews,
+                       const gchar *filename,
+                       GCancellable *cancellable,
+                       GError **error)
 {
 	EBookBackendEwsPrivate *priv = cbews->priv;
 	EwsOabDecoder *eod;
 	gboolean ret = TRUE;
 	struct _db_data data;
 
+	g_return_val_if_fail (priv->summary != NULL, FALSE);
+
 	/* remove the old address-book and create a new one in db */
-	if (e_book_backend_sqlitedb_get_is_populated (priv->ebsdb, priv->folder_id, NULL)) {
-		ret = e_book_backend_sqlitedb_delete_addressbook (priv->ebsdb, priv->folder_id, error);
+	if (e_book_backend_sqlitedb_get_is_populated (priv->summary, priv->folder_id, NULL)) {
+		GSList *uids;
+
+		uids = e_book_backend_sqlitedb_search_uids (priv->summary, priv->folder_id, NULL, NULL, NULL);
+		if (uids) {
+			e_book_backend_sqlitedb_remove_contacts (priv->summary, priv->folder_id, uids, NULL);
+			g_slist_free_full (uids, g_free);
+		}
+
 		ews_remove_attachments (priv->attachment_dir);
-		if (ret)
-			ret = e_book_backend_sqlitedb_create_addressbook (priv->ebsdb, priv->folder_id, priv->folder_name, TRUE, error);
 	}
 
 	if (!ret)
@@ -1527,13 +1889,13 @@ ews_replace_gal_in_db (EBookBackendEws *
 	       return ret;
 
 	/* mark the db as populated */
-	ret = e_book_backend_sqlitedb_set_is_populated (priv->ebsdb, priv->folder_id, TRUE, error);
+	ret = e_book_backend_sqlitedb_set_is_populated (priv->summary, priv->folder_id, TRUE, error);
 
 	return ret;
 }
 
 static gboolean
-ebews_start_gal_sync	(gpointer data)
+ebews_start_gal_sync (gpointer data)
 {
 	EBookBackendEws *cbews;
 	EBookBackendEwsPrivate *priv;
@@ -1543,57 +1905,74 @@ ebews_start_gal_sync	(gpointer data)
 	GSList *full_l = NULL;
 	gboolean ret = TRUE;
 	gchar *uncompressed_filename = NULL;
-	GCancellable *cancellable;
+	const gchar *timeout_str;
+	ESource *esource;
 
 	cbews = (EBookBackendEws *) data;
 	priv = cbews->priv;
 
-	cancellable = g_cancellable_new ();
-	oab_cnc = e_ews_connection_new (priv->oab_url, priv->username, priv->password, NULL, NULL, NULL);
+	esource = e_book_backend_get_source (E_BOOK_BACKEND (cbews));
+	timeout_str = e_source_get_property (esource, "timeout");
 
-	d(printf ("Ewsgal: Fetching oal full details file \n");)
-
-	if (!e_ews_connection_get_oal_detail (oab_cnc, priv->folder_id, "Full", &full_l, cancellable, &error)) {
+	oab_cnc = e_ews_connection_new (priv->oab_url, priv->username, priv->password,
+		e_source_get_property (esource, "email"),
+		e_source_get_property (esource, "impersonate_user"),
+		timeout_str ? atoi (timeout_str) : -1,
+		TRUE,
+		NULL, NULL, NULL);
+
+	d (printf ("Ewsgal: Fetching oal full details file \n");)
+
+	if (!e_ews_connection_get_oal_detail_sync (
+		oab_cnc, priv->folder_id, "Full", &full_l,
+		priv->cancellable, &error)) {
 		ret = FALSE;
 		goto exit;
 	}
 
-	full = (EwsOALDetails *) full_l->data; 
+	g_warn_if_fail (priv->summary != NULL);
+	if (!priv->summary)
+		goto exit;
+
+	if (full_l == NULL)
+		goto exit;
+
+	full = (EwsOALDetails *) full_l->data;
 	/* TODO fetch differential updates if available instead of downloading the whole GAL */
-	if (!e_book_backend_sqlitedb_get_is_populated (priv->ebsdb, priv->folder_id, NULL) || ews_gal_needs_update (cbews, full, &error)) {
+	if (!e_book_backend_sqlitedb_get_is_populated (priv->summary, priv->folder_id, NULL) || ews_gal_needs_update (cbews, full, &error)) {
 		gchar *seq;
-		
-		d(printf ("Ewsgal: Downloading full gal \n");)
-		uncompressed_filename = ews_download_full_gal (cbews, full, cancellable, &error);
+
+		d (printf ("Ewsgal: Downloading full gal \n");)
+		uncompressed_filename = ews_download_full_gal (cbews, full, priv->cancellable, &error);
 		if (error) {
 			ret = FALSE;
 			goto exit;
 		}
 
-		d(printf ("Ewsgal: Removing old gal \n");)
+		d (printf ("Ewsgal: Removing old gal \n");)
 		/* remove old_gal_file */
 		ret = ews_remove_old_gal_file (cbews, &error);
 		if (!ret) {
 			goto exit;
 		}
 
-		d(printf ("Ewsgal: Replacing old gal with new gal contents in db \n");)
-		ret = ews_replace_gal_in_db (cbews, uncompressed_filename, cancellable, &error);
+		d (printf ("Ewsgal: Replacing old gal with new gal contents in db \n");)
+		ret = ews_replace_gal_in_db (cbews, uncompressed_filename, priv->cancellable, &error);
 		if (!ret)
 			goto exit;
-	
+
 		seq = g_strdup_printf ("%"G_GUINT32_FORMAT, full->seq);
-		ret = e_book_backend_sqlitedb_set_key_value (priv->ebsdb, priv->folder_id, "seq", seq, &error);
+		ret = e_book_backend_sqlitedb_set_key_value (priv->summary, priv->folder_id, "seq", seq, &error);
 		g_free (seq);
-		
+
 		if (!ret) {
-			e_book_backend_sqlitedb_delete_addressbook (priv->ebsdb, priv->folder_id, &error);
+			e_book_backend_sqlitedb_delete_addressbook (priv->summary, priv->folder_id, &error);
 			goto exit;
 		}
 	}
-	
-	d(printf ("Ews gal: sync successfull complete \n");)
-	
+
+	d (printf ("Ews gal: sync successfull complete \n");)
+
 exit:
 	if (error) {
 		g_warning ("Unable to update gal : %s \n", error->message);
@@ -1626,19 +2005,23 @@ exit:
  * @error: cannot be NULL 
  **/
 static void
-ebews_sync_deleted_items (EBookBackendEws *ebews, GSList *deleted_ids, GError **error)
+ebews_sync_deleted_items (EBookBackendEws *ebews,
+                          GSList *deleted_ids,
+                          GError **error)
 {
 	GSList *l;
 	EBookBackendEwsPrivate *priv;
 
 	priv = ebews->priv;
 
+	g_return_if_fail (priv->summary != NULL);
+
 	for (l = deleted_ids; l != NULL; l = g_slist_next (l)) {
 		gchar *id = (gchar *) l->data;
 		gboolean partial_content;
-		
-		if (e_book_backend_sqlitedb_has_contact (priv->ebsdb, priv->folder_id, id, &partial_content, NULL))
-			e_book_backend_sqlitedb_remove_contact (priv->ebsdb, priv->folder_id, id, error);
+
+		if (e_book_backend_sqlitedb_has_contact (priv->summary, priv->folder_id, id, &partial_content, NULL))
+			e_book_backend_sqlitedb_remove_contact (priv->summary, priv->folder_id, id, error);
 		e_book_backend_notify_remove (E_BOOK_BACKEND (ebews), id);
 	}
 
@@ -1646,32 +2029,41 @@ ebews_sync_deleted_items (EBookBackendEw
 	g_slist_free (deleted_ids);
 }
 
-
 static void
-ebews_store_contact_items (EBookBackendEws *ebews, GSList *new_items, gboolean distribution_list, GError **error)
+ebews_store_contact_items (EBookBackendEws *ebews,
+                           GSList *new_items,
+                           gboolean distribution_list,
+                           GError **error)
 {
 	EBookBackendEwsPrivate *priv;
 	GSList *l;
-	
+
 	priv = ebews->priv;
 
+	g_return_if_fail (priv->summary != NULL);
+
 	for (l = new_items; l != NULL; l = g_slist_next (l)) {
 		EContact *contact;
 		gint i, element_type;
 		EEwsItem *item;
-	
+
 		item = (EEwsItem *) l->data;
+		if (e_ews_item_get_item_type (item) == E_EWS_ITEM_TYPE_ERROR) {
+			g_object_unref (item);
+			continue;
+		}
+
 		contact = e_contact_new ();
 
 		if (!distribution_list) {
 			for (i = 0; i < G_N_ELEMENTS (mappings); i++) {
 				element_type = mappings[i].element_type;
 
-				if (element_type == ELEMENT_TYPE_SIMPLE && !mappings [i].populate_contact_func) {
-					const char *val = mappings [i].get_simple_prop_func (item);
+				if (element_type == ELEMENT_TYPE_SIMPLE && !mappings[i].populate_contact_func) {
+					const gchar *val = mappings[i].get_simple_prop_func (item);
 
 					if (val != NULL)
-						e_contact_set (contact, mappings [i].field_id, val);
+						e_contact_set (contact, mappings[i].field_id, val);
 				} else
 					mappings[i].populate_contact_func (contact, item);
 			}
@@ -1679,44 +2071,70 @@ ebews_store_contact_items (EBookBackendE
 			/* store display_name, fileas, item id */	
 		}
 
-		e_book_backend_sqlitedb_add_contact (priv->ebsdb, priv->folder_id, contact, FALSE, error);
+		e_book_backend_sqlitedb_add_contact (priv->summary, priv->folder_id, contact, TRUE, error);
 		e_book_backend_notify_update (E_BOOK_BACKEND (ebews), contact);
-		
+
 		g_object_unref (item);
 		g_object_unref (contact);
 	}
 
-
 	g_slist_free (new_items);
 }
 
 static void
-ews_mb_free (EwsMailbox *mb)
+ebews_get_vcards_list (GSList *new_items,
+                       GSList **vcards)
 {
-	if (mb) {
-		g_free (mb->name);
-		g_free (mb->email);
-	
-		if (mb->item_id) {
-			g_free (mb->item_id->id);
-			g_free (mb->item_id->change_key);
-			g_free (mb->item_id);
+	GSList *l;
+
+	for (l = new_items; l != NULL; l = g_slist_next (l)) {
+		EContact *contact;
+		gint i, element_type;
+		EEwsItem *item;
+		gchar *vcard_string = NULL;
+
+		item = (EEwsItem *) l->data;
+		if (e_ews_item_get_item_type (item) == E_EWS_ITEM_TYPE_ERROR) {
+			g_object_unref (item);
+			continue;
 		}
 
-		g_free (mb);
+		contact = e_contact_new ();
+
+		for (i = 0; i < G_N_ELEMENTS (mappings); i++) {
+			element_type = mappings[i].element_type;
+			if (element_type == ELEMENT_TYPE_SIMPLE && !mappings[i].populate_contact_func) {
+				const gchar *val = mappings[i].get_simple_prop_func (item);
+				if (val != NULL)
+					e_contact_set (contact, mappings[i].field_id, val);
+			} else
+				mappings[i].populate_contact_func (contact, item);
+		}
+		vcard_string = e_vcard_to_string (E_VCARD (contact), EVC_FORMAT_VCARD_30);
+		*vcards = g_slist_append (*vcards, g_strdup(vcard_string));
+		g_free (vcard_string);
+		g_object_unref (item);
+		g_object_unref (contact);
 	}
+	g_slist_free (new_items);
 }
 
 static void
-ebews_store_distribution_list_items (EBookBackendEws *ebews, const EwsId *id, const gchar *d_name, GSList *members, GError **error)
+ebews_store_distribution_list_items (EBookBackendEws *ebews,
+                                     const EwsId *id,
+                                     const gchar *d_name,
+                                     GSList *members,
+                                     GError **error)
 {
 	GSList *l;
 	EContact *contact;
 
+	g_return_if_fail (ebews->priv->summary != NULL);
+
 	contact = e_contact_new ();
 	e_contact_set (contact, E_CONTACT_UID, id->id);
 	e_contact_set (contact, E_CONTACT_REV, id->change_key);
-	
+
 	e_contact_set (contact, E_CONTACT_IS_LIST, GINT_TO_POINTER (TRUE));
 	e_contact_set (contact, E_CONTACT_LIST_SHOW_ADDRESSES, GINT_TO_POINTER (TRUE));
 	e_contact_set (contact, E_CONTACT_FULL_NAME, d_name);
@@ -1730,7 +2148,7 @@ ebews_store_distribution_list_items (EBo
 			gint len = strlen (mb->name);
 			gchar *value;
 
-			if (mb->name [0] == '\"' && mb->name [len - 1] == '\"')
+			if (mb->name[0] == '\"' && mb->name[len - 1] == '\"')
 				value = g_strdup_printf ("%s <%s>", mb->name, mb->email);
 			else
 				value = g_strdup_printf ("\"%s\" <%s>", mb->name, mb->email);
@@ -1741,18 +2159,70 @@ ebews_store_distribution_list_items (EBo
 			e_vcard_attribute_add_value (attr, mb->email);
 
 		e_vcard_add_attribute (E_VCARD (contact), attr);
-		ews_mb_free (mb);
+		e_ews_mailbox_free (mb);
 	}
-	
+
 	g_slist_free (members);
-	e_book_backend_sqlitedb_add_contact (ebews->priv->ebsdb, ebews->priv->folder_id, contact, FALSE, error);
+	e_book_backend_sqlitedb_add_contact (ebews->priv->summary, ebews->priv->folder_id, contact, TRUE, error);
 	e_book_backend_notify_update (E_BOOK_BACKEND (ebews), contact);
 
 	g_object_unref (contact);
 }
 
 static void
-ebews_sync_items (EBookBackendEws *ebews, GSList *items, GError **error)
+ebews_vcards_append_dl (const EwsId *id,
+                        const gchar *d_name,
+                        GSList *members,
+                        GSList **vcards)
+{
+	GSList *l;
+	EContact *contact;
+	gchar *vcard_string = NULL;
+
+	contact = e_contact_new ();
+	e_contact_set (contact, E_CONTACT_UID, id->id);
+	e_contact_set (contact, E_CONTACT_REV, id->change_key);
+
+	e_contact_set (contact, E_CONTACT_IS_LIST, GINT_TO_POINTER (TRUE));
+	e_contact_set (contact, E_CONTACT_LIST_SHOW_ADDRESSES, GINT_TO_POINTER (TRUE));
+	e_contact_set (contact, E_CONTACT_FULL_NAME, d_name);
+
+	for (l = members; l != NULL; l = g_slist_next (l)) {
+		EwsMailbox *mb = (EwsMailbox *)	l->data;
+		EVCardAttribute *attr;
+
+		attr = e_vcard_attribute_new (NULL, EVC_EMAIL);
+		if (mb->name) {
+			gint len = strlen (mb->name);
+			gchar *value;
+
+			if (mb->name[0] == '\"' && mb->name[len - 1] == '\"')
+				value = g_strdup_printf ("%s <%s>", mb->name, mb->email);
+			else
+				value = g_strdup_printf ("\"%s\" <%s>", mb->name, mb->email);
+
+			e_vcard_attribute_add_value (attr, value);
+			g_free (value);
+		} else
+			e_vcard_attribute_add_value (attr, mb->email);
+
+		e_vcard_add_attribute (E_VCARD (contact), attr);
+		e_ews_mailbox_free (mb);
+	}
+	vcard_string = e_vcard_to_string (E_VCARD (contact), EVC_FORMAT_VCARD_30);
+	*vcards = g_slist_append (*vcards, g_strdup(vcard_string));
+	g_free (vcard_string);
+	g_slist_free (members);
+	g_object_unref (contact);
+}
+
+static gboolean
+ebews_fetch_items (EBookBackendEws *ebews,
+                   GSList *items,
+                   gboolean store_to_cache,
+                   GSList **vcards,
+                   GCancellable *cancellable,
+                   GError **error)
 {
 	EBookBackendEwsPrivate *priv;
 	EEwsConnection *cnc;
@@ -1760,6 +2230,10 @@ ebews_sync_items (EBookBackendEws *ebews
 	GSList *contact_item_ids = NULL, *dl_ids = NULL;
 	GSList *new_items = NULL;
 
+	if (!book_backend_ews_ensure_connected (ebews, cancellable, error)) {
+		return FALSE;
+	}
+
 	priv = ebews->priv;
 	cnc = priv->cnc;
 
@@ -1781,25 +2255,29 @@ ebews_sync_items (EBookBackendEws *ebews
 
 	/* TODO fetch attachments */
 	if (contact_item_ids)
-		e_ews_connection_get_items
-			(cnc, EWS_PRIORITY_MEDIUM,
-			 contact_item_ids, "Default", CONTACT_ITEM_PROPS,
-			 FALSE, NULL, &new_items, NULL, NULL,
-			 NULL, error);
+		e_ews_connection_get_items_sync (
+			cnc, EWS_PRIORITY_MEDIUM,
+			contact_item_ids, "Default", CONTACT_ITEM_PROPS,
+			FALSE, NULL, E_EWS_BODY_TYPE_TEXT, &new_items, NULL, NULL,
+			cancellable, error);
 	if (*error)
 		goto cleanup;
 
-	if (new_items)
-		ebews_store_contact_items (ebews, new_items, FALSE, error);
+	if (new_items) {
+		if (store_to_cache)
+			ebews_store_contact_items (ebews, new_items, FALSE, error);
+		else
+			ebews_get_vcards_list (new_items, vcards);
+	}
 	new_items = NULL;
 
 	/* Get the display names of the distribution lists */
 	if (dl_ids)
-		e_ews_connection_get_items
-			(cnc, EWS_PRIORITY_MEDIUM,
-			 dl_ids, "Default", NULL,
-			 FALSE, NULL, &new_items, NULL, NULL,
-			 NULL, error);
+		e_ews_connection_get_items_sync (
+			cnc, EWS_PRIORITY_MEDIUM,
+			dl_ids, "Default", NULL,
+			FALSE, NULL, E_EWS_BODY_TYPE_TEXT, &new_items, NULL, NULL,
+			cancellable, error);
 	if (*error)
 		goto cleanup;
 
@@ -1807,10 +2285,13 @@ ebews_sync_items (EBookBackendEws *ebews
 		EEwsItem *item = (EEwsItem *) l->data;
 		const gchar *d_name;
 		const EwsId *id;
-		EwsMailbox *mb = g_new0 (EwsMailbox, 1);
+		EwsMailbox *mb;
 		GSList *members = NULL;
 		gboolean includes_last;
 
+		if (e_ews_item_get_item_type (item) == E_EWS_ITEM_TYPE_ERROR)
+			continue;
+
 		id = e_ews_item_get_id (item);
 		mb = g_new0 (EwsMailbox, 1);
 		mb->item_id = (EwsId *) id;
@@ -1818,13 +2299,19 @@ ebews_sync_items (EBookBackendEws *ebews
 		/* expand dl */
 		if (*error)
 			goto cleanup;
-		
+
 		d_name = e_ews_item_get_subject (item);
-		e_ews_connection_expand_dl (cnc, EWS_PRIORITY_MEDIUM, mb, &members, &includes_last, NULL, error);
+		e_ews_connection_expand_dl_sync (
+			cnc, EWS_PRIORITY_MEDIUM, mb, &members,
+			&includes_last, priv->cancellable, error);
 		if (*error)
 			goto cleanup;
-		
-		ebews_store_distribution_list_items (ebews, id, d_name, members, error);
+
+		if (store_to_cache)
+			ebews_store_distribution_list_items (ebews, id, d_name, members, error);
+		else
+			ebews_vcards_append_dl (id, d_name, members, vcards);
+
 		g_free (mb);
 
 		if (*error)
@@ -1841,43 +2328,94 @@ cleanup:
 		g_slist_foreach (dl_ids, (GFunc) g_free, NULL);
 		g_slist_free (dl_ids);
 	}
-	
+
 	if (contact_item_ids) {
 		g_slist_foreach (contact_item_ids, (GFunc) g_free, NULL);
 		g_slist_free (contact_item_ids);
 	}
+
+	return TRUE;
+}
+
+static void
+ebews_forget_all_contacts (EBookBackendEws *ebews)
+{
+	EBookBackend *backend;
+	GSList *ids = NULL;
+
+	g_return_if_fail (E_IS_BOOK_BACKEND_EWS (ebews));
+
+	backend = E_BOOK_BACKEND (ebews);
+	g_return_if_fail (backend != NULL);
+
+	ids = e_book_backend_sqlitedb_search_uids (ebews->priv->summary, ebews->priv->folder_id, NULL, NULL, NULL);
+	if (ids) {
+		GSList *id;
+
+		e_book_backend_sqlitedb_remove_contacts (ebews->priv->summary, ebews->priv->folder_id, ids, NULL);
+		for (id = ids; id; id = id->next) {
+			e_book_backend_notify_remove (backend, id->data);
+		}
+
+		g_slist_free_full (ids, g_free);
+	}
 }
 
 static gboolean
-ebews_start_sync	(gpointer data)
+ebews_start_sync (gpointer data)
 {
 	EBookBackendEws *ebews;
 	EBookBackendEwsPrivate *priv;
+	GList *list, *link;
 	gchar *sync_state, *status_message = NULL;
 	gboolean includes_last_item;
 	GError *error = NULL;
-	EDataBookView *book_view;
 
 	ebews = (EBookBackendEws *) data;
 	priv = ebews->priv;
 
+	g_return_val_if_fail (priv->summary != NULL, FALSE);
+
+	/* Not connected? Try again later */
+	if (!priv->cnc)
+		return TRUE;
+
 	status_message = g_strdup (_("Syncing contacts..."));
-	book_view = e_book_backend_ews_utils_get_book_view (E_BOOK_BACKEND (ebews));
-	if (book_view)
-		e_data_book_view_notify_progress (book_view, -1, status_message);
+	list = e_book_backend_list_views (E_BOOK_BACKEND (ebews));
+	for (link = list; link != NULL; link = g_list_next (link))
+		e_data_book_view_notify_progress (E_DATA_BOOK_VIEW (link->data), -1, status_message);
+	g_list_free_full (list, (GDestroyNotify) g_object_unref);
+	g_free (status_message);
 
-	sync_state = e_book_backend_sqlitedb_get_sync_data (priv->ebsdb, priv->folder_id, NULL);
+	sync_state = e_book_backend_sqlitedb_get_sync_data (priv->summary, priv->folder_id, NULL);
 	do
 	{
 		GSList *items_created = NULL, *items_updated = NULL;
 		GSList *items_deleted = NULL;
+		gchar *old_sync_state = sync_state;
+
+		sync_state = NULL;
+
+		e_ews_connection_sync_folder_items_sync (
+			priv->cnc, EWS_PRIORITY_MEDIUM,
+			old_sync_state, priv->folder_id,
+			"IdOnly", NULL, EWS_MAX_FETCH_COUNT,
+			&sync_state,
+			&includes_last_item,
+			&items_created, &items_updated,
+			&items_deleted, priv->cancellable, &error);
 
-		e_ews_connection_sync_folder_items	(priv->cnc, EWS_PRIORITY_MEDIUM,
-							 &sync_state, priv->folder_id,
-							 "IdOnly", NULL,
-							 EWS_MAX_FETCH_COUNT, &includes_last_item,
-							 &items_created, &items_updated,
-							 &items_deleted, NULL, &error);
+		g_free (old_sync_state);
+
+		if (g_error_matches (error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_INVALIDSYNCSTATEDATA)) {
+			g_clear_error (&error);
+			e_book_backend_sqlitedb_set_sync_data (priv->summary, priv->folder_id, NULL, &error);
+			ebews_forget_all_contacts (ebews);
+
+			e_ews_connection_sync_folder_items_sync (priv->cnc, EWS_PRIORITY_MEDIUM, NULL, priv->folder_id, "IdOnly", NULL, EWS_MAX_FETCH_COUNT,
+				&sync_state, &includes_last_item, &items_created, &items_updated, &items_deleted,
+				priv->cancellable, &error);
+		}
 
 		if (error)
 			break;
@@ -1886,7 +2424,7 @@ ebews_start_sync	(gpointer data)
 			ebews_sync_deleted_items (ebews, items_deleted, &error);
 
 		if (items_created)
-			ebews_sync_items (ebews, items_created, &error);
+			ebews_fetch_items (ebews, items_created, TRUE, NULL, priv->cancellable, &error);
 
 		if (error) {
 			if (items_updated) {
@@ -1898,24 +2436,24 @@ ebews_start_sync	(gpointer data)
 		}
 
 		if (items_updated)
-			ebews_sync_items (ebews, items_updated, &error);
+			ebews_fetch_items (ebews, items_updated, TRUE, NULL, priv->cancellable, &error);
 
 		if (error)
 			break;
 
-		e_book_backend_sqlitedb_set_sync_data (priv->ebsdb, priv->folder_id, sync_state, &error);
+		e_book_backend_sqlitedb_set_sync_data (priv->summary, priv->folder_id, sync_state, &error);
 	} while (!error && !includes_last_item);
 
-	if (book_view) {
-		e_data_book_view_notify_complete (book_view, error);
-		e_data_book_view_unref (book_view);
-	}
-
 	if (!error)
-		e_book_backend_sqlitedb_set_is_populated (priv->ebsdb, priv->folder_id, TRUE, &error);
+		e_book_backend_sqlitedb_set_is_populated (priv->summary, priv->folder_id, TRUE, &error);
 
 	g_free (sync_state);
-	g_free (status_message);
+
+	/* hide progress message when done */
+	list = e_book_backend_list_views (E_BOOK_BACKEND (ebews));
+	for (link = list; link != NULL; link = g_list_next (link))
+		e_data_book_view_notify_progress (E_DATA_BOOK_VIEW (link->data), -1, NULL);
+	g_list_free_full (list, (GDestroyNotify) g_object_unref);
 
 	if (error) {
 		g_warning ("Error Syncing Contacts: Folder %s Error: %s", priv->folder_id, error->message);
@@ -1938,7 +2476,7 @@ delta_thread (gpointer data)
 
 	while (TRUE)	{
 		gboolean succeeded;
-	       
+
 		if (!priv->is_gal)
 			succeeded = ebews_start_sync (ebews);
 		else
@@ -1999,15 +2537,18 @@ ebews_start_refreshing (EBookBackendEws 
 
 	PRIV_LOCK (priv);
 
-	if	(priv->mode == MODE_REMOTE &&
-		 priv->cnc && priv->marked_for_offline)
-				fetch_deltas (ebews);
+	if (e_book_backend_ews_get_online (E_BOOK_BACKEND_EWS (ebews)) &&
+	    priv->cnc != NULL /*&& priv->marked_for_offline*/)
+		fetch_deltas (ebews);
 
 	PRIV_UNLOCK (priv);
 }
 
 static void
-fetch_from_offline (EBookBackendEws *ews, EDataBookView *book_view, const gchar *query, GError *error)
+fetch_from_offline (EBookBackendEws *ews,
+                    EDataBookView *book_view,
+                    const gchar *query,
+                    GError *error)
 {
 	GSList *contacts, *l;
 	EBookBackendEwsPrivate *priv;
@@ -2016,11 +2557,13 @@ fetch_from_offline (EBookBackendEws *ews
 
 	if (priv->is_gal && !g_strcmp0 (query, "(contains \"x-evolution-any-field\" \"\")")) {
 		e_data_book_view_notify_complete (book_view, error);
-		e_data_book_view_unref (book_view);
+		g_object_unref (book_view);
 		return;
 	}
 
-	contacts = e_book_backend_sqlitedb_search (priv->ebsdb, priv->folder_id, query, NULL, NULL, NULL, &error);
+	g_return_if_fail (priv->summary != NULL);
+
+	contacts = e_book_backend_sqlitedb_search (priv->summary, priv->folder_id, query, NULL, NULL, NULL, &error);
 	for (l = contacts; l != NULL; l = g_slist_next (l)) {
 		EbSdbSearchData *s_data = (EbSdbSearchData *) l->data;
 
@@ -2034,12 +2577,12 @@ fetch_from_offline (EBookBackendEws *ews
 	if (contacts)
 		g_slist_free (contacts);
 	e_data_book_view_notify_complete (book_view, error);
-	e_data_book_view_unref (book_view);
+	g_object_unref (book_view);
 }
 
 static void
-e_book_backend_ews_start_book_view (EBookBackend  *backend,
-				     EDataBookView *book_view)
+e_book_backend_ews_start_view (EBookBackend *backend,
+                               EDataBookView *book_view)
 {
 	EBookBackendEws *ebews;
 	EBookBackendEwsPrivate *priv;
@@ -2047,114 +2590,140 @@ e_book_backend_ews_start_book_view (EBoo
 	gboolean is_autocompletion = FALSE;
 	gchar *auto_comp_str = NULL;
 	GCancellable *cancellable;
-	GSList *ids = NULL, *mailboxes = NULL, *l;
+	GSList *ids = NULL, *mailboxes = NULL, *l, *contacts = NULL, *c;
 	EwsFolderId *fid;
+	ESource *source;
 	GError *error = NULL;
 	gboolean includes_last_item;
-	ESource *source;
 
 	ebews = E_BOOK_BACKEND_EWS (backend);
 	priv = ebews->priv;
+
 	query = e_data_book_view_get_card_query (book_view);
 
-	e_data_book_view_ref (book_view);
+	source = e_book_backend_get_source (backend);
+
+	g_object_ref (book_view);
 	e_data_book_view_notify_progress (book_view, -1, _("Searching..."));
 
-	switch (priv->mode) {
-	case MODE_LOCAL:
-		if (e_book_backend_sqlitedb_get_is_populated (priv->ebsdb, priv->folder_id, NULL)) {
+	if (!e_book_backend_ews_get_online (E_BOOK_BACKEND_EWS (backend))) {
+		if (priv->summary && e_book_backend_sqlitedb_get_is_populated (priv->summary, priv->folder_id, NULL)) {
 			fetch_from_offline (ebews, book_view, query, error);
 			return;
 		}
 
 		error = EDB_ERROR (OFFLINE_UNAVAILABLE);
 		e_data_book_view_notify_complete (book_view, error);
+		g_object_unref (book_view);
 		g_error_free (error);
 		return;
-	case MODE_REMOTE:
-		if (!priv->cnc) {
-			error = EDB_ERROR (AUTHENTICATION_REQUIRED);
-			ews_auth_required (backend);
-			e_data_book_view_notify_complete (book_view, error);
-			e_data_book_view_unref (book_view);
-			g_error_free (error);
-			return;
-		}
-
-		ebews_start_refreshing (ebews);
+	}
 
-		if (priv->ebsdb &&
-		    e_book_backend_sqlitedb_get_is_populated (priv->ebsdb, priv->folder_id, NULL)) {
-			fetch_from_offline (ebews, book_view, query, error);
-			return;
-		}
+	if (priv->cnc == NULL) {
+		error = EDB_ERROR (AUTHENTICATION_REQUIRED);
+		ews_auth_required (backend);
+		e_data_book_view_notify_complete (book_view, error);
+		e_data_book_view_unref (book_view);
+		g_error_free (error);
+		return;
+	}
 
-		e_book_backend_ews_build_restriction (query, &is_autocompletion, &auto_comp_str);
-		if (!is_autocompletion || !auto_comp_str) {
-			g_free (auto_comp_str);
-			e_data_book_view_notify_complete (book_view, error);
-			e_data_book_view_unref (book_view);
-			return;
-		}
+	g_return_if_fail (priv->cnc != NULL);
 
-		source = e_book_backend_get_source (backend);
-		cancellable = g_cancellable_new ();
+	ebews_start_refreshing (ebews);
 
-		/* FIXME Need to convert the Ids from EwsLegacyId format to EwsId format using
-		   convert_id operation before using it as the schema has changed between Exchange
-		   2007 and 2007_SP1 */
-		fid = g_new0 (EwsFolderId, 1);
-		fid->id = g_strdup (priv->folder_id);
-		fid->change_key = e_source_get_duped_property (source, "change-key");
-		ids = g_slist_append (ids, fid);
+	if (priv->summary &&
+	    e_book_backend_sqlitedb_get_is_populated (priv->summary, priv->folder_id, NULL)) {
+		fetch_from_offline (ebews, book_view, query, error);
+		return;
+	}
 
-		/* We do not scan until we reach the last_item as it might be good enough to show first 100
-		   items during auto-completion. Change it if needed. TODO, Personal Address-book should start using
-		   find_items rather than resolve_names to support all queries */
-		g_hash_table_insert (priv->ops, book_view, cancellable);
-		e_ews_connection_resolve_names	(priv->cnc, EWS_PRIORITY_MEDIUM, auto_comp_str,
-						 EWS_SEARCH_AD, NULL, FALSE, &mailboxes, NULL,
-						 &includes_last_item, cancellable, &error);
+	e_book_backend_ews_build_restriction (query, &is_autocompletion, &auto_comp_str);
+	if (!is_autocompletion || !auto_comp_str) {
 		g_free (auto_comp_str);
-		g_hash_table_remove (priv->ops, book_view);
-		e_ews_folder_free_fid (fid);
-		if (error != NULL) {
-			e_data_book_view_notify_complete (book_view, error);
-			e_data_book_view_unref (book_view);
-			g_clear_error (&error);
-			return;
-		}
+		e_data_book_view_notify_complete (book_view, error);
+		g_object_unref (book_view);
+		return;
+	}
+
+	cancellable = g_cancellable_new ();
+
+	/* FIXME Need to convert the Ids from EwsLegacyId format to EwsId format using
+	 * convert_id operation before using it as the schema has changed between Exchange
+	 * 2007 and 2007_SP1 */
+	fid = g_new0 (EwsFolderId, 1);
+	fid->id = g_strdup (priv->folder_id);
+	fid->change_key = e_source_get_duped_property (source, "change-key");
+	ids = g_slist_append (ids, fid);
+
+	/* We do not scan until we reach the last_item as it might be good enough to show first 100
+	 * items during auto-completion. Change it if needed. TODO, Personal Address-book should start using
+	 * find_items rather than resolve_names to support all queries */
+	g_hash_table_insert (priv->ops, book_view, cancellable);
+	e_ews_connection_resolve_names_sync (
+		priv->cnc, EWS_PRIORITY_MEDIUM, auto_comp_str,
+		EWS_SEARCH_AD, NULL, TRUE, &mailboxes, &contacts,
+		&includes_last_item, cancellable, &error);
+	g_free (auto_comp_str);
+	g_hash_table_remove (priv->ops, book_view);
+	e_ews_folder_id_free (fid);
+	if (error != NULL) {
+		e_data_book_view_notify_complete (book_view, error);
+		g_object_unref (book_view);
+		g_clear_error (&error);
+		return;
+	}
+
+	for (l = mailboxes, c = contacts; l != NULL; l = g_slist_next (l), c = c ? g_slist_next (c) : NULL) {
+		EwsMailbox *mb = l->data;
+		EwsResolveContact *rc = c ? c->data : NULL;
+		EContact *contact;
 
-		for (l = mailboxes; l != NULL; l = g_slist_next (l)) {
-			EwsMailbox *mb = l->data;
-			EContact *contact;
+		contact = e_contact_new ();
 
-			contact = e_contact_new ();
+		/* We do not get an id from the server, so just using email_id as uid for now */
+		e_contact_set (contact, E_CONTACT_UID, mb->email);
 
-			/* We do not get an id from the server, so just using email_id as uid for now */
-			e_contact_set (contact, E_CONTACT_UID, mb->email);
+		if (rc && rc->display_name && *rc->display_name)
+			e_contact_set (contact, E_CONTACT_FULL_NAME, rc->display_name);
+		else
 			e_contact_set (contact, E_CONTACT_FULL_NAME, mb->name);
-			e_contact_set (contact, E_CONTACT_EMAIL_1, mb->email);
 
-			e_data_book_view_notify_update (book_view, contact);
+		if (rc && g_hash_table_size (rc->email_addresses) > 0) {
+			GList *emails = g_hash_table_get_values (rc->email_addresses), *iter;
+			GList *use_emails = NULL;
+
+			for (iter = emails; iter; iter = iter->next) {
+				if (iter->data && g_str_has_prefix (iter->data, "SMTP:"))
+					use_emails = g_list_prepend (use_emails, ((gchar *) iter->data) + 5);
+			}
 
-			g_free (mb->email);
-			g_free (mb->name);
-			g_free (mb);
-			g_object_unref (contact);
-		}
+			if (!use_emails)
+				use_emails = g_list_prepend (use_emails, mb->email);
 
-		g_slist_free (mailboxes);
-		e_data_book_view_notify_complete (book_view, error);
-		e_data_book_view_unref (book_view);
-	default:
-		break;
+			e_contact_set (contact, E_CONTACT_EMAIL, use_emails);
+
+			g_list_free (use_emails);
+			g_list_free (emails);
+		} else
+			e_contact_set (contact, E_CONTACT_EMAIL_1, mb->email);
+
+		e_data_book_view_notify_update (book_view, contact);
+
+		e_ews_mailbox_free (mb);
+		e_ews_free_resolve_contact (rc);
+		g_object_unref (contact);
 	}
+
+	g_slist_free (mailboxes);
+	g_slist_free (contacts);
+	e_data_book_view_notify_complete (book_view, error);
+	g_object_unref (book_view);
 }
 
 static void
-e_book_backend_ews_stop_book_view (EBookBackend  *backend,
-					 EDataBookView *book_view)
+e_book_backend_ews_stop_view (EBookBackend *backend,
+                              EDataBookView *book_view)
 {
 	EBookBackendEws *bews = E_BOOK_BACKEND_EWS (backend);
 	EBookBackendEwsPrivate *priv = bews->priv;
@@ -2168,10 +2737,10 @@ e_book_backend_ews_stop_book_view (EBook
 }
 
 static void
-e_book_backend_ews_load_source 	(EBookBackend           *backend,
-				 ESource                *source,
-				 gboolean                only_if_exists,
-				 GError                **perror)
+e_book_backend_ews_load_source (EBookBackend *backend,
+                                ESource *source,
+                                gboolean only_if_exists,
+                                GError **perror)
 {
 	EBookBackendEws *cbews;
 	EBookBackendEwsPrivate *priv;
@@ -2186,15 +2755,14 @@ e_book_backend_ews_load_source 	(EBookBa
 	cache_dir = e_book_backend_get_cache_dir (backend);
 	email = e_source_get_property (source, "email");
 	is_gal = e_source_get_property (source, "gal");
-	
-	if (is_gal && !strcmp (is_gal, "1"))
-		priv->is_gal = TRUE;
+
+	priv->is_gal = is_gal && !strcmp (is_gal, "1");
 
 	if (!priv->is_gal) {
 		priv->folder_id = e_source_get_duped_property (source, "folder-id");
 		folder_name = e_source_peek_name (source);
 
-		priv->ebsdb = e_book_backend_sqlitedb_new (cache_dir, email, priv->folder_id, folder_name, TRUE, &err);
+		priv->summary = e_book_backend_sqlitedb_new (cache_dir, email, priv->folder_id, folder_name, TRUE, &err);
 		if (err) {
 			g_propagate_error (perror, err);
 			return;
@@ -2215,7 +2783,7 @@ e_book_backend_ews_load_source 	(EBookBa
 			priv->attachment_dir = g_build_filename (cache_dir, "attachments", NULL);
 			g_mkdir_with_parents (priv->attachment_dir, 0777);
 
-			priv->ebsdb = e_book_backend_sqlitedb_new (cache_dir, email, priv->folder_id, priv->folder_name, TRUE, &err);
+			priv->summary = e_book_backend_sqlitedb_new (cache_dir, email, priv->folder_id, priv->folder_name, TRUE, &err);
 			if (err) {
 				g_propagate_error (perror, err);
 				return;
@@ -2224,17 +2792,17 @@ e_book_backend_ews_load_source 	(EBookBa
 			priv->is_writable = FALSE;
 		}
 	}
-	
+
 	e_book_backend_notify_opened (backend, NULL);
 	if (priv->mode == MODE_REMOTE)
 		e_book_backend_set_online (backend, TRUE);
 }
 
 static void
-e_book_backend_ews_remove	(EBookBackend *backend,
-				 EDataBook        *book,
-				 guint32           opid,
-				 GCancellable *cancellable)
+e_book_backend_ews_remove (EBookBackend *backend,
+			   EDataBook *book,
+			   guint32 opid,
+			   GCancellable *cancellable)
 {
 	e_data_book_respond_remove (book,  opid, EDB_ERROR (SUCCESS));
 }
@@ -2255,6 +2823,7 @@ e_book_backend_ews_authenticate_user (EB
 	GError *error = NULL;
 	const gchar *host_url;
 	const gchar *read_only;
+	const gchar *timeout_str;
 
 	ebgw = E_BOOK_BACKEND_EWS (backend);
 	priv = ebgw->priv;
@@ -2273,9 +2842,14 @@ e_book_backend_ews_authenticate_user (EB
 		esource = e_book_backend_get_source (backend);
 		host_url = e_source_get_property (esource, "hosturl");
 		read_only = e_source_get_property (esource, "read_only");
+		timeout_str = e_source_get_property (esource, "timeout");
 
 		priv->cnc = e_ews_connection_new (host_url, user, passwd,
-						  NULL, NULL, &error);
+			e_source_get_property (esource, "email"),
+			e_source_get_property (esource, "impersonate_user"),
+			timeout_str ? atoi (timeout_str) : -1,
+			TRUE,
+			NULL, NULL, &error);
 
 		if ((read_only && !strcmp (read_only, "true")) || priv->is_gal) {
 			priv->is_writable = FALSE;
@@ -2327,19 +2901,19 @@ e_book_backend_ews_get_required_fields (
 
 static void
 e_book_backend_ews_get_supported_fields (EBookBackend *backend,
-					       EDataBook    *book,
-					       guint32       opid)
+					 EDataBook *book,
+					 guint32 opid)
 {
 	GList *fields = NULL;
 	gint i;
-	
+
 	for (i = 0; i < G_N_ELEMENTS (mappings); i++)
-		if (mappings [i].element_type == ELEMENT_TYPE_SIMPLE)
+		if (mappings[i].element_type == ELEMENT_TYPE_SIMPLE)
 			fields = g_list_append (fields, g_strdup (e_contact_field_name (mappings[i].field_id)));
-	
+
 	for (i = 0; i < G_N_ELEMENTS (phone_field_map); i++)
 		fields = g_list_append (fields, g_strdup (e_contact_field_name (phone_field_map[i].field)));
-	
+
 	fields = g_list_append (fields, g_strdup (e_contact_field_name (E_CONTACT_FULL_NAME)));
 	fields = g_list_append (fields, g_strdup (e_contact_field_name (E_CONTACT_NICKNAME)));
 	fields = g_list_append (fields, g_strdup (e_contact_field_name (E_CONTACT_FAMILY_NAME)));
@@ -2350,16 +2924,25 @@ e_book_backend_ews_get_supported_fields 
 	fields = g_list_append (fields, g_strdup (e_contact_field_name (E_CONTACT_ADDRESS_HOME)));
 	fields = g_list_append (fields, g_strdup (e_contact_field_name (E_CONTACT_ADDRESS_OTHER)));
 	fields = g_list_append (fields, g_strdup (e_contact_field_name (E_CONTACT_BIRTH_DATE)));
-	e_data_book_respond_get_supported_fields (book, opid,
-						  EDB_ERROR (SUCCESS),
-						  fields);
+
+	fields = g_list_append (fields, g_strdup (e_contact_field_name (E_CONTACT_NOTE)));
+
+	e_data_book_respond_get_supported_fields (book, opid, EDB_ERROR (SUCCESS), fields);
+
 	g_list_free (fields);
 }
 
-
 static gchar *
 e_book_backend_ews_get_static_capabilities (EBookBackend *backend)
 {
+	EBookBackendEws *ebews;
+
+	ebews = E_BOOK_BACKEND_EWS (backend);
+	g_return_val_if_fail (ebews != NULL, NULL);
+
+	if (ebews->priv->is_gal)
+		return g_strdup ("net,bulk-removes,contact-lists");
+
 	/* do-initial-query is enabled for system address book also, so that we get the
 	 * book_view, which is needed for displaying cache update progress.
 	 * and null query is handled for system address book.
@@ -2649,11 +3232,17 @@ e_book_backend_ews_new (void)
 static void
 e_book_backend_ews_dispose (GObject *object)
 {
-	EBookBackendEws *bgw;
-        EBookBackendEwsPrivate *priv;
+	EBookBackendEws *bews;
+	EBookBackendEwsPrivate *priv;
 
-	bgw = E_BOOK_BACKEND_EWS (object);
-        priv = bgw->priv;
+	bews = E_BOOK_BACKEND_EWS (object);
+	priv = bews->priv;
+
+	if (priv->cancellable) {
+		g_cancellable_cancel (priv->cancellable);
+		g_object_unref (priv->cancellable);
+		priv->cancellable = NULL;
+	}
 
 	if (priv->cnc) {
 		g_object_unref (priv->cnc);
@@ -2669,21 +3258,11 @@ e_book_backend_ews_dispose (GObject *obj
 		g_free (priv->oab_url);
 		priv->oab_url = NULL;
 	}
-	
+
 	if (priv->folder_name) {
 		g_free (priv->folder_name);
 		priv->folder_name = NULL;
 	}
-	
-	if (priv->username) {
-		g_free (priv->username);
-		priv->username = NULL;
-	}
-	
-	if (priv->password) {
-		g_free (priv->password);
-		priv->password = NULL;
-	}
 
 	if (priv->attachment_dir) {
 		g_free (priv->attachment_dir);
@@ -2706,9 +3285,9 @@ e_book_backend_ews_dispose (GObject *obj
 		priv->dthread = NULL;
 	}
 
-	if (priv->ebsdb) {
-		g_object_unref (priv->ebsdb);
-		priv->ebsdb = NULL;
+	if (priv->summary) {
+		g_object_unref (priv->summary);
+		priv->summary = NULL;
 	}
 
 #if EDS_CHECK_VERSION (3,1,0)
@@ -2763,8 +3342,8 @@ e_book_backend_ews_class_init (EBookBack
 	parent_class->remove                  = e_book_backend_ews_remove;
 #endif	
 	parent_class->authenticate_user       = e_book_backend_ews_authenticate_user;
-	parent_class->start_book_view         = e_book_backend_ews_start_book_view;
-	parent_class->stop_book_view          = e_book_backend_ews_stop_book_view;
+	parent_class->start_book_view         = e_book_backend_ews_start_view;
+	parent_class->stop_book_view          = e_book_backend_ews_stop_view;
 
 	object_class->dispose                 = e_book_backend_ews_dispose;
 }
@@ -2782,4 +3361,5 @@ e_book_backend_ews_init (EBookBackendEws
 
 	bews->priv = priv;
 	g_static_rec_mutex_init (&priv->rec_mutex);
+	priv->cancellable = g_cancellable_new ();
 }
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/addressbook/e-book-backend-ews-utils.c evolution-ews.sync-with-3.8.2/src/addressbook/e-book-backend-ews-utils.c
--- evolution-ews.git-gnome-3-0/src/addressbook/e-book-backend-ews-utils.c	2013-05-17 14:36:16.331669646 +0200
+++ evolution-ews.sync-with-3.8.2/src/addressbook/e-book-backend-ews-utils.c	2013-05-28 08:59:53.042838479 +0200
@@ -81,6 +81,39 @@ e_book_backend_ews_utils_get_book_view (
 	g_object_unref (views);
 	return rv;
 }
+
+GList *
+e_book_backend_list_views (EBookBackend *backend)
+{
+	EList *views = e_book_backend_get_book_views (backend);
+	EIterator *iter;
+	GList *ret_views = NULL;
+
+	if (!views)
+		return NULL;
+
+	iter = e_list_get_iterator (views);
+
+	if (!iter) {
+		g_object_unref (views);
+		return NULL;
+	}
+
+	while (e_iterator_is_valid (iter)) {
+		EDataBookView *v = (EDataBookView*) e_iterator_get (iter);
+		if (v) {
+			e_data_book_view_ref (v);
+			ret_views = g_list_prepend (ret_views, v);
+		}
+
+		e_iterator_next (iter);
+	}
+
+	g_object_unref (iter);
+	g_object_unref (views);
+
+	return g_list_reverse (ret_views);
+}
 #else
 
 static gboolean
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/addressbook/e-book-backend-ews-utils.h evolution-ews.sync-with-3.8.2/src/addressbook/e-book-backend-ews-utils.h
--- evolution-ews.git-gnome-3-0/src/addressbook/e-book-backend-ews-utils.h	2013-05-17 14:36:16.331669646 +0200
+++ evolution-ews.sync-with-3.8.2/src/addressbook/e-book-backend-ews-utils.h	2013-05-28 08:59:53.038838560 +0200
@@ -21,5 +21,10 @@
  */
 
 #include "libedata-book/e-data-book-view.h"
+#include <libedataserver/eds-version.h>
 
 EDataBookView*		e_book_backend_ews_utils_get_book_view (EBookBackend *backend);
+
+#if ! EDS_CHECK_VERSION (3,1,0)	
+GList *			e_book_backend_list_views		(EBookBackend *backend);
+#endif
\ No newline at end of file
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/addressbook/ews-oab-decoder.c evolution-ews.sync-with-3.8.2/src/addressbook/ews-oab-decoder.c
--- evolution-ews.git-gnome-3-0/src/addressbook/ews-oab-decoder.c	2013-05-17 14:36:16.341669906 +0200
+++ evolution-ews.sync-with-3.8.2/src/addressbook/ews-oab-decoder.c	2013-05-28 08:59:53.039838602 +0200
@@ -19,6 +19,10 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include <math.h>
 #include <stdlib.h>
 #include <string.h>
@@ -58,20 +62,25 @@ typedef struct {
 } EwsDeferredSet;
 
 static void
-ews_populate_simple_string (EContact *contact, EContactField field, gpointer value, gpointer user_data)
+ews_populate_simple_string (EContact *contact,
+                            EContactField field,
+                            gpointer value,
+                            gpointer user_data)
 {
 	const gchar *str = (const gchar *) value;
 	e_contact_set (contact, field, str);
 }
 
 static void
-ews_deffered_populate_physical_address (EwsDeferredSet *dset, guint32 prop_id, gpointer value)
+ews_deffered_populate_physical_address (EwsDeferredSet *dset,
+                                        guint32 prop_id,
+                                        gpointer value)
 {
-	gchar *val = g_strdup ((gchar *)value);
+	gchar *val = g_strdup ((gchar *) value);
 
 	if (!dset->addr)
 		dset->addr = g_new0 (EContactAddress, 1);
-	
+
 	switch (prop_id) {
 		case EWS_PT_STREET_ADDRESS:
 			dset->addr->street = val;
@@ -95,13 +104,16 @@ ews_deffered_populate_physical_address (
 }
 
 static void
-ews_populate_phone_numbers (EContact *contact, EContactField field, gpointer value, gpointer user_data)
+ews_populate_phone_numbers (EContact *contact,
+                            EContactField field,
+                            gpointer value,
+                            gpointer user_data)
 {
 	GSList *values = (GSList *) value;
 	gint i, len;
 
 	/* Just the two phone numbers from the list. it would be either business or home phone number. I don't
-	   see a cleaner way than this at the moment */
+	 * see a cleaner way than this at the moment */
 	len = g_slist_length (values);
 	for (i = 0; i < 2 && i < len; i++) {
 		const gchar *val = g_slist_nth_data (values, i);
@@ -110,12 +122,14 @@ ews_populate_phone_numbers (EContact *co
 }
 
 static void
-ews_populate_string_list (EContact *contact, EContactField field, gpointer value, gpointer user_data)
+ews_populate_string_list (EContact *contact,
+                          EContactField field,
+                          gpointer value,
+                          gpointer user_data)
 {
 	GSList *sl_values = (GSList *)	value, *sl;
 	GList *l_values = NULL;
 
-
 	for (sl = sl_values; sl != NULL; sl = g_slist_next (sl)) {
 		const gchar *val = (gchar *) sl_values->data;
 		l_values = g_list_prepend (l_values, g_strdup (val));
@@ -128,7 +142,10 @@ ews_populate_string_list (EContact *cont
 }
 
 static void
-ews_populate_photo (EContact *contact, EContactField field, gpointer value, gpointer user_data)
+ews_populate_photo (EContact *contact,
+                    EContactField field,
+                    gpointer value,
+                    gpointer user_data)
 {
 	EwsOabDecoder *eod = EWS_OAB_DECODER (user_data);
 	EwsOabDecoderPrivate *priv = GET_PRIVATE (eod);
@@ -139,17 +156,17 @@ ews_populate_photo (EContact *contact, E
 	gboolean success = TRUE;
 
 	/* Rename the binary file to name.jpg */
-	at = strchr(email, '@');
+	at = strchr (email, '@');
 	name = g_strndup (email, at - email);
 
 	pic_name = g_strconcat (name, ".jpg", NULL);
 	filename = g_build_filename (priv->cache_dir, pic_name, NULL);
-	
+
 	if (g_file_test (filename, G_FILE_TEST_EXISTS))
 		g_unlink (val);
 	else {
 		if (g_rename (val, filename))
-			success = FALSE;	
+			success = FALSE;
 	}
 
 	if (success) {
@@ -172,7 +189,7 @@ static const struct prop_field_mapping {
 	EContactField field;
 	void (*populate_function) (EContact *contact, EContactField field, gpointer value, gpointer user_data);
 	void (*defered_populate_function) (EwsDeferredSet *dset, guint32 prop_id, gpointer value);
-} prop_map [] = {
+} prop_map[] = {
 	{EWS_PT_SMTP_ADDRESS, E_CONTACT_EMAIL_1, ews_populate_simple_string},
 	{EWS_PT_DISPLAY_NAME, E_CONTACT_FULL_NAME, ews_populate_simple_string},
 	{EWS_PT_ACCOUNT, E_CONTACT_NICKNAME, ews_populate_simple_string},
@@ -224,7 +241,7 @@ ews_oab_decoder_finalize (GObject *objec
 		g_slist_free (priv->oab_props);
 		priv->oab_props = NULL;
 	}
-	
+
 	if (priv->hdr_props) {
 		g_slist_free (priv->hdr_props);
 		priv->hdr_props = NULL;
@@ -253,13 +270,13 @@ ews_oab_decoder_init (EwsOabDecoder *sel
 
 	priv->prop_index_dict = g_hash_table_new (g_direct_hash, g_direct_equal);
 	for (i = 1; i <= G_N_ELEMENTS (prop_map); i++)
-		g_hash_table_insert (priv->prop_index_dict, GINT_TO_POINTER (prop_map[i-1].prop_id), GINT_TO_POINTER (i));
+		g_hash_table_insert (priv->prop_index_dict, GINT_TO_POINTER (prop_map[i - 1].prop_id), GINT_TO_POINTER (i));
 }
 
-EwsOabDecoder*
-ews_oab_decoder_new	(const gchar *oab_filename,
-			 const gchar *cache_dir,
-		   	 GError **error)
+EwsOabDecoder *
+ews_oab_decoder_new (const gchar *oab_filename,
+                     const gchar *cache_dir,
+                     GError **error)
 {
 	EwsOabDecoder *eod;
 	EwsOabDecoderPrivate *priv;
@@ -273,7 +290,7 @@ ews_oab_decoder_new	(const gchar *oab_fi
 	priv->fis = g_file_read (gf, NULL, &err);
 	if (err)
 		goto exit;
-	
+
 	priv->cache_dir = g_strdup (cache_dir);
 
 exit:
@@ -303,20 +320,22 @@ ews_oab_decoder_error_quark (void)
 
 /* endian-neutral reading of little-endian data */
 #define __egi32(a,n) ( ((((guchar *) a)[n+3]) << 24) | \
-		       ((((guchar *) a)[n+2]) << 16) | \
-		       ((((guchar *) a)[n+1]) <<  8) | \
-		       ((((guchar *) a)[n+0])))
+		       ((((guchar *) a)[n + 2]) << 16) | \
+		       ((((guchar *) a)[n + 1]) <<  8) | \
+		       ((((guchar *) a)[n + 0])))
 #define EndGetI64(a) ((((guint64) __egi32(a,4)) << 32) | \
-		      ((guint) __egi32(a,0)))
+		      ((guint) __egi32 (a,0)))
 #define EndGetI32(a) __egi32(a,0)
 #define EndGetI16(a) ((((a)[1])<<8)|((a)[0]))
 
 static guint32
-ews_oab_read_uint32 (GInputStream *is, GCancellable *cancellable, GError **error)
+ews_oab_read_uint32 (GInputStream *is,
+                     GCancellable *cancellable,
+                     GError **error)
 {
 	gchar *str = g_malloc0 (4);
 	guint32 ret = 0;
-	
+
 	g_input_stream_read (is, str, 4, cancellable, error);
 	if (!*error)
 		ret = EndGetI32 (str);
@@ -326,32 +345,38 @@ ews_oab_read_uint32 (GInputStream *is, G
 }
 
 static guint16
-ews_oab_read_uint16 (GInputStream *is, GCancellable *cancellable, GError **error)
+ews_oab_read_uint16 (GInputStream *is,
+                     GCancellable *cancellable,
+                     GError **error)
 {
-	gchar *str = g_malloc0 (2);
+	guchar str[2];
 	guint16 ret = 0;
-	
+
 	g_input_stream_read (is, str, 2, cancellable, error);
 	if (!*error)
 		ret = EndGetI16 (str);
 
-	g_free (str);
 	return ret;
 }
 
 static gint
-get_pos (const gchar *str, gsize len, gchar stop)
+get_pos (const gchar *str,
+         gsize len,
+         gchar stop)
 {
 	gsize i = 0;
 
-	while (i < len && str [i] != stop)
+	while (i < len && str[i] != stop)
 		i++;
 	return i;
 }
 
 /* Read upto the stop char include the same */
 static gchar *
-ews_oab_read_upto (GInputStream *is, gchar stop, GCancellable *cancellable, GError **error)
+ews_oab_read_upto (GInputStream *is,
+                   gchar stop,
+                   GCancellable *cancellable,
+                   GError **error)
 {
 	gsize size = 50;
 	GString *str;
@@ -372,16 +397,16 @@ ews_oab_read_upto (GInputStream *is, gch
 		len = get_pos (c, size, stop);
 		if (len)
 			str = g_string_append_len (str, c, len);
-		
+
 		if (len == 0 || len < size) {
 			goffset seek = (goffset) len + 1 - (goffset) size;
-			
+
 			/* seek back */
 			g_seekable_seek ((GSeekable *) is, seek, G_SEEK_CUR, cancellable, error);
 			break;
 		}
-	 
-	        size *= 2;	
+
+		size *= 2;
 		g_free (c);
 	} while (!*error);
 
@@ -395,7 +420,9 @@ typedef struct {
 } EwsOabHdr;
 
 static EwsOabHdr *
-ews_read_oab_header (EwsOabDecoder *eod, GCancellable *cancellable, GError **error)
+ews_read_oab_header (EwsOabDecoder *eod,
+                     GCancellable *cancellable,
+                     GError **error)
 {
 	EwsOabHdr *o_hdr;
 	EwsOabDecoderPrivate *priv = GET_PRIVATE (eod);
@@ -425,16 +452,21 @@ exit:
 	return o_hdr;
 }
 
-
 static gboolean
-ews_decode_hdr_props (EwsOabDecoder *eod, gboolean oab_hdrs, GCancellable *cancellable, GError **error)
+ews_decode_hdr_props (EwsOabDecoder *eod,
+                      gboolean oab_hdrs,
+                      GCancellable *cancellable,
+                      GError **error)
 {
 	EwsOabDecoderPrivate *priv = GET_PRIVATE (eod);
 	guint32 num_props, i;
 	GSList **props;
-	
+
 	/* number of properties */
-	num_props = ews_oab_read_uint32 (G_INPUT_STREAM (priv->fis), cancellable, error);
+	num_props = ews_oab_read_uint32 (
+		G_INPUT_STREAM (priv->fis),
+		cancellable, error);
+
 	if (*error)
 		return FALSE;
 
@@ -449,36 +481,47 @@ ews_decode_hdr_props (EwsOabDecoder *eod
 	}
 
 	for (i = 0; i < num_props; i++) {
-		guint32 prop_id, flags;
-		
-		prop_id = ews_oab_read_uint32 (G_INPUT_STREAM (priv->fis), cancellable, error);
-		d(g_print ("%X \n", prop_id);)
+		guint32 prop_id;
+
+		prop_id = ews_oab_read_uint32 (
+			G_INPUT_STREAM (priv->fis),
+			cancellable, error);
+
 		*props = g_slist_prepend (*props, GUINT_TO_POINTER (prop_id));
-		
+
 		if (*error)
 			return FALSE;
-		flags = ews_oab_read_uint32 (G_INPUT_STREAM (priv->fis), cancellable, error);
+
+		/* eat the flags */
+		ews_oab_read_uint32 (
+			G_INPUT_STREAM (priv->fis),
+			cancellable, error);
+
 		if (*error)
 			return FALSE;
 
 		/* skip store anr_index and primary key prop list as we will not be using it for online search,
-		   store if required later */
+		 * store if required later */
 	}
-	
+
 	*props = g_slist_reverse (*props);
 
-	return TRUE;	
+	return TRUE;
 }
 
 static gboolean
-ews_decode_metadata (EwsOabDecoder *eod, GCancellable *cancellable, GError **error)
+ews_decode_metadata (EwsOabDecoder *eod,
+                     GCancellable *cancellable,
+                     GError **error)
 {
 	EwsOabDecoderPrivate *priv = GET_PRIVATE (eod);
 	gboolean ret = TRUE;
-	guint32 size;
 
-	/* Size */
-	size = ews_oab_read_uint32 (G_INPUT_STREAM (priv->fis), cancellable, error);
+	/* eat the size */
+	ews_oab_read_uint32 (
+		G_INPUT_STREAM (priv->fis),
+		cancellable, error);
+
 	if (*error)
 		return FALSE;
 
@@ -492,12 +535,13 @@ ews_decode_metadata (EwsOabDecoder *eod,
 }
 
 static gboolean
-ews_is_bit_set (const gchar *str, guint32 pos)
+ews_is_bit_set (const gchar *str,
+                guint32 pos)
 {
 	guint32 index, bit_pos;
 
-	index = pos/8;
-	bit_pos = pos & (8-1);
+	index = pos / 8;
+	bit_pos = pos & (8 - 1);
 
 	if ((str[index] << bit_pos) & 0x80)
 		return TRUE;
@@ -506,16 +550,18 @@ ews_is_bit_set (const gchar *str, guint3
 }
 
 static guint32
-ews_decode_uint32 (EwsOabDecoder *eod, GCancellable *cancellable, GError **error)
+ews_decode_uint32 (EwsOabDecoder *eod,
+                   GCancellable *cancellable,
+                   GError **error)
 {
 	EwsOabDecoderPrivate *priv = GET_PRIVATE (eod);
 	guint8 first;
 	guint32 ret = 0, num;
-	
+
 	g_input_stream_read (G_INPUT_STREAM (priv->fis), &first, 1, cancellable, error);
 	if (*error)
 		return ret;
-	
+
 	if (first & 0x80)
 		num = first & 0x0F;
 	else
@@ -530,24 +576,26 @@ ews_decode_uint32 (EwsOabDecoder *eod, G
 		ret = ews_oab_read_uint16 (G_INPUT_STREAM (priv->fis), cancellable, error);
 	if (num == 3) {
 		gchar *tmp, *str = g_malloc0 (num + 1);
-	
+
 		g_input_stream_read (G_INPUT_STREAM (priv->fis), str, num, cancellable, error);
 		/* not sure if its the right way to do, test it */
 		tmp = g_strconcat ("0", str, NULL);
 
 		sscanf (tmp, "%"G_GUINT32_FORMAT, &ret);
 		ret = GUINT32_SWAP_LE_BE (ret);
-		
+
 		g_free (str);
 		g_free (tmp);
 	} else if (num == 4)
 		ret = ews_oab_read_uint32 (G_INPUT_STREAM (priv->fis), cancellable, error);
 
-	return ret;	
+	return ret;
 }
 
 static gchar *
-ews_decode_binary (EwsOabDecoder *eod, GCancellable *cancellable, GError **error)
+ews_decode_binary (EwsOabDecoder *eod,
+                   GCancellable *cancellable,
+                   GError **error)
 {
 	EwsOabDecoderPrivate *priv = GET_PRIVATE (eod);
 	guint32 len;
@@ -557,7 +605,7 @@ ews_decode_binary (EwsOabDecoder *eod, G
 	len = ews_decode_uint32 (eod, cancellable, error);
 	if (*error)
 		return NULL;
-	
+
 	binary = g_malloc (len);
 	g_input_stream_read (G_INPUT_STREAM (priv->fis), binary, len, cancellable, error);
 	if (*error)
@@ -575,8 +623,11 @@ exit:
 	return filename;
 }
 
-static gpointer 
-ews_decode_oab_prop (EwsOabDecoder *eod, guint32 prop_id, GCancellable *cancellable, GError **error)
+static gpointer
+ews_decode_oab_prop (EwsOabDecoder *eod,
+                     guint32 prop_id,
+                     GCancellable *cancellable,
+                     GError **error)
 {
 	EwsOabDecoderPrivate *priv = GET_PRIVATE (eod);
 	guint32 prop_type;
@@ -588,13 +639,13 @@ ews_decode_oab_prop (EwsOabDecoder *eod,
 		case EWS_PTYP_INTEGER32:
 		{
 			guint32 val;
-			
+
 			val = ews_decode_uint32 (eod, cancellable, error);
 			ret_val = GUINT_TO_POINTER (val);
-			
-			d(g_print ("prop id %X prop type: int32 value %d \n", prop_id, val);)
-		
-			break;		
+
+			d (g_print ("prop id %X prop type: int32 value %d \n", prop_id, val);)
+
+			break;
 		}
 		case EWS_PTYP_BOOLEAN:
 		{
@@ -602,25 +653,25 @@ ews_decode_oab_prop (EwsOabDecoder *eod,
 
 			g_input_stream_read (G_INPUT_STREAM (priv->fis), &val, 1, cancellable, error);
 			ret_val = GUINT_TO_POINTER ((guint) val);
-			d(g_print ("prop id %X prop type: bool value %d \n", prop_id, val);)
-			
+			d (g_print ("prop id %X prop type: bool value %d \n", prop_id, val);)
+
 			break;
 		}
 		case EWS_PTYP_STRING8:
 		case EWS_PTYP_STRING:
 		{
 			gchar *val;
-		       	
+
 			val = ews_oab_read_upto (G_INPUT_STREAM (priv->fis), '\0', cancellable, error);
 			ret_val = (gpointer) val;
-			
-			d(g_print ("prop id %X prop type: string value %s \n", prop_id, val);)
+
+			d (g_print ("prop id %X prop type: string value %s \n", prop_id, val);)
 			break;
 		}
 		case EWS_PTYP_BINARY:
 		{
 			ret_val = ews_decode_binary (eod, cancellable, error);
-			d(g_print ("prop id %X prop type: binary value %s \n", prop_id, (gchar *) ret_val);)
+			d (g_print ("prop id %X prop type: binary value %s \n", prop_id, (gchar *) ret_val);)
 			break;
 		}
 		case EWS_PTYP_MULTIPLEINTEGER32:
@@ -634,7 +685,7 @@ ews_decode_oab_prop (EwsOabDecoder *eod,
 			num = ews_decode_uint32 (eod, cancellable, error);
 			if (*error)
 				break;
-			d(g_print ("prop id %X prop type: multi-num %d \n", prop_id, num);)
+			d (g_print ("prop id %X prop type: multi-num %d \n", prop_id, num);)
 
 			for (i = 0; i < num; i++) {
 				gpointer val;
@@ -645,8 +696,8 @@ ews_decode_oab_prop (EwsOabDecoder *eod,
 					v = ews_decode_uint32 (eod, cancellable, error);
 					val = GUINT_TO_POINTER (v);
 					list = g_slist_prepend (list, val);
-					
-					d(g_print ("prop id %X prop type: multi-int32 %d \n", prop_id, v);)
+
+					d (g_print ("prop id %X prop type: multi-int32 %d \n", prop_id, v);)
 					if (*error) {
 						g_slist_free (list);
 						return NULL;
@@ -656,10 +707,8 @@ ews_decode_oab_prop (EwsOabDecoder *eod,
 
 					if (prop_type == EWS_PTYP_MULTIPLEBINARY) {
 						val = ews_decode_binary (eod, cancellable, error);
-						d(g_print ("prop id %X prop type: multi-string %s \n", prop_id, val);)
 					} else {
 						val = ews_oab_read_upto (G_INPUT_STREAM (priv->fis), '\0', cancellable, error);
-						d(g_print ("prop id %X prop type: multi-string %s \n", prop_id, val);)
 					}
 
 					if (*error) {
@@ -671,7 +720,7 @@ ews_decode_oab_prop (EwsOabDecoder *eod,
 
 			}
 
-			break;	
+			break;
 		}
 		default:
 			g_assert_not_reached ();
@@ -681,14 +730,15 @@ ews_decode_oab_prop (EwsOabDecoder *eod,
 	return ret_val;
 }
 
-
 static void
-ews_destroy_oab_prop (guint32 prop_id, gpointer val, gboolean delete_files)
+ews_destroy_oab_prop (guint32 prop_id,
+                      gpointer val,
+                      gboolean delete_files)
 {
 	guint32 prop_type;
 
 	prop_type = prop_id & 0x0000FFFF;
-	
+
 	switch (prop_type) {
 		case EWS_PTYP_INTEGER32:
 		case EWS_PTYP_BOOLEAN:
@@ -700,10 +750,10 @@ ews_destroy_oab_prop (guint32 prop_id, g
 			break;
 		case EWS_PTYP_MULTIPLEBINARY:
 			if (delete_files)
-				g_slist_foreach ((GSList *)val, (GFunc) g_unlink, NULL);
+				g_slist_foreach ((GSList *) val, (GFunc) g_unlink, NULL);
 		case EWS_PTYP_MULTIPLESTRING8:
 		case EWS_PTYP_MULTIPLESTRING:
-			g_slist_foreach ((GSList *)val, (GFunc) g_free, NULL);
+			g_slist_foreach ((GSList *) val, (GFunc) g_free, NULL);
 		case EWS_PTYP_MULTIPLEINTEGER32:
 			g_slist_free ((GSList *) val);
 			break;
@@ -728,7 +778,12 @@ ews_destroy_oab_prop (guint32 prop_id, g
  * Returns: 
  **/
 static gboolean
-ews_decode_addressbook_record (EwsOabDecoder *eod, EContact *contact, EwsDeferredSet *dset, GSList *props, GCancellable *cancellable, GError **error)
+ews_decode_addressbook_record (EwsOabDecoder *eod,
+                               EContact *contact,
+                               EwsDeferredSet *dset,
+                               GSList *props,
+                               GCancellable *cancellable,
+                               GError **error)
 {
 	EwsOabDecoderPrivate *priv = GET_PRIVATE (eod);
 	guint bit_array_size, i, len;
@@ -736,11 +791,11 @@ ews_decode_addressbook_record (EwsOabDec
 	gboolean ret = TRUE;
 
 	len = g_slist_length (props);
-	bit_array_size = (guint) ceil (len/8.0);
+	bit_array_size = (guint) ceil (len / 8.0);
 	bit_str = g_malloc0 (bit_array_size);
 	g_input_stream_read (G_INPUT_STREAM (priv->fis), bit_str, bit_array_size, cancellable, error);
 	if (*error) {
-		ret = FALSE;	
+		ret = FALSE;
 		goto exit;
 	}
 
@@ -750,7 +805,7 @@ ews_decode_addressbook_record (EwsOabDec
 
 		if (!ews_is_bit_set (bit_str, i))
 			continue;
-		
+
 		val = g_slist_nth_data (props, i);
 		prop_id = GPOINTER_TO_UINT (val);
 
@@ -761,14 +816,14 @@ ews_decode_addressbook_record (EwsOabDec
 		if (contact && index) {
 			gint i = GPOINTER_TO_INT (index);
 
-			if (prop_map [i-1].populate_function)
-				prop_map [i-1].populate_function (contact, prop_map[i-1].field, val, (gpointer) eod);
+			if (prop_map[i - 1].populate_function)
+				prop_map[i - 1].populate_function (contact, prop_map[i - 1].field, val, (gpointer) eod);
 			else
-				prop_map [i-1].defered_populate_function (dset, prop_id, val);
+				prop_map[i - 1].defered_populate_function (dset, prop_id, val);
 		}
 
 		/* delete the binary file if we do not have the property in the index or if there
-		   was an error */
+		 * was an error */
 		ews_destroy_oab_prop (prop_id, val, (*error || !index) ? TRUE : FALSE);
 		if (*error)
 			goto exit;
@@ -777,20 +832,30 @@ ews_decode_addressbook_record (EwsOabDec
 exit:
 	if (bit_str)
 		g_free (bit_str);
-	
+
 	return ret;
 }
 
 /* Decodes the hdr and address-book records and stores the address-book records inside the db */
 static gboolean
-ews_decode_and_store_oab_records (EwsOabDecoder *eod, EwsOabContactAddedCb cb, gpointer user_data, GCancellable *cancellable, GError **error)
+ews_decode_and_store_oab_records (EwsOabDecoder *eod,
+                                  EwsOabContactAddedCb cb,
+                                  gpointer user_data,
+                                  GCancellable *cancellable,
+                                  GError **error)
 {
 	EwsOabDecoderPrivate *priv = GET_PRIVATE (eod);
 	gboolean ret = TRUE;
-	guint32 size, i;
+	guint32 i;
+
+	/* eat the size */
+	ews_oab_read_uint32 (
+		G_INPUT_STREAM (priv->fis),
+		cancellable, error);
+
+	ews_decode_addressbook_record (
+		eod, NULL, NULL, priv->hdr_props, cancellable, error);
 
-	size = ews_oab_read_uint32 (G_INPUT_STREAM (priv->fis), cancellable, error);
-	ews_decode_addressbook_record (eod, NULL, NULL, priv->hdr_props, cancellable, error);
 	if (*error) {
 		ret = FALSE;
 		goto exit;
@@ -804,56 +869,72 @@ ews_decode_and_store_oab_records (EwsOab
 
 		contact = e_contact_new ();
 		dset = g_new0 (EwsDeferredSet, 1);
-		size = ews_oab_read_uint32 (G_INPUT_STREAM (priv->fis), cancellable, error);
+
+		/* eat the size */
+		ews_oab_read_uint32 (
+			G_INPUT_STREAM (priv->fis),
+			cancellable, error);
 
 		/* fetch the offset */
 		offset = g_seekable_tell ((GSeekable *) priv->fis);
 
-		ews_decode_addressbook_record (eod, contact, dset, priv->oab_props, cancellable, error);
+		ews_decode_addressbook_record (
+			eod, contact, dset,
+			priv->oab_props, cancellable, error);
+
 		if (*error)
 			goto error;
-		
+
 		if (dset->addr)
-			e_contact_set (contact, E_CONTACT_ADDRESS_WORK, dset->addr);
-	
+			e_contact_set (
+				contact,
+				E_CONTACT_ADDRESS_WORK,
+				dset->addr);
+
 		/* set the smtp address as contact's uid */
 		uid = (gchar *) e_contact_get (contact, E_CONTACT_EMAIL_1);
-		e_contact_set (contact, E_CONTACT_UID, uid);
+		if (uid && *uid) {
+			e_contact_set (contact, E_CONTACT_UID, uid);
+
+			cb (
+				contact, offset,
+				((gfloat) (i + 1) / priv->total_records) * 100,
+				user_data, error);
+		}
 
-		cb (contact, offset, ((gfloat) (i+1)/priv->total_records)*100, user_data, error);
-		d(g_print ("%s \n", e_vcard_to_string ((EVCard *) contact, EVC_FORMAT_VCARD_30));)
-			
-error:		
+error:
 		g_object_unref (contact);
 		e_contact_address_free (dset->addr);
 		g_free (dset);
 		g_free (uid);
 
 		if (*error) {
-			ret = FALSE;	
+			ret = FALSE;
 			goto exit;
 		}
 	}
 
-exit: 
-	return ret;	
+exit:
+	return ret;
 }
 
 gchar *
-ews_oab_decoder_get_oab_prop_string	(EwsOabDecoder *eod, 
-					 GError **error)
+ews_oab_decoder_get_oab_prop_string (EwsOabDecoder *eod,
+                                     GError **error)
 {
 	EwsOabDecoderPrivate *priv = GET_PRIVATE (eod);
 	GString *str = g_string_new (NULL);
 	GSList *l;
 
 	if (!priv->oab_props) {
-		g_set_error_literal (error, EOD_ERROR, 1, "Oab props not found");
+		g_set_error_literal (
+			error, EOD_ERROR, 1,
+			"Oab props not found");
 		return NULL;
 	}
 
-	/* Ideally i would liked to store int as int instead of converting to string,
-	   but sqlite db doesn't yet support storing keys as blob */
+	/* Ideally i would liked to store int as int instead of converting to
+	 * string, but sqlite db doesn't yet support storing keys as blob. */
 	for (l = priv->oab_props; l != NULL; l = g_slist_next (l)) {
 		guint32 prop_id = GPOINTER_TO_UINT (l->data);
 		g_string_append_printf (str, "%"G_GUINT32_FORMAT, prop_id);
@@ -862,15 +943,15 @@ ews_oab_decoder_get_oab_prop_string	(Ews
 	if (str->len)
 		g_string_erase (str, str->len - 1, 1);
 
-	d(g_print ("Oab prop string: %s \n", str->str);)
+	d (g_print ("Oab prop string: %s \n", str->str);)
 
 	return g_string_free (str, FALSE);
 }
 
 gboolean
-ews_oab_decoder_set_oab_prop_string	(EwsOabDecoder *eod, 
-					 const gchar *prop_str, 
-					 GError **error)
+ews_oab_decoder_set_oab_prop_string (EwsOabDecoder *eod,
+                                     const gchar *prop_str,
+                                     GError **error)
 {
 	EwsOabDecoderPrivate *priv = GET_PRIVATE (eod);
 	gchar **vals;
@@ -881,7 +962,9 @@ ews_oab_decoder_set_oab_prop_string	(Ews
 
 	/* hmm is there a better way to check ? */
 	if (len < 2) {
-		g_set_error_literal (error, EOD_ERROR, 1, "Does not contain oab properties");
+		g_set_error_literal (
+			error, EOD_ERROR, 1,
+			"Does not contain oab properties");
 		return FALSE;
 	}
 
@@ -889,13 +972,14 @@ ews_oab_decoder_set_oab_prop_string	(Ews
 		g_slist_free (priv->oab_props);
 		priv->oab_props = NULL;
 	}
-	
+
 	for (i = 0; i < len; i++) {
 		guint32 prop_id;
 
 		sscanf (vals[i],"%"G_GUINT32_FORMAT,&prop_id);
-		priv->oab_props = g_slist_prepend (priv->oab_props, GUINT_TO_POINTER (prop_id));
-		d(printf ("%X\n", prop_id);)
+		priv->oab_props = g_slist_prepend (
+			priv->oab_props, GUINT_TO_POINTER (prop_id));
+		d (printf ("%X\n", prop_id);)
 	}
 
 	priv->oab_props = g_slist_reverse (priv->oab_props);
@@ -915,12 +999,12 @@ ews_oab_decoder_set_oab_prop_string	(Ews
  * the properties in the sqlite db.
  * Returns: TRUE if successfully decoded and indexed in db 
  **/
-gboolean	
-ews_oab_decoder_decode	(EwsOabDecoder *eod,
-			 EwsOabContactAddedCb cb,
-			 gpointer user_data,
-			 GCancellable *cancellable,
-			 GError **error)
+gboolean
+ews_oab_decoder_decode (EwsOabDecoder *eod,
+                        EwsOabContactAddedCb cb,
+                        gpointer user_data,
+                        GCancellable *cancellable,
+                        GError **error)
 {
 	EwsOabDecoderPrivate *priv = GET_PRIVATE (eod);
 	GError *err = NULL;
@@ -932,15 +1016,16 @@ ews_oab_decoder_decode	(EwsOabDecoder *e
 		ret = FALSE;
 		goto exit;
 	}
-	
+
 	priv->total_records = o_hdr->total_recs;
 	g_print ("Total records is %d \n", priv->total_records);
 
 	ret = ews_decode_metadata (eod, cancellable, &err);
 	if (!ret)
 		goto exit;
-	
-	ret = ews_decode_and_store_oab_records (eod, cb, user_data, cancellable, &err);
+
+	ret = ews_decode_and_store_oab_records (
+		eod, cb, user_data, cancellable, &err);
 exit:
 	if (o_hdr)
 		g_free (o_hdr);
@@ -948,15 +1033,15 @@ exit:
 	if (err)
 		g_propagate_error (error, err);
 
-	return ret;	
+	return ret;
 }
 
-EContact *	
-ews_oab_decoder_get_contact_from_offset	(EwsOabDecoder *eod,
-					 goffset offset,
-					 GSList *oab_props,
-					 GCancellable *cancellable,
-					 GError **error)
+EContact *
+ews_oab_decoder_get_contact_from_offset (EwsOabDecoder *eod,
+                                         goffset offset,
+                                         GSList *oab_props,
+                                         GCancellable *cancellable,
+                                         GError **error)
 {
 	EwsOabDecoderPrivate *priv = GET_PRIVATE (eod);
 	EwsDeferredSet *dset;
@@ -972,33 +1057,37 @@ ews_oab_decoder_get_contact_from_offset	
 		g_object_unref (contact);
 		contact = NULL;
 	}
-	
+
 	e_contact_address_free (dset->addr);
 	g_free (dset);
-	
+
 	return contact;
 }
 
-#include "e-book-backend-sqlitedb.h"
+#ifdef TEST_BUILD
 
 struct _db_data {
 	GSList *contact_collector;
 	guint collected_length;
-	EBookBackendSqliteDB *ebsdb;
+	EBookBackendSqliteDB *summary;
 	const gchar *folderid;
 };
 
 static void
-ews_test_store_contact (EContact *contact, goffset offset, guint percent, gpointer user_data, GError **error)
+ews_test_store_contact (EContact *contact,
+                        goffset offset,
+                        guint percent,
+                        gpointer user_data,
+                        GError **error)
 {
 	struct _db_data *data = (struct _db_data *) user_data;
-	
+
 	data->contact_collector = g_slist_prepend (data->contact_collector, g_object_ref (contact));
 	data->collected_length += 1;
 
 	if (data->collected_length == 1000 || percent >= 100) {
 		data->contact_collector = g_slist_reverse (data->contact_collector);
-		e_book_backend_sqlitedb_add_contacts (data->ebsdb, data->folderid, data->contact_collector, FALSE, error);
+		e_book_backend_sqlitedb_add_contacts (data->summary, data->folderid, data->contact_collector, FALSE, error);
 		g_print ("percent complete %d \n", percent);
 
 		g_slist_foreach (data->contact_collector, (GFunc) g_object_unref, NULL);
@@ -1008,29 +1097,29 @@ ews_test_store_contact (EContact *contac
 	}
 }
 
-gint 
-main (gint argc, gchar *argv [])
+gint
+main (gint argc,
+      gchar *argv[])
 {
-	EBookBackendSqliteDB *ebsdb;
+	EBookBackendSqliteDB *summary;
 	EwsOabDecoder *eod;
 	GError *err = NULL;
 	GTimer *timer;
 	struct _db_data data;
 
 	g_type_init ();
-	g_thread_init (NULL);
 
 	if (argc != 3) {
 		g_print ("Pass the oab filename  and cache dir as argument \n");
 		return -1;
 	}
 
-	ebsdb = e_book_backend_sqlitedb_new (argv [2], "dum", "de", "dum", TRUE, NULL);
-	eod = ews_oab_decoder_new (argv [1], argv [2], &err);
+	summary = e_book_backend_sqlitedb_new (argv[2], "dum", "de", "dum", TRUE, NULL);
+	eod = ews_oab_decoder_new (argv[1], argv[2], &err);
 
 	data.contact_collector = NULL;
 	data.collected_length = 0;
-	data.ebsdb = ebsdb;
+	data.summary = summary;
 	data.folderid = "de";
 
 	timer = g_timer_new ();
@@ -1045,7 +1134,8 @@ main (gint argc, gchar *argv [])
 		g_clear_error (&err);
 
 	g_object_unref (eod);
-	g_object_unref (ebsdb);
+	g_object_unref (summary);
 
 	return 0;
 }
+#endif /* TEST_BUILD */
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/addressbook/ews-oab-decoder.h evolution-ews.sync-with-3.8.2/src/addressbook/ews-oab-decoder.h
--- evolution-ews.git-gnome-3-0/src/addressbook/ews-oab-decoder.h	2013-05-17 14:36:16.341669906 +0200
+++ evolution-ews.sync-with-3.8.2/src/addressbook/ews-oab-decoder.h	2013-05-28 08:59:53.041838429 +0200
@@ -19,68 +19,76 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
-
-#ifndef _EWS_OAB_DECODER
-#define _EWS_OAB_DECODER
+#ifndef EWS_OAB_DECODER_H
+#define EWS_OAB_DECODER_H
 
 #include <glib.h>
 #include <glib-object.h>
 #include <gio/gio.h>
 #include <libebook/e-contact.h>
 
-G_BEGIN_DECLS
-
-#define EWS_TYPE_OAB_DECODER ews_oab_decoder_get_type()
-
+/* Standard GObject macros */
+#define EWS_TYPE_OAB_DECODER \
+	(ews_oab_decoder_get_type ())
 #define EWS_OAB_DECODER(obj) \
-  (G_TYPE_CHECK_INSTANCE_CAST ((obj), EWS_TYPE_OAB_DECODER, EwsOabDecoder))
-
-#define EWS_OAB_DECODER_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_CAST ((klass), EWS_TYPE_OAB_DECODER, EwsOabDecoderClass))
-
+	(G_TYPE_CHECK_INSTANCE_CAST \
+	((obj), EWS_TYPE_OAB_DECODER, EwsOabDecoder))
+#define EWS_OAB_DECODER_CLASS(cls) \
+	(G_TYPE_CHECK_CLASS_CAST \
+	((cls), EWS_TYPE_OAB_DECODER, EwsOabDecoderClass))
 #define EWS_IS_OAB_DECODER(obj) \
-  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EWS_TYPE_OAB_DECODER))
+	(G_TYPE_CHECK_INSTANCE_TYPE \
+	((obj), EWS_TYPE_OAB_DECODER))
+#define EWS_IS_OAB_DECODER_CLASS(cls) \
+	(G_TYPE_CHECK_CLASS_TYPE \
+	((cls), EWS_TYPE_OAB_DECODER))
+#define EWS_OAB_DECODER_GET_CLASS(obj) \
+	(G_TYPE_INSTANCE_GET_CLASS \
+	((obj), EWS_TYPE_OAB_DECODER, EwsOabDecoderClass))
 
-#define EWS_IS_OAB_DECODER_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_TYPE ((klass), EWS_TYPE_OAB_DECODER))
+G_BEGIN_DECLS
 
-#define EWS_OAB_DECODER_GET_CLASS(obj) \
-  (G_TYPE_INSTANCE_GET_CLASS ((obj), EWS_TYPE_OAB_DECODER, EwsOabDecoderClass))
+typedef struct _EwsOabDecoder EwsOabDecoder;
+typedef struct _EwsOabDecoderClass EwsOabDecoderClass;
 
-typedef struct {
-  GObject parent;
-} EwsOabDecoder;
-
-typedef struct {
-  GObjectClass parent_class;
-} EwsOabDecoderClass;
-
-GType ews_oab_decoder_get_type (void);
-
-typedef void (*EwsOabContactAddedCb) (EContact *contact, goffset offset, guint percent_complete, gpointer user_data, GError **error);
-
-EwsOabDecoder*	ews_oab_decoder_new	(const gchar *oab_filename,
-					 const gchar *cache_dir,
-					 GError **error);
-gboolean	ews_oab_decoder_decode	(EwsOabDecoder *eod,
-					 EwsOabContactAddedCb cb,
-					 gpointer user_data,
-					 GCancellable *cancellable,
-					 GError **error);
+struct _EwsOabDecoder {
+	GObject parent;
+};
+
+struct _EwsOabDecoderClass {
+	GObjectClass parent_class;
+};
+
+typedef void	(*EwsOabContactAddedCb)		(EContact *contact,
+						 goffset offset,
+						 guint percent_complete,
+						 gpointer user_data,
+						 GError **error);
+
+GType		ews_oab_decoder_get_type	(void);
+EwsOabDecoder *	ews_oab_decoder_new		(const gchar *oab_filename,
+						 const gchar *cache_dir,
+						 GError **error);
+gboolean	ews_oab_decoder_decode		(EwsOabDecoder *eod,
+						 EwsOabContactAddedCb cb,
+						 gpointer user_data,
+						 GCancellable *cancellable,
+						 GError **error);
 EContact *	ews_oab_decoder_get_contact_from_offset
-					(EwsOabDecoder *eod,
-					 goffset offset,
-					 GSList *oab_props,
-					 GCancellable *cancellable,
-					 GError **error);
-gchar *		ews_oab_decoder_get_oab_prop_string	
-					(EwsOabDecoder *eod, 
-					 GError **error);
-gboolean	ews_oab_decoder_set_oab_prop_string	
-					(EwsOabDecoder *eod,
-					 const gchar *prop_str,
-					 GError **error);
+						(EwsOabDecoder *eod,
+						 goffset offset,
+						 GSList *oab_props,
+						 GCancellable *cancellable,
+						 GError **error);
+gchar *		ews_oab_decoder_get_oab_prop_string
+						(EwsOabDecoder *eod,
+						 GError **error);
+gboolean	ews_oab_decoder_set_oab_prop_string
+						(EwsOabDecoder *eod,
+						 const gchar *prop_str,
+						 GError **error);
 
 G_END_DECLS
 
-#endif /* _EWS_OAB_DECODER */
+#endif /* EWS_OAB_DECODER_H */
+
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/addressbook/ews-oab-props.h evolution-ews.sync-with-3.8.2/src/addressbook/ews-oab-props.h
--- evolution-ews.git-gnome-3-0/src/addressbook/ews-oab-props.h	2013-05-17 14:36:16.341669906 +0200
+++ evolution-ews.sync-with-3.8.2/src/addressbook/ews-oab-props.h	2013-05-28 08:59:53.040838516 +0200
@@ -33,7 +33,6 @@
 #define EWS_PTYP_MULTIPLESTRING		0x101F
 #define EWS_PTYP_MULTIPLEBINARY		0x1102
 
-
 /* Ews OAB hdr property tags */
 #define EWS_PT_NAME			0x6800001F
 #define EWS_PT_DN			0x6804001E
@@ -41,7 +40,6 @@
 #define EWS_PT_GUID			0x6802001E
 #define	EWS_PT_ROOT_DEPARTMENT		0x8C98001E
 
-
 /* Ews OAB address-book record property tags that we are or may be interested in */
 #define EWS_PT_EMAIL_ADDRESS		0x3003001E
 #define EWS_PT_SMTP_ADDRESS		0x39FE001F
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/addressbook/libedata-book-compat.h evolution-ews.sync-with-3.8.2/src/addressbook/libedata-book-compat.h
--- evolution-ews.git-gnome-3-0/src/addressbook/libedata-book-compat.h	2013-05-17 14:36:16.342669459 +0200
+++ evolution-ews.sync-with-3.8.2/src/addressbook/libedata-book-compat.h	2013-05-28 08:59:53.040838516 +0200
@@ -30,5 +30,4 @@ void	e_data_book_respond_get_contact_lis
 void	e_book_backend_set_online		(EBookBackend *backend, gboolean is_online);
 void	e_book_backend_notify_opened		(EBookBackend *backend, GError *error);
 void	e_data_book_view_notify_progress        (EDataBookView *book_view, guint percent, const gchar *message);
-
 #endif
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/addressbook/lzx/ews-oal-decompress.c evolution-ews.sync-with-3.8.2/src/addressbook/lzx/ews-oal-decompress.c
--- evolution-ews.git-gnome-3-0/src/addressbook/lzx/ews-oal-decompress.c	2013-05-17 14:36:16.342669459 +0200
+++ evolution-ews.sync-with-3.8.2/src/addressbook/lzx/ews-oal-decompress.c	2013-05-28 08:59:53.005988661 +0200
@@ -20,6 +20,10 @@
  *
  */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include <sys/types.h>
 #include <stdlib.h>
 #include <stdio.h>
@@ -32,11 +36,11 @@
 
 /* endian-neutral reading of little-endian data */
 #define __egi32(a,n) ( ((((unsigned char *) a)[n+3]) << 24) | \
-                       ((((unsigned char *) a)[n+2]) << 16) | \
-                       ((((unsigned char *) a)[n+1]) <<  8) | \
-                       ((((unsigned char *) a)[n+0])))
+                       ((((guchar *) a)[n + 2]) << 16) | \
+                       ((((guchar *) a)[n + 1]) <<  8) | \
+                       ((((guchar *) a)[n + 0])))
 #define EndGetI64(a) ((((unsigned long long int) __egi32(a,4)) << 32) | \
-                      ((unsigned int) __egi32(a,0)))
+                      ((guint) __egi32 (a,0)))
 #define EndGetI32(a) __egi32(a,0)
 #define EndGetI16(a) ((((a)[1])<<8)|((a)[0]))
 
@@ -55,19 +59,21 @@ typedef struct {
 } LzxBlockHeader;
 
 static gboolean
-read_uint32 (FILE *input, guint32 *val)
+read_uint32 (FILE *input,
+             guint32 *val)
 {
-	gchar buf [4];
+	gchar buf[4];
 
 	if (fread (buf, 1, 4, input) == 4) {
 		*val = EndGetI32 (buf);
-		return TRUE;	
-	} else 
+		return TRUE;
+	} else
 		return FALSE;
 }
 
 static LzxHeader *
-read_headers (FILE *input, GError **error)
+read_headers (FILE *input,
+              GError **error)
 {
 	LzxHeader *lzx_h;
 	gboolean success;
@@ -99,7 +105,7 @@ exit:
 	if (!success) {
 		/* set the right domain later */
 		g_set_error_literal (error, g_quark_from_string ("lzx"), 1, "Unable to read lzx main header");
-		
+
 		g_free (lzx_h);
 		lzx_h = NULL;
 	}
@@ -108,7 +114,8 @@ exit:
 }
 
 static LzxBlockHeader *
-read_block_header (FILE *input, GError **error)
+read_block_header (FILE *input,
+                   GError **error)
 {
 	LzxBlockHeader *lzx_b;
 	gboolean success;
@@ -122,27 +129,29 @@ read_block_header (FILE *input, GError *
 	success = read_uint32 (input, &lzx_b->comp_size);
 	if (!success)
 		goto exit;
-	
+
 	success = read_uint32 (input, &lzx_b->ucomp_size);
 	if (!success)
 		goto exit;
-	
+
 	success = read_uint32 (input, &lzx_b->crc);
 
 exit:
 	if (!success) {
 		/* set the right domain later */
 		g_set_error_literal (error, g_quark_from_string ("lzx"), 1, "Unable to read lzx block header");
-		
+
 		g_free (lzx_b);
 		lzx_b = NULL;
 	}
 
-	return	lzx_b; 
+	return	lzx_b;
 }
 
 gboolean
-oal_decompress_v4_full_detail_file (const gchar *filename, const gchar *output_filename, GError **error)
+oal_decompress_v4_full_detail_file (const gchar *filename,
+                                    const gchar *output_filename,
+                                    GError **error)
 {
 	LzxHeader *lzx_h = NULL;
 	guint total_decomp_size = 0;
@@ -154,14 +163,14 @@ oal_decompress_v4_full_detail_file (cons
 	if (!input) {
 		g_set_error_literal (&err, g_quark_from_string ("lzx"), 1, "unable to open the input file");
 		ret = FALSE;
-		goto exit;	
+		goto exit;
 	}
-	
+
 	output = fopen (output_filename, "wb");
 	if (!input) {
 		g_set_error_literal (&err, g_quark_from_string ("lzx"), 1, "unable to open the output file");
 		ret = FALSE;
-		goto exit;	
+		goto exit;
 	}
 
 	lzx_h = read_headers (input, &err);
@@ -169,11 +178,11 @@ oal_decompress_v4_full_detail_file (cons
 		ret = FALSE;
 		goto exit;
 	}
-	
+
 	/* TODO decompressing multiple lzx_blocks has not been tested yet. Will need to get a setup and test it. */
 	do {
 		LzxBlockHeader *lzx_b;
-        	struct lzxd_stream *lzs;
+		struct lzxd_stream *lzs;
 		goffset offset;
 
 		lzx_b = read_block_header (input, &err);
@@ -198,24 +207,17 @@ oal_decompress_v4_full_detail_file (cons
 			}
 			g_free (buffer);
 		} else {
-			/* round to multiples of 32768 */
-			guint mul, round, set, window_bits;
-	
-			mul = ceil (lzx_b->ucomp_size / 32768.0);
-			round = mul * 32768;
-			set = g_bit_nth_lsf ((round >> 17), -1);
-			
-			if (set > 8)
-				window_bits = 25;
-			else if (set == 0 && !(round >> 17))
-				window_bits = 17;
-			else {
-				window_bits = set + 17;
-				if (round % (2^window_bits))
-					window_bits++;
-			}
+			/* The window size should be the smallest power of two between 2^17 and 2^25 that is
+			   greater than or equal to the sum of the size of the reference data rounded up to
+			   a multiple of 32768 and the size of the subject data. Since we have no reference
+			   data, forget that and the rounding. Just the smallest power of two which is large
+			   enough to cover the subject data (lzx_b->ucomp_size). */
+
+			guint window_bits = g_bit_nth_msf(lzx_b->ucomp_size - 1, -1) + 1;
 
-			if (window_bits > 25)
+			if (window_bits < 17)
+				window_bits = 17;
+			else if (window_bits > 25)
 				window_bits = 25;
 
 			lzs = lzxd_init (input, output, window_bits, 0, 16, lzx_b->ucomp_size);
@@ -227,9 +229,8 @@ oal_decompress_v4_full_detail_file (cons
 			}
 		}
 
-
 		/* Set the fp to beggining of next block. This is a HACK, looks like decompress reads beyond the block.
-		   Since we can identify the next block start from block header, we just reset the offset */
+		 * Since we can identify the next block start from block header, we just reset the offset */
 		offset += lzx_b->comp_size;
 		fseek (input, offset, SEEK_SET);
 
@@ -240,7 +241,7 @@ oal_decompress_v4_full_detail_file (cons
 exit:
 	if (input)
 		fclose (input);
-	
+
 	if (output)
 		fclose (output);
 
@@ -254,23 +255,3 @@ exit:
 
 	return ret;
 }
-
-/*
-int
-main (int argc, char *argv [])
-{
-	if (argc != 3) {
-		g_print ("Pass an lzx file and an output filename as argument \n");
-		return;
-	}
-
-	g_type_init ();
-	g_thread_init (NULL);
-
-	if (oal_decompress_v4_full_detail_file (argv [1], argv [2], NULL))
-		g_print ("Successfully decompressed \n");
-	else
-		g_print ("decompression failed \n");
-
-	return 0;
-} */
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/addressbook/lzx/Makefile.am evolution-ews.sync-with-3.8.2/src/addressbook/lzx/Makefile.am
--- evolution-ews.git-gnome-3-0/src/addressbook/lzx/Makefile.am	2013-05-17 14:36:16.342669459 +0200
+++ evolution-ews.sync-with-3.8.2/src/addressbook/lzx/Makefile.am	2013-05-28 08:59:53.005988661 +0200
@@ -1,18 +1,26 @@
+NULL =
+
 lib_LTLIBRARIES = liblzx.la
 
-liblzx_la_CPPFLAGS =				\
-	$(AM_CPPFLAGS)				\
-	$(GNOME_PLATFORM_CFLAGS)
-
-liblzx_la_SOURCES =				\
-	lzx.h					\
-	ews-oal-decompress.h			\
-	lzxd.c					\
-	ews-oal-decompress.c			\
-	readbits.h				\
-	readhuff.h
+liblzx_la_CPPFLAGS = \
+	$(AM_CPPFLAGS) \
+	$(GNOME_PLATFORM_CFLAGS) \
+	$(NULL)
+
+liblzx_la_SOURCES = \
+	lzx.h \
+	ews-oal-decompress.h \
+	lzxd.c \
+	ews-oal-decompress.c \
+	readbits.h \
+	readhuff.h \
+	$(NULL)
 
 liblzx_la_LDFLAGS = $(NO_UNDEFINED)
 
-liblzx_la_LIBADD = 				\
-	$(GNOME_PLATFORM_LIBS)
+liblzx_la_LIBADD = \
+	$(GNOME_PLATFORM_LIBS) \
+	$(LIBM) \
+	$(NULL)
+
+-include $(top_srcdir)/git.mk
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/addressbook/Makefile.am evolution-ews.sync-with-3.8.2/src/addressbook/Makefile.am
--- evolution-ews.git-gnome-3-0/src/addressbook/Makefile.am	2013-05-17 14:36:16.330555377 +0200
+++ evolution-ews.sync-with-3.8.2/src/addressbook/Makefile.am	2013-05-28 08:59:53.042838479 +0200
@@ -9,6 +9,7 @@ endif
 libebookbackendews_la_CPPFLAGS = \
 	$(AM_CPPFLAGS)					\
 	-DG_LOG_DOMAIN=\"libebookbackend\"		\
+	-I$(top_srcdir)/src	                	\
 	-I$(top_srcdir)/src/addressbook			\
 	-I$(top_srcdir)/src/server	                \
 	-I$(top_srcdir)/src/utils	                \
@@ -17,6 +18,7 @@ libebookbackendews_la_CPPFLAGS = \
 	$(LIBEBOOK_CFLAGS)				\
 	$(DB_CFLAGS)					\
 	$(EVOLUTION_ADDRESSBOOK_CFLAGS)                 \
+	$(CAMEL_CFLAGS)					\
 	$(SQLITE3_CFLAGS)			\
 	$(SOUP_CFLAGS)	
 
@@ -44,6 +46,7 @@ libebookbackendews_la_LIBADD =					\
 	$(LIBEBOOK_LIBS)					\
 	$(DB_LIBS)						\
 	$(EVOLUTION_ADDRESSBOOK_LIBS)				\
+	$(CAMEL_LIBS)						\
 	$(SQLITE3_LIBS)	\
 	$(SOUP_LIBS)
 
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/calendar/e-cal-backend-ews.c evolution-ews.sync-with-3.8.2/src/calendar/e-cal-backend-ews.c
--- evolution-ews.git-gnome-3-0/src/calendar/e-cal-backend-ews.c	2013-05-17 14:36:16.346671154 +0200
+++ evolution-ews.sync-with-3.8.2/src/calendar/e-cal-backend-ews.c	2013-05-28 08:59:53.478712478 +0200
@@ -53,6 +53,9 @@
 #include "e-ews-item-change.h"
 #include "libedata-cal-compat.h"
 
+#include <libedataserver/e-flag.h>
+#include "server/e-ews-gnome-3-8-compat.h"
+
 #ifndef O_BINARY
 #define O_BINARY 0
 #endif
@@ -88,8 +91,11 @@ struct _ECalBackendEwsPrivate {
 	icaltimezone *default_zone;
 	guint refresh_timeout;
 	gboolean refreshing;
+	EFlag *refreshing_done;
 	GHashTable *item_id_hash;
 
+	GCancellable *cancellable;
+
 #if EDS_CHECK_VERSION (3,1,0)
 	ECredentials *credentials;
 #endif
@@ -122,11 +128,55 @@ struct _ECalBackendEwsPrivate {
 
 #define PARENT_TYPE E_TYPE_CAL_BACKEND
 static ECalBackendClass *parent_class = NULL;
-static void ews_cal_sync_items_ready_cb (GObject *obj, GAsyncResult *res, gpointer user_data);
 static void ews_cal_component_get_item_id (ECalComponent *comp, gchar **itemid, gchar **changekey);
 static gboolean ews_start_sync	(gpointer data);
 static icaltimezone* e_cal_get_timezone_from_ical_component (ECalBackend *backend, icalcomponent *comp);
 
+static gboolean
+e_cal_backend_ews_get_online (ECalBackendEws *ews_backend)
+{
+	g_return_val_if_fail (E_IS_CAL_BACKEND_EWS (ews_backend), FALSE);
+
+	return ews_backend->priv && ews_backend->priv->mode != CAL_MODE_LOCAL;
+}
+
+static void
+convert_error_to_edc_error (GError **perror)
+{
+	GError *error = NULL;
+
+	g_return_if_fail (perror != NULL);
+
+	if (!*perror || (*perror)->domain == E_DATA_CAL_ERROR)
+		return;
+
+	if ((*perror)->domain == EWS_CONNECTION_ERROR) {
+		switch ((*perror)->code) {
+		case EWS_CONNECTION_ERROR_AUTHENTICATION_FAILED:
+			error = EDC_ERROR_EX (AuthenticationFailed, (*perror)->message);
+			break;
+		case EWS_CONNECTION_ERROR_CANCELLED:
+			break;
+		case EWS_CONNECTION_ERROR_FOLDERNOTFOUND:
+		case EWS_CONNECTION_ERROR_MANAGEDFOLDERNOTFOUND:
+		case EWS_CONNECTION_ERROR_PARENTFOLDERNOTFOUND:
+		case EWS_CONNECTION_ERROR_PUBLICFOLDERSERVERNOTFOUND:
+			error = EDC_ERROR_EX (NoSuchCal, (*perror)->message);
+			break;
+		case EWS_CONNECTION_ERROR_EVENTNOTFOUND:
+		case EWS_CONNECTION_ERROR_ITEMNOTFOUND:
+			error = EDC_ERROR_EX (ObjectNotFound, (*perror)->message);
+			break;
+		}
+	}
+
+	if (!error)
+		error = EDC_ERROR_EX (OtherError, (*perror)->message);
+
+	g_error_free (*perror);
+	*perror = error;
+}
+
 static void
 switch_offline (ECalBackendEws *cbews)
 {
@@ -140,12 +190,39 @@ switch_offline (ECalBackendEws *cbews)
 		priv->refresh_timeout = 0;
 	}
 
+	if (priv->cancellable) {
+		g_cancellable_cancel (priv->cancellable);
+		g_object_unref (priv->cancellable);
+		priv->cancellable = NULL;
+	}
+
 	if (priv->cnc) {
 		g_object_unref (priv->cnc);
 		priv->cnc = NULL;
 	}
 }
 
+static gboolean
+cal_backend_ews_ensure_connected (ECalBackendEws *cbews,
+				  GCancellable *cancellable,
+				  GError **perror)
+{
+	g_return_val_if_fail (E_IS_CAL_BACKEND_EWS (cbews), FALSE);
+
+	PRIV_LOCK (cbews->priv);
+
+	if (cbews->priv->cnc) {
+		PRIV_UNLOCK (cbews->priv);
+		return TRUE;
+	}
+
+	PRIV_UNLOCK (cbews->priv);
+
+	g_propagate_error (perror, EDC_ERROR (RepositoryOffline));
+
+	return FALSE;
+}
+
 /* Property Accessors */
 
 #if ! EDS_CHECK_VERSION (3, 1, 0)	
@@ -421,8 +498,9 @@ static void clear_reminder_is_set (ESoap
 	else
 		change_type = E_EWS_ITEMCHANGE_TYPE_ITEM;
 
-	e_ews_message_start_item_change (msg, change_type,
-					 edad->itemid, edad->changekey, edad->instance_index);
+	e_ews_message_start_item_change (
+		msg, change_type,
+		edad->itemid, edad->changekey, edad->instance_index);
 
 	e_ews_message_start_set_item_field (msg, "ReminderIsSet","item", "CalendarItem");
 
@@ -433,36 +511,43 @@ static void clear_reminder_is_set (ESoap
 	e_ews_message_end_item_change (msg);
 }
 
-
 static void
-ews_cal_discard_alarm_cb (GObject *object, GAsyncResult *res, gpointer user_data)
+ews_cal_discard_alarm_cb (GObject *object,
+                          GAsyncResult *res,
+                          gpointer user_data)
 {
 	EEwsConnection *cnc = E_EWS_CONNECTION (object);
 	EwsDiscardAlarmData *edad = user_data;
 	GError *error = NULL;
 
 	if (!e_ews_connection_update_items_finish (cnc, res, NULL, &error)) {
-		/* The calendar UI doesn't *display* errors unless they have
-		   the OtherError code */
-		error->code = OtherError;
+		convert_error_to_edc_error (&error);
 	}
 
+	convert_error_to_edc_error (&error);
 	e_data_cal_respond_discard_alarm (edad->cal, edad->context, error);
 
-	g_free(edad->itemid);
-	g_free(edad->changekey);
-	g_object_unref(edad->cbews);
-	g_object_unref(edad->cal);
-	g_free(edad);
+	g_free (edad->itemid);
+	g_free (edad->changekey);
+	g_object_unref (edad->cbews);
+	g_object_unref (edad->cal);
+	g_free (edad);
 }
 
 static void
-e_cal_backend_ews_discard_alarm (ECalBackend *backend, EDataCal *cal, EServerMethodContext context, GCancellable *cancellable, const gchar *uid, const gchar *rid, const gchar *auid)
+e_cal_backend_ews_discard_alarm (ECalBackend *backend,
+                                 EDataCal *cal,
+                                 EServerMethodContext context,
+                                 GCancellable *cancellable,
+                                 const gchar *uid,
+                                 const gchar *rid,
+                                 const gchar *auid)
 {
 	ECalBackendEws *cbews = (ECalBackendEws *) backend;
 	ECalBackendEwsPrivate *priv;
 	EwsDiscardAlarmData *edad;
 	ECalComponent *comp;
+	GError *local_error = NULL;
 
 	priv = cbews->priv;
 
@@ -470,15 +555,23 @@ e_cal_backend_ews_discard_alarm (ECalBac
 
 	comp = e_cal_backend_store_get_component (priv->store, uid, NULL);
 	if (!comp) {
-		e_data_cal_respond_discard_alarm (cal, context,
-						   EDC_ERROR(ObjectNotFound));
+		e_data_cal_respond_discard_alarm (
+			cal, context,
+			EDC_ERROR (ObjectNotFound));
+		PRIV_UNLOCK (priv);
 		return;
 	}
 
 	PRIV_UNLOCK (priv);
 
+	if (!cal_backend_ews_ensure_connected (cbews, cancellable, &local_error)) {
+		convert_error_to_edc_error (&local_error);
+		e_data_cal_respond_discard_alarm (cal, context, local_error);
+		return;
+	}
+
 	/* FIXME: Can't there be multiple alarms for each event? Or does
-	   Exchange not support that? */
+	 * Exchange not support that? */
 	edad = g_new0 (EwsDiscardAlarmData, 1);
 	edad->cbews = g_object_ref (cbews);
 	edad->cal = g_object_ref (cal);
@@ -492,7 +585,7 @@ e_cal_backend_ews_discard_alarm (ECalBac
 
 		if (index != NULL) {
 			/*Microsoft is counting the occurrences starting from 1
-			 where EcalComponent is starting from zerro*/
+			 where EcalComponent is starting from zerro */
 			edad->instance_index = *index + 1;
 			e_cal_component_free_sequence (index);
 		} else {
@@ -504,19 +597,25 @@ e_cal_backend_ews_discard_alarm (ECalBac
 		edad->is_occurrence = FALSE;
 		edad->instance_index = -1;
 	}
-	
+
 	ews_cal_component_get_item_id (comp, &edad->itemid, &edad->changekey);
 
-	e_ews_connection_update_items_start (priv->cnc, EWS_PRIORITY_MEDIUM,
-					     "AlwaysOverwrite", NULL,
-					     "SendToNone", NULL,
-					     clear_reminder_is_set, edad,
-					     ews_cal_discard_alarm_cb, NULL,
-					     edad);
+	e_ews_connection_update_items (
+		priv->cnc, EWS_PRIORITY_MEDIUM,
+		"AlwaysOverwrite", NULL,
+		"SendToNone", NULL,
+		clear_reminder_is_set, edad,
+		priv->cancellable,
+		ews_cal_discard_alarm_cb,
+		edad);
 }
 
 static void
-e_cal_backend_ews_get_timezone (ECalBackend *backend, EDataCal *cal, EServerMethodContext context, GCancellable *cancellable, const gchar *tzid)
+e_cal_backend_ews_get_timezone (ECalBackend *backend,
+                                EDataCal *cal,
+                                EServerMethodContext context,
+                                GCancellable *cancellable,
+                                const gchar *tzid)
 {
 	icalcomponent *icalcomp;
 	icaltimezone *zone;
@@ -579,15 +678,17 @@ e_cal_backend_ews_get_timezone (ECalBack
 
 /* changekey can be NULL if you don't want it. itemid cannot. */
 static void
-ews_cal_component_get_item_id (ECalComponent *comp, gchar **itemid, gchar **changekey)
+ews_cal_component_get_item_id (ECalComponent *comp,
+                               gchar **itemid,
+                               gchar **changekey)
 {
 	icalproperty *prop;
 	gchar *ck = NULL;
 	gchar *id = NULL;
 
-
-	prop = icalcomponent_get_first_property (e_cal_component_get_icalcomponent (comp),
-						 ICAL_X_PROPERTY);
+	prop = icalcomponent_get_first_property (
+		e_cal_component_get_icalcomponent (comp),
+		ICAL_X_PROPERTY);
 	while (prop) {
 		const gchar *x_name, *x_val;
 
@@ -598,8 +699,9 @@ ews_cal_component_get_item_id (ECalCompo
 		 else if (changekey && !ck && !g_ascii_strcasecmp (x_name, "X-EVOLUTION-CHANGEKEY"))
 			ck = g_strdup (x_val);
 
-		prop = icalcomponent_get_next_property (e_cal_component_get_icalcomponent (comp),
-							ICAL_X_PROPERTY);
+		prop = icalcomponent_get_next_property (
+			e_cal_component_get_icalcomponent (comp),
+			ICAL_X_PROPERTY);
 	}
 
 	*itemid = id;
@@ -609,34 +711,45 @@ ews_cal_component_get_item_id (ECalCompo
 
 /* changekey can be NULL if you don't want it. itemid cannot. */
 static void
-ews_cal_component_get_calendar_item_accept_id (ECalComponent *comp, gchar **itemid, gchar **changekey)
+ews_cal_component_get_calendar_item_accept_id (ECalComponent *comp,
+                                               gchar **itemid,
+                                               gchar **changekey,
+					       gchar **mail_id)
 {
 	icalproperty *prop;
-	gchar *id = NULL;
+	gchar *id_item = NULL;
+	gchar *id_accept = NULL;
 	gchar *ck = NULL;
 
-	prop = icalcomponent_get_first_property (e_cal_component_get_icalcomponent (comp),
-						 ICAL_X_PROPERTY);
+	prop = icalcomponent_get_first_property (
+		e_cal_component_get_icalcomponent (comp),
+		ICAL_X_PROPERTY);
 	while (prop) {
 		const gchar *x_name, *x_val;
 
 		x_name = icalproperty_get_x_name (prop);
 		x_val = icalproperty_get_x (prop);
-		if (!id && (!g_ascii_strcasecmp (x_name, "X-EVOLUTION-ITEMID") || !g_ascii_strcasecmp (x_name, "X-EVOLUTION-ACCEPT-ID")))
-			id = g_strdup (x_val);
+		if (!id_item && g_ascii_strcasecmp (x_name, "X-EVOLUTION-ITEMID") == 0)
+			id_item = g_strdup (x_val);
+		else if (!id_accept && g_ascii_strcasecmp (x_name, "X-EVOLUTION-ACCEPT-ID") == 0)
+			id_accept = g_strdup (x_val);
 		else if (changekey && !ck && !g_ascii_strcasecmp (x_name, "X-EVOLUTION-CHANGEKEY"))
 			ck = g_strdup (x_val);
 
-		prop = icalcomponent_get_next_property (e_cal_component_get_icalcomponent (comp),
+		prop = icalcomponent_get_next_property (
+			e_cal_component_get_icalcomponent (comp),
 			ICAL_X_PROPERTY);
 	}
 
-	*itemid = g_strdup (id);
+	if (!id_item)
+		id_item = g_strdup (id_accept);
+
+	*itemid = id_item;
+	*mail_id = id_accept;
 	if (changekey)
 		*changekey = ck;
 }
 
-
 static void
 add_comps_to_item_id_hash (ECalBackendEws *cbews)
 {
@@ -657,11 +770,12 @@ add_comps_to_item_id_hash (ECalBackendEw
 			const gchar *uid;
 
 			/* This should never happen, but sometimes when our
-			   use of X- fields has changed it has triggered. Make
-			   it cope, and not crash */
-			e_cal_component_get_uid(comp, &uid);
-			g_warning ("EWS calendar item %s had no EWS ItemID!",
-				   uid);
+			 * use of X- fields has changed it has triggered. Make
+			 * it cope, and not crash */
+			e_cal_component_get_uid (comp, &uid);
+			g_warning (
+				"EWS calendar item %s had no EWS ItemID!",
+				uid);
 			continue;
 		}
 		g_hash_table_insert (priv->item_id_hash, item_id, comp);
@@ -685,6 +799,7 @@ connect_to_server (ECalBackendEws *cbews
 
 	if (priv->mode != CAL_MODE_LOCAL && !priv->cnc && password) {
 		const gchar *host_url;
+		const gchar *timeout_str;
 
 		/* If we can be called a second time while the first is still
 		   "outstanding", we need a bit of a rethink... */
@@ -693,8 +808,14 @@ connect_to_server (ECalBackendEws *cbews
 		priv->user_email = e_source_get_duped_property (esource, "email");
 
 		host_url = e_source_get_property (esource, "hosturl");
+		timeout_str = e_source_get_property (esource, "timeout");
 		priv->cnc = e_ews_connection_new (host_url, username, password,
-						  NULL, NULL, error);
+			priv->user_email,
+			e_source_get_property (esource, "impersonate_user"),
+			timeout_str ? atoi (timeout_str) : -1,
+			TRUE,
+			NULL, NULL, error);
+
 		/* Trigger an update request, which will test our authentication */
 		if (priv->cnc) {
 			ews_start_sync (cbews);
@@ -838,8 +959,12 @@ e_cal_backend_ews_remove (ECalBackend *b
 }
 
 static void
-e_cal_backend_ews_get_object	(ECalBackend *backend, EDataCal *cal, EServerMethodContext context, GCancellable *cancellable,
-	 			 const gchar *uid, const gchar *rid)
+e_cal_backend_ews_get_object (ECalBackend *backend,
+                              EDataCal *cal,
+                              EServerMethodContext context,
+                              GCancellable *cancellable,
+                              const gchar *uid,
+                              const gchar *rid)
 {
 	ECalComponent *comp;
 	ECalBackendEwsPrivate *priv;
@@ -853,10 +978,30 @@ e_cal_backend_ews_get_object	(ECalBacken
 
 	PRIV_LOCK (priv);
 
+	if (e_cal_backend_ews_get_online (E_CAL_BACKEND_EWS (backend))) {
+		/* make sure any pending refreshing is done */
+		while (priv->refreshing) {
+			PRIV_UNLOCK (priv);
+			e_flag_wait (priv->refreshing_done);
+			PRIV_LOCK (priv);
+		}
+	}
+
 	/* search the object in the cache */
 	comp = e_cal_backend_store_get_component (priv->store, uid, rid);
-	if (comp) {
+	if (!comp && e_cal_backend_ews_get_online (E_CAL_BACKEND_EWS (backend))) {
+		/* maybe a meeting invitation, for which the calendar item is not downloaded yet,
+		 * thus synchronize local cache first */
+		ews_start_sync (cbews);
+
 		PRIV_UNLOCK (priv);
+		e_flag_wait (priv->refreshing_done);
+		PRIV_LOCK (priv);
+
+		comp = e_cal_backend_store_get_component (priv->store, uid, rid);
+	}
+
+	if (comp) {
 		if (e_cal_backend_get_kind (backend) ==
 		    icalcomponent_isa (e_cal_component_get_icalcomponent (comp)))
 			object = e_cal_component_get_as_string (comp);
@@ -867,21 +1012,23 @@ e_cal_backend_ews_get_object	(ECalBacken
 
 		if (!object)
 			g_propagate_error (&error, EDC_ERROR (ObjectNotFound));
-		goto exit;
+	} else {
+		g_propagate_error (&error, EDC_ERROR (ObjectNotFound));
 	}
 
 	PRIV_UNLOCK (priv);
 
-	/* callers will never have a uuid that is in server but not in cache */
-	g_propagate_error (&error, EDC_ERROR (ObjectNotFound));
-
-exit:
+ exit:
+	convert_error_to_edc_error (&error);
 	e_data_cal_respond_get_object (cal, context, error, object);
 	g_free (object);
 }
 
 static void
-cal_backend_ews_get_object_list (ECalBackend *backend, const gchar *sexp, GSList **objects, GError **error)
+cal_backend_ews_get_object_list (ECalBackend *backend,
+                                 const gchar *sexp,
+                                 GSList **objects,
+                                 GError **error)
 {
 	ECalBackendEws *cbews;
 	ECalBackendEwsPrivate *priv;
@@ -905,9 +1052,8 @@ cal_backend_ews_get_object_list (ECalBac
 
 	*objects = NULL;
 
-	prunning_by_time = e_cal_backend_sexp_evaluate_occur_times (cbsexp,
-									    &occur_start,
-									    &occur_end);
+	prunning_by_time = e_cal_backend_sexp_evaluate_occur_times (
+		cbsexp, &occur_start, &occur_end);
 	components = prunning_by_time ?
 		e_cal_backend_store_get_components_occuring_in_range (priv->store, occur_start, occur_end)
 		: e_cal_backend_store_get_components (priv->store);
@@ -930,13 +1076,18 @@ cal_backend_ews_get_object_list (ECalBac
 }
 
 static void
-e_cal_backend_ews_get_object_list (ECalBackend *backend, EDataCal *cal, EServerMethodContext context, GCancellable *cancellable, const gchar *sexp)
+e_cal_backend_ews_get_object_list (ECalBackend *backend,
+                                   EDataCal *cal,
+                                   EServerMethodContext context,
+                                   GCancellable *cancellable,
+                                   const gchar *sexp)
 {
 	GSList *objects = NULL, *l;
 	GError *error = NULL;
 
 	cal_backend_ews_get_object_list (backend, sexp, &objects, &error);
 
+	convert_error_to_edc_error (&error);
 	e_data_cal_respond_get_object_list (cal, context, error, objects);
 	if (objects) {
 		for (l = objects; l != NULL; l = g_slist_next (l))
@@ -946,7 +1097,9 @@ e_cal_backend_ews_get_object_list (ECalB
 }
 
 static void
-ews_cal_delete_comp (ECalBackendEws *cbews, ECalComponent *comp, const gchar *item_id)
+ews_cal_delete_comp (ECalBackendEws *cbews,
+                     ECalComponent *comp,
+                     const gchar *item_id)
 {
 	ECalBackendEwsPrivate *priv = cbews->priv;
 	gchar *comp_str;
@@ -968,16 +1121,19 @@ ews_cal_delete_comp (ECalBackendEws *cbe
 }
 
 static void
-ews_cal_append_exdate (ECalBackendEws *cbews, ECalComponent *comp, const gchar *rid, CalObjModType mod)
+ews_cal_append_exdate (ECalBackendEws *cbews,
+                       ECalComponent *comp,
+                       const gchar *rid,
+                       CalObjModType mod)
 {
 	gchar *old_comp_str, *comp_str;
 
 	old_comp_str = e_cal_component_get_as_string (comp);
 	e_cal_util_remove_instances (e_cal_component_get_icalcomponent (comp), icaltime_from_string (rid), mod);
 	comp_str = e_cal_component_get_as_string (comp);
-	
+
 	e_cal_backend_notify_object_modified (E_CAL_BACKEND (cbews), old_comp_str, comp_str);
-	
+
 	g_free (comp_str);
 	g_free (old_comp_str);
 }
@@ -995,7 +1151,9 @@ typedef struct {
 } EwsRemoveData;
 
 static void
-ews_cal_remove_object_cb (GObject *object, GAsyncResult *res, gpointer user_data)
+ews_cal_remove_object_cb (GObject *object,
+                          GAsyncResult *res,
+                          gpointer user_data)
 {
 	EwsRemoveData *remove_data = user_data;
 	GSimpleAsyncResult *simple;
@@ -1005,14 +1163,15 @@ ews_cal_remove_object_cb (GObject *objec
 
 	if (!g_simple_async_result_propagate_error (simple, &error) || error->code == EWS_CONNECTION_ERROR_ITEMNOTFOUND) {
 		/* FIXME: This is horrid. Will bite us when we start to delete
-		   more than one item at a time... */
+		 * more than one item at a time... */
 		if (remove_data->comp) ews_cal_delete_comp (remove_data->cbews, remove_data->comp, remove_data->item_id.id);
 		if (remove_data->parent) ews_cal_append_exdate (remove_data->cbews, remove_data->parent, remove_data->rid, remove_data->mod);
+	}
 
-	} else error->code = OtherError;
+	convert_error_to_edc_error (&error);
 
 	if (remove_data->context)
-		e_data_cal_respond_remove (remove_data->cal, remove_data->context, error);
+		e_data_cal_respond_remove  (remove_data->cal, remove_data->context, error);
 	else if (error) {
 		g_warning ("Remove object error :  %s\n", error->message);
 		g_clear_error (&error);
@@ -1020,27 +1179,30 @@ ews_cal_remove_object_cb (GObject *objec
 
 	g_free (remove_data->item_id.id);
 	g_free (remove_data->item_id.change_key);
-	g_object_unref(remove_data->cbews);
-	if (remove_data->comp) g_object_unref(remove_data->comp);
-	if (remove_data->parent) g_object_unref(remove_data->parent);
-	g_object_unref(remove_data->cal);
+	g_object_unref (remove_data->cbews);
+	if (remove_data->comp) g_object_unref (remove_data->comp);
+	if (remove_data->parent) g_object_unref (remove_data->parent);
+	g_object_unref (remove_data->cal);
 	if (remove_data->rid) g_free (remove_data->rid);
-	g_free(remove_data);
+	g_free (remove_data);
 }
 
 static guint
-e_cal_rid_to_index (ECalBackend *backend, const char *rid, icalcomponent *comp, GError **error)
+e_cal_rid_to_index (ECalBackend *backend,
+                    const gchar *rid,
+                    icalcomponent *comp,
+                    GError **error)
 {
 	guint index = 1;
-	icalproperty *prop = icalcomponent_get_first_property(comp, ICAL_RRULE_PROPERTY);
+	icalproperty *prop = icalcomponent_get_first_property (comp, ICAL_RRULE_PROPERTY);
 	struct icalrecurrencetype rule = icalproperty_get_rrule (prop);
 	struct icaltimetype dtstart = icalcomponent_get_dtstart (comp);
-	icalrecur_iterator* ritr;
+	icalrecur_iterator * ritr;
 	icaltimetype next, o_time;
 
 	/* icalcomponent_get_datetime needs a fix to initialize ret.zone to NULL. If a timezone is not
-	   found in libical, it remains uninitialized in that function causing invalid read or crash. so
-	   we set the timezone as we cannot identify if it has a valid timezone or not */
+	 * found in libical, it remains uninitialized in that function causing invalid read or crash. so
+	 * we set the timezone as we cannot identify if it has a valid timezone or not */
 	dtstart.zone = e_cal_get_timezone_from_ical_component (backend, comp);
 	ritr = icalrecur_iterator_new (rule, dtstart);
 	next = icalrecur_iterator_next (ritr);
@@ -1052,18 +1214,24 @@ e_cal_rid_to_index (ECalBackend *backend
 	}
 
 	icalrecur_iterator_free (ritr);
-	
+
 	if (icaltime_is_null_time (next)) {
-		g_propagate_error (error, EDC_ERROR_EX(OtherError,
-		    "Invalid occurrence ID"));
+		g_propagate_error (
+			error, EDC_ERROR_EX (OtherError,
+			"Invalid occurrence ID"));
 	}
-	
+
 	return index;
 }
 
 static void
-e_cal_backend_ews_remove_object (ECalBackend *backend, EDataCal *cal, EServerMethodContext context, GCancellable *cancellable,
-				 const gchar *uid, const gchar *rid, CalObjModType mod)
+e_cal_backend_ews_remove_object (ECalBackend *backend,
+                                 EDataCal *cal,
+                                 EServerMethodContext context,
+                                 GCancellable *cancellable,
+                                 const gchar *uid,
+                                 const gchar *rid,
+                                 CalObjModType mod)
 {
 	EwsRemoveData *remove_data;
 	ECalBackendEws *cbews = (ECalBackendEws *) backend;
@@ -1081,12 +1249,18 @@ e_cal_backend_ews_remove_object (ECalBac
 	 */
 	e_data_cal_error_if_fail (E_IS_CAL_BACKEND_EWS (cbews), InvalidArg);
 
+	if (!cal_backend_ews_ensure_connected (cbews, cancellable, &error)) {
+		convert_error_to_edc_error (&error);
+		e_data_cal_respond_remove (cal, context, error);
+		return;
+	}
+
 	priv = cbews->priv;
 
 	PRIV_LOCK (priv);
 
 	comp = e_cal_backend_store_get_component (priv->store, uid, rid);
-	
+
 	if (!rid || !*rid)
 		rid = NULL;
 
@@ -1094,37 +1268,40 @@ e_cal_backend_ews_remove_object (ECalBac
 		parent = e_cal_backend_store_get_component (priv->store, uid, NULL);
 		if (!parent) {
 			g_warning ("EEE Cant find master component with uid:%s\n", uid);
-			g_propagate_error (&error, EDC_ERROR(ObjectNotFound));
+			g_propagate_error (&error, EDC_ERROR (ObjectNotFound));
+			PRIV_UNLOCK (priv);
 			goto exit;
 		}
 	}
-	
+
 	if (!comp && !parent) {
 		g_warning ("EEE Cant find component with uid:%s & rid:%s\n", uid, rid);
-		g_propagate_error (&error, EDC_ERROR(ObjectNotFound));
+		g_propagate_error (&error, EDC_ERROR (ObjectNotFound));
+		PRIV_UNLOCK (priv);
 		goto errorlvl1;
 	}
-	
+
 	ews_cal_component_get_item_id ((comp ? comp : parent), &item_id.id, &item_id.change_key);
 
 	PRIV_UNLOCK (priv);
 
 	if (!item_id.id) {
-		g_propagate_error(&error, EDC_ERROR_EX(OtherError,
-					       "Cannot determine EWS ItemId"));
+		g_propagate_error (
+			&error, EDC_ERROR_EX (OtherError,
+			"Cannot determine EWS ItemId"));
 		goto errorlvl2;
 	}
-	
+
 	if (parent && !comp) {
 		index = e_cal_rid_to_index (backend, rid, e_cal_component_get_icalcomponent (parent), &error);
 		if (error) goto errorlvl2;
 	}
 
 	remove_data = g_new0 (EwsRemoveData, 1);
-	remove_data->cbews = g_object_ref(cbews);
+	remove_data->cbews = g_object_ref (cbews);
 	remove_data->comp = comp;
 	remove_data->parent = parent;
-	remove_data->cal = g_object_ref(cal);
+	remove_data->cal = g_object_ref (cal);
 	remove_data->context = context;
 	remove_data->index = index;
 	remove_data->item_id.id = item_id.id;
@@ -1132,10 +1309,12 @@ e_cal_backend_ews_remove_object (ECalBac
 	remove_data->rid = (rid ? g_strdup (rid) : NULL);
 	remove_data->mod = mod;
 
-	e_ews_connection_delete_item_start (priv->cnc, EWS_PRIORITY_MEDIUM, &remove_data->item_id, index,
-					     EWS_HARD_DELETE, EWS_SEND_TO_NONE, EWS_ALL_OCCURRENCES,
-					     ews_cal_remove_object_cb, NULL,
-					     remove_data);
+	e_ews_connection_delete_item (
+		priv->cnc, EWS_PRIORITY_MEDIUM, &remove_data->item_id, index,
+		EWS_HARD_DELETE, EWS_SEND_TO_NONE, EWS_ALL_OCCURRENCES,
+		priv->cancellable,
+		ews_cal_remove_object_cb,
+		remove_data);
 	return;
 
 errorlvl2:
@@ -1145,8 +1324,9 @@ errorlvl1:
 	if (parent) g_object_unref (parent);
 
 exit:
+	convert_error_to_edc_error (&error);
 	if (context)
-		e_data_cal_respond_remove (cal, context, error);
+		e_data_cal_respond_remove (cal, context, error	);
 	else if (error) {
 		g_warning ("Remove object error :  %s\n", error->message);
 		g_clear_error (&error);
@@ -1168,52 +1348,81 @@ typedef struct {
 	icalcomponent *icalcomp;
 } EwsConvertData;
 
-static void add_attendees_list_to_message(ESoapMessage *msg, const gchar *listname, GSList *list) {
+static void
+add_attendees_list_to_message (ESoapMessage *msg,
+                               const gchar *listname,
+                               GSList *list)
+{
 	GSList *item;
 
-	e_soap_message_start_element(msg, listname, NULL, NULL);
+	e_soap_message_start_element (msg, listname, NULL, NULL);
 
-	for (item = list ; item != NULL; item = item->next) {
-		e_soap_message_start_element(msg, "Attendee", NULL, NULL);
-		e_soap_message_start_element(msg, "Mailbox", NULL, NULL);
+	for (item = list; item != NULL; item = item->next) {
+		e_soap_message_start_element (msg, "Attendee", NULL, NULL);
+		e_soap_message_start_element (msg, "Mailbox", NULL, NULL);
 
-		e_ews_message_write_string_parameter(msg, "EmailAddress", NULL, item->data);
+		e_ews_message_write_string_parameter (msg, "EmailAddress", NULL, item->data);
 
-		e_soap_message_end_element(msg); /* "Mailbox" */
-		e_soap_message_end_element(msg); /* "Attendee" */
+		e_soap_message_end_element (msg); /* "Mailbox" */
+		e_soap_message_end_element (msg); /* "Attendee" */
 	}
 
-	e_soap_message_end_element(msg);
+	e_soap_message_end_element (msg);
+}
+
+static void
+convert_sensitivity_calcomp_to_xml (ESoapMessage *msg,
+				    icalcomponent *icalcomp)
+{
+	icalproperty *prop;
+
+	g_return_if_fail (msg != NULL);
+	g_return_if_fail (icalcomp != NULL);
+
+	prop = icalcomponent_get_first_property (icalcomp, ICAL_CLASS_PROPERTY);
+	if (prop) {
+		icalproperty_class classify = icalproperty_get_class (prop);
+		if (classify == ICAL_CLASS_PUBLIC) {
+			e_ews_message_write_string_parameter (msg, "Sensitivity", NULL, "Normal");
+		} else if (classify == ICAL_CLASS_PRIVATE) {
+			e_ews_message_write_string_parameter (msg, "Sensitivity", NULL, "Private");
+		} else if (classify == ICAL_CLASS_CONFIDENTIAL) {
+			e_ews_message_write_string_parameter (msg, "Sensitivity", NULL, "Personal");
+		}
+	}
 }
 
 static void
-convert_vevent_calcomp_to_xml(ESoapMessage *msg, gpointer user_data)
+convert_vevent_calcomp_to_xml (ESoapMessage *msg,
+                               gpointer user_data)
 {
 	EwsConvertData *convert_data = user_data;
 	icalcomponent *icalcomp = convert_data->icalcomp;
-	ECalComponent *comp = e_cal_component_new();
+	ECalComponent *comp = e_cal_component_new ();
 	GSList *required = NULL, *optional = NULL, *resource = NULL;
 	icaltimetype dtstart, dtend;
 	icalproperty *prop;
 	gboolean has_alarms;
-	const char *value;
+	const gchar *value;
 
-	e_cal_component_set_icalcomponent(comp, icalcomp);
+	e_cal_component_set_icalcomponent (comp, icalcomp);
 
 	/* FORMAT OF A SAMPLE SOAP MESSAGE: http://msdn.microsoft.com/en-us/library/aa564690.aspx */
 
 	/* Prepare CalendarItem node in the SOAP message */
-	e_soap_message_start_element(msg, "CalendarItem", NULL, NULL);
+	e_soap_message_start_element (msg, "CalendarItem", NULL, NULL);
 
 	/* subject */
-	value = icalcomponent_get_summary(icalcomp);
+	value = icalcomponent_get_summary (icalcomp);
 	if (value)
-		e_ews_message_write_string_parameter(msg, "Subject", NULL, value);
+		e_ews_message_write_string_parameter (msg, "Subject", NULL, value);
+
+	convert_sensitivity_calcomp_to_xml (msg, icalcomp);
 
 	/* description */
-	value = icalcomponent_get_description(icalcomp);
+	value = icalcomponent_get_description (icalcomp);
 	if (value)
-		e_ews_message_write_string_parameter_with_attribute(msg, "Body", NULL, value, "BodyType", "Text");
+		e_ews_message_write_string_parameter_with_attribute (msg, "Body", NULL, value, "BodyType", "Text");
 
 	/* set alarms */
 	has_alarms = e_cal_component_has_alarms (comp);
@@ -1226,13 +1435,13 @@ convert_vevent_calcomp_to_xml(ESoapMessa
 	dtstart = icalcomponent_get_dtstart (icalcomp);
 	dtend = icalcomponent_get_dtend (icalcomp);
 
-	ewscal_set_time (msg, "Start", &dtstart);
-	ewscal_set_time (msg, "End", &dtend);
+	ewscal_set_time (msg, "Start", &dtstart, FALSE);
+	ewscal_set_time (msg, "End", &dtend, FALSE);
 	/* We have to do the time zone(s) later, or the server rejects the request */
 
 	/* All day event ? */
 	if (icaltime_is_date (dtstart))
-		e_ews_message_write_string_parameter(msg, "IsAllDayEvent", NULL, "true");
+		e_ews_message_write_string_parameter (msg, "IsAllDayEvent", NULL, "true");
 
 	/*freebusy*/
 	prop = icalcomponent_get_first_property (icalcomp, ICAL_TRANSP_PROPERTY);
@@ -1242,100 +1451,127 @@ convert_vevent_calcomp_to_xml(ESoapMessa
 		e_ews_message_write_string_parameter (msg, "LegacyFreeBusyStatus",NULL,"Busy");
 
 	/* location */
-	value = icalcomponent_get_location(icalcomp);
+	value = icalcomponent_get_location (icalcomp);
 	if (value)
-		e_ews_message_write_string_parameter(msg, "Location", NULL, value);
-	
+		e_ews_message_write_string_parameter (msg, "Location", NULL, value);
+
 	/* collect attendees */
-	e_ews_collect_attendees(icalcomp, &required, &optional, &resource);
+	e_ews_collect_attendees (icalcomp, &required, &optional, &resource);
 
 	if (required != NULL) {
-		add_attendees_list_to_message(msg, "RequiredAttendees", required);
-		g_slist_free(required);
+		add_attendees_list_to_message (msg, "RequiredAttendees", required);
+		g_slist_free (required);
 	}
 	if (optional != NULL) {
-		add_attendees_list_to_message(msg, "OptionalAttendees", optional);
-		g_slist_free(optional);
+		add_attendees_list_to_message (msg, "OptionalAttendees", optional);
+		g_slist_free (optional);
 	}
 	if (resource != NULL) {
-		add_attendees_list_to_message(msg, "Resources", resource);
-		g_slist_free(resource);
+		add_attendees_list_to_message (msg, "Resources", resource);
+		g_slist_free (resource);
 	}
 	/* end of attendees */
 
 	/* Recurrence */
-	prop = icalcomponent_get_first_property(icalcomp, ICAL_RRULE_PROPERTY);
+	prop = icalcomponent_get_first_property (icalcomp, ICAL_RRULE_PROPERTY);
 	if (prop != NULL) {
-		ewscal_set_reccurence(msg, prop, &dtstart);
+		ewscal_set_reccurence (msg, prop, &dtstart);
 	}
 
 	if (0 /* Exchange 2010 detected */ && dtstart.zone != dtend.zone) {
 		/* We have to cast these because libical puts a const pointer into the
-		   icaltimetype, but its basic read-only icaltimezone_foo() functions
-		   take a non-const pointer! */
-		ewscal_set_timezone (msg, "StartTimeZone", (icaltimezone *)dtstart.zone);
-		ewscal_set_timezone (msg, "EndTimeZone", (icaltimezone *)dtstart.zone);
+		 * icaltimetype, but its basic read-only icaltimezone_foo() functions
+		 * take a non-const pointer! */
+		ewscal_set_timezone (msg, "StartTimeZone", (icaltimezone *) dtstart.zone);
+		ewscal_set_timezone (msg, "EndTimeZone", (icaltimezone *) dtstart.zone);
 	} else
-		ewscal_set_timezone (msg, "MeetingTimeZone", (icaltimezone *)(dtstart.zone?dtstart.zone:convert_data->cbews->priv->default_zone));
+		ewscal_set_timezone (msg, "MeetingTimeZone", (icaltimezone *)(dtstart.zone ? dtstart.zone : convert_data->cbews->priv->default_zone));
 
 	// end of "CalendarItem"
-	e_soap_message_end_element(msg);
+	e_soap_message_end_element (msg);
 }
 
 static void
-convert_vtodo_calcomp_to_xml(ESoapMessage *msg, gpointer user_data)
+convert_vtodo_calcomp_to_xml (ESoapMessage *msg,
+                              gpointer user_data)
 {
 	EwsConvertData *convert_data = user_data;
 	icalcomponent *icalcomp = convert_data->icalcomp;
 	icalproperty *prop;
 	icaltimetype dt;
-	int value;
-	char buffer[16];
+	gint value;
+	gchar buffer[16];
 
-	e_soap_message_start_element(msg, "Task", NULL, NULL);
+	e_soap_message_start_element (msg, "Task", NULL, NULL);
 
-	e_ews_message_write_string_parameter(msg, "Subject", NULL, icalcomponent_get_summary(icalcomp));
+	e_ews_message_write_string_parameter (msg, "Subject", NULL, icalcomponent_get_summary (icalcomp));
+
+	convert_sensitivity_calcomp_to_xml (msg, icalcomp);
 
 	e_ews_message_write_string_parameter_with_attribute (msg, "Body", NULL, icalcomponent_get_description (icalcomp), "BodyType", "Text");
 
 	prop = icalcomponent_get_first_property (icalcomp, ICAL_DUE_PROPERTY);
 	if (prop) {
 		dt = icalproperty_get_due (prop);
-		ewscal_set_time (msg, "DueDate", &dt);
+		ewscal_set_time (msg, "DueDate", &dt, TRUE);
 	}
 
 	prop = icalcomponent_get_first_property (icalcomp, ICAL_PERCENTCOMPLETE_PROPERTY);
 	if (prop) {
 		value = icalproperty_get_percentcomplete (prop);
 		snprintf (buffer, 16, "%d", value);
-		e_ews_message_write_string_parameter(msg, "PercentComplete", NULL, buffer);
+		e_ews_message_write_string_parameter (msg, "PercentComplete", NULL, buffer);
 	}
 
 	prop = icalcomponent_get_first_property (icalcomp, ICAL_DTSTART_PROPERTY);
 	if (prop) {
 		dt = icalproperty_get_dtstart (prop);
-		ewscal_set_time (msg, "StartDate", &dt);
+		ewscal_set_time (msg, "StartDate", &dt, TRUE);
 	}
 
 	prop = icalcomponent_get_first_property (icalcomp, ICAL_STATUS_PROPERTY);
 	if (prop) {
 		switch (icalproperty_get_status (prop)) {
 		case ICAL_STATUS_INPROCESS:
-			e_ews_message_write_string_parameter(msg, "Status", NULL, "InProgress");
+			e_ews_message_write_string_parameter (msg, "Status", NULL, "InProgress");
 			break;
 		case ICAL_STATUS_COMPLETED:
-			e_ews_message_write_string_parameter(msg, "Status", NULL, "Completed");
+			e_ews_message_write_string_parameter (msg, "Status", NULL, "Completed");
 			break;
 		default:
 			break;
 		}
 	}
 
-	e_soap_message_end_element(msg); // "Task"
+	e_soap_message_end_element (msg); // "Task"
+}
+
+static void
+convert_vjournal_calcomp_to_xml (ESoapMessage *msg,
+				 gpointer user_data)
+{
+	EwsConvertData *convert_data = user_data;
+	icalcomponent *icalcomp = convert_data->icalcomp;
+	const gchar *text;
+
+	e_soap_message_start_element (msg, "Message", NULL, NULL);
+	e_ews_message_write_string_parameter (msg, "ItemClass", NULL, "IPM.StickyNote");
+
+	e_ews_message_write_string_parameter (msg, "Subject", NULL, icalcomponent_get_summary (icalcomp));
+
+	convert_sensitivity_calcomp_to_xml (msg, icalcomp);
+
+	text = icalcomponent_get_description (icalcomp);
+	if (!text || !*text)
+		text = icalcomponent_get_summary (icalcomp);
+	e_ews_message_write_string_parameter_with_attribute (msg, "Body", NULL, text, "BodyType", "Text");
+
+	e_soap_message_end_element (msg); /* Message */
 }
 
 static void
-convert_calcomp_to_xml(ESoapMessage *msg, gpointer user_data)
+convert_calcomp_to_xml (ESoapMessage *msg,
+                        gpointer user_data)
 {
 	EwsConvertData *convert_data = user_data;
 
@@ -1346,49 +1582,61 @@ convert_calcomp_to_xml(ESoapMessage *msg
 	case ICAL_VTODO_COMPONENT:
 		convert_vtodo_calcomp_to_xml (msg, user_data);
 		break;
+	case ICAL_VJOURNAL_COMPONENT:
+		convert_vjournal_calcomp_to_xml (msg, user_data);
+		break;
 	default:
+		g_warn_if_reached ();
 		break;
 	}
-	
+
 	g_object_unref (convert_data->cbews);
 	g_free (convert_data);
 }
 
-static void
-e_cal_backend_ews_remove_object (ECalBackend *backend, EDataCal *cal, EServerMethodContext context, GCancellable *cancellable,
-				 const gchar *uid, const gchar *rid, CalObjModType mod);
 /*I will unate both type, they are same now*/
 typedef struct {
-	ECalBackendEws *cbews;
-	ECalComponent *comp;
-	int cb_type; /* 0 - nothing, 1 - create, 2 - update */
-	EDataCal *cal;
+        ECalBackendEws *cbews;
+        ECalComponent *comp;
+        gint cb_type; /* 0 - nothing,
+                                 1 - create,
+                                 2 - update */
+        EDataCal *cal;
 	EServerMethodContext context;
-	ECalComponent *oldcomp;
-	gchar *itemid;
-	gchar *changekey;
+        ECalComponent *oldcomp;
+        gchar *itemid;
+        gchar *changekey;
 
 } EwsAttachmentsData;
 
 typedef struct {
-	ECalBackendEws *cbews;
-	EDataCal *cal;
-	ECalComponent *comp;
-	ECalComponent *oldcomp;
+        ECalBackendEws *cbews;
+        EDataCal *cal;
+        ECalComponent *comp;
+        ECalComponent *oldcomp;
 	EServerMethodContext context;
-	gchar *itemid;
-	gchar *changekey;
+        gchar *itemid;
+        gchar *changekey;
 } EwsModifyData;
 
 static void
-e_cal_backend_ews_modify_object (ECalBackend *backend, EDataCal *cal, EServerMethodContext context, GCancellable *cancellable,
-				 const gchar *calobj, CalObjModType mod);
-
-static void convert_component_to_updatexml (ESoapMessage *msg, gpointer user_data);
-static void ews_cal_modify_object_cb (GObject *object, GAsyncResult *res, gpointer user_data);
-
-static void
-ews_create_attachments_cb(GObject *object, GAsyncResult *res, gpointer user_data)
+e_cal_backend_ews_modify_object (ECalBackend *backend,
+                                 EDataCal *cal,
+                                 EServerMethodContext context,
+                                 GCancellable *cancellable,
+                                 const gchar *calobj,
+                                 CalObjModType mod);
+
+static void convert_component_to_updatexml (ESoapMessage *msg,
+                                 gpointer user_data);
+static void ews_cal_modify_object_cb (GObject *object,
+                                 GAsyncResult *res,
+                                 gpointer user_data);
+
+static void
+ews_create_attachments_cb (GObject *object,
+                                 GAsyncResult *res,
+                                 gpointer user_data)
 {
 	EEwsConnection *cnc = E_EWS_CONNECTION (object);
 	EwsAttachmentsData *create_data = user_data;
@@ -1411,7 +1659,7 @@ ews_create_attachments_cb(GObject *objec
 	}
 
 	/* get exclusive access to the store */
-	e_cal_backend_store_freeze_changes(priv->store);
+	e_cal_backend_store_freeze_changes (priv->store);
 
 	/* Update change key. id remains the same, but change key changed.*/
 	icalcomp = e_cal_component_get_icalcomponent (create_data->comp);
@@ -1439,7 +1687,7 @@ ews_create_attachments_cb(GObject *objec
 	/* update changes and release access to the store */
 	e_cal_backend_store_thaw_changes (priv->store);
 
-	e_cal_component_get_uid(create_data->comp, &comp_uid);
+	e_cal_component_get_uid (create_data->comp, &comp_uid);
 	if (create_data->cb_type == 1) {
 		/*In case we have attendees we have to fake update items,
 		* this is the only way to pass attachments in meeting invite mail*/
@@ -1448,8 +1696,10 @@ ews_create_attachments_cb(GObject *objec
 			e_cal_backend_ews_modify_object ((ECalBackend *) create_data->cbews, create_data->cal, 0, NULL, icalcomponent_as_ical_string (icalcomp), CALOBJ_MOD_ALL);
 		}
 	} else if (create_data->cb_type == 2) {
-		const char *send_meeting_invitations;
-		EwsModifyData* modify_data;
+		const gchar *send_meeting_invitations;
+		const gchar *send_or_save;
+		EwsModifyData * modify_data;
+
 		modify_data = g_new0 (EwsModifyData, 1);
 		modify_data->cbews = g_object_ref (create_data->cbews);
 		modify_data->comp = create_data->comp;
@@ -1458,23 +1708,27 @@ ews_create_attachments_cb(GObject *objec
 		modify_data->context = create_data->context;
 		modify_data->itemid = create_data->itemid;
 		modify_data->changekey = change_key;
-		
-		if (e_cal_component_has_attendees (create_data->comp))
+
+		if (e_cal_component_has_attendees (create_data->comp)) {
 			send_meeting_invitations = "SendToAllAndSaveCopy";
-		else
+			send_or_save = "SendAndSaveCopy";
+		} else {
 			/*In case of appointment we have to set SendMeetingInvites to SendToNone */
 			send_meeting_invitations = "SendToNone";
-		
-		e_ews_connection_update_items_start (priv->cnc, EWS_PRIORITY_MEDIUM,
-						     "AlwaysOverwrite",
-						     "SendAndSaveCopy",
-						     send_meeting_invitations,
-						     priv->folder_id,
-						     convert_component_to_updatexml,
-						     modify_data,
-						     ews_cal_modify_object_cb,
-						     NULL,
-						     modify_data);
+			send_or_save = "SaveOnly";
+		}
+
+		e_ews_connection_update_items (
+			priv->cnc, EWS_PRIORITY_MEDIUM,
+			"AlwaysOverwrite",
+			send_or_save,
+			send_meeting_invitations,
+			priv->folder_id,
+			convert_component_to_updatexml,
+			modify_data,
+			priv->cancellable,
+			ews_cal_modify_object_cb,
+			modify_data);
 	}
 
 	g_slist_free (ids);
@@ -1487,7 +1741,9 @@ ews_create_attachments_cb(GObject *objec
 }
 
 static void
-ews_create_object_cb(GObject *object, GAsyncResult *res, gpointer user_data)
+ews_create_object_cb (GObject *object,
+                      GAsyncResult *res,
+                      gpointer user_data)
 {
 	EEwsConnection *cnc = E_EWS_CONNECTION (object);
 	EwsCreateData *create_data = user_data;
@@ -1499,44 +1755,55 @@ ews_create_object_cb(GObject *object, GA
 	const EwsId *item_id;
 	icalproperty *icalprop;
 	icalcomponent *icalcomp;
+	gchar *comp_str;
 	guint n_attach;
-	gboolean result;
 	EEwsItem *item;
-	gchar *comp_str;
 
 	/* get a list of ids from server (single item) */
-	e_ews_connection_create_items_finish(cnc, res, &ids, &error);
+	e_ews_connection_create_items_finish (cnc, res, &ids, &error);
 
 	/* make sure there was no error */
 	if (error != NULL) {
-		e_data_cal_respond_create_object(create_data->cal, create_data->context, error, NULL, NULL);
+		convert_error_to_edc_error (&error);
+		e_data_cal_respond_create_object (create_data->cal, create_data->context, error, NULL, NULL);
 		return;
 	}
 
-	item = (EEwsItem *)ids->data;
+	item = (EEwsItem *) ids->data;
 	item_id = e_ews_item_get_id (item);
 	g_slist_free (ids);
 
-	if (e_ews_item_get_item_type (item) == E_EWS_ITEM_TYPE_CALENDAR_ITEM) {
+	if (e_ews_item_get_item_type (item) == E_EWS_ITEM_TYPE_EVENT) {
 
 		items = g_slist_append (items, item_id->id);
 
 		/* get calender uid from server*/
-		result = e_ews_connection_get_items (cnc, EWS_PRIORITY_MEDIUM,
+		e_ews_connection_get_items_sync (
+			cnc, EWS_PRIORITY_MEDIUM,
 			items,
 			"IdOnly",
 			"calendar:UID",
-			FALSE, NULL,
+			FALSE, NULL, E_EWS_BODY_TYPE_TEXT,
 			&items_req,
-			NULL, NULL, NULL, &error);
+			NULL, NULL, priv->cancellable, &error);
 		if (!res && error != NULL) {
 			if (items_req)
-				g_slist_free (items_req);
+				g_slist_free_full (items_req, g_object_unref);
+			convert_error_to_edc_error (&error);
 			e_data_cal_respond_create_object (create_data->cal, create_data->context, error, NULL, NULL);
 			return;
 		}
 
 		item = (EEwsItem *) items_req->data;
+		if (e_ews_item_get_item_type (item) == E_EWS_ITEM_TYPE_ERROR) {
+			error = g_error_copy (e_ews_item_get_error (item));
+			g_slist_free_full (items_req, g_object_unref);
+
+			convert_error_to_edc_error (&error);
+			e_data_cal_respond_create_object (create_data->cal, create_data->context, error, NULL, NULL);
+			return;
+		}
+
 		item_id = e_ews_item_get_id (item);
 
 		g_slist_free (items);
@@ -1546,7 +1813,7 @@ ews_create_object_cb(GObject *object, GA
 	/* attachments */
 	n_attach = e_cal_component_get_num_attachments (create_data->comp);
 	if (n_attach > 0) {
-		EwsAttachmentsData *attach_data = g_new0(EwsAttachmentsData, 1);
+		EwsAttachmentsData *attach_data = g_new0 (EwsAttachmentsData, 1);
 
 		attach_data->cbews = g_object_ref (create_data->cbews);
 		attach_data->comp = g_object_ref (create_data->comp);
@@ -1555,51 +1822,53 @@ ews_create_object_cb(GObject *object, GA
 		attach_data->cb_type = 1;
 
 		e_cal_component_get_attachment_list (create_data->comp, &attachments);
-		e_ews_connection_create_attachments_start (cnc, EWS_PRIORITY_MEDIUM,
-							   item_id, attachments,
-							   ews_create_attachments_cb, NULL, attach_data);
+		e_ews_connection_create_attachments (
+			cnc, EWS_PRIORITY_MEDIUM,
+			item_id, attachments,
+			priv->cancellable,
+			ews_create_attachments_cb,
+			attach_data);
 
-		for (i = attachments; i ; i = i->next) g_free (i->data);
+		for (i = attachments; i; i = i->next) g_free (i->data);
 		g_slist_free (attachments);
 	}
 
 	/* get exclusive access to the store */
-	e_cal_backend_store_freeze_changes(priv->store);
+	e_cal_backend_store_freeze_changes (priv->store);
 
 	/* set a new ical property containing the change key we got from the exchange server for future use */
-	if (e_ews_item_get_item_type (item) == E_EWS_ITEM_TYPE_CALENDAR_ITEM)
+	if (e_ews_item_get_item_type (item) == E_EWS_ITEM_TYPE_EVENT)
 		e_cal_component_set_uid (create_data->comp, e_ews_item_get_uid (item));
 	else
 		e_cal_component_set_uid (create_data->comp, item_id->id);
 
 	icalprop = icalproperty_new_x (item_id->id);
 	icalproperty_set_x_name (icalprop, "X-EVOLUTION-ITEMID");
-	icalcomp = e_cal_component_get_icalcomponent(create_data->comp);
+	icalcomp = e_cal_component_get_icalcomponent (create_data->comp);
 	icalcomponent_add_property (icalcomp, icalprop);
 
 	icalprop = icalproperty_new_x (item_id->change_key);
 	icalproperty_set_x_name (icalprop, "X-EVOLUTION-CHANGEKEY");
-	icalcomp = e_cal_component_get_icalcomponent(create_data->comp);
+	icalcomp = e_cal_component_get_icalcomponent (create_data->comp);
 	icalcomponent_add_property (icalcomp, icalprop);
 
 	/* update component internal data */
-	e_cal_component_commit_sequence(create_data->comp);
+	e_cal_component_commit_sequence (create_data->comp);
 	put_component_to_store (create_data->cbews, create_data->comp);
 
-	
-	e_cal_component_get_uid(create_data->comp, &comp_uid);
+	e_cal_component_get_uid (create_data->comp, &comp_uid);
 
-	comp_str = e_cal_component_get_as_string(create_data->comp);
+	convert_error_to_edc_error (&error);
+	comp_str = e_cal_component_get_as_string (create_data->comp);
 	e_data_cal_respond_create_object (create_data->cal, create_data->context, error, comp_uid, comp_str);
-	
+
 	/* notify the backend and the application that a new object was created */
 	e_cal_backend_notify_object_created (E_CAL_BACKEND(create_data->cbews), comp_str);
-
 	g_free (comp_str);
 
 	/* place new component in our cache */
 	PRIV_LOCK (priv);
-	g_hash_table_insert (priv->item_id_hash, g_strdup(item_id->id), g_object_ref (create_data->comp));
+	g_hash_table_insert (priv->item_id_hash, g_strdup (item_id->id), g_object_ref (create_data->comp));
 	PRIV_UNLOCK (priv);
 
 	/* update changes and release access to the store */
@@ -1607,29 +1876,30 @@ ews_create_object_cb(GObject *object, GA
 
 	/* Excluded occurrences */
 	g_clear_error (&error);
-	icalprop = icalcomponent_get_first_property(icalcomp, ICAL_RRULE_PROPERTY);
+	icalprop = icalcomponent_get_first_property (icalcomp, ICAL_RRULE_PROPERTY);
 	if (icalprop != NULL) {
-		icalprop = icalcomponent_get_first_property(icalcomp, ICAL_EXDATE_PROPERTY);
-		for (; icalprop; icalprop = icalcomponent_get_next_property(icalcomp, ICAL_EXDATE_PROPERTY)) {
+		icalprop = icalcomponent_get_first_property (icalcomp, ICAL_EXDATE_PROPERTY);
+		for (; icalprop; icalprop = icalcomponent_get_next_property (icalcomp, ICAL_EXDATE_PROPERTY)) {
 			exceptions = g_slist_prepend (exceptions, g_strdup (icalproperty_get_value_as_string (icalprop)));
 		}
 
 		for (i = exceptions; i; i = i->next) {
-			e_cal_backend_ews_remove_object (E_CAL_BACKEND (create_data->cbews), create_data->cal, 0, NULL,
-							 comp_uid, i->data, CALOBJ_MOD_THIS);
+			e_cal_backend_ews_remove_object (
+				E_CAL_BACKEND (create_data->cbews), create_data->cal, 0, NULL,
+				comp_uid, i->data, CALOBJ_MOD_THIS);
 		}
 
-		g_slist_foreach (exceptions, (GFunc)g_free, NULL);
+		g_slist_foreach (exceptions, (GFunc) g_free, NULL);
 		g_slist_free (exceptions);
 	}
 
 	/* no need to keep reference to the object */
-	g_object_unref(create_data->comp);
+	g_object_unref (create_data->comp);
 
 	/* free memory allocated for create_data & unref contained objects */
-	g_object_unref(create_data->cbews);
-	g_object_unref(create_data->cal);
-	g_free(create_data);
+	g_object_unref (create_data->cbews);
+	g_object_unref (create_data->cal);
+	g_free (create_data);
 }
 
 struct TzidCbData {
@@ -1637,7 +1907,7 @@ struct TzidCbData {
 	ECalBackendEws *cbews;
 };
 
-static void tzid_cb(icalparameter *param, void *data)
+static void tzid_cb (icalparameter *param, gpointer data)
 {
 	struct TzidCbData *cbd = data;
 	const gchar *tzid;
@@ -1648,22 +1918,27 @@ static void tzid_cb(icalparameter *param
 	if (!tzid)
 		return;
 
-	zone = resolve_tzid(tzid, cbd->cbews);
+	zone = resolve_tzid (tzid, cbd->cbews);
 	if (!zone)
 		return;
 
-	new_comp = icaltimezone_get_component(zone);
+	new_comp = icaltimezone_get_component (zone);
 	if (!new_comp)
 		return;
 
-	icalcomponent_add_component(cbd->comp, icalcomponent_new_clone (new_comp));
+	icalcomponent_add_component (cbd->comp, icalcomponent_new_clone (new_comp));
 }
 
 static void
-e_cal_backend_ews_create_object (ECalBackend *backend, EDataCal *cal, EServerMethodContext context, GCancellable *cancellable, const gchar *calobj)
+e_cal_backend_ews_create_object (ECalBackend *backend,
+                                 EDataCal *cal,
+                                 EServerMethodContext context,
+                                 GCancellable *cancellable,
+                                 const gchar *calobj)
 {
 	EwsCreateData *create_data;
 	EwsConvertData *convert_data;
+	EwsFolderId *fid;
 	ECalBackendEws *cbews;
 	ECalBackendEwsPrivate *priv;
 	icalcomponent_kind kind;
@@ -1671,21 +1946,25 @@ e_cal_backend_ews_create_object (ECalBac
 	ECalComponent *comp;
 	struct icaltimetype current;
 	GError *error = NULL;
-	const char *send_meeting_invitations;
+	const gchar *send_meeting_invitations;
 	struct TzidCbData cbd;
 
 	/* sanity check */
-	e_data_cal_error_if_fail(E_IS_CAL_BACKEND_EWS(backend), InvalidArg);
-	e_data_cal_error_if_fail(calobj != NULL && *calobj != '\0', InvalidArg);
+	e_data_cal_error_if_fail (E_IS_CAL_BACKEND_EWS (backend), InvalidArg);
+	e_data_cal_error_if_fail (calobj != NULL && *calobj != '\0', InvalidArg);
 
-	cbews = E_CAL_BACKEND_EWS(backend);
+	cbews = E_CAL_BACKEND_EWS (backend);
 	priv = cbews->priv;
 
-	kind = e_cal_backend_get_kind(E_CAL_BACKEND(backend));
+	kind = e_cal_backend_get_kind (E_CAL_BACKEND (backend));
 
 	/* make sure we're not offline */
-	if (priv->mode == CAL_MODE_LOCAL) {
-		g_propagate_error(&error, EDC_ERROR(RepositoryOffline));
+	if (!e_cal_backend_ews_get_online (E_CAL_BACKEND_EWS (backend))) {
+		g_propagate_error (&error, EDC_ERROR (RepositoryOffline));
+		goto exit;
+	}
+
+	if (!cal_backend_ews_ensure_connected (cbews, cancellable, &error)) {
 		goto exit;
 	}
 
@@ -1693,20 +1972,20 @@ e_cal_backend_ews_create_object (ECalBac
 	comp =  e_cal_component_new_from_string (calobj);
 	if (comp == NULL) {
 		g_propagate_error (&error, EDC_ERROR (InvalidObject));
-		return;
+		goto exit;
 	}
-	icalcomp = e_cal_component_get_icalcomponent(comp);
+	icalcomp = e_cal_component_get_icalcomponent (comp);
 
 	/* make sure data was parsed properly */
 	if (!icalcomp) {
-		g_propagate_error(&error, EDC_ERROR(InvalidObject));
+		g_propagate_error (&error, EDC_ERROR (InvalidObject));
 		goto exit;
 	}
 
 	/* make sure ical data we parse is actually an ical component */
-	if (kind != icalcomponent_isa(icalcomp)) {
-		icalcomponent_free(icalcomp);
-		g_propagate_error(&error, EDC_ERROR(InvalidObject));
+	if (kind != icalcomponent_isa (icalcomp)) {
+		icalcomponent_free (icalcomp);
+		g_propagate_error (&error, EDC_ERROR (InvalidObject));
 		goto exit;
 	}
 
@@ -1715,17 +1994,17 @@ e_cal_backend_ews_create_object (ECalBac
 	 * them using the vtimezones in the current calendar */
 	cbd.cbews = cbews;
 	cbd.comp = icalcomp;
-	icalcomponent_foreach_tzid(icalcomp, tzid_cb, &cbd);
+	icalcomponent_foreach_tzid (icalcomp, tzid_cb, &cbd);
 
 	/* prepare new calender component */
-	current = icaltime_current_time_with_zone(icaltimezone_get_utc_timezone());
-	e_cal_component_set_created(comp, &current);
-	e_cal_component_set_last_modified(comp, &current);
+	current = icaltime_current_time_with_zone (icaltimezone_get_utc_timezone ());
+	e_cal_component_set_created (comp, &current);
+	e_cal_component_set_last_modified (comp, &current);
 
-	create_data = g_new0(EwsCreateData, 1);
-	create_data->cbews = g_object_ref(cbews);
+	create_data = g_new0 (EwsCreateData, 1);
+	create_data->cbews = g_object_ref (cbews);
 	create_data->comp = comp;
-	create_data->cal = g_object_ref(cal);
+	create_data->cal = g_object_ref (cal);
 	create_data->context = context;
 
 	convert_data = g_new0 (EwsConvertData, 1);
@@ -1746,31 +2025,39 @@ e_cal_backend_ews_create_object (ECalBac
 		/*In case of appointment we have to set SendMeetingInvites to SendToNone */
 		send_meeting_invitations = "SendToNone";
 
-	e_ews_connection_create_items_start (priv->cnc,
-					     EWS_PRIORITY_MEDIUM,
-					     "SaveOnly",
-					     send_meeting_invitations,
-					     priv->folder_id,
-					     convert_calcomp_to_xml,
-					     convert_data,
-					     ews_create_object_cb,
-					     cancellable,
-					     create_data);
+	fid = e_ews_folder_id_new (priv->folder_id, NULL, FALSE);
+
+	e_ews_connection_create_items (
+		priv->cnc,
+		EWS_PRIORITY_MEDIUM,
+		"SaveOnly",
+		send_meeting_invitations,
+		fid,
+		convert_calcomp_to_xml,
+		convert_data,
+		cancellable,
+		ews_create_object_cb,
+		create_data);
+
+	e_ews_folder_id_free (fid);
+
 	return;
 
 exit:
-	e_data_cal_respond_create_object(cal, context, error, NULL, NULL);
+	convert_error_to_edc_error (&error);
+	e_data_cal_respond_create_object (cal, context, error, NULL, NULL);
 }
 
 static void
-ews_cal_modify_object_cb (GObject *object, GAsyncResult *res, gpointer user_data)
+ews_cal_modify_object_cb (GObject *object,
+                          GAsyncResult *res,
+                          gpointer user_data)
 {
 	EEwsConnection *cnc = E_EWS_CONNECTION (object);
 	EwsModifyData *modify_data = user_data;
 	ECalBackendEws *cbews = modify_data->cbews;
 	ECalBackendEwsPrivate *priv = cbews->priv;
 	GError *error = NULL;
-	gchar *comp_str = NULL, *comp_str_old = NULL;
 	GSList *ids = NULL;
 	const EwsId *item_id;
 	icalproperty *icalprop = NULL;
@@ -1779,9 +2066,7 @@ ews_cal_modify_object_cb (GObject *objec
 	const gchar *x_name;
 
 	if (!e_ews_connection_update_items_finish (cnc, res, &ids, &error)) {
-		/* The calendar UI doesn't *display* errors unless they have
-		   the OtherError code */
-		error->code = OtherError;
+		convert_error_to_edc_error (&error);
 		if (modify_data->context)
 			e_data_cal_respond_modify_object (modify_data->cal, modify_data->context, error, NULL, NULL);
 		goto exit;
@@ -1790,9 +2075,9 @@ ews_cal_modify_object_cb (GObject *objec
 	g_object_ref (modify_data->comp);
 	g_object_ref (modify_data->oldcomp);
 
-	e_cal_backend_store_freeze_changes(priv->store);
+	e_cal_backend_store_freeze_changes (priv->store);
 
-	item_id = e_ews_item_get_id((EEwsItem *)ids->data);
+	item_id = e_ews_item_get_id ((EEwsItem *) ids->data);
 
 	/* Update change key. id remains the same, but change key changed.*/
 	icalcomp = e_cal_component_get_icalcomponent (modify_data->comp);
@@ -1811,12 +2096,18 @@ ews_cal_modify_object_cb (GObject *objec
 	e_cal_backend_store_remove_component (cbews->priv->store, id->uid, id->rid);
 	put_component_to_store (cbews, modify_data->comp);
 
-	comp_str = e_cal_component_get_as_string (modify_data->comp);
-	comp_str_old = e_cal_component_get_as_string (modify_data->oldcomp);
-
 	if (modify_data->context) {
+		gchar *comp_str_old, *comp_str;
+
+		comp_str = e_cal_component_get_as_string (modify_data->comp);
+		comp_str_old = e_cal_component_get_as_string (modify_data->oldcomp);
+
 		e_cal_backend_notify_object_modified (E_CAL_BACKEND (cbews), comp_str_old, comp_str);
+		convert_error_to_edc_error (&error);
 		e_data_cal_respond_modify_object (modify_data->cal, modify_data->context, error, comp_str_old, comp_str);
+
+		g_free (comp_str_old);
+		g_free (comp_str);
 	}
 	else if (error) {
 		g_warning ("Modify object error :  %s\n", error->message);
@@ -1824,28 +2115,31 @@ ews_cal_modify_object_cb (GObject *objec
 	} else ews_start_sync (modify_data->cbews);
 
 	PRIV_LOCK (priv);
-	g_hash_table_replace (priv->item_id_hash, g_strdup(modify_data->itemid), g_object_ref (modify_data->comp));
+	g_hash_table_replace (priv->item_id_hash, g_strdup (modify_data->itemid), g_object_ref (modify_data->comp));
 	PRIV_UNLOCK (priv);
 
 	e_cal_backend_store_thaw_changes (priv->store);
 
 	icalproperty_free (icalprop);
 	e_cal_component_free_id (id);
-	g_free(comp_str);
-	g_free(comp_str_old);
 
 exit:
-	g_free(modify_data->itemid);
-	g_free(modify_data->changekey);
-	g_object_unref(modify_data->comp);
-	g_object_unref(modify_data->oldcomp);
-	g_object_unref(modify_data->cbews);
-	g_object_unref(modify_data->cal);
-	g_free(modify_data);
+	g_free (modify_data->itemid);
+	g_free (modify_data->changekey);
+	g_object_unref (modify_data->comp);
+	g_object_unref (modify_data->oldcomp);
+	g_object_unref (modify_data->cbews);
+	g_object_unref (modify_data->cal);
+	g_free (modify_data);
 }
 
 static void
-convert_vevent_property_to_updatexml (ESoapMessage *msg, const gchar *name, const gchar *value, const gchar * prefix, const gchar *attr_name, const gchar *attr_value)
+convert_vevent_property_to_updatexml (ESoapMessage *msg,
+                                      const gchar *name,
+                                      const gchar *value,
+                                      const gchar *prefix,
+                                      const gchar *attr_name,
+                                      const gchar *attr_value)
 {
 	e_ews_message_start_set_item_field (msg, name, prefix, "CalendarItem");
 	e_ews_message_write_string_parameter_with_attribute (msg, name, NULL, value, attr_name, attr_value);
@@ -1853,7 +2147,8 @@ convert_vevent_property_to_updatexml (ES
 }
 
 static void
-convert_vevent_component_to_updatexml(ESoapMessage *msg, gpointer user_data)
+convert_vevent_component_to_updatexml (ESoapMessage *msg,
+                                       gpointer user_data)
 {
 	EwsModifyData *modify_data = user_data;
 	icalcomponent *icalcomp = e_cal_component_get_icalcomponent (modify_data->comp);
@@ -1861,45 +2156,59 @@ convert_vevent_component_to_updatexml(ES
 	GSList *required = NULL, *optional = NULL, *resource = NULL;
 	icaltimetype dtstart, dtend, dtstart_old, dtend_old;
 	icalproperty *prop, *transp;
-	const char *org_email_address = NULL, *value = NULL, *old_value = NULL;
+	const gchar *org_email_address = NULL, *value = NULL, *old_value = NULL;
 	gboolean has_alarms, has_alarms_old, dt_changed = FALSE;
 	gint alarm = 0, alarm_old = 0;
 	gchar *recid;
 	GError *error = NULL;
 
 	/* Modifying a recurring meeting ? */
-	if (icalcomponent_get_first_property(icalcomp_old, ICAL_RRULE_PROPERTY) != NULL) {
+	if (icalcomponent_get_first_property (icalcomp_old, ICAL_RRULE_PROPERTY) != NULL) {
 		/* A single occurrence ? */
-		prop = icalcomponent_get_first_property(icalcomp, ICAL_RECURRENCEID_PROPERTY);
+		prop = icalcomponent_get_first_property (icalcomp, ICAL_RECURRENCEID_PROPERTY);
 		if (prop != NULL) {
 			recid = icalproperty_get_value_as_string_r (prop);
-			e_ews_message_start_item_change (msg, E_EWS_ITEMCHANGE_TYPE_OCCURRENCEITEM,
-					 modify_data->itemid, modify_data->changekey, e_cal_rid_to_index (E_CAL_BACKEND (modify_data->cbews), recid, icalcomp_old, &error));
+			e_ews_message_start_item_change (
+				msg, E_EWS_ITEMCHANGE_TYPE_OCCURRENCEITEM,
+				modify_data->itemid, modify_data->changekey, e_cal_rid_to_index (E_CAL_BACKEND (modify_data->cbews), recid, icalcomp_old, &error));
 			free (recid);
 		} else {
-			e_ews_message_start_item_change (msg, E_EWS_ITEMCHANGE_TYPE_ITEM,
-					 modify_data->itemid, modify_data->changekey, 0);
+			e_ews_message_start_item_change (
+				msg, E_EWS_ITEMCHANGE_TYPE_ITEM,
+				modify_data->itemid, modify_data->changekey, 0);
 		}
 	} else e_ews_message_start_item_change (msg, E_EWS_ITEMCHANGE_TYPE_ITEM,
-					 modify_data->itemid, modify_data->changekey, 0);
+		modify_data->itemid, modify_data->changekey, 0);
 
 	/* subject */
 	value = icalcomponent_get_summary (icalcomp);
 	old_value = icalcomponent_get_summary (icalcomp_old);
-	if ((value && old_value && g_ascii_strcasecmp (value, old_value)) || 
+	if ((value && old_value && g_ascii_strcasecmp (value, old_value)) ||
 	 (value && old_value == NULL)) {
-			convert_vevent_property_to_updatexml (msg, "Subject", value, "item", NULL, NULL);
+		convert_vevent_property_to_updatexml (msg, "Subject", value, "item", NULL, NULL);
 	} else if (!value && old_value)
-			convert_vevent_property_to_updatexml (msg, "Subject", "", "item", NULL, NULL);
+		convert_vevent_property_to_updatexml (msg, "Subject", "", "item", NULL, NULL);
+
+	prop = icalcomponent_get_first_property (icalcomp, ICAL_CLASS_PROPERTY);
+	if (prop) {
+		icalproperty_class classify = icalproperty_get_class (prop);
+		if (classify == ICAL_CLASS_PUBLIC) {
+			convert_vevent_property_to_updatexml (msg, "Sensitivity", "Normal", "item", NULL, NULL);
+		} else if (classify == ICAL_CLASS_PRIVATE) {
+			convert_vevent_property_to_updatexml (msg, "Sensitivity", "Private", "item", NULL, NULL);
+		} else if (classify == ICAL_CLASS_CONFIDENTIAL) {
+			convert_vevent_property_to_updatexml (msg, "Sensitivity", "Personal", "item", NULL, NULL);
+		}
+	}
 
 	/*description*/
 	value = icalcomponent_get_description (icalcomp);
 	old_value = icalcomponent_get_description (icalcomp_old);
-	if ((value && old_value && g_ascii_strcasecmp (value, old_value)) || 
+	if ((value && old_value && g_ascii_strcasecmp (value, old_value)) ||
 	 (value && old_value == NULL)) {
-			convert_vevent_property_to_updatexml (msg, "Body", value, "item", "BodyType", "Text");
+		convert_vevent_property_to_updatexml (msg, "Body", value, "item", "BodyType", "Text");
 	} else if (!value && old_value)
-			convert_vevent_property_to_updatexml (msg, "Body", "", "item", "BodyType", "Text");
+		convert_vevent_property_to_updatexml (msg, "Body", "", "item", "BodyType", "Text");
 
 	/*update alarm items*/
 	has_alarms = e_cal_component_has_alarms (modify_data->comp);
@@ -1909,7 +2218,7 @@ convert_vevent_component_to_updatexml(ES
 		if (has_alarms_old)
 			alarm_old = ews_get_alarm (modify_data->oldcomp);
 		if (!(alarm == alarm_old)) {
-			char buf[20];
+			gchar buf[20];
 			snprintf (buf, 20, "%d", alarm);
 			convert_vevent_property_to_updatexml (msg, "ReminderIsSet", "true", "item", NULL, NULL);
 			convert_vevent_property_to_updatexml (msg, "ReminderMinutesBeforeStart", buf, "item", NULL, NULL);
@@ -1920,11 +2229,11 @@ convert_vevent_component_to_updatexml(ES
 	/*location*/
 	value = icalcomponent_get_location (icalcomp);
 	old_value = icalcomponent_get_location (icalcomp_old);
-	if ((value && old_value && g_ascii_strcasecmp (value, old_value)) || 
+	if ((value && old_value && g_ascii_strcasecmp (value, old_value)) ||
 	 (value && old_value == NULL)) {
-			convert_vevent_property_to_updatexml (msg, "Location", value, "calendar", NULL, NULL);
+		convert_vevent_property_to_updatexml (msg, "Location", value, "calendar", NULL, NULL);
 	} else if (!value && old_value)
-			convert_vevent_property_to_updatexml (msg, "Location", "", "calendar", NULL, NULL);
+		convert_vevent_property_to_updatexml (msg, "Location", "", "calendar", NULL, NULL);
 
 	/*freebusy*/
 	transp = icalcomponent_get_first_property (icalcomp, ICAL_TRANSP_PROPERTY);
@@ -1951,14 +2260,14 @@ convert_vevent_component_to_updatexml(ES
 	dtend_old = icalcomponent_get_dtend (icalcomp_old);
 	if (icaltime_compare (dtstart, dtstart_old) != 0) {
 		e_ews_message_start_set_item_field (msg, "Start", "calendar","CalendarItem");
-		ewscal_set_time (msg, "Start", &dtstart);
+		ewscal_set_time (msg, "Start", &dtstart, FALSE);
 		e_ews_message_end_set_item_field (msg);
 		dt_changed = TRUE;
 	}
 
 	if (icaltime_compare (dtend, dtend_old) != 0) {
 		e_ews_message_start_set_item_field (msg, "End", "calendar", "CalendarItem");
-		ewscal_set_time (msg, "End", &dtend);
+		ewscal_set_time (msg, "End", &dtend, FALSE);
 		e_ews_message_end_set_item_field (msg);
 		dt_changed = TRUE;
 	}
@@ -1972,12 +2281,12 @@ convert_vevent_component_to_updatexml(ES
 	}
 
 	/*need to test it*/
-	e_ews_collect_attendees(icalcomp, &required, &optional, &resource);
+	e_ews_collect_attendees (icalcomp, &required, &optional, &resource);
 	if (required != NULL) {
 		e_ews_message_start_set_item_field (msg, "RequiredAttendees", "calendar", "CalendarItem");
 
 		add_attendees_list_to_message (msg, "RequiredAttendees", required);
-		g_slist_free(required);
+		g_slist_free (required);
 
 		e_ews_message_end_set_item_field (msg);
 	}
@@ -1985,7 +2294,7 @@ convert_vevent_component_to_updatexml(ES
 		e_ews_message_start_set_item_field (msg, "OptionalAttendees", "calendar", "CalendarItem");
 
 		add_attendees_list_to_message (msg, "OptionalAttendees", optional);
-		g_slist_free(optional);
+		g_slist_free (optional);
 
 		e_ews_message_end_set_item_field (msg);
 	}
@@ -1993,7 +2302,7 @@ convert_vevent_component_to_updatexml(ES
 		e_ews_message_start_set_item_field (msg, "Resources", "calendar", "CalendarItem");
 
 		add_attendees_list_to_message (msg, "Resources", resource);
-		g_slist_free(resource);
+		g_slist_free (resource);
 
 		e_ews_message_end_set_item_field (msg);
 	}
@@ -2009,24 +2318,24 @@ convert_vevent_component_to_updatexml(ES
 
 	if (prop != NULL && g_strcmp0 (value, old_value)) {
 		e_ews_message_start_set_item_field (msg, "Recurrence", "calendar", "CalendarItem");
-		ewscal_set_reccurence(msg, prop, &dtstart);
+		ewscal_set_reccurence (msg, prop, &dtstart);
 		e_ews_message_end_set_item_field (msg);
 	}
 
 	if (0 /* Exchange 2010 detected */ && dtstart.zone != dtend.zone) {
 		if (dtstart.zone) {
 			e_ews_message_start_set_item_field (msg, "StartTimeZone", "calendar", "CalendarItem");
-			ewscal_set_timezone (msg, "StartTimeZone", (icaltimezone *)dtstart.zone);
+			ewscal_set_timezone (msg, "StartTimeZone", (icaltimezone *) dtstart.zone);
 			e_ews_message_end_set_item_field (msg);
 		}
 		if (dtend.zone) {
 			e_ews_message_start_set_item_field (msg, "EndTimeZone", "calendar", "CalendarItem");
-			ewscal_set_timezone (msg, "EndTimeZone", (icaltimezone *)dtend.zone);
+			ewscal_set_timezone (msg, "EndTimeZone", (icaltimezone *) dtend.zone);
 			e_ews_message_end_set_item_field (msg);
 		}
 	} else {
 		e_ews_message_start_set_item_field (msg, "MeetingTimeZone", "calendar", "CalendarItem");
-		ewscal_set_timezone (msg, "MeetingTimeZone", (icaltimezone *)(dtstart.zone?dtstart.zone:modify_data->cbews->priv->default_zone));
+		ewscal_set_timezone (msg, "MeetingTimeZone", (icaltimezone *)(dtstart.zone ? dtstart.zone : modify_data->cbews->priv->default_zone));
 		e_ews_message_end_set_item_field (msg);
 	}
 
@@ -2034,7 +2343,12 @@ convert_vevent_component_to_updatexml(ES
 }
 
 static void
-convert_vtodo_property_to_updatexml (ESoapMessage *msg, const gchar *name, const gchar *value, const gchar * prefix, const gchar *attr_name, const gchar *attr_value)
+convert_vtodo_property_to_updatexml (ESoapMessage *msg,
+                                     const gchar *name,
+                                     const gchar *value,
+                                     const gchar *prefix,
+                                     const gchar *attr_name,
+                                     const gchar *attr_value)
 {
 	e_ews_message_start_set_item_field (msg, name, prefix, "Task");
 	e_ews_message_write_string_parameter_with_attribute (msg, name, NULL, value, attr_name, attr_value);
@@ -2042,19 +2356,33 @@ convert_vtodo_property_to_updatexml (ESo
 }
 
 static void
-convert_vtodo_component_to_updatexml (ESoapMessage *msg, gpointer user_data)
+convert_vtodo_component_to_updatexml (ESoapMessage *msg,
+                                      gpointer user_data)
 {
 	EwsModifyData *modify_data = user_data;
 	icalcomponent *icalcomp = e_cal_component_get_icalcomponent (modify_data->comp);
 	icalproperty *prop;
 	icaltimetype dt;
-	int value;
-	char buffer[16];
+	gint value;
+	gchar buffer[16];
 
-	e_ews_message_start_item_change (msg, E_EWS_ITEMCHANGE_TYPE_ITEM,
-					 modify_data->itemid, modify_data->changekey, 0);
+	e_ews_message_start_item_change (
+		msg, E_EWS_ITEMCHANGE_TYPE_ITEM,
+		modify_data->itemid, modify_data->changekey, 0);
 
-	convert_vtodo_property_to_updatexml (msg, "Subject", icalcomponent_get_summary(icalcomp), "item", NULL, NULL);
+	convert_vtodo_property_to_updatexml (msg, "Subject", icalcomponent_get_summary (icalcomp), "item", NULL, NULL);
+
+	prop = icalcomponent_get_first_property (icalcomp, ICAL_CLASS_PROPERTY);
+	if (prop) {
+		icalproperty_class classify = icalproperty_get_class (prop);
+		if (classify == ICAL_CLASS_PUBLIC) {
+			convert_vtodo_property_to_updatexml (msg, "Sensitivity", "Normal", "item", NULL, NULL);
+		} else if (classify == ICAL_CLASS_PRIVATE) {
+			convert_vtodo_property_to_updatexml (msg, "Sensitivity", "Private", "item", NULL, NULL);
+		} else if (classify == ICAL_CLASS_CONFIDENTIAL) {
+			convert_vtodo_property_to_updatexml (msg, "Sensitivity", "Personal", "item", NULL, NULL);
+		}
+	}
 
 	convert_vtodo_property_to_updatexml (msg, "Body", icalcomponent_get_description (icalcomp), "item", "BodyType", "Text");
 
@@ -2062,8 +2390,10 @@ convert_vtodo_component_to_updatexml (ES
 	if (prop) {
 		dt = icalproperty_get_due (prop);
 		e_ews_message_start_set_item_field (msg, "DueDate", "task", "Task");
-		ewscal_set_time (msg, "DueDate", &dt);
+		ewscal_set_time (msg, "DueDate", &dt, TRUE);
 		e_ews_message_end_set_item_field (msg);
+	} else {
+		e_ews_message_add_delete_item_field (msg, "DueDate", "task");
 	}
 
 	prop = icalcomponent_get_first_property (icalcomp, ICAL_PERCENTCOMPLETE_PROPERTY);
@@ -2071,7 +2401,7 @@ convert_vtodo_component_to_updatexml (ES
 		value = icalproperty_get_percentcomplete (prop);
 		snprintf (buffer, 16, "%d", value);
 		e_ews_message_start_set_item_field (msg, "PercentComplete", "task", "Task");
-		e_ews_message_write_string_parameter(msg, "PercentComplete", NULL, buffer);
+		e_ews_message_write_string_parameter (msg, "PercentComplete", NULL, buffer);
 		e_ews_message_end_set_item_field (msg);
 	}
 
@@ -2079,8 +2409,10 @@ convert_vtodo_component_to_updatexml (ES
 	if (prop) {
 		dt = icalproperty_get_dtstart (prop);
 		e_ews_message_start_set_item_field (msg, "StartDate", "task", "Task");
-		ewscal_set_time (msg, "StartDate", &dt);
+		ewscal_set_time (msg, "StartDate", &dt, TRUE);
 		e_ews_message_end_set_item_field (msg);
+	} else {
+		e_ews_message_add_delete_item_field (msg, "StartDate", "task");
 	}
 
 	prop = icalcomponent_get_first_property (icalcomp, ICAL_STATUS_PROPERTY);
@@ -2105,7 +2437,58 @@ convert_vtodo_component_to_updatexml (ES
 }
 
 static void
-convert_component_to_updatexml (ESoapMessage *msg, gpointer user_data)
+convert_vjournal_property_to_updatexml (ESoapMessage *msg,
+                                     const gchar *name,
+                                     const gchar *value,
+                                     const gchar *prefix,
+                                     const gchar *attr_name,
+                                     const gchar *attr_value)
+{
+	e_ews_message_start_set_item_field (msg, name, prefix, "Message");
+	e_ews_message_write_string_parameter_with_attribute (msg, name, NULL, value, attr_name, attr_value);
+	e_ews_message_end_set_item_field (msg);
+}
+
+static void
+convert_vjournal_component_to_updatexml (ESoapMessage *msg,
+					 gpointer user_data)
+{
+	EwsModifyData *modify_data = user_data;
+	icalcomponent *icalcomp = e_cal_component_get_icalcomponent (modify_data->comp);
+	icalproperty *prop;
+	const gchar *text;
+
+	e_ews_message_start_item_change (
+		msg, E_EWS_ITEMCHANGE_TYPE_ITEM,
+		modify_data->itemid, modify_data->changekey, 0);
+
+	convert_vjournal_property_to_updatexml (msg, "ItemClass", "IPM.StickyNote", "item", NULL, NULL);
+	convert_vjournal_property_to_updatexml (msg, "Subject", icalcomponent_get_summary (icalcomp), "item", NULL, NULL);
+
+	prop = icalcomponent_get_first_property (icalcomp, ICAL_CLASS_PROPERTY);
+	if (prop) {
+		icalproperty_class classify = icalproperty_get_class (prop);
+		if (classify == ICAL_CLASS_PUBLIC) {
+			convert_vjournal_property_to_updatexml (msg, "Sensitivity", "Normal", "item", NULL, NULL);
+		} else if (classify == ICAL_CLASS_PRIVATE) {
+			convert_vjournal_property_to_updatexml (msg, "Sensitivity", "Private", "item", NULL, NULL);
+		} else if (classify == ICAL_CLASS_CONFIDENTIAL) {
+			convert_vjournal_property_to_updatexml (msg, "Sensitivity", "Personal", "item", NULL, NULL);
+		}
+	}
+
+	text = icalcomponent_get_description (icalcomp);
+	if (!text || !*text)
+		text = icalcomponent_get_summary (icalcomp);
+
+	convert_vjournal_property_to_updatexml (msg, "Body", text, "item", "BodyType", "Text");
+
+	e_ews_message_end_item_change (msg);
+}
+
+static void
+convert_component_to_updatexml (ESoapMessage *msg,
+                                gpointer user_data)
 {
 	EwsModifyData *modify_data = user_data;
 	icalcomponent *icalcomp = e_cal_component_get_icalcomponent (modify_data->comp);
@@ -2117,14 +2500,21 @@ convert_component_to_updatexml (ESoapMes
 	case ICAL_VTODO_COMPONENT:
 		convert_vtodo_component_to_updatexml (msg, user_data);
 		break;
+	case ICAL_VJOURNAL_COMPONENT:
+		convert_vjournal_component_to_updatexml (msg, user_data);
+		break;
 	default:
 		break;
 	}
 }
 
 static void
-e_cal_backend_ews_modify_object (ECalBackend *backend, EDataCal *cal, EServerMethodContext context, GCancellable *cancellable,
-				 const gchar *calobj, CalObjModType mod)
+e_cal_backend_ews_modify_object (ECalBackend *backend,
+                                 EDataCal *cal,
+                                 EServerMethodContext context,
+                                 GCancellable *cancellable,
+                                 const gchar *calobj,
+                                 CalObjModType mod)
 {
 	EwsModifyData *modify_data;
 	ECalBackendEws *cbews;
@@ -2139,34 +2529,38 @@ e_cal_backend_ews_modify_object (ECalBac
 	EwsAttachmentsData *attach_data;
 	struct TzidCbData cbd;
 
-	e_data_cal_error_if_fail(E_IS_CAL_BACKEND_EWS(backend), InvalidArg);
-	e_data_cal_error_if_fail(calobj != NULL && *calobj != '\0', InvalidArg);
+	e_data_cal_error_if_fail (E_IS_CAL_BACKEND_EWS (backend), InvalidArg);
+	e_data_cal_error_if_fail (calobj != NULL && *calobj != '\0', InvalidArg);
 
-	cbews = E_CAL_BACKEND_EWS(backend);
+	cbews = E_CAL_BACKEND_EWS (backend);
 	priv = cbews->priv;
-	kind = e_cal_backend_get_kind(E_CAL_BACKEND(backend));
+	kind = e_cal_backend_get_kind (E_CAL_BACKEND (backend));
+
+	if (!e_cal_backend_ews_get_online (E_CAL_BACKEND_EWS (backend))) {
+		g_propagate_error (&error, EDC_ERROR (RepositoryOffline));
+		goto exit;
+	}
 
-	if (priv->mode == CAL_MODE_LOCAL) {
-		g_propagate_error(&error, EDC_ERROR(RepositoryOffline));
+	if (!cal_backend_ews_ensure_connected (cbews, cancellable, &error)) {
 		goto exit;
 	}
 
-	icalcomp = icalparser_parse_string(calobj);
+	icalcomp = icalparser_parse_string (calobj);
 	if (!icalcomp) {
-		g_propagate_error(&error, EDC_ERROR(InvalidObject));
+		g_propagate_error (&error, EDC_ERROR (InvalidObject));
 		goto exit;
 	}
-	if (kind != icalcomponent_isa(icalcomp)) {
-		icalcomponent_free(icalcomp);
-		g_propagate_error(&error, EDC_ERROR(InvalidObject));
+	if (kind != icalcomponent_isa (icalcomp)) {
+		icalcomponent_free (icalcomp);
+		g_propagate_error (&error, EDC_ERROR (InvalidObject));
 		goto exit;
 	}
-	
+
 	/* pick all the tzids out of the component and resolve
 	 * them using the vtimezones in the current calendar */
 	cbd.cbews = cbews;
 	cbd.comp = icalcomp;
-	icalcomponent_foreach_tzid(icalcomp, tzid_cb, &cbd);
+	icalcomponent_foreach_tzid (icalcomp, tzid_cb, &cbd);
 
 	comp = e_cal_component_new ();
 	e_cal_component_set_icalcomponent (comp, icalcomp);
@@ -2175,8 +2569,9 @@ e_cal_backend_ews_modify_object (ECalBac
 
 	ews_cal_component_get_item_id (comp, &itemid, &changekey);
 	if (!itemid) {
-		g_propagate_error(&error, EDC_ERROR_EX(OtherError,
-					       "Cannot determine EWS ItemId"));
+		g_propagate_error (
+			&error, EDC_ERROR_EX (OtherError,
+			"Cannot determine EWS ItemId"));
 		g_object_unref (comp);
 		goto exit;
 	}
@@ -2184,15 +2579,16 @@ e_cal_backend_ews_modify_object (ECalBac
 	PRIV_LOCK (priv);
 	oldcomp = g_hash_table_lookup (priv->item_id_hash, itemid);
 	if (!oldcomp) {
-		g_propagate_error (&error, EDC_ERROR(ObjectNotFound));
+		g_propagate_error (&error, EDC_ERROR (ObjectNotFound));
 		g_object_unref (comp);
+		PRIV_UNLOCK (priv);
 		goto exit;
 	}
 	PRIV_UNLOCK (priv);
 
 	cbd.comp = e_cal_component_get_icalcomponent (oldcomp);
-	icalcomponent_foreach_tzid(cbd.comp, tzid_cb, &cbd);
-	
+	icalcomponent_foreach_tzid (cbd.comp, tzid_cb, &cbd);
+
 	/*In case we have updated attachments we have to run update attachments
 	 *before update items so attendees will receive mails with already updated attachments */
 
@@ -2216,7 +2612,9 @@ e_cal_backend_ews_modify_object (ECalBac
 			icalprop = icalcomponent_get_next_property (icalcomp, ICAL_ATTACH_PROPERTY);
 		}
 
-		items = e_ews_connection_delete_attachments (priv->cnc, EWS_PRIORITY_MEDIUM, removed_attachments_ids, cancellable, &error);
+		items = e_ews_connection_delete_attachments_sync (
+			priv->cnc, EWS_PRIORITY_MEDIUM,
+			removed_attachments_ids, cancellable, &error);
 
 		changekey = items->data;
 
@@ -2227,10 +2625,10 @@ e_cal_backend_ews_modify_object (ECalBac
 
 	/*in case we have a new attachmetns the update item will be preformed in ews_create_attachments_cb*/
 	if (added_attachments) {
-		EwsId *item_id = g_new0(EwsId, 1);
+		EwsId *item_id = g_new0 (EwsId, 1);
 		item_id->id = itemid;
 		item_id->change_key = changekey;
-		attach_data = g_new0(EwsAttachmentsData, 1);
+		attach_data = g_new0 (EwsAttachmentsData, 1);
 
 		attach_data->cbews = g_object_ref (cbews);
 		attach_data->comp = g_object_ref (comp);
@@ -2241,18 +2639,25 @@ e_cal_backend_ews_modify_object (ECalBac
 		attach_data->itemid = itemid;
 		attach_data->changekey = changekey;
 
-		if (context)
+		if (context) {
+			convert_error_to_edc_error (&error);
 			e_data_cal_respond_modify_object (cal, context, error, NULL, NULL);
+		}
 
-		e_ews_connection_create_attachments_start (priv->cnc, EWS_PRIORITY_MEDIUM,
-							   item_id, added_attachments,
-							   ews_create_attachments_cb, NULL, attach_data);
+		e_ews_connection_create_attachments (
+			priv->cnc, EWS_PRIORITY_MEDIUM,
+			item_id, added_attachments,
+			cancellable,
+			ews_create_attachments_cb,
+			attach_data);
 
 		g_slist_free (added_attachments);
 		g_free (item_id);
 
 	} else {
-		const char *send_meeting_invitations;
+		const gchar *send_meeting_invitations;
+		const gchar *send_or_save;
+
 		modify_data = g_new0 (EwsModifyData, 1);
 		modify_data->cbews = g_object_ref (cbews);
 		modify_data->comp = g_object_ref (comp);
@@ -2261,27 +2666,32 @@ e_cal_backend_ews_modify_object (ECalBac
 		modify_data->context = context;
 		modify_data->itemid = itemid;
 		modify_data->changekey = changekey;
-		
-		if (e_cal_component_has_attendees (comp))
+
+		if (e_cal_component_has_attendees (comp)) {
 			send_meeting_invitations = "SendToAllAndSaveCopy";
-		else
+			send_or_save = "SendAndSaveCopy";
+		} else {
 			/*In case of appointment we have to set SendMeetingInvites to SendToNone */
 			send_meeting_invitations = "SendToNone";
+			send_or_save = "SaveOnly";
+		}
 
-		e_ews_connection_update_items_start (priv->cnc, EWS_PRIORITY_MEDIUM,
-						     "AlwaysOverwrite",
-						     "SendAndSaveCopy",
-						     send_meeting_invitations,
-						     priv->folder_id,
-						     convert_component_to_updatexml,
-						     modify_data,
-						     ews_cal_modify_object_cb,
-						     cancellable,
-						     modify_data);
+		e_ews_connection_update_items (
+			priv->cnc, EWS_PRIORITY_MEDIUM,
+			"AlwaysOverwrite",
+			send_or_save,
+			send_meeting_invitations,
+			priv->folder_id,
+			convert_component_to_updatexml,
+			modify_data,
+			cancellable,
+			ews_cal_modify_object_cb,
+			modify_data);
 	}
 	return;
 
 exit:
+	convert_error_to_edc_error (&error);
 	if (context)
 		e_data_cal_respond_modify_object (cal, context, error, NULL, NULL);
 	else if (error) {
@@ -2291,23 +2701,23 @@ exit:
 }
 
 typedef struct {
-	const char *response_type;
-	const char *item_id;
-	const char *change_key;
+	const gchar *response_type;
+	const gchar *item_id;
+	const gchar *change_key;
 } EwsAcceptData;
 
 static gchar *
 e_ews_get_icalcomponent_as_mime_content (icalcomponent *vevent)
 {
 	icalcomponent *vcal;
-	char *vcal_str;
+	gchar *vcal_str;
 
 	vcal = icalcomponent_new (ICAL_VCALENDAR_COMPONENT);
-	icalcomponent_add_property (vcal, icalproperty_new_version("2.0"));
-	icalcomponent_add_property (vcal, icalproperty_new_method(ICAL_METHOD_REQUEST));
+	icalcomponent_add_property (vcal, icalproperty_new_version ("2.0"));
+	icalcomponent_add_property (vcal, icalproperty_new_method (ICAL_METHOD_REQUEST));
 	icalcomponent_add_component (vcal, icalcomponent_new_clone (vevent));
 
-	vcal_str = icalcomponent_as_ical_string_r ((icalcomponent *)vcal);
+	vcal_str = icalcomponent_as_ical_string_r ((icalcomponent *) vcal);
 
 	icalcomponent_free (vcal);
 
@@ -2315,74 +2725,91 @@ e_ews_get_icalcomponent_as_mime_content 
 }
 
 static void
-prepare_create_item_with_mime_content_request(ESoapMessage *msg, gpointer user_data)
+prepare_create_item_with_mime_content_request (ESoapMessage *msg,
+                                               gpointer user_data)
 {
-	gchar *mime_content = (gchar*) user_data;
+	gchar *mime_content = (gchar *) user_data;
 
 	/* Prepare CalendarItem node in the SOAP message */
-	e_soap_message_start_element(msg, "CalendarItem", NULL, NULL);
+	e_soap_message_start_element (msg, "CalendarItem", NULL, NULL);
 
 	e_ews_message_write_base64_parameter (msg,"MimeContent",NULL,mime_content);
 	// end of "CalendarItem"
-	e_soap_message_end_element(msg);
+	e_soap_message_end_element (msg);
 }
 
 static void
-e_ews_receive_objects_no_exchange_mail (ECalBackendEwsPrivate *priv, icalcomponent *subcomp, GSList *ids, GCancellable *cancellable, GError *error)
+e_ews_receive_objects_no_exchange_mail (ECalBackendEwsPrivate *priv,
+                                        icalcomponent *subcomp,
+                                        GSList *ids,
+                                        GCancellable *cancellable,
+                                        GError **error)
 {
 	gchar *mime_content = e_ews_get_icalcomponent_as_mime_content (subcomp);
-	e_ews_connection_create_items (priv->cnc, EWS_PRIORITY_MEDIUM,
-							       "SendAndSaveCopy", "SendToNone", NULL,
-							       prepare_create_item_with_mime_content_request,
-							       mime_content,
-							       &ids,
-							       cancellable,
-							       &error);
+	e_ews_connection_create_items_sync (
+		priv->cnc, EWS_PRIORITY_MEDIUM,
+		"SendAndSaveCopy", "SendToNone", NULL,
+		prepare_create_item_with_mime_content_request,
+		mime_content, &ids, cancellable, error);
 	g_free (mime_content);
 	/*we still have to send a mail with accept to meeting organizer*/
 }
 
-static const char*
-e_ews_get_current_user_meeting_reponse (icalcomponent *icalcomp, const char *current_user_mail)
+static const gchar *
+e_ews_get_current_user_meeting_reponse (icalcomponent *icalcomp,
+                                        const gchar *current_user_mail)
 {
 	icalproperty *attendee;
-	const char *attendee_str = NULL, *attendee_mail = NULL;
+	const gchar *attendee_str = NULL, *attendee_mail = NULL;
+	gint attendees_count = 0;
+
 	for (attendee = icalcomponent_get_first_property (icalcomp, ICAL_ATTENDEE_PROPERTY);
 		attendee != NULL;
-		attendee = icalcomponent_get_next_property (icalcomp, ICAL_ATTENDEE_PROPERTY)) {
+		attendee = icalcomponent_get_next_property (icalcomp, ICAL_ATTENDEE_PROPERTY), attendees_count++) {
 		attendee_str = icalproperty_get_attendee (attendee);
 
-		if (attendee_str != NULL){
+		if (attendee_str != NULL) {
 			if (!strncasecmp (attendee_str, "MAILTO:", 7))
 				attendee_mail = attendee_str + 7;
 			else
 				attendee_mail = attendee_str;
-			if (g_strcmp0 (attendee_mail, current_user_mail) == 0)
+			if (attendee_mail && current_user_mail && g_ascii_strcasecmp (attendee_mail, current_user_mail) == 0)
 				return icalproperty_get_parameter_as_string (attendee, "PARTSTAT");
 		}
 	}
+
+	/* this should not happen, but if the user's configured email does not match the one
+	   used in the invitation, like when the invitation comes to a mailing list... */
+	if (attendees_count == 1) {
+		attendee = icalcomponent_get_first_property (icalcomp, ICAL_ATTENDEE_PROPERTY);
+		g_return_val_if_fail (attendee != NULL, NULL);
+
+		return icalproperty_get_parameter_as_string (attendee, "PARTSTAT");
+	}
+
 	return NULL;
 }
 
 static void
-prepare_accept_item_request (ESoapMessage *msg, gpointer user_data)
+prepare_accept_item_request (ESoapMessage *msg,
+                             gpointer user_data)
 {
 	EwsAcceptData *data = user_data;
-	const char *response_type = data->response_type;
+	const gchar *response_type = data->response_type;
 
 	/* FORMAT OF A SAMPLE SOAP MESSAGE: http://msdn.microsoft.com/en-us/library/aa566464%28v=exchg.140%29.aspx
 	 * Accept and Decline meeting have same method code (10032)
 	 * The real status is reflected at Attendee property PARTSTAT
 	 * need to find current user as attendee and make a decision what to do.
 	 * Prepare AcceptItem node in the SOAP message */
-	
+
 	if (response_type && !g_ascii_strcasecmp (response_type, "ACCEPTED"))
 		e_soap_message_start_element (msg, "AcceptItem", NULL, NULL);
 	else if (response_type && !g_ascii_strcasecmp (response_type, "DECLINED"))
 		e_soap_message_start_element (msg, "DeclineItem", NULL, NULL);
 	else
 		e_soap_message_start_element (msg, "TentativelyAcceptItem", NULL, NULL);
-	
+
 	e_soap_message_start_element (msg, "ReferenceItemId", NULL, NULL);
 	e_soap_message_add_attribute (msg, "Id", data->item_id, NULL, NULL);
 	e_soap_message_add_attribute (msg, "ChangeKey", data->change_key, NULL, NULL);
@@ -2393,7 +2820,8 @@ prepare_accept_item_request (ESoapMessag
 }
 
 static void
-prepare_set_free_busy_status (ESoapMessage *msg, gpointer user_data)
+prepare_set_free_busy_status (ESoapMessage *msg,
+                              gpointer user_data)
 {
 	EwsAcceptData *data = user_data;
 
@@ -2409,7 +2837,11 @@ prepare_set_free_busy_status (ESoapMessa
 }
 
 static void
-e_cal_backend_ews_receive_objects (ECalBackend *backend, EDataCal *cal, EServerMethodContext context, GCancellable *cancellable, const gchar *calobj)
+e_cal_backend_ews_receive_objects (ECalBackend *backend,
+                                   EDataCal *cal,
+                                   EServerMethodContext context,
+                                   GCancellable *cancellable,
+                                   const gchar *calobj)
 {
 	ECalBackendEws *cbews;
 	ECalBackendEwsPrivate *priv;
@@ -2419,15 +2851,19 @@ e_cal_backend_ews_receive_objects (ECalB
 	icalproperty_method method;
 	EwsAcceptData *accept_data;
 
-	cbews = E_CAL_BACKEND_EWS(backend);
+	cbews = E_CAL_BACKEND_EWS (backend);
 	priv = cbews->priv;
 
 	/* make sure we're not offline */
-	if (priv->mode == CAL_MODE_LOCAL) {
+	if (!e_cal_backend_ews_get_online (E_CAL_BACKEND_EWS (backend))) {
 		g_propagate_error (&error, EDC_ERROR (RepositoryOffline));
 		goto exit;
 	}
 
+	if (!cal_backend_ews_ensure_connected (cbews, cancellable, &error)) {
+		goto exit;
+	}
+
 	icalcomp = icalparser_parse_string (calobj);
 
 	/* make sure data was parsed properly */
@@ -2449,19 +2885,19 @@ e_cal_backend_ews_receive_objects (ECalB
 
 	while (subcomp) {
 		ECalComponent *comp = e_cal_component_new ();
-		const char *response_type;
-		gchar *item_id = NULL, *change_key = NULL;
+		const gchar *response_type;
+		gchar *item_id = NULL, *change_key = NULL, *mail_id = NULL;
 		GSList *ids = NULL, *l;
 		icalproperty *recurrence_id, *transp, *summary;
-		char **split_subject;
-
+		gchar **split_subject;
+		gint pass = 0;
 
 		/* duplicate the ical component */
 		e_cal_component_set_icalcomponent (comp, icalcomponent_new_clone (subcomp));
 
 		/*getting a data for meeting request response*/
 		response_type = e_ews_get_current_user_meeting_reponse (e_cal_component_get_icalcomponent (comp), priv->user_email);
-		ews_cal_component_get_calendar_item_accept_id (comp, &item_id, &change_key);
+		ews_cal_component_get_calendar_item_accept_id (comp, &item_id, &change_key, &mail_id);
 
 		switch (method) {
 			case ICAL_METHOD_REQUEST:
@@ -2472,21 +2908,61 @@ e_cal_backend_ews_receive_objects (ECalB
 				accept_data->item_id = item_id;
 				accept_data->change_key = change_key;
 
-				/*in case we do not have item id we will create item with mime content only*/
-				if (item_id == NULL)
-					e_ews_receive_objects_no_exchange_mail (priv, subcomp, ids, cancellable, error);
-				else
-					e_ews_connection_create_items (priv->cnc, EWS_PRIORITY_MEDIUM,
-								       "SendAndSaveCopy",
-								       NULL, NULL,
-								       prepare_accept_item_request,
-								       accept_data,
-								       &ids, cancellable, &error);
-				if (error)
-					/* The calendar UI doesn't *display* errors unless they have
-					 * the OtherError code */
-					error->code = OtherError;
-			else {
+				while (pass < 2) {
+					/*in case we do not have item id we will create item with mime content only*/
+					if (item_id == NULL)
+						e_ews_receive_objects_no_exchange_mail (priv, subcomp, ids, cancellable, &error);
+					else
+						e_ews_connection_create_items_sync (
+							priv->cnc, EWS_PRIORITY_MEDIUM,
+							"SendAndSaveCopy",
+							NULL, NULL,
+							prepare_accept_item_request,
+							accept_data,
+							&ids, cancellable, &error);
+					if (pass == 0 && mail_id && item_id &&
+					    g_error_matches (error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_ITEMNOTFOUND)) {
+						/* maybe the associated accept calendar item changed
+						   on the server, thus retry with updated values */
+						GSList *my_ids;
+
+						my_ids = g_slist_append (NULL, mail_id);
+						ids = NULL;
+						if (e_ews_connection_get_items_sync (priv->cnc, EWS_PRIORITY_MEDIUM, my_ids,
+								"AllProperties", NULL, FALSE, NULL, E_EWS_BODY_TYPE_ANY, &ids, NULL, NULL,
+								cancellable, NULL)
+						    && ids && ids->data) {
+							EEwsItem *item = ids->data;
+							if (e_ews_item_get_id (item) &&
+							    g_strcmp0 (e_ews_item_get_id (item)->id, mail_id) == 0) {
+								const EwsId *calendar_item_accept_id = e_ews_item_get_calendar_item_accept_id (item);
+
+								if (calendar_item_accept_id) {
+									g_clear_error (&error);
+									pass++;
+
+									g_free (item_id);
+									g_free (change_key);
+									item_id = g_strdup (calendar_item_accept_id->id);
+									change_key = g_strdup (calendar_item_accept_id->change_key);
+
+									accept_data->item_id = item_id;
+									accept_data->change_key = change_key;
+								}
+							}
+						}
+
+						g_slist_free (my_ids);
+						g_slist_free_full (ids, g_object_unref);
+						ids = NULL;
+
+						if (pass == 0)
+							break;
+					} else {
+						break;
+					}
+				}
+			if (!error) {
 				transp = icalcomponent_get_first_property (subcomp, ICAL_TRANSP_PROPERTY);
 				if (!g_strcmp0 (icalproperty_get_value_as_string (transp), "TRANSPARENT") &&
 				    !g_strcmp0 (response_type, "ACCEPTED")) {
@@ -2500,22 +2976,22 @@ e_cal_backend_ews_receive_objects (ECalB
 							break;
 						}
 					}
-					e_ews_connection_update_items (priv->cnc, 
-								       EWS_PRIORITY_MEDIUM,
-								       "AlwaysOverwrite",
-								       NULL, "SendToNone",
-								       NULL,
-								       prepare_set_free_busy_status,
-								       accept_data,
-								       &ids,
-								       cancellable,
-								       &error);
-					if (error)
-						error->code = OtherError;
+					e_ews_connection_update_items_sync (
+						priv->cnc,
+						EWS_PRIORITY_MEDIUM,
+						"AlwaysOverwrite",
+						NULL, "SendToNone",
+						NULL,
+						prepare_set_free_busy_status,
+						accept_data,
+						&ids,
+						cancellable,
+						&error);
 				}
 			}
 				g_free (item_id);
 				g_free (change_key);
+				g_free (mail_id);
 				g_free (accept_data);
 				/*We have to run sync before any other operations */
 				ews_start_sync (cbews);
@@ -2531,11 +3007,11 @@ e_cal_backend_ews_receive_objects (ECalB
 				if (!g_strcmp0 (response_type, "ACCEPTED")) {
 					/*we have to edit the meeting subject to remove exchange header*/
 					summary = icalcomponent_get_first_property (subcomp, ICAL_SUMMARY_PROPERTY);
-					split_subject  = g_strsplit (icalproperty_get_value_as_string(summary), ":", -1);
+					split_subject  = g_strsplit (icalproperty_get_value_as_string (summary), ":", -1);
 					icalproperty_set_value_from_string (summary, split_subject[1] , "NO");
 					g_strfreev (split_subject);
 
-					e_cal_backend_ews_modify_object (backend, cal, 0, cancellable, icalcomponent_as_ical_string(subcomp), CALOBJ_MOD_ALL);
+					e_cal_backend_ews_modify_object (backend, cal, 0, cancellable, icalcomponent_as_ical_string (subcomp), CALOBJ_MOD_ALL);
 				}
 				break;
 			default:
@@ -2548,14 +3024,16 @@ e_cal_backend_ews_receive_objects (ECalB
 	icalcomponent_free (icalcomp);
 
 exit:
+	convert_error_to_edc_error (&error);
 	e_data_cal_respond_receive_objects (cal, context, error);
 }
 
-static const char *
+static const gchar *
 e_cal_get_meeting_cancellation_comment (ECalComponent *comp)
 {
 	icalproperty *prop;
-	prop = icalcomponent_get_first_property (e_cal_component_get_icalcomponent (comp),
+	prop = icalcomponent_get_first_property (
+		e_cal_component_get_icalcomponent (comp),
 		ICAL_X_PROPERTY);
 	while (prop) {
 		const gchar *x_name, *x_val;
@@ -2564,55 +3042,71 @@ e_cal_get_meeting_cancellation_comment (
 		if (!g_ascii_strcasecmp (x_name, "X-EVOLUTION-RETRACT-COMMENT"))
 			return x_val;
 
-		prop = icalcomponent_get_next_property (e_cal_component_get_icalcomponent (comp),
+		prop = icalcomponent_get_next_property (
+			e_cal_component_get_icalcomponent (comp),
 			ICAL_X_PROPERTY);
 	}
-	return NULL;
 
+	return NULL;
 }
 
-static icaltimezone*
-e_cal_get_timezone_from_ical_component (ECalBackend *backend, icalcomponent *comp) {
+static icaltimezone *
+e_cal_get_timezone_from_ical_component (ECalBackend *backend,
+                                        icalcomponent *comp)
+{
 	icalproperty *prop;
 	icalparameter *param;
-	
-	prop = icalcomponent_get_first_property(comp, ICAL_DTSTART_PROPERTY);
-	if ((param = icalproperty_get_first_parameter(prop, ICAL_TZID_PARAMETER))) {
-		const char *tzid = icalparameter_get_tzid (param);
+
+	prop = icalcomponent_get_first_property (
+		comp, ICAL_DTSTART_PROPERTY);
+	param = icalproperty_get_first_parameter (
+		prop, ICAL_TZID_PARAMETER);
+
+	if (param != NULL) {
+		const gchar *tzid;
 		icaltimezone *zone;
 
+		tzid = icalparameter_get_tzid (param);
+
 		zone = icaltimezone_get_builtin_timezone_from_tzid (tzid);
 		if (zone)
 			return zone;
-		
+
 		return e_cal_backend_ews_internal_get_timezone (E_CAL_BACKEND (backend), tzid);
 	}
-	
+
 	g_warning ("EEE Cant figure the relevant timezone of the component\n");
+
 	return NULL;
 }
 
 static void
-ewscal_send_cancellation_email (ECalBackend *backend, EEwsConnection *cnc, CamelAddress *from, CamelInternetAddress *recipient, const gchar *subject, const gchar *body, const gchar *calobj)
+ewscal_send_cancellation_email (ECalBackend *backend,
+                                EEwsConnection *cnc,
+                                CamelAddress *from,
+                                CamelInternetAddress *recipient,
+                                const gchar *subject,
+                                const gchar *body,
+                                const gchar *calobj)
 {
 	CamelMimeMessage *message;
 	GError *error = NULL;
 	CamelMultipart *multi;
 	CamelMimePart *text_part, *vcal_part;
-	char *ical_str;
+	gchar *ical_str;
 	icalcomponent *vcal, *vevent, *vtz;
 	icalproperty *prop;
 	icaltimezone *icaltz;
 	struct icaltimetype dt;
 
 	vcal = icalcomponent_new (ICAL_VCALENDAR_COMPONENT);
-	icalcomponent_add_property (vcal, icalproperty_new_version("2.0"));
-        icalcomponent_add_property (vcal, icalproperty_new_prodid("-//Evolution EWS backend//EN"));
-	icalcomponent_add_property (vcal, icalproperty_new_method(ICAL_METHOD_CANCEL));
+	icalcomponent_add_property (vcal, icalproperty_new_version ("2.0"));
+	icalcomponent_add_property (vcal, icalproperty_new_prodid ("-//Evolution EWS backend//EN"));
+	icalcomponent_add_property (vcal, icalproperty_new_method (ICAL_METHOD_CANCEL));
 	vevent = icalcomponent_new_from_string (calobj);
 	prop = icalcomponent_get_first_property (vevent, ICAL_STATUS_PROPERTY);
 	if (prop != NULL) icalcomponent_remove_property (vevent, prop);
-	icalcomponent_add_property (vevent, icalproperty_new_status(ICAL_STATUS_CANCELLED));
+	icalcomponent_add_property (vevent, icalproperty_new_status (ICAL_STATUS_CANCELLED));
 	prop = icalcomponent_get_first_property (vevent, ICAL_METHOD_PROPERTY);
 	if (prop != NULL) icalcomponent_remove_property (vevent, prop);
 	dt = icalcomponent_get_dtstart (vevent);
@@ -2624,14 +3118,14 @@ ewscal_send_cancellation_email (ECalBack
 	camel_mime_part_set_content (text_part, body, strlen (body), "text/plain");
 
 	vcal_part = camel_mime_part_new ();
-	camel_content_type_set_param(CAMEL_DATA_WRAPPER (vcal_part)->mime_type, "charset", "utf-8");
-	camel_content_type_set_param(CAMEL_DATA_WRAPPER (vcal_part)->mime_type, "method", "CANCEL");
-	ical_str = icalcomponent_as_ical_string_r ((icalcomponent *)vcal);
+	camel_content_type_set_param (CAMEL_DATA_WRAPPER (vcal_part)->mime_type, "charset", "utf-8");
+	camel_content_type_set_param (CAMEL_DATA_WRAPPER (vcal_part)->mime_type, "method", "CANCEL");
+	ical_str = icalcomponent_as_ical_string_r ((icalcomponent *) vcal);
 	camel_mime_part_set_content (vcal_part, ical_str, strlen (ical_str), "text/calendar; method=CANCEL");
 	free (ical_str);
 
 	multi = camel_multipart_new ();
-	camel_data_wrapper_set_mime_type(CAMEL_DATA_WRAPPER (multi), "multipart/alternative");
+	camel_data_wrapper_set_mime_type (CAMEL_DATA_WRAPPER (multi), "multipart/alternative");
 	camel_multipart_add_part (multi, text_part);
 	camel_multipart_set_boundary (multi, NULL);
 	camel_multipart_add_part (multi, vcal_part);
@@ -2643,13 +3137,13 @@ ewscal_send_cancellation_email (ECalBack
 	camel_mime_message_set_from (message, CAMEL_INTERNET_ADDRESS (from));
 	camel_mime_message_set_recipients (message, CAMEL_RECIPIENT_TYPE_TO, recipient);
 
-	camel_medium_set_content ((CamelMedium *)message, (CamelDataWrapper *)multi);
+	camel_medium_set_content ((CamelMedium *) message, (CamelDataWrapper *) multi);
 	g_object_unref (multi);
 
 	camel_ews_utils_create_mime_message (cnc, "SendOnly", NULL, message, 0, from, NULL, NULL, NULL, &error);
 
 	if (error) {
-		g_warning ("Failed to send cancellation email\n");
+		g_warning ("Failed to send cancellation email: %s", error->message);
 		g_clear_error (&error);
 	}
 
@@ -2658,7 +3152,11 @@ ewscal_send_cancellation_email (ECalBack
 }
 
 static void
-e_cal_backend_ews_send_objects (ECalBackend *backend, EDataCal *cal, EServerMethodContext context, GCancellable *cancellable, const gchar *calobj)
+e_cal_backend_ews_send_objects (ECalBackend *backend,
+                                EDataCal *cal,
+                                EServerMethodContext context,
+                                GCancellable *cancellable,
+                                const gchar *calobj)
 {
 	ECalBackendEws *cbews;
 	ECalBackendEwsPrivate *priv;
@@ -2667,16 +3165,19 @@ e_cal_backend_ews_send_objects (ECalBack
 	GError *error = NULL;
 	gchar *subcalobj;
 
-
-	cbews = E_CAL_BACKEND_EWS(backend);
+	cbews = E_CAL_BACKEND_EWS (backend);
 	priv = cbews->priv;
 
 	/* make sure we're not offline */
-	if (priv->mode == CAL_MODE_LOCAL) {
+	if (!e_cal_backend_ews_get_online (E_CAL_BACKEND_EWS (backend))) {
 		g_propagate_error (&error, EDC_ERROR (RepositoryOffline));
 		goto exit;
 	}
 
+	if (!cal_backend_ews_ensure_connected (cbews, cancellable, &error)) {
+		goto exit;
+	}
+
 	icalcomp = icalparser_parse_string (calobj);
 
 	/* make sure data was parsed properly */
@@ -2701,20 +3202,20 @@ e_cal_backend_ews_send_objects (ECalBack
 		subcomp = icalcomp;
 	while (subcomp) {
 		ECalComponent *comp = e_cal_component_new ();
-		const char *new_body_content = NULL, *subject = NULL, *org_email = NULL;
+		const gchar *new_body_content = NULL, *subject = NULL, *org_email = NULL;
 		const gchar *org = NULL, *attendee = NULL;
 		icalproperty *prop, *org_prop = NULL;
 		CamelInternetAddress *org_addr = camel_internet_address_new ();
 
 		e_cal_component_set_icalcomponent (comp, icalcomponent_new_clone (subcomp));
 
-		new_body_content = e_cal_get_meeting_cancellation_comment(comp);
+		new_body_content = e_cal_get_meeting_cancellation_comment (comp);
 		subject = icalproperty_get_value_as_string (icalcomponent_get_first_property (subcomp, ICAL_SUMMARY_PROPERTY));
 
 		org_prop = icalcomponent_get_first_property (subcomp, ICAL_ORGANIZER_PROPERTY);
-		org = icalproperty_get_organizer(org_prop);
+		org = icalproperty_get_organizer (org_prop);
 		if (!g_ascii_strncasecmp (org, "MAILTO:", 7))
-				org_email = (org) + 7;
+			org_email = (org) + 7;
 			else
 				org_email = org;
 
@@ -2732,7 +3233,7 @@ e_cal_backend_ews_send_objects (ECalBack
 
 			subcalobj = icalcomponent_as_ical_string_r (subcomp);
 			camel_internet_address_add (attendee_addr, icalproperty_get_parameter_as_string (prop, "CN"), attendee);
-			ewscal_send_cancellation_email (backend, priv->cnc, CAMEL_ADDRESS(org_addr), attendee_addr, subject, new_body_content, subcalobj);
+			ewscal_send_cancellation_email (backend, priv->cnc, CAMEL_ADDRESS (org_addr), attendee_addr, subject, new_body_content, subcalobj);
 			g_object_unref (attendee_addr);
 			free (subcalobj);
 		}
@@ -2745,12 +3246,14 @@ e_cal_backend_ews_send_objects (ECalBack
 	icalcomponent_free (icalcomp);
 
 exit:
+	convert_error_to_edc_error (&error);
 	e_data_cal_respond_send_objects (cal, context, error,  NULL, calobj);
 }
 
 /* TODO Do not replicate this in every backend */
 static icaltimezone *
-resolve_tzid (const gchar *tzid, gpointer user_data)
+resolve_tzid (const gchar *tzid,
+              gpointer user_data)
 {
 	icaltimezone *zone;
 
@@ -2766,209 +3269,137 @@ resolve_tzid (const gchar *tzid, gpointe
 
 static void
 put_component_to_store (ECalBackendEws *cbews,
-			ECalComponent *comp)
+                        ECalComponent *comp)
 {
 	time_t time_start, time_end;
 	ECalBackendEwsPrivate *priv;
 
 	priv = cbews->priv;
 
-	e_cal_util_get_component_occur_times (comp, &time_start, &time_end,
-				   resolve_tzid, cbews, priv->default_zone,
-				   e_cal_backend_get_kind (E_CAL_BACKEND (cbews)));
+	e_cal_util_get_component_occur_times (
+		comp, &time_start, &time_end,
+		resolve_tzid, cbews, priv->default_zone,
+		e_cal_backend_get_kind (E_CAL_BACKEND (cbews)));
 
 	e_cal_backend_store_put_component_with_time_range (priv->store, comp, time_start, time_end);
 }
 
-typedef struct {
-	ECalComponent *comp;
-	ECalBackendEws *cbews;
-	gchar* itemid;
-} EwsAttachmentData;
-
 static void
-ews_get_attachments_ready_callback (GObject *object, GAsyncResult *res, gpointer user_data)
+ews_get_attachments (ECalBackendEws *cbews,
+                     EEwsItem *item)
 {
-	EEwsConnection *cnc = E_EWS_CONNECTION (object);
-	EwsAttachmentData *att_data = user_data;
-	GError *error = NULL;
-	GSList *uris = NULL, *ids, *i;
-	ECalComponentId *id;
-	ECalBackendEws *cbews;
-	gchar *comp_str, *itemid;
-	ECalComponent *comp_att, *cache_comp = NULL;
-	icalcomponent *icalcomp;
-	icalproperty *icalprop;
-	icalparameter *icalparam;
+	gboolean has_attachment = FALSE;
+	const GSList *attachment_ids, *aid;
+	const EwsId *item_id;
+	ECalComponent *comp;
+	const gchar *uid;
+	GSList *uris = NULL;
+
+	e_ews_item_has_attachments (item, &has_attachment);
+	if (!has_attachment)
+		return;
 
-	ids = e_ews_connection_get_attachments_finish	(cnc, res, &uris, &error);
+	item_id = e_ews_item_get_id (item);
+	g_return_if_fail (item_id != NULL);
 
-	if (error != NULL) {
-		error->code = OtherError;
+	PRIV_LOCK (cbews->priv);
+	comp = g_hash_table_lookup (cbews->priv->item_id_hash, item_id->id);
+	if (!comp) {
+		PRIV_UNLOCK (cbews->priv);
+		g_warning ("%s: Failed to get component from item_id_hash", G_STRFUNC);
 		return;
 	}
 
-	comp_att = att_data->comp;
-	cbews = att_data->cbews;
-	itemid = att_data->itemid;
+	e_cal_component_get_uid (comp, &uid);
 
-	e_cal_component_set_attachment_list (comp_att, uris);
+	attachment_ids = e_ews_item_get_attachments_ids (item);
 
-	icalcomp = e_cal_component_get_icalcomponent (comp_att);
-	icalprop = icalcomponent_get_first_property (icalcomp, ICAL_ATTACH_PROPERTY);
-	i = ids;
-	for (; i && icalprop; i = i->next, icalprop = icalcomponent_get_next_property (icalcomp, ICAL_ATTACH_PROPERTY)) {
-		icalparam = icalparameter_new_x (i->data);
-		icalparameter_set_xname (icalparam, "X-EWS-ATTACHMENTID");
-		icalproperty_add_parameter (icalprop, icalparam);
-		g_free (i->data);
-	}
-
-	id = e_cal_component_get_id (comp_att);
-	cache_comp = e_cal_backend_store_get_component (cbews->priv->store, id->uid, id->rid);
-	e_cal_component_free_id (id);
+	if (e_ews_connection_get_attachments_sync (
+		cbews->priv->cnc,
+		EWS_PRIORITY_MEDIUM,
+		uid,
+		attachment_ids,
+		cbews->priv->storage_path,
+		TRUE,
+		&uris,
+		NULL, NULL,
+		cbews->priv->cancellable,
+		NULL)) {
+		icalcomponent *icalcomp;
+		icalproperty *icalprop;
+		icalparameter *icalparam;
+		ECalComponentId *id;
+		ECalComponent *cache_comp;
 
-	comp_str = e_cal_component_get_as_string (comp_att);
-	put_component_to_store (cbews, comp_att);
+		e_cal_component_set_attachment_list (comp, uris);
 
-	if (cache_comp) {
-		gchar *cache_str;
+		icalcomp = e_cal_component_get_icalcomponent (comp);
+		icalprop = icalcomponent_get_first_property (icalcomp, ICAL_ATTACH_PROPERTY);
+		for (aid = attachment_ids; aid && icalprop; aid = aid->next, icalprop = icalcomponent_get_next_property (icalcomp, ICAL_ATTACH_PROPERTY)) {
+			icalparam = icalparameter_new_x (aid->data);
+			icalparameter_set_xname (icalparam, "X-EWS-ATTACHMENTID");
+			icalproperty_add_parameter (icalprop, icalparam);
+		}
 
-		cache_str = e_cal_component_get_as_string (cache_comp);
-		e_cal_backend_notify_object_modified (E_CAL_BACKEND (cbews), cache_str, comp_str);
+		id = e_cal_component_get_id (comp);
+		cache_comp = e_cal_backend_store_get_component (cbews->priv->store, id->uid, id->rid);
+		e_cal_component_free_id (id);
 
-		g_free (cache_str);
+		put_component_to_store (cbews, comp);
 
-		PRIV_LOCK (cbews->priv);
-		g_hash_table_insert (cbews->priv->item_id_hash, g_strdup (itemid), g_object_ref (comp_att));
-		PRIV_UNLOCK (cbews->priv);
-	}
+		if (cache_comp) {
+			gchar *old_comp_str, *new_comp_str;
 
-	g_slist_foreach (uris, (GFunc) g_free, NULL);
-	g_slist_free (uris);
-	g_free(comp_str);
-	g_free(itemid);
-	g_object_unref(att_data->comp);
-	g_free(att_data);
-}
+			old_comp_str = e_cal_component_get_as_string (cache_comp);
+			new_comp_str = e_cal_component_get_as_string (comp);
 
-static void
-ews_get_attachments (ECalBackendEws *cbews, EEwsItem *item)
-{
-	gboolean has_attachment = FALSE;
+			e_cal_backend_notify_object_modified (E_CAL_BACKEND (cbews), old_comp_str, new_comp_str);
 
-	e_ews_item_has_attachments (item, & has_attachment);
-	if (has_attachment) {
-		const GSList *attachment_ids;
-		const EwsId *item_id;
-		EwsAttachmentData *att_data;
-		const gchar *uid;
+			g_free (old_comp_str);
+			g_free (new_comp_str);
+		}
 
-		attachment_ids = e_ews_item_get_attachments_ids (item);
-		item_id = e_ews_item_get_id (item);
-		att_data = g_new0 (EwsAttachmentData, 1);
-		att_data->comp = g_hash_table_lookup (cbews->priv->item_id_hash, item_id->id);
-		att_data->cbews = cbews;
-		att_data->itemid = g_strdup (item_id->id);
-		e_cal_component_get_uid (att_data->comp, &uid);
-
-		e_ews_connection_get_attachments_start (cbews->priv->cnc,
-							EWS_PRIORITY_MEDIUM,
-							uid,
-							attachment_ids,
-							cbews->priv->storage_path,
-							TRUE,
-							ews_get_attachments_ready_callback,
-							NULL, NULL,
-							NULL, att_data);
+		g_slist_free_full (uris, g_free);
 	}
 
+	PRIV_UNLOCK (cbews->priv);
 }
 
 static void
-add_item_to_cache (ECalBackendEws *cbews, EEwsItem *item)
+add_item_to_cache (ECalBackendEws *cbews,
+                   EEwsItem *item)
 {
 	ECalBackendEwsPrivate *priv;
 	icalcomponent_kind kind;
+	EEwsItemType item_type;
 	icalcomponent *vtimezone, *icalcomp, *vcomp;
 	const gchar *mime_content;
 
 	kind = e_cal_backend_get_kind ((ECalBackend *) cbews);
 	priv = cbews->priv;
 
-	if (e_ews_item_get_item_type (item) == E_EWS_ITEM_TYPE_TASK){
+	item_type = e_ews_item_get_item_type (item);
+	if (item_type == E_EWS_ITEM_TYPE_TASK || item_type == E_EWS_ITEM_TYPE_MEMO) {
 		icalproperty *icalprop;
 		icaltimetype due_date, start_date, complete_date, created;
 		icalproperty_status status  = ICAL_STATUS_NONE;
 		icalproperty_class class = ICAL_CLASS_NONE;
-		const char *ews_task_status, *sensitivity;
+		const gchar *ews_task_status, *sensitivity;
 		EwsImportance item_importance;
-		int priority = 5;
+		gint priority = 5;
 		gboolean has_this_date = FALSE;
 
 		vcomp = icalcomponent_new (ICAL_VCALENDAR_COMPONENT);
 		/*subject*/
-		icalcomp = icalcomponent_new (ICAL_VTODO_COMPONENT);
+		icalcomp = icalcomponent_new (item_type == E_EWS_ITEM_TYPE_TASK ? ICAL_VTODO_COMPONENT : ICAL_VJOURNAL_COMPONENT);
 		icalprop = icalproperty_new_summary (e_ews_item_get_subject (item));
 		icalcomponent_add_property (icalcomp, icalprop);
-		/*status*/
-		ews_task_status = e_ews_item_get_status (item);
-		if (!g_strcmp0(ews_task_status, "NotStarted") == 0) {
-			if (g_strcmp0 (ews_task_status, "Completed") == 0)
-				status = ICAL_STATUS_COMPLETED;
-			else if (g_strcmp0 (ews_task_status, "InProgress") == 0)
-				status = ICAL_STATUS_INPROCESS;
-			else if (g_strcmp0 (ews_task_status, "WaitingOnOthers") == 0)
-				status = ICAL_STATUS_NEEDSACTION;
-			else if (g_strcmp0 (ews_task_status, "Deferred") == 0)
-				status = ICAL_STATUS_CANCELLED;
-			icalprop = icalproperty_new_status (status);
-			icalcomponent_add_property (icalcomp, icalprop);
-			}
-		/*precent complete*/
-		icalprop  = icalproperty_new_percentcomplete (atoi (e_ews_item_get_percent_complete (item)));
-		icalcomponent_add_property (icalcomp, icalprop);
-
-		/*due date*/
-		e_ews_item_task_has_due_date (item, &has_this_date);
-		if (has_this_date) {
-			due_date = icaltime_from_timet_with_zone (e_ews_item_get_due_date (item), 0, priv->default_zone);
-			icalprop = icalproperty_new_due (due_date);
-			icalcomponent_add_property (icalcomp, icalprop);
-		}
-
-		/*start date*/
-		has_this_date = FALSE;
-		e_ews_item_task_has_start_date (item, &has_this_date);
-		if (has_this_date) {
-			start_date = icaltime_from_timet_with_zone (e_ews_item_get_start_date (item), 0, priv->default_zone);
-			icalprop = icalproperty_new_dtstart (start_date);
-			icalcomponent_add_property (icalcomp, icalprop);
-		}
-
-		/*complete date*/
-		has_this_date = FALSE;
-		e_ews_item_task_has_complete_date (item, &has_this_date);
-		if (has_this_date) {
-			complete_date = icaltime_from_timet_with_zone (e_ews_item_get_complete_date (item), 0, priv->default_zone);
-			icalprop = icalproperty_new_completed (complete_date);
-			icalcomponent_add_property (icalcomp, icalprop);
-		}
 
 		/*date time created*/
 		created = icaltime_from_timet_with_zone (e_ews_item_get_date_created (item), 0, priv->default_zone);
 		icalprop = icalproperty_new_created (created);
 		icalcomponent_add_property (icalcomp, icalprop);
 
-		/*priority*/
-		item_importance = e_ews_item_get_importance (item);
-		if (item_importance == EWS_ITEM_HIGH)
-			priority = 3;
-		else if (item_importance == EWS_ITEM_LOW)
-			priority = 7;
-		icalprop = icalproperty_new_priority (priority);
-		icalcomponent_add_property (icalcomp, icalprop);
-
 		/*sensitivity*/
 		sensitivity = e_ews_item_get_sensitivity (item);
 		if (g_strcmp0 (sensitivity, "Normal") == 0)
@@ -2986,12 +3417,12 @@ add_item_to_cache (ECalBackendEws *cbews
 		icalcomponent_add_property (icalcomp, icalprop);
 
 		/*task assaingments*/
-		if (e_ews_item_get_delegator (item)!= NULL) {
-			const char *task_owner = e_ews_item_get_delegator (item);
+		if (e_ews_item_get_delegator (item) != NULL) {
+			const gchar *task_owner = e_ews_item_get_delegator (item);
 			GSList *mailboxes = NULL, *l;
 			GError *error = NULL;
 			gboolean includes_last_item;
-			char *mailtoname;
+			gchar *mailtoname;
 			icalparameter *param;
 
 			/*The task owner according to Exchange is current user, even that the task was assigned by
@@ -2999,16 +3430,17 @@ add_item_to_cache (ECalBackendEws *cbews
 
 			mailtoname = g_strdup_printf ("mailto:%s", priv->user_email);
 			icalprop = icalproperty_new_attendee (mailtoname);
-			g_free(mailtoname);
+			g_free (mailtoname);
 
 			param = icalparameter_new_cn (e_ews_item_get_owner (item));
 			icalproperty_add_parameter (icalprop, param);
 			icalcomponent_add_property (icalcomp, icalprop);
 
 			/* get delegator mail box*/
-			e_ews_connection_resolve_names	(priv->cnc, EWS_PRIORITY_MEDIUM, task_owner,
-						 EWS_SEARCH_AD, NULL, FALSE, &mailboxes, NULL,
-						 &includes_last_item, NULL, &error);
+			e_ews_connection_resolve_names_sync (
+				priv->cnc, EWS_PRIORITY_MEDIUM, task_owner,
+				EWS_SEARCH_AD, NULL, FALSE, &mailboxes, NULL,
+				&includes_last_item, priv->cancellable, &error);
 
 			for (l = mailboxes; l != NULL; l = g_slist_next (l)) {
 				EwsMailbox *mb = l->data;
@@ -3020,37 +3452,94 @@ add_item_to_cache (ECalBackendEws *cbews
 				icalcomponent_add_property (icalcomp, icalprop);
 
 				g_free (mailtoname);
-				g_free (mb->email);
-				g_free (mb->name);
-				g_free (mb);
+				e_ews_mailbox_free (mb);
 			}
 			g_slist_free (mailboxes);
 		}
 
+		if (item_type == E_EWS_ITEM_TYPE_TASK) {
+			/*start date*/
+			has_this_date = FALSE;
+			e_ews_item_task_has_start_date (item, &has_this_date);
+			if (has_this_date) {
+				start_date = icaltime_from_timet_with_zone (e_ews_item_get_start_date (item), 0, priv->default_zone);
+				start_date.is_date = 1;
+				icalprop = icalproperty_new_dtstart (start_date);
+				icalcomponent_add_property (icalcomp, icalprop);
+			}
+
+			/*status*/
+			ews_task_status = e_ews_item_get_status (item);
+			if (!g_strcmp0 (ews_task_status, "NotStarted") == 0) {
+				if (g_strcmp0 (ews_task_status, "Completed") == 0)
+					status = ICAL_STATUS_COMPLETED;
+				else if (g_strcmp0 (ews_task_status, "InProgress") == 0)
+					status = ICAL_STATUS_INPROCESS;
+				else if (g_strcmp0 (ews_task_status, "WaitingOnOthers") == 0)
+					status = ICAL_STATUS_NEEDSACTION;
+				else if (g_strcmp0 (ews_task_status, "Deferred") == 0)
+					status = ICAL_STATUS_CANCELLED;
+				icalprop = icalproperty_new_status (status);
+				icalcomponent_add_property (icalcomp, icalprop);
+			}
+
+			/*precent complete*/
+			icalprop  = icalproperty_new_percentcomplete (atoi (e_ews_item_get_percent_complete (item)));
+			icalcomponent_add_property (icalcomp, icalprop);
+
+			/*due date*/
+			e_ews_item_task_has_due_date (item, &has_this_date);
+			if (has_this_date) {
+				due_date = icaltime_from_timet_with_zone (e_ews_item_get_due_date (item), 0, priv->default_zone);
+				due_date.is_date = 1;
+				icalprop = icalproperty_new_due (due_date);
+				icalcomponent_add_property (icalcomp, icalprop);
+			}
+
+			/*complete date*/
+			has_this_date = FALSE;
+			e_ews_item_task_has_complete_date (item, &has_this_date);
+			if (has_this_date) {
+				complete_date = icaltime_from_timet_with_zone (e_ews_item_get_complete_date (item), 0, priv->default_zone);
+				complete_date.is_date = 1;
+				icalprop = icalproperty_new_completed (complete_date);
+				icalcomponent_add_property (icalcomp, icalprop);
+			}
+
+			/*priority*/
+			item_importance = e_ews_item_get_importance (item);
+			if (item_importance == EWS_ITEM_HIGH)
+				priority = 3;
+			else if (item_importance == EWS_ITEM_LOW)
+				priority = 7;
+			icalprop = icalproperty_new_priority (priority);
+			icalcomponent_add_property (icalcomp, icalprop);
+		}
 
 		icalcomponent_add_component (vcomp,icalcomp);
 	} else {
 		struct icaltimetype dt;
 		icaltimezone *zone;
+
 		mime_content = e_ews_item_get_mime_content (item);
 		vcomp = icalparser_parse_string (mime_content);
 
 		/* Add the timezone */
 		vtimezone = icalcomponent_get_first_component (vcomp, ICAL_VTIMEZONE_COMPONENT);
-		if (vtimezone) {
+		if (vtimezone != NULL) {
 			zone = icaltimezone_new ();
-			icaltimezone_set_component (zone, icalcomponent_new_clone (vtimezone));
-			if (icaltimezone_get_tzid(zone))
-				e_cal_backend_store_put_timezone (priv->store, zone);
-
+			vtimezone = icalcomponent_new_clone (vtimezone);
+			icaltimezone_set_component (zone, vtimezone);
+			e_cal_backend_store_put_timezone (priv->store, zone);
 			icaltimezone_free (zone, TRUE);
 		}
 
 		zone = NULL;
-		if (e_ews_item_get_tzid (item) && (zone = (icaltimezone *)e_cal_backend_store_get_timezone(priv->store, e_ews_item_get_tzid (item))) == NULL)
-			zone = (icaltimezone *)icaltimezone_get_builtin_timezone(e_ews_item_get_tzid (item));
+		if (e_ews_item_get_tzid (item) &&
+		    (zone = (icaltimezone *) e_cal_backend_store_get_timezone (priv->store, e_ews_item_get_tzid (item))) == NULL)
+			zone = (icaltimezone *) icaltimezone_get_builtin_timezone (e_ews_item_get_tzid (item));
 
-		if (zone) {
+		if (zone != NULL) {
 			icalcomp = icalcomponent_get_first_component (vcomp, kind);
 
 			icalcomponent_add_component (vcomp, icalcomponent_new_clone (icaltimezone_get_component (zone)));
@@ -3071,34 +3560,42 @@ add_item_to_cache (ECalBackendEws *cbews
 		icalproperty *icalprop, *freebusy;
 		const EwsId *item_id;
 		ECalComponentId *id;
-		gchar *comp_str;
 		const GSList *l = NULL;
-		const char *org_email_address = e_ews_collect_organizer(icalcomp);
-		const char *uid = e_ews_item_get_uid (item);
+		const gchar *org_email_address = e_ews_collect_organizer (icalcomp);
+		const gchar *uid = e_ews_item_get_uid (item);
 
 		item_id = e_ews_item_get_id (item);
 
 		/* Attendees */
 		for (l = e_ews_item_get_attendees (item); l != NULL; l = g_slist_next (l)) {
 			icalparameter *param, *cu_type;
-			char *mailtoname;
-			EwsAttendee *attendee = (EwsAttendee *)l->data;
+			gchar *mailtoname;
+			const gchar *email = NULL;
+			EwsAttendee *attendee = (EwsAttendee *) l->data;
+
+			if (!attendee->mailbox)
+				continue;
+
+			if (g_strcmp0 (attendee->mailbox->routing_type, "EX") == 0)
+				email = e_ews_item_util_strip_ex_address (attendee->mailbox->email);
+
 			/*remove organizer for attendees list*/
-			if (g_ascii_strcasecmp (org_email_address, attendee->mailbox->email)== 0)
+			if (g_ascii_strcasecmp (org_email_address, email ? email : attendee->mailbox->email) == 0) {
 				continue;
+			}
 
-			mailtoname = g_strdup_printf("mailto:%s", attendee->mailbox->email);
-			icalprop = icalproperty_new_attendee(mailtoname);
-			g_free(mailtoname);
+			mailtoname = g_strdup_printf ("mailto:%s", email ? email : attendee->mailbox->email);
+			icalprop = icalproperty_new_attendee (mailtoname);
+			g_free (mailtoname);
 
-			param = icalparameter_new_cn(attendee->mailbox->name);
-			icalproperty_add_parameter(icalprop, param);
+			param = icalparameter_new_cn (attendee->mailbox->name);
+			icalproperty_add_parameter (icalprop, param);
 
-			if (g_ascii_strcasecmp(attendee->attendeetype, "Required") == 0) {
+			if (g_ascii_strcasecmp (attendee->attendeetype, "Required") == 0) {
 				param = icalparameter_new_role (ICAL_ROLE_REQPARTICIPANT);
 				cu_type = icalparameter_new_cutype (ICAL_CUTYPE_INDIVIDUAL);
 			}
-			else if (g_ascii_strcasecmp(attendee->attendeetype, "Resource") == 0) {
+			else if (g_ascii_strcasecmp (attendee->attendeetype, "Resource") == 0) {
 				param = icalparameter_new_role (ICAL_ROLE_NONPARTICIPANT);
 				cu_type = icalparameter_new_cutype (ICAL_CUTYPE_RESOURCE);
 			}
@@ -3121,27 +3618,27 @@ add_item_to_cache (ECalBackendEws *cbews
 				param = icalparameter_new_partstat (ICAL_PARTSTAT_NEEDSACTION);
 			else if (g_ascii_strcasecmp (attendee->responsetype, "Unknown") == 0)
 				param = icalparameter_new_partstat (ICAL_PARTSTAT_NONE);
-			icalproperty_add_parameter(icalprop, param);
+			icalproperty_add_parameter (icalprop, param);
 
-			icalcomponent_add_property(icalcomp, icalprop);
+			icalcomponent_add_property (icalcomp, icalprop);
 		}
 
 		/* Free/Busy */
 		freebusy = icalcomponent_get_first_property (icalcomp, ICAL_TRANSP_PROPERTY);
-		if (!freebusy && (e_ews_item_get_item_type(item)!=E_EWS_ITEM_TYPE_TASK)) {
+		if (!freebusy && (e_ews_item_get_item_type (item) != E_EWS_ITEM_TYPE_TASK)) {
 			/* Busy by default */
-			freebusy = icalproperty_new_transp(ICAL_TRANSP_OPAQUE);
+			freebusy = icalproperty_new_transp (ICAL_TRANSP_OPAQUE);
 			icalcomponent_add_property (icalcomp, freebusy);
 		}
 		for (icalprop = icalcomponent_get_first_property (icalcomp, ICAL_X_PROPERTY);
-				icalprop != NULL;
-				icalprop = icalcomponent_get_next_property (icalcomp, ICAL_X_PROPERTY)) {
+			icalprop != NULL;
+			icalprop = icalcomponent_get_next_property (icalcomp, ICAL_X_PROPERTY)) {
 
-			if (g_strcmp0(icalproperty_get_x_name(icalprop), "X-MICROSOFT-CDO-BUSYSTATUS") == 0) {
-				if (g_strcmp0(icalproperty_get_value_as_string(icalprop), "BUSY") == 0) {
-					icalproperty_set_transp(freebusy, ICAL_TRANSP_OPAQUE);
+			if (g_strcmp0 (icalproperty_get_x_name (icalprop), "X-MICROSOFT-CDO-BUSYSTATUS") == 0) {
+				if (g_strcmp0 (icalproperty_get_value_as_string (icalprop), "BUSY") == 0) {
+					icalproperty_set_transp (freebusy, ICAL_TRANSP_OPAQUE);
 				} else {
-					icalproperty_set_transp(freebusy, ICAL_TRANSP_TRANSPARENT);
+					icalproperty_set_transp (freebusy, ICAL_TRANSP_TRANSPARENT);
 				}
 
 				break;
@@ -3150,11 +3647,11 @@ add_item_to_cache (ECalBackendEws *cbews
 
 		/*AllDayEvent*/
 		for (icalprop = icalcomponent_get_first_property (icalcomp, ICAL_X_PROPERTY);
-				icalprop != NULL;
-				icalprop = icalcomponent_get_next_property (icalcomp, ICAL_X_PROPERTY)) {
+			icalprop != NULL;
+			icalprop = icalcomponent_get_next_property (icalcomp, ICAL_X_PROPERTY)) {
 
-			if (g_strcmp0(icalproperty_get_x_name(icalprop), "X-MICROSOFT-CDO-ALLDAYEVENT") == 0) {
-				if (g_strcmp0(icalproperty_get_value_as_string(icalprop), "TRUE") == 0) {
+			if (g_strcmp0 (icalproperty_get_x_name (icalprop), "X-MICROSOFT-CDO-ALLDAYEVENT") == 0) {
+				if (g_strcmp0 (icalproperty_get_value_as_string (icalprop), "TRUE") == 0) {
 					struct icaltimetype dtend, dtstart;
 					dtstart = icalcomponent_get_dtstart (icalcomp);
 					dtstart.is_date = 1;
@@ -3192,7 +3689,7 @@ add_item_to_cache (ECalBackendEws *cbews
 			}
 		}
 
-		icalcomponent_set_uid (icalcomp,uid?uid:item_id->id);
+		icalcomponent_set_uid (icalcomp,uid ? uid : item_id->id);
 
 		icalprop = icalproperty_new_x (item_id->id);
 		icalproperty_set_x_name (icalprop, "X-EVOLUTION-ITEMID");
@@ -3209,22 +3706,24 @@ add_item_to_cache (ECalBackendEws *cbews
 		cache_comp = e_cal_backend_store_get_component (priv->store, id->uid, id->rid);
 		e_cal_component_free_id (id);
 
-		comp_str = e_cal_component_get_as_string (comp);
 		put_component_to_store (cbews, comp);
 
 		if (!cache_comp) {
+			gchar *comp_str = e_cal_component_get_as_string (comp);
+
 			e_cal_backend_notify_object_created (E_CAL_BACKEND (cbews), comp_str);
+
+			g_free (comp_str);
 		} else {
-			gchar *cache_str;
+			gchar *old_comp_str = e_cal_component_get_as_string (cache_comp);
+			gchar *new_comp_str = e_cal_component_get_as_string (comp);
 
-			cache_str = e_cal_component_get_as_string (cache_comp);
-			e_cal_backend_notify_object_modified (E_CAL_BACKEND (cbews), cache_str, comp_str);
+			e_cal_backend_notify_object_modified (E_CAL_BACKEND (cbews), old_comp_str, new_comp_str);
 
-			g_free (cache_str);
+			g_free (old_comp_str);
+			g_free (new_comp_str);
 		}
 
-		g_free (comp_str);
-
 		PRIV_LOCK (priv);
 		g_hash_table_insert (priv->item_id_hash, g_strdup (item_id->id), g_object_ref (comp));
 		PRIV_UNLOCK (priv);
@@ -3234,58 +3733,81 @@ add_item_to_cache (ECalBackendEws *cbews
 	icalcomponent_free (vcomp);
 }
 
-struct _ews_sync_data {
-	ECalBackendEws *cbews;
-	gchar *sync_state;
-	gboolean sync_pending;
-	gchar *master_uid;
-};
+static void
+ews_refreshing_inc (ECalBackendEws *cbews)
+{
+	PRIV_LOCK (cbews->priv);
+	if (!cbews->priv->refreshing)
+		e_flag_clear (cbews->priv->refreshing_done);
+	cbews->priv->refreshing++;
+	PRIV_UNLOCK (cbews->priv);
+}
 
 static void
-ews_cal_get_items_ready_cb (GObject *obj, GAsyncResult *res, gpointer user_data)
+ews_refreshing_dec (ECalBackendEws *cbews)
+{
+	PRIV_LOCK (cbews->priv);
+	if (!cbews->priv->refreshing) {
+		e_flag_set (cbews->priv->refreshing_done);
+		PRIV_UNLOCK (cbews->priv);
+
+		g_warning ("%s: Invalid call, currently not refreshing", G_STRFUNC);
+		return;
+	}
+	cbews->priv->refreshing--;
+	if (!cbews->priv->refreshing) {
+		e_flag_set (cbews->priv->refreshing_done);
+	}
+	PRIV_UNLOCK (cbews->priv);
+}
+
+static void
+ews_cal_sync_get_items_sync (ECalBackendEws *cbews,
+                             const GSList *item_ids,
+                             const gchar *default_props,
+                             const gchar *additional_props)
 {
-	EEwsConnection *cnc;
-	ECalBackendEws *cbews;
 	ECalBackendEwsPrivate *priv;
 	GSList *items = NULL, *l;
-	struct _ews_sync_data *sync_data, *sub_sync_data;
 	GError *error = NULL;
 
-	sync_data = (struct _ews_sync_data *) user_data;
-	cbews = sync_data->cbews;
 	priv = cbews->priv;
-	cnc = (EEwsConnection *) obj;
 
-	e_ews_connection_get_items_finish	(cnc, res, &items, &error);
-	if (error != NULL) {
-		g_warning ("Unable to get items %s \n", error->message);
-
-		PRIV_LOCK (priv);
-		priv->refreshing = FALSE;
-		PRIV_UNLOCK (priv);
+	e_ews_connection_get_items_sync (
+		priv->cnc,
+		EWS_PRIORITY_MEDIUM,
+		item_ids,
+		default_props,
+		additional_props,
+		FALSE,
+		NULL,
+		E_EWS_BODY_TYPE_TEXT,
+		&items,
+		NULL, NULL,
+		priv->cancellable,
+		&error);
 
+	if (error) {
+		g_debug ("%s: Unable to get items: %s", G_STRFUNC, error->message);
 		g_clear_error (&error);
-		goto exit;
+
+		return;
 	}
 
 	/* fetch modified occurrences */
-	for (l = items; l != NULL; l = g_slist_next(l)) {
-		const GSList *modified_occurrences = e_ews_item_get_modified_occurrences (l->data);
-
-		if (modified_occurrences) {
-			const EwsId *item_id = e_ews_item_get_id (l->data);
+	for (l = items; l != NULL; l = g_slist_next (l)) {
+		EEwsItem *item = l->data;
+		const GSList *modified_occurrences;
 
-			sub_sync_data = g_new0 (struct _ews_sync_data, 1);
-			sub_sync_data->cbews = sync_data->cbews;
-			sub_sync_data->master_uid = g_strdup (item_id->id);
-
-			e_ews_connection_get_items_start(g_object_ref(cnc), EWS_PRIORITY_MEDIUM,
-					modified_occurrences,
-					"IdOnly", "item:Attachments item:HasAttachments item:MimeContent calendar:TimeZone calendar:UID calendar:Resources calendar:ModifiedOccurrences calendar:RequiredAttendees calendar:OptionalAttendees",
-					FALSE, NULL, ews_cal_get_items_ready_cb, NULL, NULL, NULL,
-					(gpointer) sub_sync_data);
+		if (!item || e_ews_item_get_item_type (item) == E_EWS_ITEM_TYPE_ERROR)
+			continue;
 
-			g_object_unref(cnc);
+		modified_occurrences = e_ews_item_get_modified_occurrences (item);
+		if (modified_occurrences) {
+			ews_cal_sync_get_items_sync (
+				cbews, modified_occurrences,
+				"IdOnly",
+				"item:Attachments item:HasAttachments item:MimeContent calendar:TimeZone calendar:UID calendar:Resources calendar:ModifiedOccurrences calendar:RequiredAttendees calendar:OptionalAttendees");
 		}
 	}
 
@@ -3293,109 +3815,48 @@ ews_cal_get_items_ready_cb (GObject *obj
 	for (l = items; l != NULL; l = g_slist_next (l)) {
 		EEwsItem *item = (EEwsItem *) l->data;
 
-		if (item) {
+		if (!item)
+			continue;
+
+		if (e_ews_item_get_item_type (item) != E_EWS_ITEM_TYPE_ERROR) {
 			add_item_to_cache (cbews, item);
 			ews_get_attachments (cbews, item);
-			g_object_unref (item);
 		}
+
+		g_object_unref (item);
 	}
 	e_cal_backend_store_thaw_changes (priv->store);
 
-
-	if (sync_data->sync_state)
-		e_cal_backend_store_put_key_value (priv->store, SYNC_KEY, sync_data->sync_state);
-	if (sync_data->sync_pending)
-		e_ews_connection_sync_folder_items_start
-						(g_object_ref (priv->cnc), EWS_PRIORITY_MEDIUM,
-						 sync_data->sync_state, priv->folder_id,
-						 "IdOnly", NULL,
-						 EWS_MAX_FETCH_COUNT,
-						 ews_cal_sync_items_ready_cb,
-						 NULL, cbews);
-
-exit:
-	g_free (sync_data->master_uid);
-	g_free (sync_data->sync_state);
-	g_free (sync_data);
+	g_slist_free (items);
 }
 
 static void
-ews_cal_sync_items_ready_cb (GObject *obj, GAsyncResult *res, gpointer user_data)
+cal_backend_ews_process_folder_items (ECalBackendEws *cbews,
+                                      const gchar *sync_state,
+                                      GSList *items_created,
+                                      GSList *items_updated,
+                                      GSList *items_deleted)
 {
-	EEwsConnection *cnc;
-	ECalBackendEws *cbews;
 	ECalBackendEwsPrivate *priv;
-	GSList *items_created = NULL, *items_updated = NULL;
-	GSList *items_deleted = NULL, *l[2], *m, *cal_item_ids = NULL, *task_item_ids = NULL;
-	gchar *sync_state = NULL;
-	gboolean includes_last_item;
-	GError *error = NULL;
-	struct _ews_sync_data *sync_data = NULL;
+	GSList *l[2], *m, *cal_item_ids = NULL, *task_memo_item_ids = NULL;
 	gint i;
 
-	cnc = (EEwsConnection *) obj;
-	cbews = (ECalBackendEws *) user_data;
 	priv = cbews->priv;
 
-	e_ews_connection_sync_folder_items_finish	(cnc, res, &sync_state, &includes_last_item,
-							 &items_created, &items_updated,
-							 &items_deleted, &error);
-
-	/*FIXME invoke a dummy request in authenticate user to ensure we have a valid connection to avoid this mess */
-#if ! EDS_CHECK_VERSION (3,1,0)
-	PRIV_LOCK (priv);
-	if (priv->opening_ctx) {
-		/* Report success/failure for calendar open if pending,
-		   translating an authentication failure into something that
-		   will be recognized and handled appropriately */
-		if (error && error->domain == EWS_CONNECTION_ERROR &&
-		    error->code == EWS_CONNECTION_ERROR_AUTHENTICATION_FAILED) {
-			e_data_cal_respond_open(priv->opening_cal, priv->opening_ctx,
-					       EDC_ERROR(AuthenticationFailed));
-		} else {
-			e_data_cal_respond_open(priv->opening_cal, priv->opening_ctx,
-					       error?g_error_copy (error):NULL);
-		}
-		priv->opening_ctx = 0;
-		priv->opening_cal = NULL;
-		if (error) {
-			priv->cnc = NULL;
-			g_object_unref (cnc);
-		}
-
-	}
-	PRIV_UNLOCK (priv);
-#else
-	if (!(error && error->domain == EWS_CONNECTION_ERROR && error->code == EWS_CONNECTION_ERROR_AUTHENTICATION_FAILED))
-		e_cal_backend_notify_readonly (E_CAL_BACKEND (cbews), FALSE);
-#endif	
-
-	if (error != NULL) {
-		g_warning ("Unable to Sync changes %s \n", error->message);
-
-		PRIV_LOCK (priv);
-		priv->refreshing = FALSE;
-		PRIV_UNLOCK (priv);
-
-		g_clear_error (&error);
-		return;
-	}
-
 	l[0] = items_created;
 	l[1] = items_updated;
 
 	for (i = 0; i < 2; i++)	{
-		for (;l[i] != NULL; l[i] = g_slist_next (l[i])) {
+		for (; l[i] != NULL; l[i] = g_slist_next (l[i])) {
 			EEwsItem *item = (EEwsItem *) l[i]->data;
 			EEwsItemType type = e_ews_item_get_item_type (item);
 			const EwsId *id;
 
 			id = e_ews_item_get_id (item);
-			if (type == E_EWS_ITEM_TYPE_CALENDAR_ITEM)
-				cal_item_ids = g_slist_append (cal_item_ids, g_strdup (id->id));
-			else if (type == E_EWS_ITEM_TYPE_TASK)
-				task_item_ids = g_slist_append (task_item_ids, g_strdup (id->id));
-			g_object_unref (item);
+			if (type == E_EWS_ITEM_TYPE_EVENT)
+				cal_item_ids = g_slist_prepend (cal_item_ids, id->id);
+			else if (type == E_EWS_ITEM_TYPE_TASK || type == E_EWS_ITEM_TYPE_MEMO)
+				task_memo_item_ids = g_slist_prepend (task_memo_item_ids, id->id);
 		}
 	}
 
@@ -3409,95 +3870,202 @@ ews_cal_sync_items_ready_cb (GObject *ob
 		PRIV_UNLOCK (priv);
 
 		if (comp)
-			ews_cal_delete_comp(cbews, comp, item_id);
-
-		g_free (m->data);
+			ews_cal_delete_comp (cbews, comp, item_id);
 	}
 	e_cal_backend_store_thaw_changes (priv->store);
 
-	if (!cal_item_ids && !task_item_ids && !includes_last_item) {
-		e_cal_backend_store_put_key_value (priv->store, SYNC_KEY, sync_state);
-		e_ews_connection_sync_folder_items_start
-						(g_object_ref (priv->cnc), EWS_PRIORITY_MEDIUM,
-						 sync_state, priv->folder_id,
-						 "IdOnly", NULL,
-						 EWS_MAX_FETCH_COUNT,
-						 ews_cal_sync_items_ready_cb,
-						 NULL, cbews);
-		g_free (sync_state);
-		goto exit;
+	if (cal_item_ids) {
+		ews_cal_sync_get_items_sync (
+			cbews,
+			cal_item_ids,
+			"IdOnly",
+			"item:Attachments item:HasAttachments item:MimeContent calendar:TimeZone calendar:UID calendar:Resources calendar:ModifiedOccurrences calendar:RequiredAttendees calendar:OptionalAttendees");
 	}
 
-	if (cal_item_ids || task_item_ids) {
-		sync_data = g_new0 (struct _ews_sync_data, 1);
-		sync_data->cbews = cbews;
-		sync_data->sync_state = sync_state;
-		sync_data->sync_pending = !includes_last_item;
-	}
-
-	if (cal_item_ids)
-		e_ews_connection_get_items_start (cnc,
-						  EWS_PRIORITY_MEDIUM,
-						  cal_item_ids,
-						  "IdOnly",
-						  "item:Attachments item:HasAttachments item:MimeContent calendar:TimeZone calendar:UID calendar:Resources calendar:ModifiedOccurrences calendar:RequiredAttendees calendar:OptionalAttendees",
-						  FALSE, NULL,
-						  ews_cal_get_items_ready_cb,
-						  NULL, NULL, NULL,
-						  (gpointer) sync_data);
-
-	if (task_item_ids)
-		e_ews_connection_get_items_start (cnc, EWS_PRIORITY_MEDIUM,
-						  task_item_ids,
-						  "AllProperties",
-						  NULL,
-						  FALSE,
-						  NULL,
-						  ews_cal_get_items_ready_cb,
-						  NULL, NULL, NULL,
-						  (gpointer) sync_data);
+	if (task_memo_item_ids) {
+		ews_cal_sync_get_items_sync (
+			cbews,
+			task_memo_item_ids,
+			"AllProperties",
+			NULL);
+	}
 
+	g_slist_free (cal_item_ids);
+	g_slist_free (task_memo_item_ids);
+}
 
-exit:
-	if (cal_item_ids) {
-		g_slist_foreach (cal_item_ids, (GFunc) g_free, NULL);
-		g_slist_free (cal_item_ids);
-	}
-	if (task_item_ids) {
-		g_slist_foreach (task_item_ids, (GFunc) g_free, NULL);
-		g_slist_free (task_item_ids);
+static void
+cbews_forget_all_components (ECalBackendEws *cbews)
+{
+	ECalBackend *backend;
+	GSList *ids, *ii;
+
+	g_return_if_fail (E_IS_CAL_BACKEND_EWS (cbews));
+
+	backend = E_CAL_BACKEND (cbews);
+	g_return_if_fail (backend != NULL);
+
+	ids = e_cal_backend_store_get_component_ids (cbews->priv->store);
+	for (ii = ids; ii; ii = ii->next) {
+		ECalComponentId *id = ii->data;
+
+		if (!id)
+			continue;
+
+		e_cal_backend_store_remove_component (cbews->priv->store, id->uid, id->rid);
+		e_cal_backend_notify_object_removed (backend, id, NULL, NULL);
 	}
 
-	if (items_created)
-		g_slist_free (items_created);
-	if (items_updated)
-		g_slist_free (items_updated);
-	if (items_deleted)
-		g_slist_free (items_deleted);
+	g_slist_free_full (ids, (GDestroyNotify) e_cal_component_free_id);
 }
 
-static gboolean
-ews_start_sync	(gpointer data)
+static gpointer
+ews_start_sync_thread (gpointer data)
 {
 	ECalBackendEws *cbews;
 	ECalBackendEwsPrivate *priv;
-	const gchar *sync_state;
+	GSList *items_created = NULL;
+	GSList *items_updated = NULL;
+	GSList *items_deleted = NULL;
+	gboolean includes_last_item;
+	gchar *old_sync_state = NULL;
+	gchar *new_sync_state = NULL;
+	GError *error = NULL;
 
 	cbews = (ECalBackendEws *) data;
 	priv = cbews->priv;
 
-	PRIV_LOCK (priv);
-	priv->refreshing = TRUE;
-	PRIV_UNLOCK (priv);
+	old_sync_state = g_strdup (e_cal_backend_store_get_key_value (priv->store, SYNC_KEY));
+	do {
+		includes_last_item = TRUE;
+
+		e_ews_connection_sync_folder_items_sync (
+			priv->cnc, EWS_PRIORITY_MEDIUM,
+			old_sync_state, priv->folder_id,
+			"IdOnly", "item:ItemClass",
+			EWS_MAX_FETCH_COUNT,
+			&new_sync_state,
+			&includes_last_item,
+			&items_created,
+			&items_updated,
+			&items_deleted,
+			priv->cancellable,
+			&error);
+
+		if (g_error_matches (error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_INVALIDSYNCSTATEDATA)) {
+			g_clear_error (&error);
+			e_cal_backend_store_put_key_value (priv->store, SYNC_KEY, NULL);
+			cbews_forget_all_components (cbews);
+
+			e_ews_connection_sync_folder_items_sync (priv->cnc, EWS_PRIORITY_MEDIUM, NULL, priv->folder_id, "IdOnly", NULL, EWS_MAX_FETCH_COUNT,
+				&new_sync_state, &includes_last_item, &items_created, &items_updated, &items_deleted,
+				priv->cancellable, &error);
+		}
+
+#if ! EDS_CHECK_VERSION (3,1,0)
+		PRIV_LOCK (priv);
+		if (priv->opening_ctx) {
+			/* Report success/failure for calendar open if pending,
+			   translating an authentication failure into something that
+			   will be recognized and handled appropriately */
+			if (g_error_matches (error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_AUTHENTICATION_FAILED)) {
+				e_data_cal_respond_open(priv->opening_cal, priv->opening_ctx,
+						       EDC_ERROR (AuthenticationFailed));
+			} else {
+				e_data_cal_respond_open (priv->opening_cal, priv->opening_ctx,
+						       error ? g_error_copy (error) : NULL);
+			}
+
+			priv->opening_ctx = 0;
+			priv->opening_cal = NULL;
+
+			if (error) {
+				g_object_unref (priv->cnc);
+				priv->cnc = NULL;
+				PRIV_UNLOCK (priv);
+				g_clear_error (&error);
+				break;
+			}
+
+		}
+		PRIV_UNLOCK (priv);
+#endif
+
+		if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED) ||
+		    g_error_matches (error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_CANCELLED)) {
+			break;
+		}
+
+		if (!g_error_matches (error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_AUTHENTICATION_FAILED)) {
+			priv->read_only = FALSE;
+			e_cal_backend_notify_readonly (E_CAL_BACKEND (cbews), priv->read_only);
+		}
+
+		if (error == NULL) {
+			cal_backend_ews_process_folder_items (
+				cbews, new_sync_state,
+				items_created, items_updated, items_deleted);
+
+			g_slist_free_full (items_created, (GDestroyNotify) g_object_unref);
+			g_slist_free_full (items_updated, (GDestroyNotify) g_object_unref);
+			g_slist_free_full (items_deleted, (GDestroyNotify) g_free);
+			items_created = NULL;
+			items_updated = NULL;
+			items_deleted = NULL;
+		} else {
+			g_warn_if_fail (items_created == NULL);
+			g_warn_if_fail (items_updated == NULL);
+			g_warn_if_fail (items_deleted == NULL);
+
+			g_warning ("%s: %s", G_STRFUNC, error->message);
+			g_error_free (error);
+			break;
+		}
+
+		g_free (old_sync_state);
+		old_sync_state = new_sync_state;
+		e_cal_backend_store_put_key_value (priv->store, SYNC_KEY, new_sync_state);
+		new_sync_state = NULL;
+	} while (!includes_last_item);
+
+	ews_refreshing_dec (cbews);
+
+	g_slist_free_full (items_created, (GDestroyNotify) g_object_unref);
+	g_slist_free_full (items_updated, (GDestroyNotify) g_object_unref);
+	g_slist_free_full (items_deleted, (GDestroyNotify) g_free);
+
+	g_free (new_sync_state);
+	g_free (old_sync_state);
+
+	g_object_unref (cbews);
+
+	return NULL;
+}
+
+static gboolean
+ews_start_sync (gpointer data)
+{
+	ECalBackendEws *cbews = data;
+
+	PRIV_LOCK (cbews->priv);
+	if (cbews->priv->refreshing) {
+		PRIV_UNLOCK (cbews->priv);
+		return TRUE;
+	}
+
+	ews_refreshing_inc (cbews);
+
+	if (!cbews->priv->cnc) {
+		ews_refreshing_dec (cbews);
+		PRIV_UNLOCK (cbews->priv);
+		return FALSE;
+	}
+	PRIV_UNLOCK (cbews->priv);
+
+	/* run the actual operation in thread,
+	 * to not block main thread of the factory */
+	g_thread_create (ews_start_sync_thread, g_object_ref (cbews), FALSE, NULL);
 
-	sync_state = e_cal_backend_store_get_key_value (priv->store, SYNC_KEY);
-	e_ews_connection_sync_folder_items_start
-						(priv->cnc, EWS_PRIORITY_MEDIUM,
-						 sync_state, priv->folder_id,
-						 "IdOnly", NULL,
-						 EWS_MAX_FETCH_COUNT,
-						 ews_cal_sync_items_ready_cb,
-						 NULL, cbews);
 	return TRUE;
 }
 
@@ -3510,51 +4078,80 @@ ews_cal_start_refreshing (ECalBackendEws
 
 	PRIV_LOCK (priv);
 
-	if	(!priv->refresh_timeout &&
- 		 priv->mode == CAL_MODE_REMOTE &&
-		 priv->cnc) {
-			ews_start_sync (cbews);
-			priv->refresh_timeout = g_timeout_add_seconds
-							(REFRESH_INTERVAL,
-							 (GSourceFunc) ews_start_sync,
-							  cbews);
+	if (!priv->refresh_timeout &&
+	    e_cal_backend_ews_get_online (E_CAL_BACKEND_EWS (cbews)) &&
+	    priv->cnc) {
+		ews_start_sync (cbews);
+		priv->refresh_timeout = g_timeout_add_seconds (
+			REFRESH_INTERVAL, (GSourceFunc) ews_start_sync, cbews);
 	}
 
 	PRIV_UNLOCK (priv);
 }
 
 static void
-e_cal_backend_ews_start_query (ECalBackend *backend, EDataCalView *query)
+e_cal_backend_ews_start_query (ECalBackend *backend,
+                               EDataCalView *query)
 {
 	ECalBackendEws *cbews;
-	GSList *objects = NULL;
+	ECalBackendEwsPrivate *priv;
+	GSList *components, *l;
+	ECalBackendSExp *cbsexp;
+	const gchar *sexp;
+	gboolean search_needed = TRUE;
+	time_t occur_start = -1, occur_end = -1;
+	gboolean prunning_by_time;
 	GError *err = NULL;
+	GList *objects = NULL;
 
 	cbews = E_CAL_BACKEND_EWS (backend);
+	priv = cbews->priv;
 
 	ews_cal_start_refreshing (cbews);
-	cal_backend_ews_get_object_list (backend, e_data_cal_view_get_text (query),
-					 &objects, &err);
-	if (err) {
+	cbsexp = e_data_cal_view_get_sexp (query);
+	if (!cbsexp) {
+		err = EDC_ERROR (InvalidQuery);
 		e_data_cal_view_notify_complete (query, err);
 		g_error_free (err);
 		return;
 	}
 
-	/* notify listeners of all objects */
-	if (objects) {
-		e_data_cal_view_notify_objects_added_compat (query, objects);
+	sexp = e_cal_backend_sexp_text (cbsexp);
+	if (!sexp || !strcmp (sexp, "#t"))
+		search_needed = FALSE;
 
-		/* free memory */
-		g_slist_foreach (objects, (GFunc) g_free, NULL);
-		g_slist_free (objects);
+	prunning_by_time = e_cal_backend_sexp_evaluate_occur_times (
+		cbsexp, &occur_start, &occur_end);
+	components = prunning_by_time ?
+		e_cal_backend_store_get_components_occuring_in_range (priv->store, occur_start, occur_end)
+		: e_cal_backend_store_get_components (priv->store);
+
+	for (l = components; l != NULL; l = l->next) {
+		ECalComponent *comp = E_CAL_COMPONENT (l->data);
+
+		if (e_cal_backend_get_kind (backend) ==
+		    icalcomponent_isa (e_cal_component_get_icalcomponent (comp))) {
+			if ((!search_needed) ||
+			    (e_cal_backend_sexp_match_comp (cbsexp, comp, backend))) {
+				objects = g_list_prepend (objects, e_cal_component_get_as_string (comp));
+			}
+		}
 	}
 
+	if (objects) {
+		e_data_cal_view_notify_objects_added (query, objects);
+		g_list_free_full (objects, g_free);
+	}
+
+	g_slist_free_full (components, g_object_unref);
 	e_data_cal_view_notify_complete (query, NULL);
 }
 
 static void
-e_cal_backend_ews_refresh (ECalBackend *backend, EDataCal *cal, EServerMethodContext context, GCancellable *cancellable) 
+e_cal_backend_ews_refresh (ECalBackend *backend,
+                           EDataCal *cal,
+                           EServerMethodContext context,
+                           GCancellable *cancellable)
 {
 	ECalBackendEws *cbews;
 	ECalBackendEwsPrivate *priv;
@@ -3564,16 +4161,17 @@ e_cal_backend_ews_refresh (ECalBackend *
 	priv = cbews->priv;
 
 	/* make sure we're not offline */
-	if (priv->mode == CAL_MODE_LOCAL) {
-		g_propagate_error(&error, EDC_ERROR(RepositoryOffline));
+	if (!e_cal_backend_ews_get_online (E_CAL_BACKEND_EWS (backend))) {
+		g_propagate_error (&error, EDC_ERROR (RepositoryOffline));
 		goto exit;
 	}
 
-	PRIV_LOCK(priv);
-	ews_start_sync(cbews);
-	PRIV_UNLOCK(priv);
+	PRIV_LOCK (priv);
+	ews_start_sync (cbews);
+	PRIV_UNLOCK (priv);
 
 exit:
+	convert_error_to_edc_error (&error);
 	e_data_cal_respond_refresh (cal, context, error);
 }
 
@@ -3588,7 +4186,8 @@ typedef struct {
 } EwsFreeBusyData;
 
 static void
-prepare_free_busy_request (ESoapMessage *msg, gpointer user_data)
+prepare_free_busy_request (ESoapMessage *msg,
+                           gpointer user_data)
 {
 	EwsFreeBusyData *free_busy_data = user_data;
 	GSList *addr;
@@ -3596,81 +4195,71 @@ prepare_free_busy_request (ESoapMessage 
 
 	ewscal_set_availability_timezone (msg, free_busy_data->timezone);
 
-	e_soap_message_start_element(msg, "MailboxDataArray", "messages", NULL);
+	e_soap_message_start_element (msg, "MailboxDataArray", "messages", NULL);
 
 	for (addr = free_busy_data->users; addr; addr = addr->next) {
-		e_soap_message_start_element(msg, "MailboxData", NULL, NULL);
+		e_soap_message_start_element (msg, "MailboxData", NULL, NULL);
 
-		e_soap_message_start_element(msg, "Email", NULL, NULL);
+		e_soap_message_start_element (msg, "Email", NULL, NULL);
 		e_ews_message_write_string_parameter (msg, "Address", NULL, addr->data);
-		e_soap_message_end_element(msg); /* "Email" */
+		e_soap_message_end_element (msg); /* "Email" */
 
 		e_ews_message_write_string_parameter (msg, "AttendeeType", NULL, "Required");
 		e_ews_message_write_string_parameter (msg, "ExcludeConflicts", NULL, "false");
 
-		e_soap_message_end_element(msg); /* "MailboxData" */
+		e_soap_message_end_element (msg); /* "MailboxData" */
 	}
 
-	e_soap_message_end_element(msg); /* "MailboxDataArray" */
+	e_soap_message_end_element (msg); /* "MailboxDataArray" */
 
-	e_soap_message_start_element(msg, "FreeBusyViewOptions", NULL, NULL);
+	e_soap_message_start_element (msg, "FreeBusyViewOptions", NULL, NULL);
 
-	e_soap_message_start_element(msg, "TimeWindow", NULL, NULL);
+	e_soap_message_start_element (msg, "TimeWindow", NULL, NULL);
 	t_start = icaltime_from_timet_with_zone (free_busy_data->start, 0, free_busy_data->timezone);
 	t_end = icaltime_from_timet_with_zone (free_busy_data->end, 0, free_busy_data->timezone);
-	ewscal_set_time (msg, "StartTime", &t_start);
-	ewscal_set_time (msg, "EndTime", &t_end);
-	e_soap_message_end_element(msg); /* "TimeWindow" */
+	ewscal_set_time (msg, "StartTime", &t_start, FALSE);
+	ewscal_set_time (msg, "EndTime", &t_end, FALSE);
+	e_soap_message_end_element (msg); /* "TimeWindow" */
 
 	e_ews_message_write_string_parameter (msg, "MergedFreeBusyIntervalInMinutes", NULL, "60");
 	e_ews_message_write_string_parameter (msg, "RequestedView", NULL, "DetailedMerged");
 
-	e_soap_message_end_element(msg); /* "FreeBusyViewOptions" */
+	e_soap_message_end_element (msg); /* "FreeBusyViewOptions" */
 }
 
 static void
-ews_cal_get_free_busy_cb (GObject *obj, GAsyncResult *res, gpointer user_data)
+ews_cal_get_free_busy_cb (GObject *obj,
+                          GAsyncResult *res,
+                          gpointer user_data)
 {
-	EEwsConnection *cnc = (EEwsConnection *)obj;
+	EEwsConnection *cnc = (EEwsConnection *) obj;
 	EwsFreeBusyData *free_busy_data = user_data;
 	GSList *free_busy_sl = NULL, *i;
 	GSList *free_busy = NULL, *j;
 	GError *error = NULL;
-#if ! EDS_CHECK_VERSION (3,1,0)	
-	GList *fb = NULL;
-#endif	
 
 	if (!e_ews_connection_get_free_busy_finish (cnc, res, &free_busy_sl, &error)) {
-		error->code = OtherError;
 		goto done;
 	}
-	
+
 	for (i = free_busy_sl, j = free_busy_data->users; i && j; i = i->next, j = j->next) {
 		/* add attendee property */
-		icalcomponent_add_property((icalcomponent *)i->data, icalproperty_new_attendee (j->data));
+		icalcomponent_add_property ((icalcomponent *) i->data, icalproperty_new_attendee (j->data));
 
 		free_busy = g_slist_append (free_busy, icalcomponent_as_ical_string_r (i->data));
 	}
 	g_slist_free (free_busy_sl);
 
 done:
-#if ! EDS_CHECK_VERSION (3,1,0)	
-	for (j = free_busy; j != NULL; j = g_slist_next (j))
-		fb = g_list_prepend (fb, j->data);
-	if (fb)
-		fb = g_list_reverse (fb);
-	e_data_cal_notify_free_busy (free_busy_data->cal, free_busy_data->context, error, fb);
-	g_list_free (fb);
-#else
 	if (free_busy)
 		e_data_cal_report_free_busy_data (free_busy_data->cal, free_busy);
+	convert_error_to_edc_error (&error);
 	e_data_cal_respond_get_free_busy (free_busy_data->cal, free_busy_data->context, error);
-#endif
 
 	/* FIXME free free_busy_sl ? */
 	g_slist_foreach (free_busy, (GFunc) g_free, NULL);
 	g_slist_free (free_busy);
-	g_slist_foreach (free_busy_data->users, (GFunc)free, NULL);
+	g_slist_foreach (free_busy_data->users, (GFunc) free, NULL);
 	g_slist_free (free_busy_data->users);
 	g_object_unref (free_busy_data->cal);
 	g_object_unref (free_busy_data->cbews);
@@ -3678,9 +4267,13 @@ done:
 }
 
 static void
-e_cal_backend_ews_get_free_busy (ECalBackend *backend, EDataCal *cal,
-				 EServerMethodContext context, GCancellable *cancellable, const GSList *users,
-				 time_t start, time_t end)
+e_cal_backend_ews_get_free_busy (ECalBackend *backend,
+                                 EDataCal *cal,
+                                 EServerMethodContext context,
+                                 GCancellable *cancellable,
+                                 const GSList *users,
+                                 time_t start,
+                                 time_t end)
 {
 	ECalBackendEws *cbews = E_CAL_BACKEND_EWS (backend);
 	ECalBackendEwsPrivate *priv = cbews->priv;
@@ -3689,21 +4282,24 @@ e_cal_backend_ews_get_free_busy (ECalBac
 	GSList *users_copy = NULL;
 
 	/* make sure we're not offline */
-	if (priv->mode == CAL_MODE_LOCAL)
-	{
+	if (!e_cal_backend_ews_get_online (E_CAL_BACKEND_EWS (backend))) {
 		g_propagate_error (&error, EDC_ERROR (RepositoryOffline));
 		goto exit;
 	}
 
+	if (!cal_backend_ews_ensure_connected (cbews, cancellable, &error)) {
+		goto exit;
+	}
+
 	/* EWS can support only 100 identities, which is the maximum number of identities that the Web service method can request
-	 see http://msdn.microsoft.com/en-us/library/aa564001%28v=EXCHG.140%29.aspx*/
+	 see http://msdn.microsoft.com / en - us / library / aa564001 % 28v = EXCHG.140 % 29.aspx */
 	if (g_slist_length ((GSList *) users) > 100)
 	{
 		g_propagate_error (&error, EDC_ERROR (SearchSizeLimitExceeded));
 		goto exit;
 	}
 
-	for (;users; users = users->next)
+	for (; users; users = users->next)
 	    users_copy = g_slist_append (users_copy, g_strdup (users->data));
 
 	free_busy_data = g_new0 (EwsFreeBusyData, 1);
@@ -3715,17 +4311,19 @@ e_cal_backend_ews_get_free_busy (ECalBac
 	free_busy_data->end = end;
 	free_busy_data->timezone = priv->default_zone;
 
-	e_ews_connection_get_free_busy_start (priv->cnc,
-					      EWS_PRIORITY_MEDIUM,
-					      prepare_free_busy_request,
-					      free_busy_data,
-					      ews_cal_get_free_busy_cb,
-					      cancellable,
-					      free_busy_data);
+	e_ews_connection_get_free_busy (
+		priv->cnc,
+		EWS_PRIORITY_MEDIUM,
+		prepare_free_busy_request,
+		free_busy_data,
+		cancellable,
+		ews_cal_get_free_busy_cb,
+		free_busy_data);
 
 	return;
 
 exit:
+	convert_error_to_edc_error (&error);
 #if ! EDS_CHECK_VERSION (3,1,0)	
 	e_data_cal_notify_free_busy (cal, context, error, NULL);
 #else
@@ -3853,6 +4451,31 @@ e_cal_backend_ews_set_online (ECalBacken
 static void
 e_cal_backend_ews_dispose (GObject *object)
 {
+	ECalBackendEws *cbews;
+	ECalBackendEwsPrivate *priv;
+
+	g_return_if_fail (object != NULL);
+	g_return_if_fail (E_IS_CAL_BACKEND_EWS (object));
+
+	cbews = E_CAL_BACKEND_EWS (object);
+	priv = cbews->priv;
+
+	if (priv->refresh_timeout) {
+		g_source_remove (priv->refresh_timeout);
+		priv->refresh_timeout = 0;
+	}
+
+	if (priv->cancellable) {
+		g_cancellable_cancel (priv->cancellable);
+		g_object_unref (priv->cancellable);
+		priv->cancellable = NULL;
+	}
+
+	if (priv->cnc) {
+		g_object_unref (priv->cnc);
+		priv->cnc = NULL;
+	}
+
 	if (G_OBJECT_CLASS (parent_class)->dispose)
 		(* G_OBJECT_CLASS (parent_class)->dispose) (object);
 }
@@ -3873,12 +4496,6 @@ e_cal_backend_ews_finalize (GObject *obj
 	/* Clean up */
 	g_static_rec_mutex_free (&priv->rec_mutex);
 
-	/* TODO Cancel all the server requests */
-	if (priv->cnc) {
-		g_object_unref (priv->cnc);
-		priv->cnc = NULL;
-	}
-
 	if (priv->store) {
 		g_object_unref (priv->store);
 		priv->store = NULL;
@@ -3904,13 +4521,13 @@ e_cal_backend_ews_finalize (GObject *obj
 		priv->default_zone = NULL;
 	}
 
-	if (priv->refresh_timeout) {
-		g_source_remove (priv->refresh_timeout);
-		priv->refresh_timeout = 0;
-	}
-
 	g_hash_table_destroy (priv->item_id_hash);
 
+	if (priv->refreshing_done) {
+		e_flag_free (priv->refreshing_done);
+		priv->refreshing_done = NULL;
+	}
+
 #if EDS_CHECK_VERSION (3,1,0)
 	e_credentials_free (priv->credentials);
 	priv->credentials = NULL;
@@ -3933,11 +4550,13 @@ e_cal_backend_ews_init (ECalBackendEws *
 
 	/* create the mutex for thread safety */
 	g_static_rec_mutex_init (&priv->rec_mutex);
+	priv->refreshing_done = e_flag_new ();
 	priv->item_id_hash = g_hash_table_new_full
 						(g_str_hash, g_str_equal,
 						 (GDestroyNotify) g_free,
 						 (GDestroyNotify) g_object_unref);
 	priv->default_zone = icaltimezone_get_utc_timezone ();
+	priv->cancellable = g_cancellable_new ();
 
 	cbews->priv = priv;
 }
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/calendar/e-cal-backend-ews-utils.c evolution-ews.sync-with-3.8.2/src/calendar/e-cal-backend-ews-utils.c
--- evolution-ews.git-gnome-3-0/src/calendar/e-cal-backend-ews-utils.c	2013-05-17 14:36:16.344670141 +0200
+++ evolution-ews.sync-with-3.8.2/src/calendar/e-cal-backend-ews-utils.c	2013-05-28 08:59:53.478712478 +0200
@@ -32,22 +32,28 @@
 #include <glib/gstdio.h>
 #include <gio/gio.h>
 
-#include <e-ews-connection.h>
-#include <e-ews-message.h>
 #include <libecal/e-cal-recur.h>
 #include <libecal/e-cal-time-util.h>
 #include <libsoup/soup-misc.h>
+
+#include "server/e-ews-connection.h"
+#include "server/e-ews-message.h"
+
 #include "e-cal-backend-ews-utils.h"
-#include "libedataserver/e-source-list.h"
 
 /*
  * Iterate over the icalcomponent properties and collect attendees
  */
-void e_ews_collect_attendees(icalcomponent *comp, GSList **required, GSList **optional, GSList **resource) {
+void
+e_ews_collect_attendees (icalcomponent *comp,
+                         GSList **required,
+                         GSList **optional,
+                         GSList **resource)
+{
 	icalproperty *prop;
 	icalparameter *param;
 	const gchar *str = NULL;
-	const char *org_email_address = NULL;
+	const gchar *org_email_address = NULL;
 
 	/* we need to know who the orgenizer is so we wont duplicate him/her */
 	org_email_address = e_ews_collect_organizer (comp);
@@ -62,7 +68,7 @@ void e_ews_collect_attendees(icalcompone
 		if (!g_ascii_strncasecmp (str, "mailto:", 7)) str = (str) + 7;
 
 		/* if this attenddee is the orgenizer - dont add him/her
-		 in some cases there is no maito for email if meeting orginazer*/
+		 in some cases there is no maito for email if meeting orginazer */
 		if (g_ascii_strcasecmp (org_email_address, str) == 0) continue;
 
 		/* figure type of attendee, add to relevant list */
@@ -71,7 +77,7 @@ void e_ews_collect_attendees(icalcompone
 		/*in case of new time proposal the role parameter is not a part of ical*/
 		if (!param) continue;
 
-		switch (icalparameter_get_role(param)) {
+		switch (icalparameter_get_role (param)) {
 		case ICAL_ROLE_OPTPARTICIPANT:
 			*optional = g_slist_append (*optional, (gpointer)str);
 			break;
@@ -90,7 +96,8 @@ void e_ews_collect_attendees(icalcompone
 	}
 }
 
-gint ews_get_alarm (ECalComponent *comp)
+gint
+ews_get_alarm (ECalComponent *comp)
 {
 	GList *alarm_uids = e_cal_component_get_alarm_uids (comp);
 	ECalComponentAlarm *alarm = e_cal_component_get_alarm (comp, (const gchar *) (alarm_uids->data));
@@ -114,7 +121,9 @@ gint ews_get_alarm (ECalComponent *comp)
 	return dur_int;
 }
 
-void ews_set_alarm (ESoapMessage *msg, ECalComponent *comp)
+void
+ews_set_alarm (ESoapMessage *msg,
+               ECalComponent *comp)
 {
 	/* We know there would be only a single alarm in EWS calendar item */
 	GList *alarm_uids = e_cal_component_get_alarm_uids (comp);
@@ -125,7 +134,7 @@ void ews_set_alarm (ESoapMessage *msg, E
 	e_cal_component_alarm_get_action (alarm, &action);
 	if (action == E_CAL_COMPONENT_ALARM_DISPLAY) {
 		ECalComponentAlarmTrigger trigger;
-		char buf[20];
+		gchar buf[20];
 		gint dur_int = 0;
 		e_cal_component_alarm_get_trigger (alarm, &trigger);
 		switch (trigger.type) {
@@ -143,52 +152,87 @@ void ews_set_alarm (ESoapMessage *msg, E
 
 }
 
-void ewscal_set_time (ESoapMessage *msg, const gchar *name, icaltimetype *t)
-{
-	char *str;
+void
+ewscal_set_time (ESoapMessage *msg,
+                 const gchar *name,
+                 icaltimetype *t,
+                 gboolean with_timezone)
+{
+	gchar *str;
+	gchar *tz_ident = NULL;
+
+	if (with_timezone) {
+		if (t->is_utc || !t->zone || t->zone == icaltimezone_get_utc_timezone ()) {
+			tz_ident = g_strdup ("Z");
+		} else {
+			gint offset, is_daylight, hrs, mins;
+
+			offset = icaltimezone_get_utc_offset (
+				icaltimezone_get_utc_timezone (), t, &is_daylight);
+
+			offset = offset * (-1);
+			hrs = offset / 60;
+			mins = offset % 60;
+
+			if (hrs < 0)
+				hrs *= -1;
+			if (mins < 0)
+				mins *= -1;
+
+			tz_ident = g_strdup_printf ("%s%02d:%02d", offset > 0 ? "+" : "-", hrs, mins);
+		}
+	}
 
-	str = g_strdup_printf("%04d-%02d-%02dT%02d:%02d:%02d",
-			      t->year, t->month, t->day,
-			      t->hour, t->minute, t->second);
+	str = g_strdup_printf (
+		"%04d-%02d-%02dT%02d:%02d:%02d%s",
+		t->year, t->month, t->day,
+		t->hour, t->minute, t->second,
+		tz_ident ? tz_ident : "");
 
-	e_ews_message_write_string_parameter(msg, name, NULL, str);
+	e_ews_message_write_string_parameter (msg, name, NULL, str);
+
+	g_free (tz_ident);
 	g_free (str);
 }
 
-static void ewscal_set_date (ESoapMessage *msg, const gchar *name, icaltimetype *t)
-{
-	char *str;
-
-	str = g_strdup_printf("%04d-%02d-%02d",
-			      t->year, t->month, t->day);
+static void
+ewscal_set_date (ESoapMessage *msg,
+                 const gchar *name,
+                 icaltimetype *t)
+{
+	gchar *str;
+
+	str = g_strdup_printf (
+		"%04d-%02d-%02d",
+		t->year, t->month, t->day);
 
-	e_ews_message_write_string_parameter(msg, name, NULL, str);
+	e_ews_message_write_string_parameter (msg, name, NULL, str);
 	g_free (str);
 }
 
-static const char *number_to_month(int num) {
-	static const char *months[] = {
+static const gchar *number_to_month (gint num) {
+	static const gchar *months[] = {
 		"January", "February", "March", "April", "May", "June", "July",
 		"August", "September", "October", "November", "December"
 	};
 
-	return months[num-1];
+	return months[num - 1];
 }
 
-static const char *number_to_weekday(int num) {
-	static const char *days[] = {
+static const gchar *number_to_weekday (gint num) {
+	static const gchar *days[] = {
 		"Sunday", "Monday", "Tuesday", "Wednesday",
 		"Thursday", "Friday", "Saturday",
 		"Day", "Weekday", "WeekendDay"
 	};
 
-	return days[num-1];
+	return days[num - 1];
 }
 
-static const char *weekindex_to_ical(int index) {
+static const gchar *weekindex_to_ical (gint index) {
 	static struct {
-		const char *exch;
-		int index;
+		const gchar *exch;
+		gint index;
 	} table[] = {
 		{ "First", 1 },
 		{ "Second", 2 },
@@ -197,7 +241,7 @@ static const char *weekindex_to_ical(int
 		{ "Fifth", 5 },
 		{ "Last", -1 }
 	};
-	int i;
+	gint i;
 
 	for (i = 0; i < 6; i++) {
 		if (index == table[i].index)
@@ -207,83 +251,91 @@ static const char *weekindex_to_ical(int
 	return 0;
 }
 
-static void ewscal_add_rrule (ESoapMessage *msg, icalproperty *prop)
+static void
+ewscal_add_rrule (ESoapMessage *msg,
+                  icalproperty *prop)
 {
-	struct icalrecurrencetype recur = icalproperty_get_rrule(prop);
+	struct icalrecurrencetype recur = icalproperty_get_rrule (prop);
 
-	e_soap_message_start_element(msg, "RelativeYearlyRecurrence", NULL, NULL);
+	e_soap_message_start_element (msg, "RelativeYearlyRecurrence", NULL, NULL);
 
-	e_ews_message_write_string_parameter(msg, "DaysOfWeek", NULL, number_to_weekday(icalrecurrencetype_day_day_of_week(recur.by_day[0])));
-	e_ews_message_write_string_parameter(msg, "DayOfWeekIndex", NULL, weekindex_to_ical(icalrecurrencetype_day_position(recur.by_day[0])));
-	e_ews_message_write_string_parameter(msg, "Month", NULL, number_to_month(recur.by_month[0]));
+	e_ews_message_write_string_parameter (msg, "DaysOfWeek", NULL, number_to_weekday (icalrecurrencetype_day_day_of_week (recur.by_day[0])));
+	e_ews_message_write_string_parameter (msg, "DayOfWeekIndex", NULL, weekindex_to_ical (icalrecurrencetype_day_position (recur.by_day[0])));
+	e_ews_message_write_string_parameter (msg, "Month", NULL, number_to_month (recur.by_month[0]));
 
-	e_soap_message_end_element(msg); /* "RelativeYearlyRecurrence" */
+	e_soap_message_end_element (msg); /* "RelativeYearlyRecurrence" */
 }
 
-static void ewscal_add_timechange (ESoapMessage *msg, icalcomponent *comp, int baseoffs)
+static void
+ewscal_add_timechange (ESoapMessage *msg,
+                       icalcomponent *comp,
+                       gint baseoffs)
 {
-	char buffer[16], *offset;
+	gchar buffer[16], *offset;
 	const gchar *tzname;
 	icalproperty *prop;
 	struct icaltimetype dtstart;
-	int utcoffs;
+	gint utcoffs;
 
-	prop = icalcomponent_get_first_property(comp, ICAL_TZNAME_PROPERTY);
+	prop = icalcomponent_get_first_property (comp, ICAL_TZNAME_PROPERTY);
 	if (prop) {
 		tzname = icalproperty_get_tzname (prop);
-		e_soap_message_add_attribute(msg, "TimeZoneName", tzname, NULL, NULL);
+		e_soap_message_add_attribute (msg, "TimeZoneName", tzname, NULL, NULL);
 	}
 
 	/* Calculate zone Offset from BaseOffset */
-	prop = icalcomponent_get_first_property(comp, ICAL_TZOFFSETTO_PROPERTY);
+	prop = icalcomponent_get_first_property (comp, ICAL_TZOFFSETTO_PROPERTY);
 	if (prop) {
-		utcoffs = -icalproperty_get_tzoffsetto(prop);
+		utcoffs = -icalproperty_get_tzoffsetto (prop);
 		utcoffs -= baseoffs;
-		offset = icaldurationtype_as_ical_string_r(icaldurationtype_from_int(utcoffs));
-		e_ews_message_write_string_parameter(msg, "Offset", NULL, offset);
-		free(offset);
+		offset = icaldurationtype_as_ical_string_r (icaldurationtype_from_int (utcoffs));
+		e_ews_message_write_string_parameter (msg, "Offset", NULL, offset);
+		free (offset);
 	}
 
-	prop = icalcomponent_get_first_property(comp, ICAL_RRULE_PROPERTY);
+	prop = icalcomponent_get_first_property (comp, ICAL_RRULE_PROPERTY);
 	if (prop)
 		ewscal_add_rrule (msg, prop);
 
-	prop = icalcomponent_get_first_property(comp, ICAL_DTSTART_PROPERTY);
+	prop = icalcomponent_get_first_property (comp, ICAL_DTSTART_PROPERTY);
 	if (prop) {
-		dtstart = icalproperty_get_dtstart(prop);
-		snprintf(buffer, 16, "%02d:%02d:%02d", dtstart.hour, dtstart.minute, dtstart.second);
-		e_ews_message_write_string_parameter(msg, "Time", NULL, buffer);
+		dtstart = icalproperty_get_dtstart (prop);
+		snprintf (buffer, 16, "%02d:%02d:%02d", dtstart.hour, dtstart.minute, dtstart.second);
+		e_ews_message_write_string_parameter (msg, "Time", NULL, buffer);
 	}
 }
 
-void ewscal_set_timezone (ESoapMessage *msg, const gchar *name, icaltimezone *icaltz)
+void
+ewscal_set_timezone (ESoapMessage *msg,
+                     const gchar *name,
+                     icaltimezone *icaltz)
 {
 	icalcomponent *comp;
 	icalproperty *prop;
 	const gchar *location;
 	icalcomponent *xstd, *xdaylight;
-	int std_utcoffs;
+	gint std_utcoffs;
 	gchar *offset;
 
 	if (!icaltz)
 		return;
 
-	comp = icaltimezone_get_component(icaltz);
+	comp = icaltimezone_get_component (icaltz);
 
 	/* Exchange needs a BaseOffset, followed by either *both*
-	   Standard and Daylight zones, or neither of them. If there's
-	   more than one STANDARD or DAYLIGHT component in the VTIMEZONE,
-	   we ignore the extra. So fully-specified timezones including
-	   historical DST rules cannot be handled by Exchange. */
+	 * Standard and Daylight zones, or neither of them. If there's
+	 * more than one STANDARD or DAYLIGHT component in the VTIMEZONE,
+	 * we ignore the extra. So fully-specified timezones including
+	 * historical DST rules cannot be handled by Exchange. */
 
 	/* FIXME: Walk through them all to find the *latest* ones, like
-	   icaltimezone_get_tznames_from_vtimezone() does. */
-	xstd = icalcomponent_get_first_component(comp, ICAL_XSTANDARD_COMPONENT);
-	xdaylight = icalcomponent_get_first_component(comp, ICAL_XDAYLIGHT_COMPONENT);
+	 * icaltimezone_get_tznames_from_vtimezone() does. */
+	xstd = icalcomponent_get_first_component (comp, ICAL_XSTANDARD_COMPONENT);
+	xdaylight = icalcomponent_get_first_component (comp, ICAL_XDAYLIGHT_COMPONENT);
 
 	/* If there was only a DAYLIGHT component, swap them over and pretend
-	   it was the STANDARD component. We're only going to give the server
-	   the BaseOffset anyway. */
+	 * it was the STANDARD component. We're only going to give the server
+	 * the BaseOffset anyway. */
 	if (!xstd) {
 		xstd = xdaylight;
 		xdaylight = NULL;
@@ -296,139 +348,173 @@ void ewscal_set_timezone (ESoapMessage *
 	if (!location)
 		location = icaltimezone_get_tznames (icaltz);
 
-	e_soap_message_start_element(msg, name, NULL, NULL);
-	e_soap_message_add_attribute(msg, "TimeZoneName", location, NULL, NULL);
+	e_soap_message_start_element (msg, name, NULL, NULL);
+	e_soap_message_add_attribute (msg, "TimeZoneName", location, NULL, NULL);
 
 	/* Fetch the timezone offsets for the standard (or only) zone.
-	   Negate it, because Exchange does it backwards */
+	 * Negate it, because Exchange does it backwards */
 	if (xstd) {
-		prop = icalcomponent_get_first_property(xstd, ICAL_TZOFFSETTO_PROPERTY);
-		std_utcoffs = -icalproperty_get_tzoffsetto(prop);
+		prop = icalcomponent_get_first_property (xstd, ICAL_TZOFFSETTO_PROPERTY);
+		std_utcoffs = -icalproperty_get_tzoffsetto (prop);
 	} else {
 		/* UTC has no properties at all, so just set manually */
 		std_utcoffs = 0;
 	}
 
 	/* This is the overall BaseOffset tag, which the Standard and Daylight
-	   zones are offset from. It's redundant, but Exchange always sets it
-	   to the offset of the Standard zone, and the Offset in the Standard
-	   zone to zero. So try to avoid problems by doing the same. */
-	offset = icaldurationtype_as_ical_string_r(icaldurationtype_from_int(std_utcoffs));
-	e_ews_message_write_string_parameter(msg, "BaseOffset", NULL, offset);
+	 * zones are offset from. It's redundant, but Exchange always sets it
+	 * to the offset of the Standard zone, and the Offset in the Standard
+	 * zone to zero. So try to avoid problems by doing the same. */
+	offset = icaldurationtype_as_ical_string_r (icaldurationtype_from_int (std_utcoffs));
+	e_ews_message_write_string_parameter (msg, "BaseOffset", NULL, offset);
 	free (offset);
 
 	/* Only write the full TimeChangeType information, including the
-	   recurrence rules for the DST changes, if there is more than
-	   one. */
+	 * recurrence rules for the DST changes, if there is more than
+	 * one. */
 	if (xdaylight) {
 		/* Standard */
-		e_soap_message_start_element(msg, "Standard", NULL, NULL);
+		e_soap_message_start_element (msg, "Standard", NULL, NULL);
 		ewscal_add_timechange (msg, xstd, std_utcoffs);
-		e_soap_message_end_element(msg); /* "Standard" */
+		e_soap_message_end_element (msg); /* "Standard" */
 
 		/* DayLight */
-		e_soap_message_start_element(msg, "Daylight", NULL, NULL);
+		e_soap_message_start_element (msg, "Daylight", NULL, NULL);
 		ewscal_add_timechange (msg, xdaylight, std_utcoffs);
-		e_soap_message_end_element(msg); /* "Daylight" */
+		e_soap_message_end_element (msg); /* "Daylight" */
 	}
-	e_soap_message_end_element(msg); /* "MeetingTimeZone" */
+	e_soap_message_end_element (msg); /* "MeetingTimeZone" */
 }
 
-static void ewscal_add_availability_rrule (ESoapMessage *msg, icalproperty *prop)
+static void
+ewscal_add_availability_rrule (ESoapMessage *msg,
+                               icalproperty *prop)
 {
-	struct icalrecurrencetype recur = icalproperty_get_rrule(prop);
-	char buffer[16];
+	struct icalrecurrencetype recur = icalproperty_get_rrule (prop);
+	gchar buffer[16];
 
-	snprintf (buffer, 16, "%d", icalrecurrencetype_day_position(recur.by_day[0]));
-	e_ews_message_write_string_parameter(msg, "DayOrder", NULL, buffer);
+	snprintf (buffer, 16, "%d", icalrecurrencetype_day_position (recur.by_day[0]));
+	e_ews_message_write_string_parameter (msg, "DayOrder", NULL, buffer);
 
 	snprintf (buffer, 16, "%d", recur.by_month[0]);
-	e_ews_message_write_string_parameter(msg, "Month", NULL, buffer);
+	e_ews_message_write_string_parameter (msg, "Month", NULL, buffer);
+
+	e_ews_message_write_string_parameter (msg, "DayOfWeek", NULL, number_to_weekday (icalrecurrencetype_day_day_of_week (recur.by_day[0])));
+}
+
+static void
+ewscal_add_availability_default_timechange (ESoapMessage *msg)
+{
+
+	e_soap_message_start_element (msg, "StandardTime", NULL, NULL);
+	e_ews_message_write_string_parameter (msg, "Bias", NULL, "0");
+	e_ews_message_write_string_parameter (msg, "Time", NULL, "00:00:00");
+	e_ews_message_write_string_parameter (msg, "DayOrder", NULL, "0");
+	e_ews_message_write_string_parameter (msg, "Month", NULL, "0");
+	e_ews_message_write_string_parameter (msg, "DayOfWeek", NULL, "Sunday");
+	e_soap_message_end_element (msg);
 
-	e_ews_message_write_string_parameter(msg, "DayOfWeek", NULL, number_to_weekday(icalrecurrencetype_day_day_of_week(recur.by_day[0])));
+	e_soap_message_start_element (msg, "DaylightTime", NULL, NULL);
+	e_ews_message_write_string_parameter (msg, "Bias", NULL, "0");
+	e_ews_message_write_string_parameter (msg, "Time", NULL, "00:00:00");
+	e_ews_message_write_string_parameter (msg, "DayOrder", NULL, "0");
+	e_ews_message_write_string_parameter (msg, "Month", NULL, "0");
+	e_ews_message_write_string_parameter (msg, "DayOfWeek", NULL, "Sunday");
+	e_soap_message_end_element (msg);
 }
 
-static void ewscal_add_availability_timechange (ESoapMessage *msg, icalcomponent *comp, int baseoffs)
+static void
+ewscal_add_availability_timechange (ESoapMessage *msg,
+                                    icalcomponent *comp,
+                                    gint baseoffs)
 {
-	char buffer[16];
+	gchar buffer[16];
 	icalproperty *prop;
 	struct icaltimetype dtstart;
-	int utcoffs;
+	gint utcoffs;
 
 	/* Calculate zone Offset from BaseOffset */
-	prop = icalcomponent_get_first_property(comp, ICAL_TZOFFSETTO_PROPERTY);
+	prop = icalcomponent_get_first_property (comp, ICAL_TZOFFSETTO_PROPERTY);
 	if (prop) {
-		utcoffs = -icalproperty_get_tzoffsetto(prop)/60;
+		utcoffs = -icalproperty_get_tzoffsetto (prop) / 60;
 		utcoffs -= baseoffs;
 		snprintf (buffer, 16, "%d", utcoffs);
-		e_ews_message_write_string_parameter(msg, "Bias", NULL, buffer);
+		e_ews_message_write_string_parameter (msg, "Bias", NULL, buffer);
 	}
 
-	prop = icalcomponent_get_first_property(comp, ICAL_DTSTART_PROPERTY);
+	prop = icalcomponent_get_first_property (comp, ICAL_DTSTART_PROPERTY);
 	if (prop) {
-		dtstart = icalproperty_get_dtstart(prop);
-		snprintf(buffer, 16, "%02d:%02d:%02d", dtstart.hour, dtstart.minute, dtstart.second);
-		e_ews_message_write_string_parameter(msg, "Time", NULL, buffer);
+		dtstart = icalproperty_get_dtstart (prop);
+		snprintf (buffer, 16, "%02d:%02d:%02d", dtstart.hour, dtstart.minute, dtstart.second);
+		e_ews_message_write_string_parameter (msg, "Time", NULL, buffer);
 	}
 
-	prop = icalcomponent_get_first_property(comp, ICAL_RRULE_PROPERTY);
+	prop = icalcomponent_get_first_property (comp, ICAL_RRULE_PROPERTY);
 	if (prop)
 		ewscal_add_availability_rrule (msg, prop);
 }
 
-void ewscal_set_availability_timezone (ESoapMessage *msg, icaltimezone *icaltz)
+void
+ewscal_set_availability_timezone (ESoapMessage *msg,
+                                  icaltimezone *icaltz)
 {
 	icalcomponent *comp;
 	icalproperty *prop;
 	icalcomponent *xstd, *xdaylight;
-	int std_utcoffs;
+	gint std_utcoffs;
 	gchar *offset;
 
 	if (!icaltz)
 		return;
 
-	comp = icaltimezone_get_component(icaltz);
+	comp = icaltimezone_get_component (icaltz);
 
-	xstd = icalcomponent_get_first_component(comp, ICAL_XSTANDARD_COMPONENT);
-	xdaylight = icalcomponent_get_first_component(comp, ICAL_XDAYLIGHT_COMPONENT);
-
-	/* Should never happen. Exchange will bail out */
-	if (!xstd || !xdaylight)
-		return;
+	xstd = icalcomponent_get_first_component (comp, ICAL_XSTANDARD_COMPONENT);
+	xdaylight = icalcomponent_get_first_component (comp, ICAL_XDAYLIGHT_COMPONENT);
 
-	e_soap_message_start_element(msg, "TimeZone", NULL, NULL);
+	/*TimeZone is the root element of GetUserAvailabilityRequest*/
+	e_soap_message_start_element (msg, "TimeZone", NULL, NULL);
 
 	/* Fetch the timezone offsets for the standard (or only) zone.
-	   Negate it, because Exchange does it backwards */
-	prop = icalcomponent_get_first_property(xstd, ICAL_TZOFFSETTO_PROPERTY);
-	std_utcoffs = -icalproperty_get_tzoffsetto(prop)/60;
+	 * Negate it, because Exchange does it backwards */
+	if (xstd) {
+		prop = icalcomponent_get_first_property (xstd, ICAL_TZOFFSETTO_PROPERTY);
+		std_utcoffs = -icalproperty_get_tzoffsetto (prop) / 60;
+	} else
+		std_utcoffs = 0;
 
 	/* This is the overall BaseOffset tag, which the Standard and Daylight
-	   zones are offset from. It's redundant, but Exchange always sets it
-	   to the offset of the Standard zone, and the Offset in the Standard
-	   zone to zero. So try to avoid problems by doing the same. */
+	 * zones are offset from. It's redundant, but Exchange always sets it
+	 * to the offset of the Standard zone, and the Offset in the Standard
+	 * zone to zero. So try to avoid problems by doing the same. */
 	offset = g_strdup_printf ("%d", std_utcoffs);
-	e_ews_message_write_string_parameter(msg, "Bias", NULL, offset);
+	e_ews_message_write_string_parameter (msg, "Bias", NULL, offset);
 	g_free (offset);
 
 	if (xdaylight) {
 		/* Standard */
-		e_soap_message_start_element(msg, "StandardTime", NULL, NULL);
+		e_soap_message_start_element (msg, "StandardTime", NULL, NULL);
 		ewscal_add_availability_timechange (msg, xstd, std_utcoffs);
-		e_soap_message_end_element(msg); /* "StandardTime" */
+		e_soap_message_end_element (msg); /* "StandardTime" */
 
 		/* DayLight */
-		e_soap_message_start_element(msg, "DaylightTime", NULL, NULL);
+		e_soap_message_start_element (msg, "DaylightTime", NULL, NULL);
 		ewscal_add_availability_timechange (msg, xdaylight, std_utcoffs);
-		e_soap_message_end_element(msg); /* "DaylightTime" */
-	}
-	e_soap_message_end_element(msg); /* "TimeZone" */
+		e_soap_message_end_element (msg); /* "DaylightTime" */
+	} else
+		/* Set default values*/
+		ewscal_add_availability_default_timechange (msg);
+
+	e_soap_message_end_element (msg); /* "TimeZone" */
 }
 
-void ewscal_set_reccurence (ESoapMessage *msg, icalproperty *rrule, icaltimetype *dtstart)
+void
+ewscal_set_reccurence (ESoapMessage *msg,
+                       icalproperty *rrule,
+                       icaltimetype *dtstart)
 {
-	char buffer[256];
-	int i, len;
+	gchar buffer[256];
+	gint i, len;
 	gboolean is_relative = FALSE;
 
 	/* MSDN reference: http://msdn.microsoft.com/en-us/library/aa580471%28v=EXCHG.80%29.aspx
@@ -451,13 +537,15 @@ void ewscal_set_reccurence (ESoapMessage
 			snprintf (buffer, 32, "%d", recur.interval);
 			e_ews_message_write_string_parameter (msg, "Interval", NULL, buffer);
 
-			len = snprintf (buffer, 256, "%s",
-				number_to_weekday(icalrecurrencetype_day_day_of_week(recur.by_day[0])));
+			len = snprintf (
+				buffer, 256, "%s",
+				number_to_weekday (icalrecurrencetype_day_day_of_week (recur.by_day[0])));
 			for (i = 1; recur.by_day[i] != ICAL_RECURRENCE_ARRAY_MAX; i++) {
-				len += snprintf (buffer+len, 256-len, " %s",
-					number_to_weekday(icalrecurrencetype_day_day_of_week(recur.by_day[i])));
+				len += snprintf (
+					buffer + len, 256 - len, " %s",
+					number_to_weekday (icalrecurrencetype_day_day_of_week (recur.by_day[i])));
 			}
-			e_ews_message_write_string_parameter(msg, "DaysOfWeek", NULL, buffer);
+			e_ews_message_write_string_parameter (msg, "DaysOfWeek", NULL, buffer);
 
 			e_soap_message_end_element (msg); /* "WeeklyRecurrence" */
 			break;
@@ -470,23 +558,24 @@ void ewscal_set_reccurence (ESoapMessage
 				 relative monthly recurrence evolution can set.
 				 TODO: extend the code with all possible monthly recurrence settings */
 				snprintf (buffer, 32, "%d", recur.interval);
-				e_ews_message_write_string_parameter(msg, "Interval", NULL, buffer);
-				
-				e_ews_message_write_string_parameter(msg, "DaysOfWeek", NULL,
-					number_to_weekday (icalrecurrencetype_day_day_of_week(recur.by_day[0])));
-				
-				e_ews_message_write_string_parameter(msg, "DayOfWeekIndex", NULL, weekindex_to_ical ((recur.by_set_pos[0] == 5 ? -1 : recur.by_set_pos[0])));
+				e_ews_message_write_string_parameter (msg, "Interval", NULL, buffer);
+
+				e_ews_message_write_string_parameter (
+					msg, "DaysOfWeek", NULL,
+					number_to_weekday (icalrecurrencetype_day_day_of_week (recur.by_day[0])));
+
+				e_ews_message_write_string_parameter (msg, "DayOfWeekIndex", NULL, weekindex_to_ical ((recur.by_set_pos[0] == 5 ? -1 : recur.by_set_pos[0])));
 
 				e_soap_message_end_element (msg); /* "RelativeMonthlyRecurrence" */
 
 			} else {
 				e_soap_message_start_element (msg, "AbsoluteMonthlyRecurrence", NULL, NULL);
 
-                                snprintf (buffer, 256, "%d", recur.interval);
+				snprintf (buffer, 256, "%d", recur.interval);
 				e_ews_message_write_string_parameter (msg, "Interval", NULL, buffer);
 
 				snprintf (buffer, 256, "%d", recur.by_month_day[0]);
-				e_ews_message_write_string_parameter(msg, "DayOfMonth", NULL, buffer);
+				e_ews_message_write_string_parameter (msg, "DayOfMonth", NULL, buffer);
 
 				e_soap_message_end_element (msg); /* "AbsoluteMonthlyRecurrence" */
 
@@ -508,14 +597,16 @@ void ewscal_set_reccurence (ESoapMessage
 				} else {
 					snprintf (buffer, 256, "%d", dtstart->day);
 				}
-				e_ews_message_write_string_parameter(msg, "DayOfMonth", NULL, buffer);
+				e_ews_message_write_string_parameter (msg, "DayOfMonth", NULL, buffer);
 
 				if (recur.by_month[0] != ICAL_RECURRENCE_ARRAY_MAX) {
 					snprintf (buffer, 256, "%d", recur.by_month_day[0]);
-					e_ews_message_write_string_parameter(msg, "Month", NULL,
+					e_ews_message_write_string_parameter (
+						msg, "Month", NULL,
 						number_to_month (recur.by_month[0]));
 				} else {
-					e_ews_message_write_string_parameter(msg, "Month", NULL,
+					e_ews_message_write_string_parameter (
+						msg, "Month", NULL,
 						number_to_month (dtstart->month));
 				}
 
@@ -557,17 +648,18 @@ exit:
 }
 
 static struct icaltimetype
-icalcomponent_get_datetime(icalcomponent *comp, icalproperty *prop)
+icalcomponent_get_datetime (icalcomponent *comp,
+                            icalproperty *prop)
 {
 	/* Extract datetime with proper timezone */
 	icalcomponent *c;
 	icalparameter *param;
 	struct icaltimetype ret;
 
-	ret = icalvalue_get_datetime (icalproperty_get_value(prop));
+	ret = icalvalue_get_datetime (icalproperty_get_value (prop));
 
 	if ((param = icalproperty_get_first_parameter (prop, ICAL_TZID_PARAMETER)) != NULL) {
-		const char *tzid = icalparameter_get_tzid (param);
+		const gchar *tzid = icalparameter_get_tzid (param);
 		icaltimezone *tz = NULL;
 
 		for (c = comp; c != NULL; c = icalcomponent_get_parent (c)) {
@@ -576,16 +668,18 @@ icalcomponent_get_datetime(icalcomponent
 		}
 
 		if (tz == NULL)
-			tz = icaltimezone_get_builtin_timezone_from_tzid(tzid);
+			tz = icaltimezone_get_builtin_timezone_from_tzid (tzid);
 
 		if (tz != NULL)
-			ret = icaltime_set_timezone(&ret, tz);
+			ret = icaltime_set_timezone (&ret, tz);
 	}
 
 	return ret;
 }
 
-void ewscal_set_reccurence_exceptions (ESoapMessage *msg, icalcomponent *comp)
+void
+ewscal_set_reccurence_exceptions (ESoapMessage *msg,
+                                  icalcomponent *comp)
 {
 	icalproperty *exdate;
 
@@ -596,7 +690,7 @@ void ewscal_set_reccurence_exceptions (E
 	e_soap_message_start_element (msg, "DeletedOccurrences", NULL, NULL);
 
 	for (; exdate; exdate = icalcomponent_get_next_property (comp, ICAL_EXDATE_PROPERTY)) {
-		struct icaltimetype exdatetime = icalcomponent_get_datetime(comp, exdate);
+		struct icaltimetype exdatetime = icalcomponent_get_datetime (comp, exdate);
 
 		e_soap_message_start_element (msg, "DeletedOccurrence", NULL, NULL);
 
@@ -608,12 +702,16 @@ void ewscal_set_reccurence_exceptions (E
 	e_soap_message_end_element (msg); /* "DeletedOccurrences" */
 }
 
-void ewscal_get_attach_differences (const GSList *original, const GSList *modified, GSList **removed, GSList **added)
+void
+ewscal_get_attach_differences (const GSList *original,
+                               const GSList *modified,
+                               GSList **removed,
+                               GSList **added)
 {
 	gboolean flag;
 	GSList *i, *i_next, *j, *j_next, *original_copy, *modified_copy;
-	original_copy = g_slist_copy ((GSList *)original);
-	modified_copy = g_slist_copy ((GSList *)modified);
+	original_copy = g_slist_copy ((GSList *) original);
+	modified_copy = g_slist_copy ((GSList *) modified);
 
 	for (j = modified_copy; j; j = j_next) {
 		j_next = j->next;
@@ -637,40 +735,45 @@ void ewscal_get_attach_differences (cons
 /*
  * get meeting organizer e-mail address
  */
-const char *e_ews_collect_organizer(icalcomponent *comp)
+const gchar *
+e_ews_collect_organizer (icalcomponent *comp)
 {
 	icalproperty *org_prop = NULL;
 	const gchar *org = NULL;
-	const char *org_email_address = NULL;
+	const gchar *org_email_address = NULL;
 
 	org_prop = icalcomponent_get_first_property (comp, ICAL_ORGANIZER_PROPERTY);
-	org = icalproperty_get_organizer(org_prop);
+	org = icalproperty_get_organizer (org_prop);
 	if (!org)
 		org = "";
-	else
+	else {
 		if (!g_ascii_strncasecmp (org, "MAILTO:", 7))
-				org_email_address = (org) + 7;
-			else
-				org_email_address = org;
+			org_email_address = (org) + 7;
+		else
+			org_email_address = org;
+	}
+
 	return org_email_address;
 }
 
-gchar *e_ews_extract_attachment_id_from_uri (const gchar *uri)
+gchar *
+e_ews_extract_attachment_id_from_uri (const gchar *uri)
 {
 	gchar *attachment_id, *filepath = g_filename_from_uri (uri, NULL, NULL);
 	gchar **dirs = g_strsplit (filepath, "/", 0);
-	int n = 0;
+	gint n = 0;
 
 	while (dirs[n]) n++;
 
-	attachment_id = g_strdup (dirs[n-1]);
+	attachment_id = g_strdup (dirs[n - 1]);
 
 	g_strfreev (dirs);
 
 	return attachment_id;
 }
 
-void e_ews_clean_icalcomponent (icalcomponent *icalcomp)
+void
+e_ews_clean_icalcomponent (icalcomponent *icalcomp)
 {
 	icalproperty *prop, *item_id_prop = NULL, *changekey_prop = NULL;
 
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/calendar/e-cal-backend-ews-utils.h evolution-ews.sync-with-3.8.2/src/calendar/e-cal-backend-ews-utils.h
--- evolution-ews.git-gnome-3-0/src/calendar/e-cal-backend-ews-utils.h	2013-05-17 14:36:16.344670141 +0200
+++ evolution-ews.sync-with-3.8.2/src/calendar/e-cal-backend-ews-utils.h	2013-05-28 08:59:53.478712478 +0200
@@ -31,10 +31,10 @@ G_BEGIN_DECLS
 #define MINUTES_IN_HOUR 60
 #define SECS_IN_MINUTE 60
 
-const char *e_ews_collect_organizer(icalcomponent *comp);
-void e_ews_collect_attendees(icalcomponent *comp, GSList **required, GSList **optional, GSList **resource);
+const gchar *e_ews_collect_organizer (icalcomponent *comp);
+void e_ews_collect_attendees (icalcomponent *comp, GSList **required, GSList **optional, GSList **resource);
 
-void ewscal_set_time (ESoapMessage *msg, const gchar *name, icaltimetype *t);
+void ewscal_set_time (ESoapMessage *msg, const gchar *name, icaltimetype *t, gboolean with_timezone);
 void ewscal_set_timezone (ESoapMessage *msg, const gchar *name, icaltimezone *icaltz);
 void ewscal_set_availability_timezone (ESoapMessage *msg, icaltimezone *icaltz);
 void ewscal_set_reccurence (ESoapMessage *msg, icalproperty *rrule, icaltimetype *dtstart);
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/calendar/libedata-cal-compat.h evolution-ews.sync-with-3.8.2/src/calendar/libedata-cal-compat.h
--- evolution-ews.git-gnome-3-0/src/calendar/libedata-cal-compat.h	2013-05-17 14:36:16.347669869 +0200
+++ evolution-ews.sync-with-3.8.2/src/calendar/libedata-cal-compat.h	2013-05-28 08:59:53.479712340 +0200
@@ -48,4 +48,6 @@ void		e_data_cal_respond_get_free_busy		
 void		e_data_cal_report_free_busy_data		(EDataCal *cal, const GSList *freebusy);
 void            e_data_cal_view_notify_complete                 (EDataCalView *view, const GError *error);
 
+#define e_data_cal_view_get_sexp e_data_cal_view_get_object_sexp
+
 #endif
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/calendar/Makefile.am evolution-ews.sync-with-3.8.2/src/calendar/Makefile.am
--- evolution-ews.git-gnome-3-0/src/calendar/Makefile.am	2013-05-17 14:36:16.343669523 +0200
+++ evolution-ews.sync-with-3.8.2/src/calendar/Makefile.am	2013-05-28 08:59:53.479712340 +0200
@@ -8,6 +8,8 @@ libecalbackendews_la_CPPFLAGS = \
 	$(AM_CPPFLAGS)					\
 	-I$(top_srcdir)					\
 	-I$(top_builddir)				\
+	-I$(top_srcdir)/src				\
+	-I$(top_builddir)/src				\
 	-I$(top_srcdir)/src/calendar			\
 	-I$(top_builddir)/src/calendar			\
 	-I$(top_srcdir)/src/server			\
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/camel/camel-ews-folder.c evolution-ews.sync-with-3.8.2/src/camel/camel-ews-folder.c
--- evolution-ews.git-gnome-3-0/src/camel/camel-ews-folder.c	2013-05-17 14:36:16.348670560 +0200
+++ evolution-ews.sync-with-3.8.2/src/camel/camel-ews-folder.c	2013-05-28 08:59:53.268712513 +0200
@@ -48,6 +48,7 @@ which needs to be better organized via f
 #include <e-ews-item-change.h>
 #include <e-ews-message.h>
 #include <e-ews-compat.h>
+#include <e-ews-gnome-3-8-compat.h>
 
 #include "camel-ews-folder.h"
 #include "camel-ews-private.h"
@@ -91,74 +92,61 @@ struct _CamelEwsFolderPrivate {
 
 extern gint camel_application_is_exiting;
 
-static gboolean
-ews_delete_messages (CamelFolder *folder, GSList *deleted_items, gboolean expunge, GCancellable *cancellable, GError **error);
+static gboolean ews_delete_messages (CamelFolder *folder, GSList *deleted_items, gboolean expunge, GCancellable *cancellable, GError **error);
+static gboolean ews_refresh_info_sync (CamelFolder *folder, EVO3(GCancellable *cancellable,) GError **error);
 
 #define d(x)
 
 G_DEFINE_TYPE (CamelEwsFolder, camel_ews_folder, CAMEL_TYPE_OFFLINE_FOLDER)
 
 static gchar *
-ews_get_filename (CamelFolder *folder, const gchar *uid, GError **error)
+ews_get_filename (CamelFolder *folder,
+                  const gchar *uid,
+                  GError **error)
 {
-	CamelEwsFolder *ews_folder = CAMEL_EWS_FOLDER(folder);
+	CamelEwsFolder *ews_folder = CAMEL_EWS_FOLDER (folder);
 	GChecksum *sha = g_checksum_new (G_CHECKSUM_SHA256);
-	gchar *ret;
+	gchar *filename;
 
-	g_checksum_update(sha, (guchar *)uid, strlen(uid));
-	ret = camel_data_cache_get_filename (ews_folder->cache, "cur",
-					     g_checksum_get_string (sha),
-					     error);
+	g_checksum_update (sha, (guchar *) uid, strlen (uid));
+	filename = camel_data_cache_get_filename (
+		ews_folder->cache, "cur", g_checksum_get_string (sha), error);
 	g_checksum_free (sha);
-	return ret;
+
+	return filename;
 }
 
 static gint
 ews_data_cache_remove (CamelDataCache *cdc,
-		       const gchar *path,
-		       const gchar *key,
-		       GError **error)
+                       const gchar *path,
+                       const gchar *key,
+                       GError **error)
 {
 	GChecksum *sha = g_checksum_new (G_CHECKSUM_SHA256);
 	gint ret;
 
-	g_checksum_update(sha, (guchar *)key, strlen(key));
-	ret = camel_data_cache_remove (cdc, path, g_checksum_get_string (sha),
-				       error);
+	g_checksum_update (sha, (guchar *) key, strlen (key));
+	ret = camel_data_cache_remove (
+		cdc, path, g_checksum_get_string (sha), error);
 	g_checksum_free (sha);
+
 	return ret;
 }
 
 static CamelStream *
 ews_data_cache_get (CamelDataCache *cdc,
-		    const gchar *path,
-		    const gchar *key,
-		    GError **error)
+                    const gchar *path,
+                    const gchar *key,
+                    GError **error)
 {
 	GChecksum *sha = g_checksum_new (G_CHECKSUM_SHA256);
 	CamelStream *ret;
 
-	g_checksum_update(sha, (guchar *)key, strlen(key));
-	ret = camel_data_cache_get (cdc, path, g_checksum_get_string (sha),
-				    error);
+	g_checksum_update (sha, (guchar *) key, strlen (key));
+	ret = camel_data_cache_get (
+		cdc, path, g_checksum_get_string (sha), error);
 	g_checksum_free (sha);
-	return ret;
-}
 
-static gchar *
-ews_data_cache_get_filename (CamelDataCache *cdc,
-			     const gchar *path,
-			     const gchar *key,
-			     GError **error)
-{
-	GChecksum *sha = g_checksum_new (G_CHECKSUM_SHA256);
-	gchar *ret;
-
-	g_checksum_update(sha, (guchar *)key, strlen(key));
-	ret = camel_data_cache_get_filename (cdc, path,
-					     g_checksum_get_string (sha),
-					     error);
-	g_checksum_free (sha);
 	return ret;
 }
 
@@ -175,8 +163,28 @@ static gboolean camel_data_wrapper_const
 #endif
 
 
+static gchar *
+ews_data_cache_get_filename (CamelDataCache *cdc,
+                             const gchar *path,
+                             const gchar *key,
+                             GError **error)
+{
+	GChecksum *sha = g_checksum_new (G_CHECKSUM_SHA256);
+	gchar *filename;
+
+	g_checksum_update (sha, (guchar *) key, strlen (key));
+	filename = camel_data_cache_get_filename (
+		cdc, path, g_checksum_get_string (sha), error);
+	g_checksum_free (sha);
+
+	return filename;
+}
+
 static CamelMimeMessage *
-camel_ews_folder_get_message_from_cache (CamelEwsFolder *ews_folder, const gchar *uid, GCancellable *cancellable, GError **error)
+camel_ews_folder_get_message_from_cache (CamelEwsFolder *ews_folder,
+                                         const gchar *uid,
+                                         GCancellable *cancellable,
+                                         GError **error)
 {
 	CamelStream *stream;
 	CamelMimeMessage *msg;
@@ -187,11 +195,12 @@ camel_ews_folder_get_message_from_cache 
 	g_static_rec_mutex_lock (&priv->cache_lock);
 	stream = ews_data_cache_get (ews_folder->cache, "cur", uid, error);
 	if (!stream) {
-		gchar *old_fname = camel_data_cache_get_filename (ews_folder->cache, "cur",
-								  uid, error);
+		gchar *old_fname = camel_data_cache_get_filename (
+			ews_folder->cache, "cur", uid, error);
 		if (!g_access (old_fname, R_OK)) {
-			gchar *new_fname = ews_data_cache_get_filename (ews_folder->cache,
-									"cur", uid, error);
+			gchar *new_fname = ews_data_cache_get_filename (
+				ews_folder->cache,
+				"cur", uid, error);
 			g_rename (old_fname, new_fname);
 			g_free (new_fname);
 			stream = ews_data_cache_get (ews_folder->cache, "cur", uid, error);
@@ -206,7 +215,7 @@ camel_ews_folder_get_message_from_cache 
 	msg = camel_mime_message_new ();
 
 	if (!camel_data_wrapper_construct_from_stream_sync (
-				(CamelDataWrapper *)msg, stream, cancellable, error)) {
+		(CamelDataWrapper *) msg, stream, cancellable, error)) {
 		g_object_unref (msg);
 		msg = NULL;
 	}
@@ -218,7 +227,7 @@ camel_ews_folder_get_message_from_cache 
 }
 
 static CamelMimePart *
-ews_get_calendar_mime_part (CamelMimePart* mimepart)
+ews_get_calendar_mime_part (CamelMimePart *mimepart)
 {
 	guint partnumber, i;
 	CamelDataWrapper *datawrapper;
@@ -234,7 +243,7 @@ ews_get_calendar_mime_part (CamelMimePar
 			if (!child_mimepart)
 				goto exit;
 
-			ret_mimepart = ews_get_calendar_mime_part (child_mimepart) ;
+			ret_mimepart = ews_get_calendar_mime_part (child_mimepart);
 			if (ret_mimepart)
 				return ret_mimepart;
 		}
@@ -253,34 +262,41 @@ ews_get_calendar_mime_part (CamelMimePar
 }
 
 static gchar *
-ews_update_mgtrequest_mime_calendar_itemid (const gchar* mime_fname, const EwsId* item_id, gboolean is_calendar_UID, GError **error)
+ews_update_mgtrequest_mime_calendar_itemid (const gchar *mime_fname,
+                                            const EwsId *calendar_item_id,
+                                            gboolean is_calendar_UID,
+					    const EwsId *mail_item_id,
+                                            GError **error)
 {
 	CamelMimeParser *mimeparser;
 	CamelMimeMessage *msg;
 	CamelMimePart *mimepart = NULL;
-	int fd_old;
+	gint fd_old;
 	gchar *mime_fname_new = NULL;
 
 	// original mime file
 	fd_old = open (mime_fname, O_RDONLY);
 	if (fd_old == -1) {
-		g_set_error (error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
-			     _("Unable to open mimecontent temporary file!"));
+		g_set_error (
+			error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
+			_("Unable to open mimecontent temporary file!"));
 		return NULL;
 	}
 
 	mimeparser = camel_mime_parser_new ();
 	if (camel_mime_parser_init_with_fd (mimeparser, fd_old) == -1) {
-		g_set_error (error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
-			     _("Unable to generate parser from mimecontent!"));
+		g_set_error (
+			error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
+			_("Unable to generate parser from mimecontent!"));
 		goto exit_parser;
 	}
 
 	msg = camel_mime_message_new ();
-	if (EVO3_sync(camel_mime_part_construct_from_parser) (CAMEL_MIME_PART(msg),
-							      mimeparser, EVO3(NULL,) error) == -1) {
-		g_set_error (error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
-			     _("Unable to parse meeting request mimecontent!"));
+	if (EVO3_sync(camel_mime_part_construct_from_parser) (
+		CAMEL_MIME_PART (msg), mimeparser, EVO3(NULL,) error) == -1) {
+		g_set_error (
+			error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
+			_("Unable to parse meeting request mimecontent!"));
 		goto exit_msg;
 	}
 
@@ -293,13 +309,13 @@ ews_update_mgtrequest_mime_calendar_item
 		icalproperty *icalprop;
 		gchar *calstring_new, *dir;
 		const gchar *temp;
-		int fd;
+		gint fd;
 		gboolean success = FALSE;
 
 		dw = camel_medium_get_content (CAMEL_MEDIUM (mimepart));
 		tmpstream = camel_stream_mem_new ();
-		if (EVO3_sync(camel_data_wrapper_decode_to_stream) (dw,
-								    tmpstream, EVO3(NULL,) error) == -1) {
+		if (EVO3_sync(camel_data_wrapper_decode_to_stream) (
+			dw, tmpstream, EVO3(NULL,) error) == -1) {
 			g_object_unref (tmpstream);
 			goto exit_msg;
 		}
@@ -307,25 +323,28 @@ ews_update_mgtrequest_mime_calendar_item
 		g_byte_array_append (ba, (guint8 *) "\0", 1);
 		icalcomp = icalparser_parse_string ((gchar *) ba->data);
 		subcomp = icalcomponent_get_first_component (icalcomp, ICAL_VEVENT_COMPONENT);
-		icalprop = icalproperty_new_x (item_id->change_key);
+		icalprop = icalproperty_new_x (calendar_item_id->change_key);
 		icalproperty_set_x_name (icalprop, "X-EVOLUTION-CHANGEKEY");
 
 		/* In order to accept items we have to store AssociatedCalendarItemId (X-EVOLUTION-ITEMID)
-		 * or mail id (X-EVOLUTION-ACCEPT-ID ) when we do not have AssociatedCalendarItemId */
+		 * or mail id (X-EVOLUTION-ACCEPT-ID) when we do not have AssociatedCalendarItemId */
 		icalcomponent_add_property (subcomp, icalprop);
-		if (is_calendar_UID){
-			icalprop = icalproperty_new_x (item_id->id);
+		if (is_calendar_UID) {
+			icalprop = icalproperty_new_x (calendar_item_id->id);
 			icalproperty_set_x_name (icalprop, "X-EVOLUTION-ITEMID");
 			icalcomponent_add_property (subcomp, icalprop);
-		} else {
-			icalprop = icalproperty_new_x (item_id->id);
-			icalproperty_set_x_name (icalprop, "X-EVOLUTION-ACCEPT-ID");
-			icalcomponent_add_property (subcomp, icalprop);
 		}
+
+		icalprop = icalproperty_new_x (mail_item_id->id);
+		icalproperty_set_x_name (icalprop, "X-EVOLUTION-ACCEPT-ID");
+		icalcomponent_add_property (subcomp, icalprop);
+
 		calstring_new = icalcomponent_as_ical_string_r (icalcomp);
-		camel_mime_part_set_content (mimepart,
-					     (const gchar*) calstring_new, strlen (calstring_new),
-					     "text/calendar");
+		camel_mime_part_set_content (
+			mimepart,
+			(const gchar *) calstring_new,
+			strlen (calstring_new),
+			"text/calendar");
 		g_free (calstring_new);
 		icalcomponent_free (icalcomp);
 		g_object_unref (tmpstream);
@@ -333,16 +352,18 @@ ews_update_mgtrequest_mime_calendar_item
 		// Create a new file to store updated mimecontent
 		temp = g_strrstr (mime_fname, "/");
 		dir = g_strndup (mime_fname, temp - mime_fname);
-		mime_fname_new = g_build_filename ((const gchar*) dir, "XXXXXX", NULL);
+		mime_fname_new = g_build_filename ((const gchar *) dir, "XXXXXX", NULL);
 		fd = g_mkstemp (mime_fname_new);
 		if (fd == -1) {
-			g_set_error (error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
-				     _("Unable to create cache file"));
+			g_set_error (
+				error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
+				_("Unable to create cache file"));
 			goto exit_save;
 		}
 		newstream = camel_stream_fs_new_with_fd (fd);
-		if (EVO3_sync(camel_data_wrapper_write_to_stream) (CAMEL_DATA_WRAPPER (msg),
-								   newstream, EVO3(NULL,) error) == -1)
+		if (EVO3_sync(camel_data_wrapper_write_to_stream) (
+			CAMEL_DATA_WRAPPER (msg),
+			newstream, EVO3(NULL,) error) == -1)
 			goto exit_save;
 		if (camel_stream_flush (newstream, EVO3(NULL,) error) == -1)
 			goto exit_save;
@@ -375,7 +396,11 @@ ews_update_mgtrequest_mime_calendar_item
 }
 
 static CamelMimeMessage *
-camel_ews_folder_get_message (CamelFolder *folder, const gchar *uid, gint pri, GCancellable *cancellable, GError **error)
+camel_ews_folder_get_message (CamelFolder *folder,
+                              const gchar *uid,
+                              gint pri,
+                              GCancellable *cancellable,
+                              GError **error)
 {
 	CamelEwsFolder *ews_folder;
 	CamelEwsFolderPrivate *priv;
@@ -389,15 +414,16 @@ camel_ews_folder_get_message (CamelFolde
 	gchar *cache_file;
 	gchar *dir;
 	const gchar *temp;
-	gpointer progress_data;
 	gboolean res;
+	gpointer progress_data;
 	gchar *mime_fname_new = NULL;
+	GError *local_error = NULL;
 
 	ews_store = (CamelEwsStore *) camel_folder_get_parent_store (folder);
 	ews_folder = (CamelEwsFolder *) folder;
 	priv = ews_folder->priv;
 
-	if (!camel_ews_store_connected (ews_store, error))
+	if (!camel_ews_store_connected (ews_store, cancellable, error))
 		return NULL;
 
 	g_mutex_lock (priv->state_lock);
@@ -405,10 +431,10 @@ camel_ews_folder_get_message (CamelFolde
 	/* If another thread is already fetching this message, wait for it */
 
 	/* FIXME: We might end up refetching a message anyway, if another
-	   thread has already finished fetching it by the time we get to
-	   this point in the code — ews_folder_get_message_sync() doesn't
-	   hold any locks when it calls get_message_from_cache() and then
-	   falls back to this function. */
+	 * thread has already finished fetching it by the time we get to
+	 * this point in the code — ews_folder_get_message_sync() doesn't
+	 * hold any locks when it calls get_message_from_cache() and then
+	 * falls back to this function. */
 	if (g_hash_table_lookup (priv->uid_eflags, uid)) {
 		do {
 			g_cond_wait (priv->fetch_cond, priv->state_lock);
@@ -421,46 +447,52 @@ camel_ews_folder_get_message (CamelFolde
 	}
 
 	/* Because we're using this as a form of mutex, we *know* that
-	   we won't be inserting where an entry already exists. So it's
-	   OK to insert uid itself, not g_strdup (uid) */
-	g_hash_table_insert (priv->uid_eflags, (gchar *)uid, (gchar *)uid);
+	 * we won't be inserting where an entry already exists. So it's
+	 * OK to insert uid itself, not g_strdup (uid) */
+	g_hash_table_insert (priv->uid_eflags, (gchar *) uid, (gchar *) uid);
 	g_mutex_unlock (priv->state_lock);
 
-	cnc = camel_ews_store_get_connection (ews_store);
+	cnc = camel_ews_store_ref_connection (ews_store);
 	ids = g_slist_append (ids, (gchar *) uid);
 	EVO3(progress_data = cancellable);
 	EVO2(progress_data = camel_operation_registered ());
 
-	mime_dir = g_build_filename (camel_data_cache_get_path (ews_folder->cache),
-				     "mimecontent", NULL);
+	mime_dir = g_build_filename (
+		camel_data_cache_get_path (ews_folder->cache),
+		"mimecontent", NULL);
 
 	if (g_access (mime_dir, F_OK) == -1 &&
 	    g_mkdir_with_parents (mime_dir, 0700) == -1) {
-		g_set_error (error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
-			     _("Unable to create cache path"));
+		g_set_error (
+			error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
+			_("Unable to create cache path"));
 		g_free (mime_dir);
 		goto exit;
 	}
 
-	res = e_ews_connection_get_items (cnc, pri, ids, "IdOnly", "item:MimeContent",
-					  TRUE, mime_dir,
-					  &items,
-					  (ESoapProgressFn)camel_operation_progress,
-					  progress_data,
-					  cancellable, error);
+	res = e_ews_connection_get_items_sync (
+		cnc, pri, ids, "IdOnly", "item:MimeContent",
+		TRUE, mime_dir, E_EWS_BODY_TYPE_ANY,
+		&items,
+		(ESoapProgressFn) camel_operation_progress,
+		progress_data,
+		cancellable, &local_error);
 	g_free (mime_dir);
 
-	if (!res)
+	if (!res || !items) {
+		camel_ews_store_maybe_disconnect (ews_store, local_error);
+		g_propagate_error (error, local_error);
 		goto exit;
+	}
 
 	/* The mime_content actually contains the *filename*, due to the
-	   streaming hack in ESoapMessage */
+	 * streaming hack in ESoapMessage */
 	mime_content = e_ews_item_get_mime_content (items->data);
 
 	/* Exchange returns random UID for associated calendar item, which has no way
-	   to match with calendar components saved in calendar cache. So manually get
-	   AssociatedCalendarItemId, replace the random UID with this ItemId,
-	   And save updated message data to a new temp file */
+	 * to match with calendar components saved in calendar cache. So manually get
+	 * AssociatedCalendarItemId, replace the random UID with this ItemId,
+	 * And save updated message data to a new temp file */
 	if (e_ews_item_get_item_type (items->data) == E_EWS_ITEM_TYPE_MEETING_REQUEST ||
 		e_ews_item_get_item_type (items->data) == E_EWS_ITEM_TYPE_MEETING_CANCELLATION ||
 		e_ews_item_get_item_type (items->data) == E_EWS_ITEM_TYPE_MEETING_MESSAGE ||
@@ -470,17 +502,23 @@ camel_ews_folder_get_message (CamelFolde
 		gboolean is_calendar_UID = TRUE;
 
 		// Get AssociatedCalendarItemId with second get_items call
-		res = e_ews_connection_get_items (cnc, pri, ids, "IdOnly", "meeting:AssociatedCalendarItemId",
-						  FALSE, NULL,
-						  &items_req,
-						  (ESoapProgressFn)camel_operation_progress,
-						  progress_data,
-						  cancellable, error);
-		if (!res) {
+		res = e_ews_connection_get_items_sync (
+			cnc, pri, ids, "IdOnly",
+			"meeting:AssociatedCalendarItemId",
+			FALSE, NULL, E_EWS_BODY_TYPE_ANY,
+			&items_req,
+			(ESoapProgressFn) camel_operation_progress,
+			(gpointer) progress_data,
+			cancellable, &local_error);
+		if (!res || (items_req && e_ews_item_get_item_type (items_req->data) == E_EWS_ITEM_TYPE_ERROR)) {
 			if (items_req) {
 				g_object_unref (items_req->data);
 				g_slist_free (items_req);
 			}
+			if (local_error) {
+				camel_ews_store_maybe_disconnect (ews_store, local_error);
+				g_propagate_error (error, local_error);
+			}
 			goto exit;
 		}
 		calendar_item_accept_id = e_ews_item_get_calendar_item_accept_id (items_req->data);
@@ -489,7 +527,7 @@ camel_ews_folder_get_message (CamelFolde
 			calendar_item_accept_id = e_ews_item_get_id (items->data);
 			is_calendar_UID = FALSE;
 		}
-		mime_fname_new = ews_update_mgtrequest_mime_calendar_itemid (mime_content, calendar_item_accept_id, is_calendar_UID, error);
+		mime_fname_new = ews_update_mgtrequest_mime_calendar_itemid (mime_content, calendar_item_accept_id, is_calendar_UID, e_ews_item_get_id (items->data), error);
 		if (mime_fname_new)
 			mime_content = (const gchar *) mime_fname_new;
 
@@ -499,14 +537,15 @@ camel_ews_folder_get_message (CamelFolde
 		}
 	}
 
-	cache_file = ews_data_cache_get_filename (ews_folder->cache, "cur",
-						  uid, error);
+	cache_file = ews_data_cache_get_filename (
+		ews_folder->cache, "cur", uid, error);
 	temp = g_strrstr (cache_file, "/");
 	dir = g_strndup (cache_file, temp - cache_file);
 
 	if (g_mkdir_with_parents (dir, 0700) == -1) {
-		g_set_error (error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
-			     _("Unable to create cache path"));
+		g_set_error (
+			error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
+			_("Unable to create cache path"));
 		g_free (dir);
 		g_free (cache_file);
 		goto exit;
@@ -514,8 +553,9 @@ camel_ews_folder_get_message (CamelFolde
 	g_free (dir);
 
 	if (g_rename (mime_content, cache_file) != 0) {
-		g_set_error (error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
-			     _("Failed to move message cache file"));
+		g_set_error (
+			error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
+			_("Failed to move message cache file"));
 		g_free (cache_file);
 		goto exit;
 	}
@@ -545,10 +585,43 @@ exit:
 
 	if (mime_fname_new)
 		g_free (mime_fname_new);
+	g_object_unref (cnc);
 
 	return message;
 }
 
+static void
+ews_folder_maybe_update_mlist (CamelFolder *folder,
+			       const gchar *uid,
+			       CamelMimeMessage *message)
+{
+	CamelEwsMessageInfo *mi;
+
+	g_return_if_fail (CAMEL_IS_FOLDER (folder));
+	g_return_if_fail (uid != NULL);
+	g_return_if_fail (message != NULL);
+
+	mi = (CamelEwsMessageInfo *) camel_folder_summary_get (folder->summary, uid);
+	if (!mi)
+		return;
+
+	if (!mi->info.mlist || !*mi->info.mlist) {
+		/* update mailing list information, if necessary */
+		gchar *mlist = camel_header_raw_check_mailing_list (&(CAMEL_MIME_PART (message)->headers));
+
+		if (mlist) {
+			if (mi->info.mlist)
+				camel_pstring_free (mi->info.mlist);
+			mi->info.mlist = camel_pstring_add (mlist, TRUE);
+			mi->info.dirty = TRUE;
+
+			camel_folder_summary_touch (folder->summary);
+		}
+	}
+
+	camel_message_info_free ((CamelMessageInfo *) mi);
+}
+
 /* Get the message from cache if available otherwise get it from server */
 static CamelMimeMessage *
 ews_folder_get_message_sync (CamelFolder *folder, const gchar *uid, EVO3(GCancellable *cancellable,) GError **error )
@@ -557,14 +630,20 @@ ews_folder_get_message_sync (CamelFolder
 	EVO2(GCancellable *cancellable = NULL);
 
 	message = camel_ews_folder_get_message_from_cache ((CamelEwsFolder *)folder, uid, cancellable, NULL);
-	if (!message)
+	if (!message) {
 		message = camel_ews_folder_get_message (folder, uid, EWS_ITEM_HIGH, cancellable, error);
+		if (message)
+			ews_folder_maybe_update_mlist (folder, uid, message);
+	}
 
 	return message;
 }
 
 static GPtrArray *
-ews_folder_search_by_expression (CamelFolder *folder, const gchar *expression, GError **error)
+ews_folder_search_by_expression (CamelFolder *folder,
+                                 const gchar *expression,
+                                 EVO3(GCancellable *cancellable,)
+                                 GError **error)
 {
 	CamelEwsFolder *ews_folder;
 	CamelEwsFolderPrivate *priv;
@@ -576,7 +655,7 @@ ews_folder_search_by_expression (CamelFo
 	g_mutex_lock (priv->search_lock);
 
 	camel_folder_search_set_folder (ews_folder->search, folder);
-	matches = camel_folder_search_search (ews_folder->search, expression, NULL, error);
+	matches = camel_folder_search_search (ews_folder->search, expression, NULL, EVO3(cancellable,) error);
 
 	g_mutex_unlock (priv->search_lock);
 
@@ -584,7 +663,10 @@ ews_folder_search_by_expression (CamelFo
 }
 
 static guint32
-ews_folder_count_by_expression (CamelFolder *folder, const gchar *expression, GError **error)
+ews_folder_count_by_expression (CamelFolder *folder,
+                                const gchar *expression,
+                                EVO3(GCancellable *cancellable,)
+                                GError **error)
 {
 	CamelEwsFolder *ews_folder;
 	CamelEwsFolderPrivate *priv;
@@ -596,7 +678,7 @@ ews_folder_count_by_expression (CamelFol
 	g_mutex_lock (priv->search_lock);
 
 	camel_folder_search_set_folder (ews_folder->search, folder);
-	matches = camel_folder_search_count (ews_folder->search, expression, error);
+	matches = camel_folder_search_count (ews_folder->search, expression, EVO3(cancellable,) error);
 
 	g_mutex_unlock (priv->search_lock);
 
@@ -604,7 +686,11 @@ ews_folder_count_by_expression (CamelFol
 }
 
 static GPtrArray *
-ews_folder_search_by_uids(CamelFolder *folder, const gchar *expression, GPtrArray *uids, GError **error)
+ews_folder_search_by_uids (CamelFolder *folder,
+                           const gchar *expression,
+                           GPtrArray *uids,
+                           EVO3(GCancellable *cancellable,)
+                           GError **error)
 {
 	CamelEwsFolder *ews_folder;
 	CamelEwsFolderPrivate *priv;
@@ -619,7 +705,7 @@ ews_folder_search_by_uids(CamelFolder *f
 	g_mutex_lock (priv->search_lock);
 
 	camel_folder_search_set_folder (ews_folder->search, folder);
-	matches = camel_folder_search_search (ews_folder->search, expression, uids, error);
+	matches = camel_folder_search_search (ews_folder->search, expression, uids, EVO3(cancellable,) error);
 
 	g_mutex_unlock (priv->search_lock);
 
@@ -627,7 +713,8 @@ ews_folder_search_by_uids(CamelFolder *f
 }
 
 static void
-ews_folder_search_free (CamelFolder *folder, GPtrArray *uids)
+ews_folder_search_free (CamelFolder *folder,
+                        GPtrArray *uids)
 {
 	CamelEwsFolder *ews_folder;
 	CamelEwsFolderPrivate *priv;
@@ -650,7 +737,8 @@ ews_folder_search_free (CamelFolder *fol
 
 
 static void
-msg_update_flags (ESoapMessage *msg, gpointer user_data)
+msg_update_flags (ESoapMessage *msg,
+                  gpointer user_data)
 {
 	GSList *mi_list = user_data;
 	CamelEwsMessageInfo *mi;
@@ -662,10 +750,11 @@ msg_update_flags (ESoapMessage *msg, gpo
 
 		flags_changed = mi->server_flags ^ mi->info.flags;
 
-		e_ews_message_start_item_change (msg, E_EWS_ITEMCHANGE_TYPE_ITEM,
-						 mi->info.uid, mi->change_key, 0);
+		e_ews_message_start_item_change (
+			msg, E_EWS_ITEMCHANGE_TYPE_ITEM,
+			mi->info.uid, mi->change_key, 0);
 		if (flags_changed & CAMEL_MESSAGE_FLAGGED) {
-			const char *flag;
+			const gchar *flag;
 
 			if (mi->info.flags & CAMEL_MESSAGE_FLAGGED)
 				flag = "High";
@@ -694,15 +783,17 @@ msg_update_flags (ESoapMessage *msg, gpo
 			e_soap_message_end_element (msg);
 
 			e_soap_message_start_element (msg, "Message", NULL, NULL);
-			e_ews_message_write_string_parameter (msg, "IsRead", NULL,
-					      (mi->info.flags & CAMEL_MESSAGE_SEEN)?"true":"false");
+			e_ews_message_write_string_parameter (
+				msg, "IsRead", NULL,
+				(mi->info.flags & CAMEL_MESSAGE_SEEN) ?
+				"true" : "false");
 
 			e_soap_message_end_element (msg); /* Message */
 			e_soap_message_end_element (msg); /* SetItemField */
 		}
 		/* Ick Ick Ick. Why in hell is there a field in the database for the Icon
-		   *anyway*? Why isn't there a better place for forwarded/answered status? */
-		if (flags_changed & (CAMEL_MESSAGE_FORWARDED|CAMEL_MESSAGE_ANSWERED)) {
+		 * *anyway*? Why isn't there a better place for forwarded/answered status? */
+		if (flags_changed & (CAMEL_MESSAGE_FORWARDED | CAMEL_MESSAGE_ANSWERED)) {
 			gint icon = (mi->info.flags & CAMEL_MESSAGE_SEEN) ? 0x100 : 0x101;
 
 			if (mi->info.flags & CAMEL_MESSAGE_ANSWERED)
@@ -742,7 +833,7 @@ msg_update_flags (ESoapMessage *msg, gpo
 		e_soap_message_start_element (msg, "Message", NULL, NULL);
 		e_soap_message_start_element (msg, "Categories", NULL, NULL);
 
-		ews_utils_replace_server_user_flags(msg, mi);
+		ews_utils_replace_server_user_flags (msg, mi);
 
 		e_soap_message_end_element (msg); /* Categories */
 		e_soap_message_end_element (msg); /* Message */
@@ -750,89 +841,297 @@ msg_update_flags (ESoapMessage *msg, gpo
 
 		e_ews_message_end_item_change (msg);
 
+		mi->info.flags = mi->info.flags & (~CAMEL_MESSAGE_FOLDER_FLAGGED);
+		mi->info.dirty = TRUE;
+
+		camel_folder_summary_touch (mi->info.summary);
+
 		camel_message_info_free (mi);
 	}
 	/* Don't think we need to free the list; we already freed every element */
 }
 
 static gboolean
-ews_sync_mi_flags (CamelFolder *folder, GSList *mi_list, GCancellable *cancellable, GError **error)
+ews_sync_mi_flags (CamelFolder *folder,
+                   GSList *mi_list,
+                   GCancellable *cancellable,
+                   GError **error)
 {
 	CamelEwsStore *ews_store;
 	EEwsConnection *cnc;
+	GError *local_error = NULL;
+	gboolean res;
 
 	ews_store = (CamelEwsStore *) camel_folder_get_parent_store (folder);
-	cnc = camel_ews_store_get_connection (ews_store);
 
-	return e_ews_connection_update_items (cnc, EWS_PRIORITY_LOW,
-					      "AlwaysOverwrite", "SaveOnly",
-					      NULL, NULL,
-					      msg_update_flags, mi_list, NULL,
-					      cancellable, error);
+	if (!camel_ews_store_connected (ews_store, cancellable, error)) {
+		return FALSE;
+	}
+
+	cnc = camel_ews_store_ref_connection (ews_store);
+
+	res = e_ews_connection_update_items_sync (
+		cnc, EWS_PRIORITY_LOW,
+		"AlwaysOverwrite", "SaveOnly",
+		NULL, NULL,
+		msg_update_flags, mi_list, NULL,
+		cancellable, &local_error);
+
+	if (local_error) {
+		camel_ews_store_maybe_disconnect (ews_store, local_error);
+		g_propagate_error (error, local_error);
+	}
+
+	g_object_unref (cnc);
+
+	return res;
+}
+
+static gboolean
+ews_folder_is_of_type (CamelFolder *folder,
+                       guint32 folder_type)
+{
+	CamelStore *parent_store;
+	CamelEwsStore *ews_store;
+	gboolean is_of_type;
+	gchar *folder_id;
+
+	g_return_val_if_fail (folder != NULL, FALSE);
+
+	parent_store = camel_folder_get_parent_store (folder);
+	ews_store = CAMEL_EWS_STORE (parent_store);
+
+	g_return_val_if_fail (ews_store != NULL, FALSE);
+
+	folder_type = folder_type & CAMEL_FOLDER_TYPE_MASK;
+	folder_id = camel_ews_store_summary_get_folder_id_from_name (ews_store->summary, camel_folder_get_full_name (folder));
+	is_of_type = folder_id &&
+		(camel_ews_store_summary_get_folder_flags (ews_store->summary, folder_id, NULL) & CAMEL_FOLDER_TYPE_MASK) == folder_type;
+	g_free (folder_id);
+
+	return is_of_type;
 }
+
 static gboolean
-ews_synchronize_sync (CamelFolder *folder, gboolean expunge, EVO3(GCancellable *cancellable,) GError **error)
+ews_move_to_junk_folder (CamelFolder *folder,
+                         GSList *junk_uids,
+                         GCancellable *cancellable,
+                         GError **error)
+{
+	CamelEwsFolder *ews_folder;
+	CamelStore *parent_store;
+	CamelEwsStore *ews_store;
+	EEwsConnection *cnc;
+	gboolean status = TRUE;
+
+	if (ews_folder_is_of_type (folder, CAMEL_FOLDER_TYPE_JUNK)) {
+		/* cannot move to itself, but treat it as success */
+		g_slist_free_full (junk_uids, (GDestroyNotify) camel_pstring_free);
+		return TRUE;
+	}
+
+	ews_store = CAMEL_EWS_STORE (camel_folder_get_parent_store (folder));
+
+	parent_store = camel_folder_get_parent_store (folder);
+	ews_folder = CAMEL_EWS_FOLDER (folder);
+	ews_store = CAMEL_EWS_STORE (parent_store);
+
+	if (!camel_ews_store_connected (ews_store, cancellable, error))
+		return FALSE;
+
+	cnc = camel_ews_store_ref_connection (ews_store);
+
+	if (junk_uids) {
+		GSList *moved_items = NULL;
+		GError *local_error = NULL;
+		gchar *folder_id;
+
+		folder_id = camel_ews_store_summary_get_folder_id_from_folder_type (
+			ews_store->summary, CAMEL_FOLDER_TYPE_JUNK);
+
+		status = e_ews_connection_move_items_sync (
+			cnc, EWS_PRIORITY_MEDIUM, folder_id, FALSE,
+			junk_uids, &moved_items, cancellable, &local_error);
+
+		if (!status && local_error && local_error->code == EWS_CONNECTION_ERROR_ITEMNOTFOUND) {
+			/* If move failed due to the item not found, ignore the error,
+			 * trigger folder info refresh and then go on to clear the
+			 * cache of the remove items anyway. */
+			g_clear_error (&local_error);
+			status = ews_refresh_info_sync (folder, EVO3(cancellable,) &local_error);
+		}
+
+		g_slist_free_full (moved_items, g_object_unref);
+		g_free (folder_id);
+
+		if (status) {
+			CamelFolderChangeInfo *changes;
+			GSList *iter;
+
+			changes = camel_folder_change_info_new ();
+
+			for (iter = junk_uids; iter; iter = g_slist_next (iter)) {
+				const gchar *uid = iter->data;
+
+				camel_folder_summary_lock (folder->summary, CAMEL_FOLDER_SUMMARY_SUMMARY_LOCK);
+
+				camel_folder_change_info_remove_uid (changes, uid);
+				camel_folder_summary_remove_uid (folder->summary, uid);
+				ews_data_cache_remove (ews_folder->cache, "cur", uid, NULL);
+
+				camel_folder_summary_unlock (folder->summary, CAMEL_FOLDER_SUMMARY_SUMMARY_LOCK);
+			}
+
+			if (camel_folder_change_info_changed (changes)) {
+				camel_folder_summary_touch (folder->summary);
+				camel_folder_changed (folder, changes);
+			}
+			camel_folder_change_info_free (changes);
+		}
+
+		if (local_error) {
+			camel_ews_store_maybe_disconnect (ews_store, local_error);
+			g_propagate_error (error, local_error);
+		}
+
+		g_slist_free_full (junk_uids, (GDestroyNotify) camel_pstring_free);
+	}
+
+	g_object_unref (cnc);
+
+	return status;
+}
+
+static gboolean
+ews_synchronize_sync (CamelFolder *folder,
+                      gboolean expunge,
+                      EVO3(GCancellable *cancellable,)
+                      GError **error)
 {
 	CamelEwsStore *ews_store;
 	GPtrArray *uids;
-	GSList *mi_list = NULL, *deleted_uids = NULL;
-	int mi_list_len = 0;
+	GSList *mi_list = NULL, *deleted_uids = NULL, *junk_uids = NULL;
+	gint mi_list_len = 0;
 	gboolean success = TRUE;
-	int i;
+	gint i;
+	GError *local_error = NULL;
 	EVO2(GCancellable *cancellable = NULL);
 
 	ews_store = (CamelEwsStore *) camel_folder_get_parent_store (folder);
 
-	if (!camel_ews_store_connected (ews_store, error))
+	if (!camel_ews_store_connected (ews_store, cancellable, error))
 		return FALSE;
 
-	uids = camel_folder_summary_get_changed (folder->summary);
-	if (!uids->len) {
-		camel_folder_free_uids (folder, uids);
+	if (camel_folder_summary_get_deleted_count (folder->summary) > 0 ||
+	    camel_folder_summary_get_junk_count (folder->summary) > 0) {
+		camel_folder_summary_prepare_fetch_all (folder->summary, NULL);
+		uids = camel_folder_summary_get_array (folder->summary);
+	} else {
+		uids = camel_folder_summary_get_changed (folder->summary);
+	}
+	if (!uids || !uids->len) {
+		camel_folder_summary_free_array (uids);
 		return TRUE;
 	}
 
 	for (i = 0; success && i < uids->len; i++) {
-		guint32 flags_changed;
-		CamelEwsMessageInfo *mi = (void *)camel_folder_summary_uid (folder->summary, uids->pdata[i]);
+		guint32 flags_changed, flags_set;
+		CamelEwsMessageInfo *mi = (gpointer) camel_folder_summary_get (folder->summary, uids->pdata[i]);
 		if (!mi)
 			continue;
 
-		flags_changed = mi->server_flags ^ mi->info.flags;
+		flags_set = camel_message_info_flags (mi);
+		flags_changed = mi->server_flags ^ flags_set;
 
 		/* Exchange doesn't seem to have a sane representation
-		   for most flags — not even replied/forwarded. */
-		if (flags_changed & (CAMEL_MESSAGE_SEEN|CAMEL_MESSAGE_ANSWERED|CAMEL_MESSAGE_FORWARDED|CAMEL_MESSAGE_FLAGGED)) {
+		 * for most flags — not even replied/forwarded. */
+		if ((flags_set & CAMEL_MESSAGE_FOLDER_FLAGGED) != 0 &&
+		    (flags_changed & (CAMEL_MESSAGE_SEEN | CAMEL_MESSAGE_ANSWERED | CAMEL_MESSAGE_FORWARDED | CAMEL_MESSAGE_FLAGGED)) != 0) {
 			mi_list = g_slist_append (mi_list, mi);
 			mi_list_len++;
-		} else if (flags_changed & CAMEL_MESSAGE_DELETED) {
-			deleted_uids = g_slist_prepend (deleted_uids, (gpointer) camel_pstring_strdup (uids->pdata [i]));
+
+			if (flags_set & CAMEL_MESSAGE_DELETED)
+				deleted_uids = g_slist_prepend (deleted_uids, (gpointer) camel_pstring_strdup (uids->pdata[i]));
+			else if (flags_set & CAMEL_MESSAGE_JUNK)
+				junk_uids = g_slist_prepend (junk_uids, (gpointer) camel_pstring_strdup (uids->pdata[i]));
+		} else if (flags_set & CAMEL_MESSAGE_DELETED) {
+			deleted_uids = g_slist_prepend (deleted_uids, (gpointer) camel_pstring_strdup (uids->pdata[i]));
 			camel_message_info_free (mi);
-		} else {
+		} else if (flags_set & CAMEL_MESSAGE_JUNK) {
+			junk_uids = g_slist_prepend (junk_uids, (gpointer) camel_pstring_strdup (uids->pdata[i]));
+			camel_message_info_free (mi);
+		} else if ((flags_set & CAMEL_MESSAGE_FOLDER_FLAGGED) != 0) {
 			/* OK, the change must have been the labels */
 			mi_list = g_slist_append (mi_list, mi);
 			mi_list_len++;
-		}			
+		} else {
+			camel_message_info_free (mi);
+		}
 
 		if (mi_list_len == EWS_MAX_FETCH_COUNT) {
-			success = ews_sync_mi_flags (folder, mi_list, cancellable, error);
+			success = ews_sync_mi_flags (folder, mi_list, cancellable, &local_error);
 			mi_list = NULL;
 			mi_list_len = 0;
 		}
 	}
-	
-	if (mi_list_len)
-		success = ews_sync_mi_flags (folder, mi_list, cancellable, error);
 
-	if (deleted_uids)
-		success = ews_delete_messages (folder, deleted_uids, FALSE, cancellable, error);
+	if (mi_list_len && success) {
+		success = ews_sync_mi_flags (folder, mi_list, cancellable, &local_error);
+		if (local_error && g_error_matches (local_error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_ACCESSDENIED)) {
+			/* if cannot save flags, then it can be a public or
+			   a foreign folder with no write access;
+			   the flags will be saved locally, at least */
+			g_clear_error (&local_error);
+			success = TRUE;
+		}			
+	}
+
+	if (deleted_uids && success)
+		success = ews_delete_messages (folder, deleted_uids, ews_folder_is_of_type (folder, CAMEL_FOLDER_TYPE_TRASH), cancellable, &local_error);
+	else
+		g_slist_free_full (deleted_uids, (GDestroyNotify) camel_pstring_free);
+
+	if (junk_uids && success)
+		success = ews_move_to_junk_folder (folder, junk_uids, cancellable, &local_error);
+	else
+		g_slist_free_full (junk_uids, (GDestroyNotify) camel_pstring_free);
+
+	camel_folder_summary_save_to_db (folder->summary, NULL);
+	camel_folder_summary_free_array (uids);
+
+	if (local_error)
+		g_propagate_error (error, local_error);
 
-	camel_folder_free_uids (folder, uids);
 	return success;
 }
 
+static gboolean
+folder_has_inbox_type (CamelEwsStore *ews_store,
+                       const gchar *folder_name)
+{
+	gchar *folder_id;
+	guint64 flags;
+
+	g_return_val_if_fail (CAMEL_IS_EWS_STORE (ews_store), FALSE);
+	g_return_val_if_fail (folder_name != NULL, FALSE);
+
+	folder_id = camel_ews_store_summary_get_folder_id_from_name (ews_store->summary, folder_name);
+	if (!folder_id)
+		return FALSE;
+
+	flags = camel_ews_store_summary_get_folder_flags (ews_store->summary, folder_id, NULL);
+
+	g_free (folder_id);
+
+	return (flags & CAMEL_FOLDER_TYPE_MASK) == CAMEL_FOLDER_TYPE_INBOX;
+}
+
 CamelFolder *
-camel_ews_folder_new (CamelStore *store, const gchar *folder_name, const gchar *folder_dir, GCancellable *cancellable, GError **error)
+camel_ews_folder_new (CamelStore *store,
+                      const gchar *folder_name,
+                      const gchar *folder_dir,
+                      GCancellable *cancellable,
+                      GError **error)
 {
 	CamelFolder *folder;
 	CamelEwsFolder *ews_folder;
@@ -853,7 +1152,7 @@ camel_ews_folder_new (CamelStore *store,
 		"name", short_name, "full-name", folder_name,
 		"parent_store", store, NULL);
 
-	ews_folder = CAMEL_EWS_FOLDER(folder);
+	ews_folder = CAMEL_EWS_FOLDER (folder);
 
 	summary_file = g_build_filename (folder_dir, "summary", NULL);
 	folder->summary = camel_ews_summary_new (folder, summary_file);
@@ -871,7 +1170,7 @@ camel_ews_folder_new (CamelStore *store,
 	state_file = g_build_filename (folder_dir, "cmeta", NULL);
 	camel_object_set_state_filename (CAMEL_OBJECT (folder), state_file);
 	camel_object_state_read (CAMEL_OBJECT (folder));
-	g_free(state_file);
+	g_free (state_file);
 
 	ews_folder->cache = camel_data_cache_new (folder_dir, error);
 	if (!ews_folder->cache) {
@@ -879,7 +1178,8 @@ camel_ews_folder_new (CamelStore *store,
 		return NULL;
 	}
 
-	if (!g_ascii_strcasecmp (folder_name, "Inbox")) {
+	if (!g_ascii_strcasecmp (folder_name, "Inbox") ||
+	    folder_has_inbox_type (CAMEL_EWS_STORE (store), folder_name)) {
 		if (camel_url_get_param (camel_service_get_camel_url ((CamelService *) store), "filter"))
 			folder->folder_flags |= CAMEL_FOLDER_FILTER_RECENT;
 	}
@@ -894,12 +1194,19 @@ camel_ews_folder_new (CamelStore *store,
 }
 
 static void
-sync_updated_items (CamelEwsFolder *ews_folder, EEwsConnection *cnc, GSList *updated_items, GCancellable *cancellable, GError **error)
+sync_updated_items (CamelEwsFolder *ews_folder,
+                    EEwsConnection *cnc,
+                    GSList *updated_items,
+                    GCancellable *cancellable,
+                    GError **error)
 {
+	CamelEwsStore *ews_store;
 	CamelFolder *folder = (CamelFolder *) ews_folder;
 	GSList *items = NULL, *l;
 	GSList *generic_item_ids = NULL, *msg_ids = NULL;
+	GError *local_error = NULL;
 
+	ews_store = CAMEL_EWS_STORE (camel_folder_get_parent_store (folder));
 
 	for (l = updated_items; l != NULL; l = g_slist_next (l)) {
 		EEwsItem *item = (EEwsItem *) l->data;
@@ -907,21 +1214,21 @@ sync_updated_items (CamelEwsFolder *ews_
 		CamelMessageInfo *mi;
 
 		/* Compare the item_type from summary as the updated items seems to
-		   arrive as generic types while its not the case */
-		mi = camel_folder_summary_uid (folder->summary, id->id);
+		 * arrive as generic types while its not the case */
+		mi = camel_folder_summary_get (folder->summary, id->id);
 		if (!mi) {
 			g_object_unref (item);
 			continue;
 		}
 
 		/* Check if the item has really changed */
-		if (!strcmp (((CamelEwsMessageInfo *)mi)->change_key, id->change_key)) {
+		if (!strcmp (((CamelEwsMessageInfo *) mi)->change_key, id->change_key)) {
 			camel_message_info_free (mi);
 			g_object_unref (item);
 			continue;
 		}
 
-		if (((CamelEwsMessageInfo *)mi)->item_type == E_EWS_ITEM_TYPE_GENERIC_ITEM)
+		if (((CamelEwsMessageInfo *) mi)->item_type == E_EWS_ITEM_TYPE_GENERIC_ITEM)
 			generic_item_ids = g_slist_append (generic_item_ids, g_strdup (id->id));
 		else
 			msg_ids = g_slist_append (msg_ids, g_strdup (id->id));
@@ -932,25 +1239,33 @@ sync_updated_items (CamelEwsFolder *ews_
 	g_slist_free (updated_items);
 
 	if (msg_ids)
-		e_ews_connection_get_items
-			(g_object_ref (cnc), EWS_PRIORITY_MEDIUM,
-			 msg_ids, "IdOnly", SUMMARY_MESSAGE_FLAGS,
-			 FALSE, NULL, &items, NULL, NULL,
-			 cancellable, error);
+		e_ews_connection_get_items_sync (
+			cnc, EWS_PRIORITY_MEDIUM,
+			msg_ids, "IdOnly", SUMMARY_MESSAGE_FLAGS,
+			FALSE, NULL, E_EWS_BODY_TYPE_ANY, &items, NULL, NULL,
+			cancellable, &local_error);
 
 	camel_ews_utils_sync_updated_items (ews_folder, items);
 	items = NULL;
-	if (*error)
+	if (local_error) {
+		camel_ews_store_maybe_disconnect (ews_store, local_error);
+		g_propagate_error (error, local_error);
 		goto exit;
+	}
 
 	if (generic_item_ids)
-		e_ews_connection_get_items
-			(g_object_ref (cnc), EWS_PRIORITY_MEDIUM,
-			 generic_item_ids, "IdOnly", SUMMARY_ITEM_FLAGS,
-			 FALSE, NULL, &items, NULL, NULL,
-			 cancellable, error);
+		e_ews_connection_get_items_sync (
+			cnc, EWS_PRIORITY_MEDIUM,
+			generic_item_ids, "IdOnly", SUMMARY_ITEM_FLAGS,
+			FALSE, NULL, E_EWS_BODY_TYPE_ANY, &items, NULL, NULL,
+			cancellable, &local_error);
 	camel_ews_utils_sync_updated_items (ews_folder, items);
 
+	if (local_error) {
+		camel_ews_store_maybe_disconnect (ews_store, local_error);
+		g_propagate_error (error, local_error);
+	}
+
 exit:
 	if (msg_ids) {
 		g_slist_foreach (msg_ids, (GFunc) g_free, NULL);
@@ -964,10 +1279,18 @@ exit:
 }
 
 static void
-sync_created_items (CamelEwsFolder *ews_folder, EEwsConnection *cnc, GSList *created_items, GCancellable *cancellable, GError **error)
+sync_created_items (CamelEwsFolder *ews_folder,
+                    EEwsConnection *cnc,
+                    GSList *created_items,
+                    GCancellable *cancellable,
+                    GError **error)
 {
+	CamelEwsStore *ews_store;
 	GSList *items = NULL, *l;
 	GSList *generic_item_ids = NULL, *msg_ids = NULL, *post_item_ids = NULL;
+	GError *local_error = NULL;
+
+	ews_store = CAMEL_EWS_STORE (camel_folder_get_parent_store (CAMEL_FOLDER (ews_folder)));
 
 	for (l = created_items; l != NULL; l = g_slist_next (l)) {
 		EEwsItem *item = (EEwsItem *) l->data;
@@ -980,9 +1303,9 @@ sync_created_items (CamelEwsFolder *ews_
 		id = e_ews_item_get_id (item);
 		item_type = e_ews_item_get_item_type (item);
 		/* created_msg_ids are items other than generic item. We fetch them
-		   separately since the property sets vary */
+		 * separately since the property sets vary */
 		/* FIXME: Do we need to handle any other item types
-		   "specially"? */
+		 * "specially"? */
 		if (item_type == E_EWS_ITEM_TYPE_MESSAGE ||
 			item_type == E_EWS_ITEM_TYPE_MEETING_REQUEST ||
 			item_type == E_EWS_ITEM_TYPE_MEETING_MESSAGE ||
@@ -999,40 +1322,50 @@ sync_created_items (CamelEwsFolder *ews_
 	g_slist_free (created_items);
 
 	if (msg_ids)
-		e_ews_connection_get_items
-			(g_object_ref (cnc), EWS_PRIORITY_MEDIUM,
-			 msg_ids, "IdOnly", SUMMARY_MESSAGE_PROPS,
-			 FALSE, NULL, &items, NULL, NULL,
-			 cancellable, error);
-
-	if (*error)
+		e_ews_connection_get_items_sync (
+			cnc, EWS_PRIORITY_MEDIUM,
+			msg_ids, "IdOnly", SUMMARY_MESSAGE_PROPS,
+			FALSE, NULL, E_EWS_BODY_TYPE_ANY, &items, NULL, NULL,
+			cancellable, &local_error);
+
+	if (local_error) {
+		camel_ews_store_maybe_disconnect (ews_store, local_error);
+		g_propagate_error (error, local_error);
 		goto exit;
+	}
 
-	camel_ews_utils_sync_created_items (ews_folder, items);
+	camel_ews_utils_sync_created_items (ews_folder, cnc, items, cancellable);
 	items = NULL;
 
 	if (post_item_ids)
-		e_ews_connection_get_items
-			(g_object_ref (cnc), EWS_PRIORITY_MEDIUM,
-			 post_item_ids, "IdOnly", SUMMARY_POSTITEM_PROPS,
-			 FALSE, NULL, &items, NULL, NULL,
-			 cancellable, error);
-
-	if (*error)
+		e_ews_connection_get_items_sync (
+			cnc, EWS_PRIORITY_MEDIUM,
+			post_item_ids, "IdOnly", SUMMARY_POSTITEM_PROPS,
+			FALSE, NULL, E_EWS_BODY_TYPE_ANY, &items, NULL, NULL,
+			cancellable, &local_error);
+
+	if (local_error) {
+		camel_ews_store_maybe_disconnect (ews_store, local_error);
+		g_propagate_error (error, local_error);
 		goto exit;
+	}
 
-	camel_ews_utils_sync_created_items (ews_folder, items);
+	camel_ews_utils_sync_created_items (ews_folder, cnc, items, cancellable);
 	items = NULL;
 
 	if (generic_item_ids)
-		e_ews_connection_get_items
-			(g_object_ref (cnc), EWS_PRIORITY_MEDIUM,
-			 generic_item_ids, "IdOnly", SUMMARY_ITEM_PROPS,
-			 FALSE, NULL, &items, NULL, NULL,
-			 cancellable, error);
-
-	camel_ews_utils_sync_created_items (ews_folder, items);
-
+		e_ews_connection_get_items_sync (
+			cnc, EWS_PRIORITY_MEDIUM,
+			generic_item_ids, "IdOnly", SUMMARY_ITEM_PROPS,
+			FALSE, NULL, E_EWS_BODY_TYPE_ANY, &items, NULL, NULL,
+			cancellable, &local_error);
+
+	camel_ews_utils_sync_created_items (ews_folder, cnc, items, cancellable);
+
+	if (local_error) {
+		camel_ews_store_maybe_disconnect (ews_store, local_error);
+		g_propagate_error (error, local_error);
+	}
 exit:
 	if (msg_ids) {
 		g_slist_foreach (msg_ids, (GFunc) g_free, NULL);
@@ -1050,8 +1383,49 @@ exit:
 	}
 }
 
+static void
+ews_folder_forget_all_mails (CamelEwsFolder *ews_folder)
+{
+	CamelFolder *folder;
+	CamelFolderChangeInfo *changes;
+	GPtrArray *known_uids;
+	gint ii;
+
+	g_return_if_fail (CAMEL_IS_EWS_FOLDER (ews_folder));
+
+	folder = CAMEL_FOLDER (ews_folder);
+	g_return_if_fail (folder != NULL);
+
+	known_uids = camel_folder_summary_get_array (folder->summary);
+	if (!known_uids)
+		return;
+
+	changes = camel_folder_change_info_new ();
+
+	camel_folder_summary_lock (folder->summary, CAMEL_FOLDER_SUMMARY_SUMMARY_LOCK);
+	for (ii = 0; ii < known_uids->len; ii++) {
+		const gchar *uid = g_ptr_array_index (known_uids, ii);
+
+		camel_folder_change_info_remove_uid (changes, uid);
+		camel_folder_summary_remove_uid (folder->summary, uid);
+		ews_data_cache_remove (ews_folder->cache, "cur", uid, NULL);
+	}
+	camel_folder_summary_unlock (folder->summary, CAMEL_FOLDER_SUMMARY_SUMMARY_LOCK);
+
+	if (camel_folder_change_info_changed (changes)) {
+		camel_folder_summary_touch (folder->summary);
+		camel_folder_summary_save_to_db (folder->summary, NULL);
+		camel_folder_changed (folder, changes);
+	}
+
+	camel_folder_change_info_free (changes);
+	camel_folder_summary_free_array (known_uids);
+}
+
 static gboolean
-ews_refresh_info_sync (CamelFolder *folder, EVO3(GCancellable *cancellable,) GError **error)
+ews_refresh_info_sync (CamelFolder *folder,
+                       EVO3(GCancellable *cancellable,)
+                       GError **error)
 {
 	CamelEwsFolder *ews_folder;
 	CamelEwsFolderPrivate *priv;
@@ -1061,7 +1435,7 @@ ews_refresh_info_sync (CamelFolder *fold
 	gchar *id;
 	gchar *sync_state;
 	gboolean includes_last_item = FALSE;
-	GError *rerror = NULL;
+	GError *local_error = NULL;
 	EVO2(GCancellable *cancellable = NULL);
 
 	full_name = camel_folder_get_full_name (folder);
@@ -1070,7 +1444,7 @@ ews_refresh_info_sync (CamelFolder *fold
 	ews_folder = (CamelEwsFolder *) folder;
 	priv = ews_folder->priv;
 
-	if (!camel_ews_store_connected (ews_store, error))
+	if (!camel_ews_store_connected (ews_store, cancellable, error))
 		return FALSE;
 
 	g_mutex_lock (priv->state_lock);
@@ -1083,42 +1457,56 @@ ews_refresh_info_sync (CamelFolder *fold
 	priv->refreshing = TRUE;
 	g_mutex_unlock (priv->state_lock);
 
-	cnc = camel_ews_store_get_connection (ews_store);
-	id = camel_ews_store_summary_get_folder_id_from_name
-						(ews_store->summary,
-						 full_name);
+	cnc = camel_ews_store_ref_connection (ews_store);
+	g_return_val_if_fail (cnc != NULL, FALSE);
+
+	camel_folder_summary_prepare_fetch_all (folder->summary, NULL);
+
+	id = camel_ews_store_summary_get_folder_id_from_name (
+		ews_store->summary, full_name);
+
+	camel_operation_start (NULL, _("Updating folder '%s'"), camel_folder_get_full_name (folder));
 
 	/* Sync folder items does not return the fields ToRecipients,
-	   CCRecipients. With the item_type unknown, its not possible
-	   to fetch the right properties which are valid for an item type.
-	   Due to these reasons we just get the item ids and its type in
-	   SyncFolderItem request and fetch the item using the
-	   GetItem request. */
+	 * CCRecipients. With the item_type unknown, its not possible
+	 * to fetch the right properties which are valid for an item type.
+	 * Due to these reasons we just get the item ids and its type in
+	 * SyncFolderItem request and fetch the item using the
+	 * GetItem request. */
 	sync_state = ((CamelEwsSummary *) folder->summary)->sync_state;
-	do
-	{
+	do {
 		GSList *items_created = NULL, *items_updated = NULL;
 		GSList *items_deleted = NULL;
 		guint32 total, unread;
 
-		e_ews_connection_sync_folder_items
-							(cnc, EWS_PRIORITY_MEDIUM,
-							 &sync_state, id,
-							 "IdOnly", NULL,
-							 EWS_MAX_FETCH_COUNT, &includes_last_item,
-							 &items_created, &items_updated,
-							 &items_deleted, cancellable, &rerror);
+		e_ews_connection_sync_folder_items_sync (cnc, EWS_PRIORITY_MEDIUM, sync_state, id, "IdOnly", NULL, EWS_MAX_FETCH_COUNT,
+			&sync_state, &includes_last_item, &items_created, &items_updated, &items_deleted,
+			cancellable, &local_error);
+
+		if (g_error_matches (local_error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_INVALIDSYNCSTATEDATA)) {
+			g_clear_error (&local_error);
+			g_free (((CamelEwsSummary *) folder->summary)->sync_state);
+			((CamelEwsSummary *) folder->summary)->sync_state = NULL;
+			sync_state = NULL;
+			ews_folder_forget_all_mails (ews_folder);
+
+			e_ews_connection_sync_folder_items_sync (cnc, EWS_PRIORITY_MEDIUM, NULL, id, "IdOnly", NULL, EWS_MAX_FETCH_COUNT,
+				&sync_state, &includes_last_item, &items_created, &items_updated, &items_deleted,
+				cancellable, &local_error);
+		}
 
-		if (rerror)
+		if (local_error) {
+			camel_ews_store_maybe_disconnect (ews_store, local_error);
 			break;
+		}
 
 		if (items_deleted)
 			camel_ews_utils_sync_deleted_items (ews_folder, items_deleted);
 
 		if (items_created)
-			sync_created_items (ews_folder, cnc, items_created, cancellable, &rerror);
+			sync_created_items (ews_folder, cnc, items_created, cancellable, &local_error);
 
-		if (rerror) {
+		if (local_error) {
 			if (items_updated) {
 				g_slist_foreach (items_updated, (GFunc) g_object_unref, NULL);
 				g_slist_free (items_updated);
@@ -1128,13 +1516,13 @@ ews_refresh_info_sync (CamelFolder *fold
 		}
 
 		if (items_updated)
-			sync_updated_items (ews_folder, cnc, items_updated, cancellable, &rerror);
+			sync_updated_items (ews_folder, cnc, items_updated, cancellable, &local_error);
 
-		if (rerror)
+		if (local_error)
 			break;
 
 		total = camel_folder_summary_count (folder->summary);
-		unread = folder->summary->unread_count;
+		unread = camel_folder_summary_get_unread_count (folder->summary);
 
 		camel_ews_store_summary_set_folder_total (ews_store->summary, id, total);
 		camel_ews_store_summary_set_folder_unread (ews_store->summary, id, unread);
@@ -1144,69 +1532,87 @@ ews_refresh_info_sync (CamelFolder *fold
 		((CamelEwsSummary *) folder->summary)->sync_state = sync_state;
 
 		camel_folder_summary_touch (folder->summary);
-		camel_folder_summary_save_to_db (folder->summary, NULL);
+	} while (!local_error && !includes_last_item && !camel_operation_cancel_check (NULL));
 
-	} while (!rerror && !includes_last_item);
+	camel_folder_summary_save_to_db (folder->summary, NULL);
 
-	if (rerror)
-		g_propagate_error (error, rerror);
+	camel_operation_end (NULL);
+
+	if (local_error)
+		g_propagate_error (error, local_error);
 
 	g_mutex_lock (priv->state_lock);
 	priv->refreshing = FALSE;
 	g_mutex_unlock (priv->state_lock);
 	if (sync_state != ((CamelEwsSummary *) folder->summary)->sync_state)
-		g_free(sync_state);
+		g_free (sync_state);
 	g_object_unref (cnc);
 	g_free (id);
 
-	return !rerror;
+	return !local_error;
 }
 
 static gboolean
-ews_append_message_sync (CamelFolder *folder, CamelMimeMessage *message,
-	 		 EVO2(const) CamelMessageInfo *info,
-			 gchar **appended_uid,
-	 		 EVO3(GCancellable *cancellable,) GError **error)
+ews_append_message_sync (CamelFolder *folder,
+                         CamelMimeMessage *message,
+                         const CamelMessageInfo *info,
+                         gchar **appended_uid,
+                         EVO3(GCancellable *cancellable,)
+                         GError **error)
 {
 	EVO2(GCancellable *cancellable = NULL;)
 	gchar *itemid, *changekey;
 	const gchar *folder_name;
 	gchar *folder_id;
+	EwsFolderId *fid;
 	CamelAddress *from;
 	CamelEwsStore *ews_store;
 	EEwsConnection *cnc;
+	GError *local_error = NULL;
+
+	ews_store = (CamelEwsStore *) camel_folder_get_parent_store (folder);
 
-	ews_store = (CamelEwsStore *)camel_folder_get_parent_store(folder);
+	if (!camel_ews_store_connected (ews_store, cancellable, error)) {
+		return FALSE;
+	}
 
 	folder_name = camel_folder_get_full_name (folder);
-	folder_id = camel_ews_store_summary_get_folder_id_from_name (ews_store->summary,
-								     folder_name);
+	folder_id = camel_ews_store_summary_get_folder_id_from_name (
+		ews_store->summary,
+		folder_name);
 	if (!folder_id)
 		return FALSE;
 
 	from = CAMEL_ADDRESS (camel_mime_message_get_from (message));
 
-	cnc = camel_ews_store_get_connection(ews_store);
+	cnc = camel_ews_store_ref_connection (ews_store);
 
 	if (!cnc) {
-		g_set_error (error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
-			     _("Cant perform actions on the folder while in offline mode"));
+		g_free (folder_id);
+		g_set_error (
+			error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
+			_("Cant perform actions on the folder while in offline mode"));
 		return FALSE;
 	}
 
-	if (!camel_ews_utils_create_mime_message (cnc, "SaveOnly", folder_id,
-						  message,
-						  camel_message_info_flags (info),
-						  from, &itemid, &changekey,
-						  cancellable, error)) {
+	fid = e_ews_folder_id_new (folder_id, NULL, FALSE);
+	if (!camel_ews_utils_create_mime_message (
+		cnc, "SaveOnly", fid, message,
+		camel_message_info_flags (info),
+		from, &itemid, &changekey,
+		cancellable, &local_error)) {
+		camel_ews_store_maybe_disconnect (ews_store, local_error);
+		g_propagate_error (error, local_error);
+		e_ews_folder_id_free (fid);
 		g_free (folder_id);
 		g_object_unref (cnc);
 		return FALSE;
 	}
+	e_ews_folder_id_free (fid);
 	g_free (folder_id);
 
 	/* FIXME: Do we have to add it to the summary info ourselves?
-	   Hopefully, since we need to store the changekey with it... */
+	 * Hopefully, since we need to store the changekey with it... */
 	if (appended_uid)
 		*appended_uid = itemid;
 	else
@@ -1234,7 +1640,7 @@ ews_transfer_messages_to_sync	(CamelFold
 	CamelFolderChangeInfo *changes = NULL;
 	const gchar *dst_full_name;
 	gchar *dst_id;
-	GError *rerror = NULL;
+	GError *local_error = NULL;
 	GSList *ids = NULL, *ret_items = NULL;
 	gint i = 0;
 	EVO2(GCancellable *cancellable = NULL);
@@ -1242,50 +1648,62 @@ ews_transfer_messages_to_sync	(CamelFold
 	dst_full_name = camel_folder_get_full_name (destination);
 	dst_ews_store = (CamelEwsStore *) camel_folder_get_parent_store (destination);
 
-	if (!camel_ews_store_connected (dst_ews_store, error))
+	if (!camel_ews_store_connected (dst_ews_store, cancellable, error))
 		return FALSE;
 
-	cnc = camel_ews_store_get_connection (dst_ews_store);
-	dst_id = camel_ews_store_summary_get_folder_id_from_name
-						(dst_ews_store->summary,
-						 dst_full_name);
+	cnc = camel_ews_store_ref_connection (dst_ews_store);
+	dst_id = camel_ews_store_summary_get_folder_id_from_name (
+		dst_ews_store->summary, dst_full_name);
 
 	for (i = 0; i < uids->len; i++) {
-		ids = g_slist_append(ids, (gchar *)uids->pdata[i]);
+		ids = g_slist_append (ids, (gchar *) uids->pdata[i]);
 	}
 
-	if (e_ews_connection_move_items	(cnc, EWS_PRIORITY_MEDIUM,
-					 dst_id, !delete_originals,
-					 ids, &ret_items,
-					 cancellable, &rerror)) {
+	if (e_ews_connection_move_items_sync (
+		cnc, EWS_PRIORITY_MEDIUM,
+		dst_id, !delete_originals,
+		ids, &ret_items,
+		cancellable, &local_error)) {
+
 		if (delete_originals) {
 			changes = camel_folder_change_info_new ();
-			for (i=0; i < uids->len; i++) {
+			for (i = 0; i < uids->len; i++) {
 				camel_folder_summary_remove_uid (source->summary, uids->pdata[i]);
 				camel_folder_change_info_remove_uid (changes, uids->pdata[i]);
 			}
-			camel_folder_changed (source, changes);
+			if (camel_folder_change_info_changed (changes)) {
+				camel_folder_summary_touch (source->summary);
+				camel_folder_changed (source, changes);
+			}
 			camel_folder_change_info_free (changes);
 		}
 
-		/*update the store about the content of the source and destination folders*/
-		ews_refresh_info_sync (source, EVO3(cancellable,) NULL);
-		ews_refresh_info_sync (destination, EVO3(cancellable,) NULL);
+		/* update destination folder only if not frozen, to not update
+		   for each single message transfer during filtering
+		 */
+		if (!camel_folder_is_frozen (destination))
+			ews_refresh_info_sync (destination, EVO3(cancellable,) NULL);
 	}
 	g_free (dst_id);
 
-	if (rerror)
-		g_propagate_error (error, rerror);
+	if (local_error) {
+		camel_ews_store_maybe_disconnect (dst_ews_store, local_error);
+		g_propagate_error (error, local_error);
+	}
 
 	g_object_unref (cnc);
 	g_slist_free (ids);
-	g_slist_free (ret_items);
+	g_slist_free_full (ret_items, g_object_unref);
 
-	return !rerror;
+	return !local_error;
 }
 
 static gboolean
-ews_delete_messages (CamelFolder *folder, GSList *deleted_items, gboolean expunge, GCancellable *cancellable, GError **error)
+ews_delete_messages (CamelFolder *folder,
+                     GSList *deleted_items,
+                     gboolean expunge,
+                     GCancellable *cancellable,
+                     GError **error)
 {
 	CamelEwsFolder *ews_folder;
 	CamelStore *parent_store;
@@ -1294,96 +1712,118 @@ ews_delete_messages (CamelFolder *folder
 	EEwsConnection *cnc;
 	gboolean status = TRUE;
 	GSList *deleted_head = NULL;
-	
+
 	parent_store = camel_folder_get_parent_store (folder);
 	ews_folder = CAMEL_EWS_FOLDER (folder);
 	ews_store = CAMEL_EWS_STORE (parent_store);
 	deleted_head = deleted_items;
 
-	cnc = camel_ews_store_get_connection (ews_store);
+	if (!camel_ews_store_connected (ews_store, cancellable, error)) {
+		return FALSE;
+	}
+
+	cnc = camel_ews_store_ref_connection (ews_store);
 	changes = camel_folder_change_info_new ();
 
 	if (deleted_items) {
-		GError *rerror = NULL;
+		GError *local_error = NULL;
 		EwsDeleteType delete_type;
 
 		delete_type = expunge ? EWS_HARD_DELETE : EWS_MOVE_TO_DELETED_ITEMS;
 
-		camel_service_lock (CAMEL_SERVICE (ews_store), CAMEL_SERVICE_REC_CONNECT_LOCK);
-		status = e_ews_connection_delete_items (cnc, EWS_PRIORITY_MEDIUM, deleted_items, delete_type,
-							EWS_SEND_TO_NONE, FALSE, cancellable, &rerror);
-		camel_service_unlock (CAMEL_SERVICE (ews_store), CAMEL_SERVICE_REC_CONNECT_LOCK);
+		status = e_ews_connection_delete_items_sync (
+			cnc, EWS_PRIORITY_MEDIUM, deleted_items, delete_type,
+			EWS_SEND_TO_NONE, FALSE, cancellable, &local_error);
 
-		if (!status && rerror->code == EWS_CONNECTION_ERROR_ITEMNOTFOUND) {
+		if (!status && local_error->code == EWS_CONNECTION_ERROR_ITEMNOTFOUND) {
 			/* If delete failed due to the item not found, ignore the error,
-			   trigger folder info refresh and then go on to clear the
-			   cache of the deleted items anyway. */
-			g_clear_error(&rerror);
-			status = ews_refresh_info_sync (folder, EVO3(cancellable,) &rerror);
+			 * trigger folder info refresh and then go on to clear the
+			 * cache of the deleted items anyway. */
+			g_clear_error (&local_error);
+			status = ews_refresh_info_sync (folder, EVO3(cancellable,) &local_error);
 		}
 
 		if (status) {
 			while (deleted_items) {
-				const gchar *uid = (gchar *)deleted_items->data;
+				const gchar *uid = (gchar *) deleted_items->data;
 				camel_folder_summary_lock (folder->summary, CAMEL_FOLDER_SUMMARY_SUMMARY_LOCK);
 				camel_folder_change_info_remove_uid (changes, uid);
 				camel_folder_summary_remove_uid (folder->summary, uid);
-				ews_data_cache_remove(ews_folder->cache, "cur", uid, NULL);
+				ews_data_cache_remove (ews_folder->cache, "cur", uid, NULL);
 				camel_folder_summary_unlock (folder->summary, CAMEL_FOLDER_SUMMARY_SUMMARY_LOCK);
 				deleted_items = g_slist_next (deleted_items);
 			}
 		}
 
-		if (rerror)
-			g_propagate_error (error, rerror);
+		if (local_error) {
+			camel_ews_store_maybe_disconnect (ews_store, local_error);
+			g_propagate_error (error, local_error);
+		}
 
-		camel_folder_changed (folder, changes);
+		if (camel_folder_change_info_changed (changes)) {
+			camel_folder_summary_touch (folder->summary);
+			camel_folder_changed (folder, changes);
+		}
 
 		g_slist_foreach (deleted_head, (GFunc) camel_pstring_free, NULL);
 		g_slist_free (deleted_head);
 	}
 
 	camel_folder_change_info_free (changes);
-	
+	g_object_unref (cnc);
+
 	return status;
 }
 
 static gboolean
-ews_expunge_sync (CamelFolder *folder, EVO3(GCancellable *cancellable,) GError **error)
+ews_expunge_sync (CamelFolder *folder,
+                  EVO3(GCancellable *cancellable,)
+                  GError **error)
 {
 	CamelEwsStore *ews_store;
 	CamelEwsMessageInfo *ews_info;
 	CamelMessageInfo *info;
 	CamelStore *parent_store;
 	GSList *deleted_items = NULL;
+	gint i;
+	gboolean is_trash;
+	GPtrArray *known_uids;
 	EVO2(GCancellable *cancellable = NULL;)
-	gint i, count;
 
 	parent_store = camel_folder_get_parent_store (folder);
 	ews_store = CAMEL_EWS_STORE (parent_store);
 
-	if (!camel_ews_store_connected (ews_store, error))
+	if (!camel_ews_store_connected (ews_store, cancellable, error))
 		return FALSE;
-	
-	/* FIXME Run expunge on just trash folder once we are able to identify the exact trash */
 
-	/*Collect UIDs of deleted messages.*/
-	count = camel_folder_summary_count (folder->summary);
-	for (i = 0; i < count; i++) {
-		info = camel_folder_summary_index (folder->summary, i);
+	is_trash = ews_folder_is_of_type (folder, CAMEL_FOLDER_TYPE_TRASH);
+
+	camel_folder_summary_prepare_fetch_all (folder->summary, NULL);
+	known_uids = camel_folder_summary_get_array (folder->summary);
+	if (!known_uids)
+		return TRUE;
+
+	/* Collect UIDs of deleted messages. */
+	for (i = 0; i < known_uids->len; i++) {
+		const gchar *uid = g_ptr_array_index (known_uids, i);
+
+		info = camel_folder_summary_get (folder->summary, uid);
 		ews_info = (CamelEwsMessageInfo *) info;
-		if (ews_info && (ews_info->info.flags & CAMEL_MESSAGE_DELETED)) {
-			const gchar *uid = camel_message_info_uid (info);
+		if (ews_info && (is_trash || (ews_info->info.flags & CAMEL_MESSAGE_DELETED) != 0))
 			deleted_items = g_slist_prepend (deleted_items, (gpointer) camel_pstring_strdup (uid));
-		}
+
 		camel_message_info_free (info);
 	}
 
+	camel_folder_summary_free_array (known_uids);
+
 	return ews_delete_messages (folder, deleted_items, TRUE, cancellable, error);
 }
 
 static gint
-ews_cmp_uids (CamelFolder *folder, const gchar *uid1, const gchar *uid2)
+ews_cmp_uids (CamelFolder *folder,
+              const gchar *uid1,
+              const gchar *uid2)
 {
 	g_return_val_if_fail (uid1 != NULL, 0);
 	g_return_val_if_fail (uid2 != NULL, 0);
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/camel/camel-ews-provider.c evolution-ews.sync-with-3.8.2/src/camel/camel-ews-provider.c
--- evolution-ews.git-gnome-3-0/src/camel/camel-ews-provider.c	2013-05-17 14:36:16.348670560 +0200
+++ evolution-ews.sync-with-3.8.2/src/camel/camel-ews-provider.c	2013-05-28 08:59:53.266712262 +0200
@@ -61,6 +61,13 @@ static CamelProviderConfEntry ews_conf_e
 	  N_("Automatically synchroni_ze remote mail locally"), "0" },
 	{ CAMEL_PROVIDER_CONF_SECTION_END },
 
+	{ CAMEL_PROVIDER_CONF_SECTION_START, "connection", NULL, N_("Connection") },
+	{ CAMEL_PROVIDER_CONF_CHECKSPIN, "timeout", NULL,
+	  /* Translators: '%s' is preplaced with a widget, where "
+	   * user can select how long the timeout should be. */
+	  N_("Connection _timeout (in seconds) %s"), "0:1:120:32768" },
+	{ CAMEL_PROVIDER_CONF_SECTION_END },
+
 	{ CAMEL_PROVIDER_CONF_END }
 };
 
@@ -82,33 +89,50 @@ static CamelProvider ews_provider = {
 	/* ... */
 };
 
-/*TODO support more auth types */
-CamelServiceAuthType camel_ews_password_authtype = {
-	N_("Password"),
+CamelServiceAuthType camel_ews_ntlm_authtype = {
+	N_("NTLM"),
 
 	N_("This option will connect to the Exchange server using a "
-	   "plaintext password."),
+	   "plaintext password with NTLM authentication."),
 
 	"",
 	TRUE
 };
 
+/* Do not define, to not confuse users, the libsoup 2.30.x may switch to Basic silently
+   in the background, if the NTLM fails */
+/*CamelServiceAuthType camel_ews_basic_authtype = {
+	N_("Basic"),
+
+	N_("This option will connect to the Exchange server using a "
+	   "plaintext password with Basic authentication."),
+
+	"PLAIN",
+	TRUE
+};*/
+
 void
 camel_provider_module_init(void)
 {
 	ews_provider.url_hash = ews_url_hash;
 	ews_provider.url_equal = ews_url_equal;
-	ews_provider.authtypes = g_list_prepend (ews_provider.authtypes, &camel_ews_password_authtype);
+	ews_provider.authtypes = g_list_prepend (
+		/*g_list_prepend (NULL, &camel_ews_basic_authtype)*/ NULL,
+		&camel_ews_ntlm_authtype);
 	ews_provider.translation_domain = GETTEXT_PACKAGE;
 
-	ews_provider.object_types[CAMEL_PROVIDER_STORE] =  camel_ews_store_get_type ();
-	ews_provider.object_types[CAMEL_PROVIDER_TRANSPORT] = camel_ews_transport_get_type ();
+	ews_provider.object_types[CAMEL_PROVIDER_STORE] =  CAMEL_TYPE_EWS_STORE;
+	ews_provider.object_types[CAMEL_PROVIDER_TRANSPORT] = CAMEL_TYPE_EWS_TRANSPORT;
+
+	bindtextdomain (GETTEXT_PACKAGE, EXCHANGE_EWS_LOCALEDIR);
+	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
 
 	camel_provider_register (&ews_provider);
 }
 
 static void
-add_hash (guint *hash, gchar *s)
+add_hash (guint *hash,
+          gchar *s)
 {
 	if (s)
 		*hash ^= g_str_hash(s);
@@ -117,7 +141,7 @@ add_hash (guint *hash, gchar *s)
 static guint
 ews_url_hash (gconstpointer key)
 {
-	const CamelURL *u = (CamelURL *)key;
+	const CamelURL *u = (CamelURL *) key;
 	guint hash = 0;
 
 	add_hash (&hash, u->user);
@@ -128,7 +152,8 @@ ews_url_hash (gconstpointer key)
 }
 
 static gint
-check_equal (gchar *s1, gchar *s2)
+check_equal (gchar *s1,
+             gchar *s2)
 {
 	if (s1 == NULL) {
 		if (s2 == NULL)
@@ -144,7 +169,8 @@ check_equal (gchar *s1, gchar *s2)
 }
 
 static gint
-ews_url_equal (gconstpointer a, gconstpointer b)
+ews_url_equal (gconstpointer a,
+               gconstpointer b)
 {
 	const CamelURL *u1 = a, *u2 = b;
 
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/camel/camel-ews-store.c evolution-ews.sync-with-3.8.2/src/camel/camel-ews-store.c
--- evolution-ews.git-gnome-3-0/src/camel/camel-ews-store.c	2013-05-17 14:36:16.350669728 +0200
+++ evolution-ews.sync-with-3.8.2/src/camel/camel-ews-store.c	2013-05-28 08:59:53.267712492 +0200
@@ -23,7 +23,9 @@
  *
  */
 
+#ifdef HAVE_CONFIG_H
 #include <config.h>
+#endif
 
 #include <errno.h>
 #include <stdio.h>
@@ -36,7 +38,10 @@
 #include <glib/gi18n-lib.h>
 #include <glib/gstdio.h>
 
+#include <gconf/gconf-client.h>
+
 #include <libedataserver/e-flag.h>
+#include <libedataserver/e-account-list.h>
 #include <e-ews-compat.h>
 #include <e-ews-item-change.h>
 #include <e-ews-message.h>
@@ -46,7 +51,8 @@
 #include "camel-ews-summary.h"
 #include "camel-ews-utils.h"
 #include "ews-camel-compat.h"
-#include "ews-esource-utils.h"
+
+#include "server/e-ews-gnome-3-8-compat.h"
 
 #ifdef G_OS_WIN32
 #include <winsock2.h>
@@ -63,11 +69,11 @@
 #define FINFO_REFRESH_INTERVAL 60
 
 struct _CamelEwsStorePrivate {
-
-	gchar *host_url;
 	time_t last_refresh_time;
 	GMutex *get_finfo_lock;
-	EEwsConnection *cnc;
+	EEwsConnection *connection;
+	GMutex *connection_lock;
+	GSList *public_folders; /* EEwsFolder * objects */
 };
 
 #if ! EDS_CHECK_VERSION(2,33,0)
@@ -89,7 +95,9 @@ static inline gboolean camel_offline_sto
 }
 #endif
 
-extern CamelServiceAuthType camel_ews_password_authtype; /*for the query_auth_types function*/
+static gboolean ews_store_test_connection (CamelEwsStore *ews_store,
+					   EVO3(GCancellable *cancellable,)
+					   GError **error);
 static gboolean	ews_store_construct	(CamelService *service, CamelSession *session,
 			 		 CamelProvider *provider, CamelURL *url,
 		 			 GError **error);
@@ -140,10 +148,54 @@ G_DEFINE_TYPE (CamelEwsStore, camel_ews_
 
 #endif
 
+static void
+ews_migrate_to_user_cache_dir (CamelService *service)
+{
+	const gchar *user_data_dir, *user_cache_dir;
+
+	g_return_if_fail (service != NULL);
+	g_return_if_fail (CAMEL_IS_SERVICE (service));
+
+	user_data_dir = camel_service_get_user_data_dir (service);
+	user_cache_dir = camel_service_get_user_cache_dir (service);
+
+	g_return_if_fail (user_data_dir != NULL);
+	g_return_if_fail (user_cache_dir != NULL);
+
+	/* migrate only if the source directory exists and the destination doesn't */
+	if (g_file_test (user_data_dir, G_FILE_TEST_EXISTS | G_FILE_TEST_IS_DIR) &&
+	    !g_file_test (user_cache_dir, G_FILE_TEST_EXISTS | G_FILE_TEST_IS_DIR)) {
+		gchar *parent_dir;
+
+		parent_dir = g_path_get_dirname (user_cache_dir);
+		g_mkdir_with_parents (parent_dir, S_IRWXU);
+		g_free (parent_dir);
+
+		if (g_rename (user_data_dir, user_cache_dir) == -1) {
+			g_debug ("%s: Failed to migrate '%s' to '%s': %s", G_STRFUNC, user_data_dir, user_cache_dir, g_strerror (errno));
+		} else {
+			gchar *old_summary_file = g_build_filename (user_cache_dir, "folder-tree", NULL);
+
+			if (old_summary_file && g_file_test (old_summary_file, G_FILE_TEST_EXISTS)) {
+				gchar *new_summary_file = g_build_filename (user_cache_dir, "folder-tree", NULL);
+
+				if (new_summary_file && g_rename (old_summary_file, new_summary_file) == -1)
+					g_debug ("%s: Failed to migrate '%s' to '%s': %s", G_STRFUNC, old_summary_file, new_summary_file, g_strerror (errno));
+
+				g_free (new_summary_file);
+			}
+
+			g_free (old_summary_file);
+		}
+	}
+}
+
 static gboolean
-ews_store_construct	(CamelService *service, CamelSession *session,
-			 CamelProvider *provider, CamelURL *url,
-			 GError **error)
+ews_store_construct (CamelService *service,
+                     CamelSession *session,
+                     CamelProvider *provider,
+		     CamelURL *url,
+                     GError **error)
 {
 	CamelEwsStore *ews_store;
 	CamelEwsStorePrivate *priv;
@@ -157,16 +209,19 @@ ews_store_construct	(CamelService *servi
 	if (!service_class->construct (service, session, provider, url, error))
 		return FALSE;
 #endif	
-	
+
+	ews_migrate_to_user_cache_dir (service);
+
 	ews_store = (CamelEwsStore *) service;
 	priv = ews_store->priv;
 
 	/* Disable virtual trash and junk folders. Exchange has real
 	   folders for that */
 	((CamelStore *)ews_store)->flags &= ~(CAMEL_STORE_VTRASH|CAMEL_STORE_VJUNK);
+	((CamelStore *) ews_store)->flags |= CAMEL_STORE_REAL_JUNK_FOLDER;
 
 	/*storage path*/
-	session_storage_path = camel_session_get_storage_path (session, service, error);
+	session_storage_path = g_strdup (camel_service_get_user_cache_dir (service));
 	if (!session_storage_path) {
 		g_set_error (
 			error, CAMEL_STORE_ERROR,
@@ -176,8 +231,7 @@ ews_store_construct	(CamelService *servi
 	}
 	ews_store->storage_path = session_storage_path;
 
-	priv->host_url = g_strdup (camel_url_get_param (url, "hosturl"));
-	if (!priv->host_url) {
+	if (!camel_url_get_param (url, "hosturl")) {
 		g_set_error (
 			error, CAMEL_STORE_ERROR,
 			CAMEL_STORE_ERROR_INVALID,
@@ -188,7 +242,7 @@ ews_store_construct	(CamelService *servi
 	/* Note. update account-listener plugin if filename is changed here, as it would remove the summary
 	   by forming the path itself */
 	g_mkdir_with_parents (ews_store->storage_path, 0700);
-	summary_file = g_build_filename (ews_store->storage_path, "folder-tree-v2", NULL);
+	summary_file = g_build_filename (ews_store->storage_path, "folder-tree", NULL);
 	ews_store->summary = camel_ews_store_summary_new (summary_file);
 	camel_ews_store_summary_load (ews_store->summary, NULL);
 
@@ -196,6 +250,289 @@ ews_store_construct	(CamelService *servi
 	return TRUE;
 }
 
+/* returns NULL when it's safe to use the default "Public Folders" name; otherwise g_free() it */
+static gchar *
+ews_store_get_public_folders_name (CamelEwsStore *ews_store)
+{
+	gchar *use_name = NULL;
+	gchar *tmp_fid;
+	gint counter = 0;
+
+	tmp_fid = camel_ews_store_summary_get_folder_id_from_name (
+		ews_store->summary, EWS_PUBLIC_FOLDER_ROOT_DISPLAY_NAME);
+	while (tmp_fid) {
+		counter++;
+
+		g_free (tmp_fid);
+		g_free (use_name);
+
+		/* Translators: This composes a "Public Folders" folder name for case when
+		 * user has such in his store already. The %s is replaced with "Public Folders",
+		 * the %d with counter, thus it composes name like "Public Folders_1"
+		*/
+		use_name = g_strdup_printf (
+			C_("PublicFolders", "%s_%d"),
+			EWS_PUBLIC_FOLDER_ROOT_DISPLAY_NAME, counter);
+
+		tmp_fid = camel_ews_store_summary_get_folder_id_from_name (ews_store->summary, use_name);
+	}
+
+	return use_name;
+}
+
+void
+camel_ews_store_ensure_virtual_folders (CamelEwsStore *ews_store)
+{
+	gboolean needs_foreign = FALSE, has_foreign = FALSE;
+	gboolean needs_public = FALSE, has_public = FALSE;
+	CamelFolderInfo *fi;
+	GSList *folders, *iter;
+	GHashTable *children_count;
+	GHashTableIter tab_iter;
+	gpointer key, value;
+
+	g_return_if_fail (CAMEL_IS_EWS_STORE (ews_store));
+
+	folders = camel_ews_store_summary_get_folders (ews_store->summary, NULL);
+	if (!folders)
+		return;
+
+	children_count = g_hash_table_new (g_str_hash, g_str_equal);
+
+	for (iter = folders; iter; iter = iter->next) {
+		const gchar *fid = iter->data;
+		GError *error = NULL;
+
+		if (!fid)
+			continue;
+
+		if (g_str_has_prefix (fid, "ForeignMailbox::") &&
+		    !g_hash_table_contains (children_count, fid))
+			g_hash_table_insert (children_count, (gpointer) fid, GINT_TO_POINTER (0));
+
+		if (g_str_equal (fid, EWS_PUBLIC_FOLDER_ROOT_ID) &&
+		    !g_hash_table_contains (children_count, fid))
+			g_hash_table_insert (children_count, (gpointer) fid, GINT_TO_POINTER (0));
+
+		if (!has_foreign && g_str_equal (fid, EWS_FOREIGN_FOLDER_ROOT_ID))
+			has_foreign = TRUE;
+		else if (camel_ews_store_summary_get_foreign (ews_store->summary, fid, &error) && !error) {
+			gchar *pfid;
+
+			needs_foreign = TRUE;
+
+			pfid = camel_ews_store_summary_get_parent_folder_id (ews_store->summary, fid, NULL);
+			if (pfid && g_str_has_prefix (pfid, "ForeignMailbox::")) {
+				gint count = GPOINTER_TO_INT (g_hash_table_lookup (children_count, pfid));
+
+				g_hash_table_insert (children_count, (gpointer) pfid, GINT_TO_POINTER (count + 1));
+			}
+		}
+
+		g_clear_error (&error);
+
+		if (!has_public && g_str_equal (fid, EWS_PUBLIC_FOLDER_ROOT_ID))
+			has_public = TRUE;
+		else if (camel_ews_store_summary_get_public (ews_store->summary, fid, &error) && !error) {
+			EEwsFolderType ftype;
+			gchar *pfid;
+
+			ftype = camel_ews_store_summary_get_folder_type (ews_store->summary, fid, &error);
+			if (ftype == E_EWS_FOLDER_TYPE_MAILBOX && !error) {
+				guint64 fflags;
+
+				fflags = camel_ews_store_summary_get_folder_flags (ews_store->summary, fid, &error);
+				if ((fflags & CAMEL_FOLDER_SUBSCRIBED) != 0 && !error) {
+					needs_public = TRUE;
+
+					pfid = camel_ews_store_summary_get_parent_folder_id (ews_store->summary, fid, NULL);
+					if (pfid && g_str_equal (pfid, EWS_PUBLIC_FOLDER_ROOT_ID)) {
+						gint count = GPOINTER_TO_INT (g_hash_table_lookup (children_count, pfid));
+
+						g_hash_table_insert (children_count, (gpointer) pfid, GINT_TO_POINTER (count + 1));
+					}
+				}
+			}
+		}
+
+		g_clear_error (&error);
+	}
+
+	g_hash_table_iter_init (&tab_iter, children_count);
+	while (g_hash_table_iter_next (&tab_iter, &key, &value)) {
+		gint count = GPOINTER_TO_INT (value);
+
+		if (!count) {
+			CamelFolderInfo *fi;
+
+			if (has_foreign && g_str_equal (key, EWS_FOREIGN_FOLDER_ROOT_ID))
+				has_foreign = FALSE;
+
+			if (has_public && g_str_equal (key, EWS_PUBLIC_FOLDER_ROOT_ID))
+				has_public = FALSE;
+
+			fi = camel_ews_utils_build_folder_info (ews_store, key);
+			camel_ews_store_summary_remove_folder (ews_store->summary, key, NULL);
+
+			camel_subscribable_folder_unsubscribed (CAMEL_SUBSCRIBABLE (ews_store), fi);
+			camel_store_folder_deleted (CAMEL_STORE (ews_store), fi);
+			camel_folder_info_free (fi);
+		}
+	}
+
+	g_hash_table_destroy (children_count);
+
+	if (needs_foreign && !has_foreign) {
+		gchar *use_name = NULL;
+		gchar *tmp_fid;
+		gint counter = 0;
+
+		tmp_fid = camel_ews_store_summary_get_folder_id_from_name (
+			ews_store->summary, EWS_FOREIGN_FOLDER_ROOT_DISPLAY_NAME);
+		while (tmp_fid) {
+			counter++;
+
+			g_free (tmp_fid);
+			g_free (use_name);
+
+			/* Translators: This composes a "Foreign Folders" folder name for case when
+			 * user has such in his store already. The %s is replaced with "Foreign Folders",
+			 * the %d with counter, thus it composes name like "Foreign Folders_1"
+			*/
+			use_name = g_strdup_printf (
+				C_("ForeignFolders", "%s_%d"),
+				EWS_FOREIGN_FOLDER_ROOT_DISPLAY_NAME, counter);
+
+			tmp_fid = camel_ews_store_summary_get_folder_id_from_name (ews_store->summary, use_name);
+		}
+
+		camel_ews_store_summary_new_folder (
+			ews_store->summary,
+			EWS_FOREIGN_FOLDER_ROOT_ID, NULL, NULL,
+			use_name ? use_name : EWS_FOREIGN_FOLDER_ROOT_DISPLAY_NAME,
+			E_EWS_FOLDER_TYPE_MAILBOX,
+			CAMEL_FOLDER_SYSTEM | CAMEL_FOLDER_NOSELECT,
+			0, FALSE, FALSE);
+
+		g_free (use_name);
+
+		fi = camel_ews_utils_build_folder_info (ews_store, EWS_FOREIGN_FOLDER_ROOT_ID);
+		camel_store_folder_created (CAMEL_STORE (ews_store), fi);
+		camel_subscribable_folder_subscribed (CAMEL_SUBSCRIBABLE (ews_store), fi);
+		camel_folder_info_free (fi);
+	} else if (has_foreign && !needs_foreign) {
+		CamelFolderInfo *fi;
+
+		fi = camel_ews_utils_build_folder_info (ews_store, EWS_FOREIGN_FOLDER_ROOT_ID);
+		camel_ews_store_summary_remove_folder (ews_store->summary, EWS_FOREIGN_FOLDER_ROOT_ID, NULL);
+
+		camel_subscribable_folder_unsubscribed (CAMEL_SUBSCRIBABLE (ews_store), fi);
+		camel_store_folder_deleted (CAMEL_STORE (ews_store), fi);
+		camel_folder_info_free (fi);
+	}
+
+	if (needs_public && !has_public) {
+		gchar *use_name;
+
+		use_name = ews_store_get_public_folders_name (ews_store);
+
+		camel_ews_store_summary_new_folder (
+			ews_store->summary,
+			EWS_PUBLIC_FOLDER_ROOT_ID, NULL, NULL,
+			use_name ? use_name : EWS_PUBLIC_FOLDER_ROOT_DISPLAY_NAME,
+			E_EWS_FOLDER_TYPE_MAILBOX,
+			CAMEL_FOLDER_SYSTEM | CAMEL_FOLDER_NOSELECT,
+			0, FALSE, FALSE);
+
+		g_free (use_name);
+
+		fi = camel_ews_utils_build_folder_info (ews_store, EWS_PUBLIC_FOLDER_ROOT_ID);
+		camel_store_folder_created (CAMEL_STORE (ews_store), fi);
+		camel_subscribable_folder_subscribed (CAMEL_SUBSCRIBABLE (ews_store), fi);
+		camel_folder_info_free (fi);
+	} else if (has_public && !needs_public) {
+		CamelFolderInfo *fi;
+
+		fi = camel_ews_utils_build_folder_info (ews_store, EWS_PUBLIC_FOLDER_ROOT_ID);
+		camel_ews_store_summary_remove_folder (ews_store->summary, EWS_PUBLIC_FOLDER_ROOT_ID, NULL);
+
+		camel_subscribable_folder_unsubscribed (CAMEL_SUBSCRIBABLE (ews_store), fi);
+		camel_store_folder_deleted (CAMEL_STORE (ews_store), fi);
+		camel_folder_info_free (fi);
+	}
+
+	camel_ews_store_summary_rebuild_hashes (ews_store->summary);
+	camel_ews_store_summary_save (ews_store->summary, NULL);
+
+	g_slist_free_full (folders, g_free);
+}
+
+void
+camel_ews_store_ensure_unique_path (CamelEwsStore *ews_store,
+                                    gchar **ppath)
+{
+	gboolean done;
+	guint counter = 0;
+	gchar *base_path = NULL;
+
+	g_return_if_fail (CAMEL_IS_EWS_STORE (ews_store));
+	g_return_if_fail (ews_store->summary != NULL);
+	g_return_if_fail (ppath != NULL);
+	g_return_if_fail (*ppath != NULL);
+
+	done = FALSE;
+	while (!done) {
+		gchar *fid;
+
+		done = TRUE;
+
+		fid = camel_ews_store_summary_get_folder_id_from_name (ews_store->summary, *ppath);
+		if (fid) {
+			g_free (fid);
+
+			done = FALSE;
+			counter++;
+			if (!counter) {
+				g_debug ("%s: Counter overflow", G_STRFUNC);
+				break;
+			}
+
+			if (!base_path)
+				base_path = *ppath;
+			else
+				g_free (*ppath);
+
+			*ppath = g_strdup_printf ("%s_%u", base_path, counter);
+		}
+	}
+
+	g_free (base_path);
+}
+
+static void
+ews_update_folder_hierarchy (CamelEwsStore *ews_store,
+                             gchar *sync_state,
+                             gboolean includes_last_folder,
+                             GSList *folders_created,
+                             GSList *folders_deleted,
+                             GSList *folders_updated,
+			     GSList **created_folder_ids)
+{
+	ews_utils_sync_folders (ews_store, folders_created, folders_deleted, folders_updated, created_folder_ids);
+	camel_ews_store_ensure_virtual_folders (ews_store);
+
+	camel_ews_store_summary_store_string_val (ews_store->summary, "sync_state", sync_state);
+	camel_ews_store_summary_save (ews_store->summary, NULL);
+
+	g_slist_foreach (folders_created, (GFunc) g_object_unref, NULL);
+	g_slist_foreach (folders_updated, (GFunc) g_object_unref, NULL);
+	g_slist_foreach (folders_deleted, (GFunc) g_free, NULL);
+	g_slist_free (folders_created);
+	g_slist_free (folders_deleted);
+	g_slist_free (folders_updated);
+	g_free (sync_state);
+}
+
 static guint
 ews_hash_folder_name (gconstpointer key)
 {
@@ -249,6 +586,8 @@ ews_connect_sync (CamelService *service,
 	CamelEwsStore *ews_store;
 	CamelEwsStorePrivate *priv;
 	CamelURL *url;
+	const gchar *timeout_str;
+	gint timeout;
 
 	ews_store = (CamelEwsStore *) service;
 	priv = ews_store->priv;
@@ -259,16 +598,31 @@ ews_connect_sync (CamelService *service,
 
 	camel_service_lock (service, CAMEL_SERVICE_REC_CONNECT_LOCK);
 
-	if (priv->cnc) {
+	if (priv->connection) {
 		camel_service_unlock (service, CAMEL_SERVICE_REC_CONNECT_LOCK);
 		return TRUE;
 	}
 
-	priv->cnc = e_ews_connection_new (priv->host_url, url->user, NULL,
-					  G_CALLBACK (ews_store_authenticate), service,
-					  error);
+	timeout_str = camel_url_get_param (url, "timeout");
+	timeout = timeout_str ? atoi (timeout_str) : -1;
+
+	priv->connection = e_ews_connection_new (camel_url_get_param (url, "hosturl"),
+						 url->user,
+						 NULL, /* password */
+						 camel_url_get_param (url, "email"),
+						 camel_url_get_param (url, "impersonate_user"),
+						 timeout,
+						 TRUE,
+						 G_CALLBACK (ews_store_authenticate),
+						 service,
+						 error);
+
+	if (!priv->connection || !ews_store_test_connection (ews_store, EVO3(cancellable,) error)) {
+		if (priv->connection) {
+			g_object_unref (priv->connection);
+			priv->connection = NULL;
+		}
 
-	if (!priv->cnc) {
 		camel_service_unlock (service, CAMEL_SERVICE_REC_CONNECT_LOCK);
 		EVO3_sync(camel_service_disconnect) (service, TRUE, NULL);
 		return FALSE;
@@ -288,232 +642,1005 @@ ews_disconnect_sync (CamelService *servi
 	CamelEwsStore *ews_store = (CamelEwsStore *) service;
 	CamelServiceClass *service_class;
 
-	service_class = CAMEL_SERVICE_CLASS (camel_ews_store_parent_class);
-	if (!service_class->EVO3_sync(disconnect) (service, clean, EVO3(cancellable,) error))
-		return FALSE;
-
 	camel_service_lock (service, CAMEL_SERVICE_REC_CONNECT_LOCK);
 
 	/* TODO cancel all operations in the connection */
-	g_object_unref (ews_store->priv->cnc);
-	ews_store->priv->cnc = NULL;
+	if (ews_store->priv->connection) {
+		e_ews_connection_set_password (ews_store->priv->connection, NULL);
+		g_object_unref (ews_store->priv->connection);
+		ews_store->priv->connection = NULL;
+	}
 
 	camel_service_unlock (service, CAMEL_SERVICE_REC_CONNECT_LOCK);
 
-	return TRUE;
-}
-
-static  GList*
-ews_store_query_auth_types_sync (CamelService *service, EVO3(GCancellable *cancellable,) GError **error)
-{
-	GList *auth_types = NULL;
-
-	d(printf("in query auth types\n"));
-	auth_types = g_list_prepend (auth_types,  &camel_ews_password_authtype);
-	return auth_types;
+	service_class = CAMEL_SERVICE_CLASS (camel_ews_store_parent_class);
+	return service_class->EVO3_sync(disconnect) (service, clean, EVO3(cancellable,) error);
 }
 
-static CamelFolderInfo* ews_create_folder_sync (CamelStore *store, const gchar *parent_name,const gchar *folder_name,EVO3(GCancellable *cancellable,)GError **error);
+typedef struct {
+	const gchar *dist_folder_id;
+	gint info_flags;
+} SystemFolder;
+
+static SystemFolder system_folder[] = {
+	{"calendar", CAMEL_FOLDER_SYSTEM | CAMEL_FOLDER_TYPE_EVENTS},
+	{"contacts", CAMEL_FOLDER_SYSTEM | CAMEL_FOLDER_TYPE_CONTACTS},
+	{"deleteditems", CAMEL_FOLDER_SYSTEM | CAMEL_FOLDER_TYPE_TRASH},
+	{"drafts", CAMEL_FOLDER_SYSTEM},
+	{"inbox", CAMEL_FOLDER_SYSTEM | CAMEL_FOLDER_TYPE_INBOX},
+	{"journal", CAMEL_FOLDER_SYSTEM | CAMEL_EWS_FOLDER_TYPE_JOURNAL},
+	{"notes", CAMEL_FOLDER_SYSTEM | CAMEL_FOLDER_TYPE_MEMOS},
+	{"outbox", CAMEL_FOLDER_SYSTEM | CAMEL_FOLDER_TYPE_OUTBOX},
+	{"sentitems", CAMEL_FOLDER_SYSTEM | CAMEL_FOLDER_TYPE_SENT},
+	{"tasks", CAMEL_FOLDER_SYSTEM | CAMEL_FOLDER_TYPE_TASKS},
+	{"msgfolderroot", CAMEL_FOLDER_SYSTEM},
+	{"root", CAMEL_FOLDER_SYSTEM},
+	{"junkemail", CAMEL_FOLDER_SYSTEM | CAMEL_FOLDER_TYPE_JUNK},
+	{"searchfolders", CAMEL_FOLDER_SYSTEM},
+};
 
-static CamelFolder *
-ews_get_folder_sync (CamelStore *store, const gchar *folder_name, guint32 flags, EVO3(GCancellable *cancellable,) GError **error)
+static void
+ews_store_set_flags (CamelEwsStore *ews_store,
+                     GSList *folders)
 {
-	EVO2(GCancellable *cancellable = NULL;)
-	CamelEwsStore *ews_store;
-	CamelFolder *folder = NULL;
-	gchar *fid, *folder_dir;
-
-	ews_store = (CamelEwsStore *) store;
-
-	fid = camel_ews_store_summary_get_folder_id_from_name (ews_store->summary, folder_name);
-
-	/* We don't support CAMEL_STORE_FOLDER_EXCL. Nobody ever uses it */
-	if (!fid && (flags & CAMEL_STORE_FOLDER_CREATE)) {
-		CamelFolderInfo *fi;
-		const gchar *parent, *top, *slash;
-		gchar *copy = NULL;
+	GSList *temp = NULL;
+	EEwsFolder *folder = NULL;
+	const EwsFolderId *fid = NULL;
+	gint n = 0;
+
+	temp = folders;
+	while (temp != NULL) {
+		folder = (EEwsFolder *) temp->data;
 
-		slash = strrchr (folder_name, '/');
-		if (slash) {
-			copy = g_strdup (folder_name);
+		if (folder && !e_ews_folder_is_error (folder)) {
+			fid = e_ews_folder_get_id (folder);
 
-			/* Split into parent path, and new name */
-			copy[slash - folder_name] = 0;
-			parent = copy;
-			top = copy + (slash - folder_name) + 1;
-		} else {
-			parent = "";
-			top = folder_name;
+			if (camel_ews_store_summary_has_folder (ews_store->summary, fid->id))
+				camel_ews_store_summary_set_folder_flags (ews_store->summary, fid->id, system_folder[n].info_flags);
 		}
 
-		fi = ews_create_folder_sync (store, parent, top, EVO3(cancellable,) error);
-		g_free (copy);
-
-		if (!fi)
-			return NULL;
-
-		camel_folder_info_free (fi);
-	} else if (!fid) {
-		g_set_error (error, CAMEL_STORE_ERROR,
-			     CAMEL_ERROR_GENERIC,
-			     _("No such folder: %s"), folder_name);
-		return NULL;
-	} else {
-		/* We don't actually care what it is; only that it exists */
-		g_free (fid);
+		temp = temp->next;
+		n++;
 	}
-
-	folder_dir = g_build_filename (ews_store->storage_path, "folders", folder_name, NULL);
-	folder = camel_ews_folder_new (store, folder_name, folder_dir, cancellable, error);
-
-	g_free (folder_dir);
-
-	return folder;
 }
 
-static CamelFolderInfo *
-folder_info_from_store_summary (CamelEwsStore *store, const gchar *top, guint32 flags, GError **error)
+static void
+ews_store_forget_all_folders (CamelEwsStore *ews_store)
 {
-	CamelEwsStoreSummary *ews_summary;
+	CamelStore *store;
+	CamelSubscribable *subscribable;
 	GSList *folders, *l;
-	GPtrArray *folder_infos;
-	CamelFolderInfo *root_fi = NULL;
 
-	ews_summary = store->summary;
-	folders = camel_ews_store_summary_get_folders (ews_summary, top);
+	g_return_if_fail (CAMEL_IS_EWS_STORE (ews_store));
 
-	if (!folders)
-		return NULL;
+	store = CAMEL_STORE (ews_store);
+	subscribable = CAMEL_SUBSCRIBABLE (ews_store);
+	folders = camel_ews_store_summary_get_folders (ews_store->summary, NULL);
 
-	folder_infos = g_ptr_array_new ();
+	if (!folders)
+		return;
 
 	for (l = folders; l != NULL; l = g_slist_next (l)) {
 		CamelFolderInfo *fi;
-		gint64 ftype;
+		EEwsFolderType ftype;
 
-		ftype = camel_ews_store_summary_get_folder_type (ews_summary, l->data, NULL);
-		if (ftype != EWS_FOLDER_TYPE_MAILBOX)
+		ftype = camel_ews_store_summary_get_folder_type (ews_store->summary, l->data, NULL);
+		if (ftype != E_EWS_FOLDER_TYPE_MAILBOX)
 			continue;
 
-		fi = camel_ews_utils_build_folder_info (store, l->data);
-		g_ptr_array_add	(folder_infos, fi);
+		fi = camel_ews_utils_build_folder_info (ews_store, l->data);
+		camel_subscribable_folder_unsubscribed (subscribable, fi);
+		camel_store_folder_deleted (store, fi);
+		camel_folder_info_free (fi);
 	}
 
-	root_fi = camel_folder_info_build (folder_infos, top, '/', TRUE);
-
-	g_ptr_array_free (folder_infos, TRUE);
-	g_slist_foreach (folders, (GFunc) g_free, NULL);
-	g_slist_free (folders);
-
-	return root_fi;
+	g_slist_free_full (folders, g_free);
 }
 
+struct EwsUpdateForeignSubfoldersData
+{
+	CamelEwsStore *ews_store;
+	gchar *folder_id;
+};
+
 static void
-ews_update_folder_hierarchy (CamelEwsStore *ews_store, gchar *sync_state,
-			     gboolean includes_last_folder, GSList *folders_created,
-			     GSList *folders_deleted, GSList *folders_updated)
+ews_update_foreign_subfolders_data_free (gpointer data)
 {
-	ews_utils_sync_folders (ews_store, folders_created, folders_deleted, folders_updated);
-	camel_ews_store_summary_store_string_val (ews_store->summary, "sync_state", sync_state);
-	camel_ews_store_summary_save (ews_store->summary, NULL);
+	struct EwsUpdateForeignSubfoldersData *euf = data;
 
-	g_slist_foreach (folders_created, (GFunc) g_object_unref, NULL);
-	g_slist_foreach (folders_updated, (GFunc) g_object_unref, NULL);
-	g_slist_foreach (folders_deleted, (GFunc) g_free, NULL);
-	g_slist_free (folders_created);
-	g_slist_free (folders_deleted);
-	g_slist_free (folders_updated);
-	g_free (sync_state);
+	if (euf) {
+		g_object_unref (euf->ews_store);
+		g_free (euf->folder_id);
+		g_free (euf);
+	}
 }
 
 static void
-ews_folder_hierarchy_ready_cb (GObject *obj, GAsyncResult *res, gpointer user_data)
+ews_store_update_foreign_subfolders (CamelSession *session,
+				     GCancellable *cancellable,
+				     gpointer user_data,
+				     GError **error)
 {
-	GSList *folders_created = NULL, *folders_updated = NULL;
-	GSList *folders_deleted = NULL;
-	CamelEwsStore *ews_store = (CamelEwsStore *) user_data;
-	CamelEwsStorePrivate *priv = ews_store->priv;
-	EEwsConnection *cnc = (EEwsConnection *) obj;
-	gchar *sync_state = NULL;
-	gboolean includes_last_folder;
-	GError *error = NULL;
+	struct EwsUpdateForeignSubfoldersData *euf = user_data;
+	CamelEwsStore *ews_store;
+	EEwsConnection *conn;
+	GSList *tocheck = NULL, *remote_folders = NULL, *local_folders = NULL;
+	const gchar *fid;
+	GError *local_error = NULL;
 
-	e_ews_connection_sync_folder_hierarchy_finish	(cnc, res, &sync_state, &includes_last_folder,
-							 &folders_created, &folders_updated,
-							 &folders_deleted, &error);
+	g_return_if_fail (euf != NULL);
 
-	if (error != NULL) {
-		g_warning ("Unable to fetch the folder hierarchy: %s :%d \n", error->message, error->code);
+	ews_store = euf->ews_store;
+	fid = euf->folder_id;
 
-		g_mutex_lock (priv->get_finfo_lock);
-		ews_store->priv->last_refresh_time -= FINFO_REFRESH_INTERVAL;
-		g_mutex_unlock (priv->get_finfo_lock);
-		goto exit;
-	}
-	ews_update_folder_hierarchy (ews_store, sync_state, includes_last_folder,
-				     folders_created, folders_deleted, folders_updated);
+	if (!camel_offline_store_get_online (CAMEL_OFFLINE_STORE (ews_store)))
+		return;
 
-	g_mutex_lock (priv->get_finfo_lock);
-	ews_store->priv->last_refresh_time = time (NULL);
-	g_mutex_unlock (priv->get_finfo_lock);
+	conn = camel_ews_store_ref_connection (ews_store);
+	g_return_if_fail (conn != NULL);
 
-exit:
-	g_object_unref (ews_store);
-	g_clear_error (&error);
-}
+	camel_operation_push_message (cancellable, _("Updating foreign folder structure"));
 
-static gboolean
-ews_refresh_finfo (CamelEwsStore *ews_store)
-{
-	gchar *sync_state;
-	
-	if (!camel_offline_store_get_online (CAMEL_OFFLINE_STORE (ews_store)))
-		return FALSE;
+	/* read remote folder structure at the server */
+	while (fid && !g_cancellable_is_cancelled (cancellable) && !local_error) {
+		gboolean includes_last_item = FALSE;
+		EwsFolderId *folder_id = e_ews_folder_id_new (fid, NULL, FALSE);
 
-	if (!EVO3_sync(camel_service_connect) ((CamelService *) ews_store, NULL))
-		return FALSE;
+		while (!includes_last_item && !g_cancellable_is_cancelled (cancellable) && !local_error) {
+			GSList *folders = NULL, *ff;
 
-	sync_state = camel_ews_store_summary_get_string_val (ews_store->summary, "sync_state", NULL);
+			if (!e_ews_connection_find_folder_sync (conn, EWS_PRIORITY_MEDIUM, folder_id,
+				&includes_last_item, &folders, cancellable, &local_error))
+				break;
 
+			for (ff = folders; ff != NULL; ff = ff->next) {
+				EEwsFolder *folder = ff->data;
 
-	e_ews_connection_sync_folder_hierarchy_start	(ews_store->priv->cnc, EWS_PRIORITY_MEDIUM,
-							 sync_state, ews_folder_hierarchy_ready_cb,
-							 NULL, g_object_ref (ews_store));
-	g_free (sync_state);
-	return TRUE;
-}
+				e_ews_folder_set_parent_id (folder, e_ews_folder_id_new (fid, NULL, FALSE));
 
-static CamelFolderInfo *
-ews_get_folder_info_sync (CamelStore *store, const gchar *top, guint32 flags, EVO3(GCancellable *cancellable,) GError **error)
-{
-	EVO2(GCancellable *cancellable = NULL;)
-	CamelEwsStore *ews_store;
-	CamelEwsStorePrivate *priv;
-	CamelFolderInfo *fi = NULL;
-	gchar *sync_state;
-	gboolean initial_setup = FALSE;
-	GSList *folders_created = NULL, *folders_updated = NULL;
-	GSList *folders_deleted = NULL;
-	gboolean includes_last_folder;
+				remote_folders = g_slist_prepend (remote_folders, folder);
 
-	ews_store = (CamelEwsStore *) store;
-	priv = ews_store->priv;
+				if (e_ews_folder_get_child_count (folder) > 0 && e_ews_folder_get_id (folder))
+					tocheck = g_slist_prepend (tocheck, e_ews_folder_get_id (folder)->id);
+			}
+		}
 
-	g_mutex_lock (priv->get_finfo_lock);
-	if (!(camel_offline_store_get_online (CAMEL_OFFLINE_STORE (store))
-	      && EVO3_sync(camel_service_connect) ((CamelService *)store, error))) {
-		g_mutex_unlock (priv->get_finfo_lock);
-		goto offline;
-	}
+		e_ews_folder_id_free (folder_id);
 
-	sync_state = camel_ews_store_summary_get_string_val (ews_store->summary, "sync_state", NULL);
-	if (!sync_state)
+		if (tocheck) {
+			fid = g_slist_last (tocheck)->data;
+			tocheck = g_slist_remove (tocheck, fid);
+		} else {
+			fid = NULL;
+		}
+	}
+
+	/* get local folder structure */
+	if (!local_error && !g_cancellable_is_cancelled (cancellable)) {
+		gchar *full_name = camel_ews_store_summary_get_folder_full_name (ews_store->summary, euf->folder_id, NULL);
+		if (full_name) {
+			local_folders = camel_ews_store_summary_get_folders (ews_store->summary, full_name);
+		}
+		g_free (full_name);
+	}
+
+	/* merge local and remote folder structures */
+	if (!local_error && !g_cancellable_is_cancelled (cancellable)) {
+		GHashTable *locals = g_hash_table_new (g_str_hash, g_str_equal);
+		GSList *ii;
+
+		remote_folders = g_slist_reverse (remote_folders);
+
+		for (ii = local_folders; ii; ii = ii->next) {
+			g_hash_table_insert (locals, ii->data, ii->data);
+		}
+
+		for (ii = remote_folders; ii; ii = ii->next) {
+			EEwsFolder *folder = ii->data;
+			const EwsFolderId *folder_id = e_ews_folder_get_id (folder);
+			const EwsFolderId *parent_fid = e_ews_folder_get_parent_id (folder);
+
+			if (e_ews_folder_get_folder_type (folder) == E_EWS_FOLDER_TYPE_MAILBOX &&
+			    folder_id && folder_id->id) {
+				if (!g_hash_table_remove (locals, folder_id->id)) {
+					CamelFolderInfo *fi;
+
+					/* it's a new folder, add it */
+					camel_ews_store_summary_new_folder (
+						ews_store->summary,
+						folder_id->id, parent_fid ? parent_fid->id : euf->folder_id, folder_id->change_key,
+						e_ews_folder_get_name (folder), E_EWS_FOLDER_TYPE_MAILBOX,
+						CAMEL_FOLDER_SUBSCRIBED, e_ews_folder_get_total_count (folder), TRUE, FALSE);
+
+					fi = camel_ews_utils_build_folder_info (ews_store, folder_id->id);
+					camel_store_folder_created (CAMEL_STORE (ews_store), fi);
+					camel_subscribable_folder_subscribed (CAMEL_SUBSCRIBABLE (ews_store), fi);
+					camel_folder_info_free (fi);
+				}
+			}
+		}
+
+		/* to not remove the parent */
+		g_hash_table_remove (locals, euf->folder_id);
+
+		/* and now the locals contains only folders which were removed */
+		if (g_hash_table_size (locals) > 0) {
+			CamelSubscribable *subscribable = CAMEL_SUBSCRIBABLE (ews_store);
+			CamelStore *store = CAMEL_STORE (ews_store);
+			GHashTableIter iter;
+			gpointer key, value;
+
+			g_hash_table_iter_init (&iter, locals);
+			while (g_hash_table_iter_next (&iter, &key, &value)) {
+				CamelFolderInfo *fi;
+
+				fi = camel_ews_utils_build_folder_info (ews_store, key);
+				camel_subscribable_folder_unsubscribed (subscribable, fi);
+				camel_store_folder_deleted (store, fi);
+				camel_folder_info_free (fi);
+			}
+		}
+
+		g_hash_table_destroy (locals);
+
+		camel_ews_store_summary_save (ews_store->summary, &local_error);
+	}
+
+	if (local_error)
+		g_propagate_error (error, local_error);
+
+	camel_operation_pop_message (cancellable);
+
+	g_slist_free_full (remote_folders, g_object_unref);
+	g_slist_free_full (local_folders, g_free);
+	g_slist_free (tocheck);
+	g_object_unref (conn);
+}
+
+void
+camel_ews_store_update_foreign_subfolders (CamelEwsStore *ews_store,
+					   const gchar *fid)
+{
+	struct EwsUpdateForeignSubfoldersData *euf;
+	CamelSession *session;
+
+	g_return_if_fail (CAMEL_IS_EWS_STORE (ews_store));
+	g_return_if_fail (fid != NULL);
+
+	session = camel_service_ref_session (CAMEL_SERVICE (ews_store));
+	g_return_if_fail (session != NULL);
+
+	euf = g_new0 (struct EwsUpdateForeignSubfoldersData, 1);
+	euf->ews_store = g_object_ref (ews_store);
+	euf->folder_id = g_strdup (fid);
+
+	camel_session_submit_job (
+		session, ews_store_update_foreign_subfolders,
+		euf, ews_update_foreign_subfolders_data_free);
+
+	g_object_unref (session);
+}
+
+static void
+ews_store_maybe_update_sent_and_drafts (CamelEwsStore *ews_store,
+					/* const */ GSList *ews_folders)
+{
+	CamelService *service = (CamelService *) ews_store;
+	GConfClient *gconf_client;
+	EAccountList *account_list;
+	EAccount *account;
+	EIterator *it;
+	gboolean changed = FALSE;
+
+	g_return_if_fail (CAMEL_IS_EWS_STORE (ews_store));
+	g_return_if_fail (service->url != NULL);
+	g_return_if_fail (service->provider != NULL);
+
+	gconf_client = gconf_client_get_default ();
+	account_list = e_account_list_new (gconf_client);
+	g_object_unref (gconf_client);
+	g_return_if_fail (account_list != NULL);
+
+	for (it = e_list_get_iterator ((EList *) account_list); e_iterator_is_valid (it); e_iterator_next (it)) {
+		CamelURL *url;
+
+		account = (EAccount *) e_iterator_get (it);
+
+		if (!account || !account->enabled)
+			continue;
+
+		if (!account->source->url || g_ascii_strncasecmp (account->source->url, "ews://", 6) != 0)
+			continue;
+
+		url = camel_url_new (account->source->url, NULL);
+		if (!url)
+			continue;
+
+		if (service->provider->url_equal (url, service->url)) {
+			if (account->sent_folder_uri &&
+			    g_str_has_suffix (account->sent_folder_uri, "/.local/share/evolution/mail/local#Sent")) {
+				gchar *folder_id;
+
+				folder_id = camel_ews_store_summary_get_folder_id_from_folder_type (ews_store->summary, CAMEL_FOLDER_TYPE_SENT);
+				if (folder_id) {
+					gchar *furi = camel_ews_utils_build_folder_uri (ews_store, folder_id);
+
+					if (furi && *furi) {
+						changed = TRUE;
+						e_account_set_string (account, E_ACCOUNT_SENT_FOLDER_URI, furi);
+					}
+
+					g_free (furi);
+					g_free (folder_id);
+				}
+			}
+
+			if (account->drafts_folder_uri &&
+			    g_str_has_suffix (account->drafts_folder_uri, "/.local/share/evolution/mail/local#Drafts")) {
+				if (g_slist_length (ews_folders) == G_N_ELEMENTS (system_folder)) {
+					gint ii;
+					for (ii = 0; ii < G_N_ELEMENTS (system_folder); ii++) {
+						if (g_str_equal ("drafts", system_folder[ii].dist_folder_id)) {
+							break;
+						}
+					}
+
+					if (ii < G_N_ELEMENTS (system_folder)) {
+						EEwsFolder *drafts = g_slist_nth (ews_folders, ii)->data;
+						if (drafts && !e_ews_folder_is_error (drafts)) {
+							const EwsFolderId *fid = e_ews_folder_get_id (drafts);
+
+							if (fid && fid->id) {
+								gchar *furi = camel_ews_utils_build_folder_uri (ews_store, fid->id);
+
+								if (furi && *furi) {
+									changed = TRUE;
+									e_account_set_string (account, E_ACCOUNT_DRAFTS_FOLDER_URI, furi);
+								}
+
+								g_free (furi);
+							}
+						}
+					}
+				}
+			}
+
+			camel_url_free (url);
+			break;
+		}
+
+		camel_url_free (url);
+	}
+
+	if (changed)
+		e_account_list_save (account_list);
+
+	g_object_unref (account_list);
+}
+
+static gboolean
+ews_store_test_connection (CamelEwsStore *ews_store,
+			   EVO3(GCancellable *cancellable,)
+			   GError **error)
+{
+	EVO2(GCancellable *cancellable = NULL;)
+	gboolean success = FALSE;
+	EEwsConnection *connection;
+	GSList *folders_created = NULL;
+	GSList *folders_updated = NULL;
+	GSList *folders_deleted = NULL;
+	GSList *folder_ids = NULL, *folders = NULL;
+	GSList *created_folder_ids = NULL;
+	gboolean includes_last_folder = FALSE;
+	gboolean initial_setup = FALSE;
+	gchar *old_sync_state = NULL, *new_sync_state = NULL;
+	GError *local_error = NULL, *folder_err = NULL;
+
+	g_return_val_if_fail (CAMEL_IS_EWS_STORE (ews_store), FALSE);
+	g_return_val_if_fail (ews_store->priv->connection != NULL, FALSE);
+
+	g_mutex_lock (ews_store->priv->connection_lock);
+	connection = ews_store->priv->connection;
+	if (connection)
+		g_object_ref (connection);
+	g_mutex_unlock (ews_store->priv->connection_lock);
+
+	/* XXX We need to run some operation that requires authentication
+	 *     but does not change any server-side state, so we can check
+	 *     the error status and determine if our password is valid.
+	 *     David suggested e_ews_connection_sync_folder_hierarchy(),
+	 *     since we have to do that eventually anyway. */
+
+	/*use old sync_state from summary*/
+	old_sync_state = camel_ews_store_summary_get_string_val (ews_store->summary, "sync_state", NULL);
+	if (!old_sync_state)
 		initial_setup = TRUE;
 
-	if (!initial_setup && flags & CAMEL_STORE_FOLDER_INFO_SUBSCRIBED) {
+	e_ews_connection_sync_folder_hierarchy_sync (connection, EWS_PRIORITY_MEDIUM, old_sync_state,
+		&new_sync_state, &includes_last_folder, &folders_created, &folders_updated, &folders_deleted,
+		cancellable, &local_error);
+
+	g_free (old_sync_state);
+	old_sync_state = NULL;
+
+	if (!initial_setup && g_error_matches (local_error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_INVALIDSYNCSTATEDATA)) {
+		g_clear_error (&local_error);
+		ews_store_forget_all_folders (ews_store);
+		camel_ews_store_summary_store_string_val (ews_store->summary, "sync_state", "");
+		camel_ews_store_summary_clear (ews_store->summary);
+
+		initial_setup = TRUE;
+
+		e_ews_connection_sync_folder_hierarchy_sync (connection, EWS_PRIORITY_MEDIUM, NULL,
+			&new_sync_state, &includes_last_folder, &folders_created, &folders_updated, &folders_deleted,
+			cancellable, &local_error);
+	}
+
+	if (local_error == NULL) {
+		GSList *foreign_fids, *ff;
+
+		g_mutex_lock (ews_store->priv->connection_lock);
+		if (ews_store->priv->connection != NULL)
+			g_object_unref (ews_store->priv->connection);
+		ews_store->priv->connection = g_object_ref (connection);
+		g_mutex_unlock (ews_store->priv->connection_lock);
+
+		/* This consumes all allocated result data. */
+		ews_update_folder_hierarchy (
+			ews_store, new_sync_state, includes_last_folder,
+			folders_created, folders_deleted, folders_updated, &created_folder_ids);
+
+		/* Also update folder structures of foreign folders,
+		   those which are subscribed with subfolders */
+		foreign_fids = camel_ews_store_summary_get_foreign_folders (ews_store->summary, NULL);
+		for (ff = foreign_fids; ff != NULL; ff = ff->next) {
+			const gchar *fid = ff->data;
+
+			if (camel_ews_store_summary_get_foreign_subfolders (ews_store->summary, fid, NULL)) {
+				camel_ews_store_update_foreign_subfolders (ews_store, fid);
+			}
+		}
+
+		g_slist_free_full (foreign_fids, g_free);
+	} else {
+		g_mutex_lock (ews_store->priv->connection_lock);
+		if (ews_store->priv->connection != NULL) {
+			g_object_unref (ews_store->priv->connection);
+			ews_store->priv->connection = NULL;
+		}
+		if (connection) {
+			g_object_unref (connection);
+			connection = NULL;
+		}
+		g_mutex_unlock (ews_store->priv->connection_lock);
+
+		g_free (new_sync_state);
+
+		/* Make sure we're not leaking anything. */
+		g_warn_if_fail (folders_created == NULL);
+		g_warn_if_fail (folders_updated == NULL);
+		g_warn_if_fail (folders_deleted == NULL);
+	}
+
+	/*get folders using distinguished id by GetFolder operation and set system flags to folders, only for first time*/
+	if (!local_error && initial_setup) {
+		gint n = 0;
+
+		while (n < G_N_ELEMENTS (system_folder)) {
+			EwsFolderId *fid = NULL;
+
+			fid = g_new0 (EwsFolderId, 1);
+			fid->id = g_strdup (system_folder[n].dist_folder_id);
+			fid->is_distinguished_id = TRUE;
+			folder_ids = g_slist_append (folder_ids, fid);
+			n++;
+		}
+
+		/* fetch system folders first using getfolder operation*/
+		e_ews_connection_get_folder_sync (
+			connection, EWS_PRIORITY_MEDIUM, "IdOnly",
+			NULL, folder_ids, &folders,
+			cancellable, &folder_err);
+
+		if (folders && (g_slist_length (folders) != G_N_ELEMENTS (system_folder)))
+			d (printf ("Error : not all folders are returned by getfolder operation"));
+		else if (folder_err == NULL && folders != NULL)
+			ews_store_set_flags (ews_store, folders);
+		else if (folder_err) {
+			/*report error and make sure we are not leaking anything*/
+			g_warn_if_fail (folders == NULL);
+		} else
+			d (printf ("folders for respective distinguished ids don't exist"));
+
+		ews_store_maybe_update_sent_and_drafts (ews_store, folders);
+
+		g_slist_foreach (folders, (GFunc) g_object_unref, NULL);
+		g_slist_foreach (folder_ids, (GFunc) e_ews_folder_id_free, NULL);
+		g_slist_free (folders);
+		g_slist_free (folder_ids);
+		g_clear_error (&folder_err);
+	}
+
+	/* postpone notification of new folders to time when also folder flags are known,
+	   thus the view in evolution sows Inbox with an Inbox icon. */
+	for (folder_ids = created_folder_ids; folder_ids; folder_ids = folder_ids->next) {
+		CamelFolderInfo *fi;
+
+		fi = camel_ews_utils_build_folder_info (ews_store, folder_ids->data);
+		camel_store_folder_created (CAMEL_STORE (ews_store), fi);
+		camel_subscribable_folder_subscribed (CAMEL_SUBSCRIBABLE (ews_store), fi);
+		camel_folder_info_free (fi);
+	}
+
+	g_slist_free_full (created_folder_ids, g_free);
+
+	if (local_error == NULL) {
+		success = TRUE;
+	} else {
+		g_propagate_error (error, local_error);
+		success = FALSE;
+	}
+
+	if (connection)
+		g_object_unref (connection);
+
+	return success;
+}
+
+static  GList *
+ews_store_query_auth_types_sync (CamelService *service,
+                                 EVO3(GCancellable *cancellable,)
+                                 GError **error)
+{
+	g_set_error_literal (error, CAMEL_ERROR, CAMEL_ERROR_GENERIC, _("Query for authentication types is not supported"));
+
+	return NULL;
+}
+
+static CamelFolderInfo* ews_create_folder_sync (CamelStore *store, const gchar *parent_name,const gchar *folder_name,EVO3(GCancellable *cancellable,)GError **error);
+
+static CamelFolder *
+ews_get_folder_sync (CamelStore *store,
+                     const gchar *folder_name,
+                     guint32 flags,
+                     EVO3(GCancellable *cancellable,)
+                     GError **error)
+{
+	EVO2(GCancellable *cancellable = NULL;)
+	CamelEwsStore *ews_store;
+	CamelFolder *folder = NULL;
+	gchar *fid, *folder_dir;
+
+	ews_store = (CamelEwsStore *) store;
+
+	fid = camel_ews_store_summary_get_folder_id_from_name (ews_store->summary, folder_name);
+
+	/* We don't support CAMEL_STORE_FOLDER_EXCL. Nobody ever uses it */
+	if (!fid && (flags & CAMEL_STORE_FOLDER_CREATE)) {
+		CamelFolderInfo *fi;
+		const gchar *parent, *top, *slash;
+		gchar *copy = NULL;
+
+		slash = strrchr (folder_name, '/');
+		if (slash) {
+			copy = g_strdup (folder_name);
+
+			/* Split into parent path, and new name */
+			copy[slash - folder_name] = 0;
+			parent = copy;
+			top = copy + (slash - folder_name) + 1;
+		} else {
+			parent = "";
+			top = folder_name;
+		}
+
+		fi = ews_create_folder_sync (store, parent, top, EVO3(cancellable,) error);
+		g_free (copy);
+
+		if (!fi)
+			return NULL;
+
+		camel_folder_info_free (fi);
+	} else if (!fid) {
+		g_set_error (error, CAMEL_STORE_ERROR,
+			     CAMEL_ERROR_GENERIC,
+			     _("No such folder: %s"), folder_name);
+		return NULL;
+	} else {
+		/* We don't actually care what it is; only that it exists */
+		g_free (fid);
+	}
+
+	folder_dir = g_build_filename (ews_store->storage_path, "folders", folder_name, NULL);
+	folder = camel_ews_folder_new (store, folder_name, folder_dir, cancellable, error);
+
+	g_free (folder_dir);
+
+	return folder;
+}
+
+static gchar *
+get_public_folder_full_name (EEwsFolder *folder,
+			     GHashTable *folders_by_id)
+{
+	const EwsFolderId *parent_fid;
+	GString *full_name;
+
+	g_return_val_if_fail (folder != NULL, NULL);
+	g_return_val_if_fail (folders_by_id != NULL, NULL);
+
+	full_name = g_string_new (e_ews_folder_get_name (folder));
+	while (folder) {
+		parent_fid = e_ews_folder_get_parent_id (folder);
+		if (!parent_fid || !parent_fid->id)
+			break;
+
+		folder = g_hash_table_lookup (folders_by_id, parent_fid->id);
+		if (folder) {
+			g_string_prepend (full_name, "/");
+			g_string_prepend (full_name, e_ews_folder_get_name (folder));
+		}
+	}
+
+	g_string_prepend (full_name, "/");
+	g_string_prepend (full_name, EWS_PUBLIC_FOLDER_ROOT_DISPLAY_NAME);
+
+	return g_string_free (full_name, FALSE);
+}
+
+static CamelFolderInfo *
+folder_info_from_store_summary (CamelEwsStore *store,
+                                const gchar *top,
+                                guint32 flags,
+				GCancellable *cancellable,
+                                GError **error)
+{
+	CamelEwsStoreSummary *ews_summary;
+	GPtrArray *folder_infos = NULL;
+	CamelFolderInfo *root_fi = NULL, *fi;
+
+	/* search in public folders */
+	if ((flags & CAMEL_STORE_FOLDER_INFO_SUBSCRIPTION_LIST) != 0) {
+		GHashTable *folders_by_id;
+		GSList *fiter;
+		GList *esources = NULL;
+		gchar *hosturl = NULL, *username = NULL;
+
+		g_mutex_lock (store->priv->get_finfo_lock);
+
+		if (!store->priv->public_folders) {
+			g_mutex_unlock (store->priv->get_finfo_lock);
+			return NULL;
+		}
+
+		folder_infos = g_ptr_array_new ();
+		folders_by_id = g_hash_table_new (g_str_hash, g_str_equal);
+
+		for (fiter = store->priv->public_folders; fiter != NULL; fiter = g_slist_next (fiter)) {
+			EEwsFolder *folder = fiter->data;
+			const EwsFolderId *fid;
+
+			if (!folder)
+				continue;
+
+			fid = e_ews_folder_get_id (folder);
+			if (!fid || !fid->id)
+				continue;
+
+			g_hash_table_insert (folders_by_id, fid->id, folder);
+		}
+
+		fi = camel_folder_info_new ();
+		fi->full_name = g_strdup (EWS_PUBLIC_FOLDER_ROOT_DISPLAY_NAME);
+		fi->name = g_strdup (fi->full_name);
+		fi->flags = CAMEL_FOLDER_SYSTEM | CAMEL_FOLDER_NOSELECT;
+		fi->unread = 0;
+		fi->total = 0;
+
+		g_ptr_array_add (folder_infos, fi);
+
+		for (fiter = store->priv->public_folders; fiter != NULL; fiter = g_slist_next (fiter)) {
+			EEwsFolder *folder = fiter->data;
+			const EwsFolderId *fid;
+
+			if (!folder)
+				continue;
+
+			fid = e_ews_folder_get_id (folder);
+			if (!fid || !fid->id)
+				continue;
+
+			fi = camel_folder_info_new ();
+			fi->full_name = get_public_folder_full_name (folder, folders_by_id);
+			fi->name = g_strdup (e_ews_folder_get_name (folder));
+			fi->flags = 0;
+			fi->unread = 0;
+			fi->total = 0;
+
+			switch (e_ews_folder_get_folder_type (folder)) {
+			case E_EWS_FOLDER_TYPE_CALENDAR:
+				fi->flags |= CAMEL_FOLDER_TYPE_EVENTS;
+				break;
+			case E_EWS_FOLDER_TYPE_CONTACTS:
+				fi->flags |= CAMEL_FOLDER_TYPE_CONTACTS;
+				break;
+			case E_EWS_FOLDER_TYPE_TASKS:
+				fi->flags |= CAMEL_FOLDER_TYPE_TASKS;
+				break;
+			case E_EWS_FOLDER_TYPE_MEMOS:
+				fi->flags |= CAMEL_FOLDER_TYPE_MEMOS;
+				break;
+			default:
+				break;
+			}
+
+			if (camel_ews_store_summary_has_folder (store->summary, fid->id)) {
+				guint64 fflags = camel_ews_store_summary_get_folder_flags (store->summary, fid->id, NULL);
+
+				if ((fflags & CAMEL_FOLDER_SUBSCRIBED) != 0)
+					fi->flags |= CAMEL_FOLDER_SUBSCRIBED;
+			}
+
+			if (!(fi->flags & CAMEL_FOLDER_SUBSCRIBED) &&
+			    e_ews_folder_get_folder_type (folder) != E_EWS_FOLDER_TYPE_MAILBOX) {
+				if (!hosturl && !username && !esources) {
+					CamelURL *url = camel_service_get_camel_url (CAMEL_SERVICE (store));
+
+					hosturl = g_strdup (camel_url_get_param (url, "hosturl"));
+					username = g_strdup (url->user);
+					esources = e_ews_folder_utils_get_esources (hosturl, username, cancellable, NULL);
+				}
+
+				if (e_ews_folder_utils_is_subscribed_as_esource (esources, hosturl, username, fid->id))
+					fi->flags |= CAMEL_FOLDER_SUBSCRIBED;
+			}
+
+			g_ptr_array_add (folder_infos, fi);
+		}
+
+		g_list_free_full (esources, g_object_unref);
+		g_hash_table_destroy (folders_by_id);
+		g_free (hosturl);
+		g_free (username);
+		g_mutex_unlock (store->priv->get_finfo_lock);
+
+	/* search in regular/subscribed folders */
+	} else {
+		GSList *folders, *fiter;
+
+		ews_summary = store->summary;
+		folders = camel_ews_store_summary_get_folders (ews_summary, top);
+		if (!folders)
+			return NULL;
+
+		folder_infos = g_ptr_array_new ();
+
+		for (fiter = folders; fiter != NULL; fiter = g_slist_next (fiter)) {
+			EEwsFolderType ftype;
+			const gchar *fid = fiter->data;
+
+			ftype = camel_ews_store_summary_get_folder_type (ews_summary, fid, NULL);
+			if (ftype != E_EWS_FOLDER_TYPE_MAILBOX)
+				continue;
+
+			if (camel_ews_store_summary_get_public (ews_summary, fid, NULL)) {
+				guint64 fflags;
+
+				fflags = camel_ews_store_summary_get_folder_flags (ews_summary, fid, NULL);
+				if (!(fflags & CAMEL_FOLDER_SUBSCRIBED))
+					continue;
+			}
+
+			fi = camel_ews_utils_build_folder_info (store, fid);
+			g_ptr_array_add (folder_infos, fi);
+		}
+
+		g_slist_free_full (folders, g_free);
+	}
+
+	root_fi = camel_folder_info_build (folder_infos, top, '/', TRUE);
+	g_ptr_array_free (folder_infos, TRUE);
+
+	return root_fi;
+}
+
+static void
+ews_folder_hierarchy_ready_cb (GObject *obj,
+                               GAsyncResult *res,
+                               gpointer user_data)
+{
+	GSList *folders_created = NULL, *folders_updated = NULL;
+	GSList *folders_deleted = NULL;
+	CamelEwsStore *ews_store = (CamelEwsStore *) user_data;
+	CamelEwsStorePrivate *priv = ews_store->priv;
+	EEwsConnection *cnc = (EEwsConnection *) obj;
+	gchar *sync_state = NULL;
+	gboolean includes_last_folder;
+	GError *error = NULL;
+
+	e_ews_connection_sync_folder_hierarchy_finish (
+		cnc, res, &sync_state, &includes_last_folder,
+		&folders_created, &folders_updated,
+		&folders_deleted, &error);
+
+	if (error != NULL) {
+		g_warning ("Unable to fetch the folder hierarchy: %s :%d \n", error->message, error->code);
+
+		camel_ews_store_maybe_disconnect (ews_store, error);
+
+		g_mutex_lock (priv->get_finfo_lock);
+		ews_store->priv->last_refresh_time -= FINFO_REFRESH_INTERVAL;
+		g_mutex_unlock (priv->get_finfo_lock);
+		goto exit;
+	}
+	g_mutex_lock (priv->get_finfo_lock);
+	ews_update_folder_hierarchy (
+		ews_store, sync_state, includes_last_folder,
+		folders_created, folders_deleted, folders_updated, NULL);
+
+	ews_store->priv->last_refresh_time = time (NULL);
+	g_mutex_unlock (priv->get_finfo_lock);
+
+exit:
+	g_object_unref (ews_store);
+	g_clear_error (&error);
+}
+
+static gboolean
+ews_refresh_finfo (CamelEwsStore *ews_store)
+{
+	EEwsConnection *connection;
+	gchar *sync_state;
+
+	if (!camel_offline_store_get_online (CAMEL_OFFLINE_STORE (ews_store)))
+		return FALSE;
+
+	if (!EVO3_sync (camel_service_connect) ((CamelService *) ews_store, EVO3(NULL,) NULL))
+		return FALSE;
+
+	sync_state = camel_ews_store_summary_get_string_val (ews_store->summary, "sync_state", NULL);
+
+	connection = camel_ews_store_ref_connection (ews_store);
+
+	e_ews_connection_sync_folder_hierarchy (
+		connection, EWS_PRIORITY_MEDIUM,
+		sync_state, NULL, ews_folder_hierarchy_ready_cb,
+		g_object_ref (ews_store));
+
+	g_object_unref (connection);
+
+	g_free (sync_state);
+
+	return TRUE;
+}
+
+static CamelFolderInfo *
+ews_get_folder_info_sync (CamelStore *store,
+                          const gchar *top,
+                          guint32 flags,
+                          EVO3(GCancellable *cancellable,)
+                          GError **error)
+{
+	EVO2(GCancellable *cancellable = NULL;)
+	CamelEwsStore *ews_store;
+	CamelEwsStorePrivate *priv;
+	CamelFolderInfo *fi = NULL;
+	EEwsConnection *connection;
+	gchar *old_sync_state, *new_sync_state = NULL;
+	gboolean initial_setup = FALSE;
+	GSList *folders_created = NULL, *folders_updated = NULL;
+	GSList *folders_deleted = NULL;
+	gboolean includes_last_folder;
+	gboolean success;
+	GError *local_error = NULL;
+
+	ews_store = (CamelEwsStore *) store;
+	priv = ews_store->priv;
+
+	if ((flags & CAMEL_STORE_FOLDER_INFO_SUBSCRIPTION_LIST) != 0) {
+		gboolean includes_last_folder = TRUE;
+		GSList *folders = NULL, *to_check = NULL;
+		EwsFolderId *folder_id;
+
+		if (!camel_offline_store_get_online (CAMEL_OFFLINE_STORE (ews_store))) {
+			g_set_error_literal (
+				error, CAMEL_SERVICE_ERROR, CAMEL_SERVICE_ERROR_UNAVAILABLE,
+				_("Cannot list EWS public folders in offline mode"));
+			return NULL;
+		}
+
+		g_mutex_lock (priv->get_finfo_lock);
+
+		g_slist_free_full (priv->public_folders, g_object_unref);
+		priv->public_folders = NULL;
+
+		connection = camel_ews_store_ref_connection (ews_store);
+		folder_id = e_ews_folder_id_new ("publicfoldersroot", NULL, TRUE);
+		to_check = g_slist_append (to_check, folder_id);
+
+		while (!local_error && !g_cancellable_is_cancelled (cancellable) && to_check) {
+			folder_id = to_check->data;
+			to_check = g_slist_remove (to_check, folder_id);
+
+			while (e_ews_connection_find_folder_sync (connection, EWS_PRIORITY_MEDIUM, folder_id, &includes_last_folder, &folders,
+				cancellable, &local_error) && !local_error &&
+				!g_cancellable_is_cancelled (cancellable)) {
+				GSList *fiter;
+
+				if (!folders)
+					break;
+
+				for (fiter = folders; fiter != NULL; fiter = fiter->next) {
+					EEwsFolder *folder = fiter->data;
+
+					if (e_ews_folder_get_child_count (folder) > 0) {
+						const EwsFolderId *fid = e_ews_folder_get_id (folder);
+
+						if (fid)
+							to_check = g_slist_prepend (to_check,
+								e_ews_folder_id_new (fid->id, fid->change_key, fid->is_distinguished_id));
+					}
+
+					if (!e_ews_folder_get_parent_id (folder)) {
+						if (!folder_id->is_distinguished_id) {
+							e_ews_folder_set_parent_id (folder,
+								e_ews_folder_id_new (folder_id->id, folder_id->change_key, folder_id->is_distinguished_id));
+						} else {
+							e_ews_folder_set_parent_id (folder, e_ews_folder_id_new (EWS_PUBLIC_FOLDER_ROOT_ID, NULL, FALSE));
+						}
+					}
+				}
+
+				priv->public_folders = g_slist_concat (priv->public_folders, folders);
+				folders = NULL;
+
+				if (includes_last_folder)
+					break;
+			}
+
+			e_ews_folder_id_free (folder_id);
+		}
+
+		g_mutex_unlock (priv->get_finfo_lock);
+
+		g_object_unref (connection);
+		g_slist_free_full (to_check, (GDestroyNotify) e_ews_folder_id_free);
+
+		camel_ews_store_ensure_virtual_folders (ews_store);
+
+		if (local_error) {
+			camel_ews_store_maybe_disconnect (ews_store, local_error);
+			g_propagate_error (error, local_error);
+
+			return NULL;
+		}
+
+		if (!priv->public_folders) {
+			g_set_error_literal (
+				error, CAMEL_SERVICE_ERROR, CAMEL_SERVICE_ERROR_UNAVAILABLE,
+				_("Cannot find any EWS public folders"));
+			return NULL;
+		}
+
+		goto offline;
+	}
+
+	g_mutex_lock (priv->get_finfo_lock);
+	if (!(camel_offline_store_get_online (CAMEL_OFFLINE_STORE (store))
+	      && EVO3_sync(camel_service_connect) ((CamelService *) store, EVO3(cancellable,) error))) {
+		camel_ews_store_ensure_virtual_folders (ews_store);
+		g_mutex_unlock (priv->get_finfo_lock);
+		goto offline;
+	}
+
+	old_sync_state = camel_ews_store_summary_get_string_val (ews_store->summary, "sync_state", NULL);
+	if (!old_sync_state)
+		initial_setup = TRUE;
+
+	if (!initial_setup && (flags & CAMEL_STORE_FOLDER_INFO_SUBSCRIBED) != 0) {
 		time_t now = time (NULL);
-		
-		g_free (sync_state);
+
+		g_free (old_sync_state);
 		if (now - priv->last_refresh_time > FINFO_REFRESH_INTERVAL && ews_refresh_finfo (ews_store))
 			ews_store->priv->last_refresh_time = time (NULL);
 
@@ -521,67 +1648,141 @@ ews_get_folder_info_sync (CamelStore *st
 		goto offline;
 	}
 
-	if (!e_ews_connection_sync_folder_hierarchy (ews_store->priv->cnc, EWS_PRIORITY_MEDIUM,
-						    &sync_state, &includes_last_folder,
-						    &folders_created, &folders_updated,
-						    &folders_deleted, cancellable, error)) {
-		if (error)
-			g_warning ("Unable to fetch the folder hierarchy: %s :%d \n",
-				   (*error)->message, (*error)->code);
+	connection = camel_ews_store_ref_connection (ews_store);
+
+	success = e_ews_connection_sync_folder_hierarchy_sync (connection, EWS_PRIORITY_MEDIUM, old_sync_state,
+		&new_sync_state, &includes_last_folder, &folders_created, &folders_updated, &folders_deleted,
+		cancellable, &local_error);
+
+	g_free (old_sync_state);
+	old_sync_state = NULL;
+
+	if (!initial_setup && g_error_matches (local_error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_INVALIDSYNCSTATEDATA)) {
+		g_clear_error (&local_error);
+		ews_store_forget_all_folders (ews_store);
+		camel_ews_store_summary_store_string_val (ews_store->summary, "sync_state", "");
+		camel_ews_store_summary_clear (ews_store->summary);
+
+		initial_setup = TRUE;
+
+		success = e_ews_connection_sync_folder_hierarchy_sync (connection, EWS_PRIORITY_MEDIUM, NULL,
+			&new_sync_state, &includes_last_folder, &folders_created, &folders_updated, &folders_deleted,
+			cancellable, &local_error);
+	}
+
+	g_object_unref (connection);
+
+	if (!success) {
+		if (local_error)
+			g_warning (
+				"Unable to fetch the folder hierarchy: %s :%d \n",
+				local_error->message, local_error->code);
 		else
 			g_warning ("Unable to fetch the folder hierarchy.\n");
 
+		camel_ews_store_maybe_disconnect (ews_store, local_error);
+		g_propagate_error (error, local_error);
+
 		g_mutex_unlock (priv->get_finfo_lock);
 		return NULL;
 	}
-	ews_update_folder_hierarchy (ews_store, sync_state, includes_last_folder,
-				     folders_created, folders_deleted, folders_updated);
+	ews_update_folder_hierarchy (
+		ews_store, new_sync_state, includes_last_folder,
+		folders_created, folders_deleted, folders_updated, NULL);
 	g_mutex_unlock (priv->get_finfo_lock);
 
 offline:
-	fi = folder_info_from_store_summary ( (CamelEwsStore *) store, top, flags, error);
+	fi = folder_info_from_store_summary (ews_store, top, flags, cancellable, error);
 	return fi;
 }
 
-static CamelFolderInfo*
+static CamelFolderInfo *
 ews_create_folder_sync (CamelStore *store,
-		const gchar *parent_name,
-		const gchar *folder_name,
-		EVO3(GCancellable *cancellable,)
-		GError **error)
+                        const gchar *parent_name,
+                        const gchar *folder_name,
+                        EVO3(GCancellable *cancellable,)
+                        GError **error)
 {
+	EVO2(GCancellable *cancellable = NULL;)
 	CamelEwsStore *ews_store = CAMEL_EWS_STORE (store);
 	CamelEwsStoreSummary *ews_summary = ews_store->summary;
 	gchar *fid = NULL;
 	gchar *full_name;
 	EwsFolderId *folder_id;
-	EVO2(GCancellable *cancellable = NULL;)
+	EEwsConnection *connection;
 	CamelFolderInfo *fi = NULL;
+	gboolean success;
+	GError *local_error = NULL;
+
+	if (parent_name && *parent_name)
+		full_name = g_strdup_printf ("%s/%s", parent_name, folder_name);
+	else
+		full_name = g_strdup (folder_name);
+
+	fid = camel_ews_store_summary_get_folder_id_from_name (ews_summary, full_name);
+	if (fid) {
+		g_free (fid);
+		g_set_error (
+			error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
+			_("Cannot create folder '%s', folder already exists"),
+			full_name);
+		g_free (full_name);
+		return NULL;
+	}
+
+	g_free (full_name);
 
-	
 	/* Get Parent folder ID */
 	if (parent_name && parent_name[0]) {
-		fid = camel_ews_store_summary_get_folder_id_from_name (ews_summary,
-								       parent_name);
+		fid = camel_ews_store_summary_get_folder_id_from_name (
+			ews_summary, parent_name);
 		if (!fid) {
-			g_set_error (error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
-				     _("Parent folder %s does not exist"), parent_name);
+			g_set_error (
+				error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
+				_("Parent folder %s does not exist"),
+				parent_name);
+			return NULL;
+		}
+
+		if (g_str_equal (fid, EWS_FOREIGN_FOLDER_ROOT_ID)) {
+			g_free (fid);
+
+			g_set_error (
+				error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
+				_("Cannot create folder under '%s', it is used for folders of other users only"),
+				parent_name);
+			return NULL;
+		}
+
+		if (g_str_equal (fid, EWS_PUBLIC_FOLDER_ROOT_ID)) {
+			g_free (fid);
+
+			g_set_error (
+				error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
+				_("Cannot create folder under '%s', it is used for public folders only"),
+				parent_name);
 			return NULL;
 		}
 	}
 
-	if (!ews_store->priv->cnc) {
-		g_set_error (error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
-			     _("Cant perform actions on the folder while in offline mode"));
+	if (!camel_ews_store_connected (ews_store, cancellable, error)) {
 		if (fid) g_free (fid);
 		return NULL;
 	}
 
-	/* Make the call */
-	if (!e_ews_connection_create_folder (ews_store->priv->cnc,
-					     EWS_PRIORITY_MEDIUM, fid,
-					     FALSE, folder_name, &folder_id,
-					     cancellable, error)) {
+	connection = camel_ews_store_ref_connection (ews_store);
+
+	success = e_ews_connection_create_folder_sync (
+		connection,
+		EWS_PRIORITY_MEDIUM, fid,
+		FALSE, folder_name, E_EWS_FOLDER_TYPE_MAILBOX,
+		&folder_id, cancellable, &local_error);
+
+	g_object_unref (connection);
+
+	if (!success) {
+		camel_ews_store_maybe_disconnect (ews_store, local_error);
+		g_propagate_error (error, local_error);
 		g_free (fid);
 		return NULL;
 	}
@@ -592,52 +1793,93 @@ ews_create_folder_sync (CamelStore *stor
 	else
 		full_name = g_strdup (folder_name);
 
-	camel_ews_store_summary_new_folder (ews_summary, folder_id->id,
-					    fid, folder_id->change_key,
-					    folder_name,
-					    EWS_FOLDER_TYPE_MAILBOX,
-					    0, 0);
+	camel_ews_store_summary_new_folder (
+		ews_summary, folder_id->id,
+		fid, folder_id->change_key,
+		folder_name,
+		E_EWS_FOLDER_TYPE_MAILBOX,
+		0, 0, FALSE, FALSE);
 	fi = camel_ews_utils_build_folder_info (ews_store, folder_id->id);
-	e_ews_folder_free_fid (folder_id);
+	e_ews_folder_id_free (folder_id);
 
 	camel_store_folder_created (store, fi);
+	camel_subscribable_folder_subscribed (CAMEL_SUBSCRIBABLE (ews_store), fi);
 
 	g_free (full_name);
 	g_free (fid);
 	return fi;
 }
 
-static gboolean
-ews_delete_folder_sync	(CamelStore *store,
-			 const gchar *folder_name,
-			 EVO3(GCancellable *cancellable,)
-			 GError **error)
-{
-	CamelEwsStore *ews_store = CAMEL_EWS_STORE (store);
-	CamelEwsStoreSummary *ews_summary = ews_store->summary;
-	gchar *fid;
-	EVO2(GCancellable *cancellable = NULL;)
-	CamelFolderInfo *fi = NULL;
+static gboolean
+ews_delete_folder_sync (CamelStore *store,
+                        const gchar *folder_name,
+                        EVO3(GCancellable *cancellable,)
+                        GError **error)
+{
+	EVO2(GCancellable *cancellable = NULL;)
+	CamelEwsStore *ews_store = CAMEL_EWS_STORE (store);
+	CamelEwsStoreSummary *ews_summary = ews_store->summary;
+	gchar *fid;
+	CamelFolderInfo *fi = NULL;
+	gboolean success;
+	GError *local_error = NULL;
+
+	fid = camel_ews_store_summary_get_folder_id_from_name (
+		ews_summary, folder_name);
+	if (!fid) {
+		g_set_error (
+			error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
+			_("Folder does not exist"));
+		return FALSE;
+	}
+
+	if (g_str_equal (fid, EWS_FOREIGN_FOLDER_ROOT_ID)) {
+		g_free (fid);
+
+		g_set_error (
+			error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
+			_("Cannot remove folder '%s', it is used for folders of other users only"),
+			folder_name);
+		return FALSE;
+	}
+
+	if (g_str_equal (fid, EWS_PUBLIC_FOLDER_ROOT_ID)) {
+		g_free (fid);
 
-	fid = camel_ews_store_summary_get_folder_id_from_name (ews_summary,
-							       folder_name);
-	if (!fid) {
-		g_set_error (error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
-			     _("Folder does not exist"));
+		g_set_error (
+			error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
+			_("Cannot remove folder '%s', it is used for public folders only"),
+			folder_name);
 		return FALSE;
 	}
 
-	if (!ews_store->priv->cnc) {
-		g_set_error (error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
-			     _("Cant perform actions on the folder while in offline mode"));
+	if (!camel_ews_store_connected (ews_store, cancellable, error)) {
 		g_free (fid);
 		return FALSE;
 	}
 
-	if (!e_ews_connection_delete_folder (ews_store->priv->cnc,
-					     EWS_PRIORITY_MEDIUM,
-					     fid, FALSE, "HardDelete",
-					     cancellable, error)) {
+	if (camel_ews_store_summary_get_foreign (ews_store->summary, fid, NULL) ||
+	    camel_ews_store_summary_get_public (ews_store->summary, fid, NULL)) {
+		/* do not delete foreign or public folders,
+		 * only remove them from local store */
+		success = TRUE;
+	} else {
+		EEwsConnection *connection;
+
+		connection = camel_ews_store_ref_connection (ews_store);
+
+		success = e_ews_connection_delete_folder_sync (
+			connection,
+			EWS_PRIORITY_MEDIUM,
+			fid, FALSE, "HardDelete",
+			cancellable, &local_error);
+
+		g_object_unref (connection);
+	}
+
+	if (!success) {
+		camel_ews_store_maybe_disconnect (ews_store, local_error);
+		g_propagate_error (error, local_error);
 		g_free (fid);
 		return FALSE;
 	}
@@ -645,11 +1887,15 @@ ews_delete_folder_sync	(CamelStore *stor
 	fi = camel_ews_utils_build_folder_info (ews_store, fid);
 	camel_ews_store_summary_remove_folder (ews_summary, fid, error);
 
+	camel_subscribable_folder_unsubscribed (CAMEL_SUBSCRIBABLE (ews_store), fi);
 	camel_store_folder_deleted (store, fi);
 	camel_folder_info_free (fi);
 
 	g_free (fid);
 
+	camel_ews_store_ensure_virtual_folders (ews_store);
+	camel_ews_store_summary_save (ews_store->summary, NULL);
+
 	return TRUE;
 }
 
@@ -659,15 +1905,19 @@ struct _rename_cb_data {
 	const gchar *folder_id;
 };
 
-static void rename_folder_cb (ESoapMessage *msg, gpointer user_data)
+static void
+rename_folder_cb (ESoapMessage *msg,
+                  gpointer user_data)
 {
 	struct _rename_cb_data *rename_data = user_data;
 
-	e_ews_message_start_item_change (msg, E_EWS_ITEMCHANGE_TYPE_FOLDER,
-					 rename_data->folder_id, rename_data->change_key, 0);
+	e_ews_message_start_item_change (
+		msg, E_EWS_ITEMCHANGE_TYPE_FOLDER,
+		rename_data->folder_id, rename_data->change_key, 0);
 	e_soap_message_start_element (msg, "SetFolderField", NULL, NULL);
-	e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL,
-							      "FieldURI", "folder:DisplayName");
+	e_ews_message_write_string_parameter_with_attribute (
+		msg, "FieldURI", NULL, NULL,
+		"FieldURI", "folder:DisplayName");
 
 	e_soap_message_start_element (msg, "Folder", NULL, NULL);
 	e_ews_message_write_string_parameter (msg, "DisplayName", NULL, rename_data->display_name);
@@ -679,46 +1929,50 @@ static void rename_folder_cb (ESoapMessa
 }
 
 static gboolean
-ews_rename_folder_sync	(CamelStore *store,
-			const gchar *old_name,
-			const gchar *new_name,
-			EVO3(GCancellable *cancellable,)
-			GError **error)
+ews_rename_folder_sync (CamelStore *store,
+                        const gchar *old_name,
+                        const gchar *new_name,
+                        EVO3(GCancellable *cancellable,)
+                        GError **error)
 {
+	EVO2(GCancellable *cancellable = NULL;)
 	CamelEwsStore *ews_store = CAMEL_EWS_STORE (store);
 	CamelEwsStoreSummary *ews_summary = ews_store->summary;
+	EEwsConnection *connection;
 	const gchar *old_slash, *new_slash;
-	EVO2(GCancellable *cancellable = NULL;)
 	gchar *fid;
 	gchar *changekey;
 	gboolean res = FALSE;
+	GError *local_error = NULL;
 
 	if (!strcmp (old_name, new_name))
 		return TRUE;
 
-	if (!ews_store->priv->cnc) {
-		g_set_error (error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
-			     _("Cant perform actions on the folder while in offline mode"));
+	if (!camel_ews_store_connected (ews_store, cancellable, error)) {
 		return FALSE;
 	}
 
 	fid = camel_ews_store_summary_get_folder_id_from_name (ews_summary, old_name);
 	if (!fid) {
-		g_set_error (error, CAMEL_STORE_ERROR,
-			     CAMEL_STORE_ERROR_NO_FOLDER,
-			     _("Folder %s does not exist"), old_name);
+		g_set_error (
+			error, CAMEL_STORE_ERROR,
+			CAMEL_STORE_ERROR_NO_FOLDER,
+			_("Folder %s does not exist"), old_name);
 		return FALSE;
 	}
 
 	changekey = camel_ews_store_summary_get_change_key (ews_summary, fid, error);
 	if (!changekey) {
 		g_free (fid);
-		g_set_error (error, CAMEL_STORE_ERROR,
-			     CAMEL_STORE_ERROR_NO_FOLDER,
-			     _("No change key record for folder %s"), fid);
+		g_set_error (
+			error, CAMEL_STORE_ERROR,
+			CAMEL_STORE_ERROR_NO_FOLDER,
+			_("No change key record for folder %s"), fid);
 		return FALSE;
 	}
 
+	connection = camel_ews_store_ref_connection (ews_store);
+
 	old_slash = g_strrstr (old_name, "/");
 	new_slash = g_strrstr (new_name, "/");
 
@@ -733,28 +1987,29 @@ ews_rename_folder_sync	(CamelStore *stor
 		new_slash = new_name;
 
 	if (strcmp (old_slash, new_slash)) {
-		int parent_len = old_slash - old_name;
+		gint parent_len = old_slash - old_name;
 		struct _rename_cb_data *rename_data;
 
 		/* Folder basename changed (i.e. UpdateFolder needed).
-		   Therefore, we can only do it if the folder hasn't also
-		   been moved from one parent folder to another.
-
-		   Strictly speaking, we could probably handle this, even
-		   if there are name collisions. We could UpdateFolder to
-		   a new temporary name that doesn't exist in either the
-		   old or new parent folders, then MoveFolder, then issue
-		   another UpdateFolder to the name we actually wanted.
-		   But since the Evolution UI doesn't seem to let us
-		   make both changes at the same time anyway, we'll just
-		   bail out for now; we can deal with it later if we need
-		   to.
+		 * Therefore, we can only do it if the folder hasn't also
+		 * been moved from one parent folder to another.
+ *
+		 * Strictly speaking, we could probably handle this, even
+		 * if there are name collisions. We could UpdateFolder to
+		 * a new temporary name that doesn't exist in either the
+		 * old or new parent folders, then MoveFolder, then issue
+		 * another UpdateFolder to the name we actually wanted.
+		 * But since the Evolution UI doesn't seem to let us
+		 * make both changes at the same time anyway, we'll just
+		 * bail out for now; we can deal with it later if we need
+		 * to.
 		*/
 		if (new_slash - new_name != parent_len ||
 		    strncmp (old_name, new_name, parent_len)) {
-			g_set_error (error, CAMEL_STORE_ERROR,
-				     CAMEL_STORE_ERROR_INVALID,
-				     _("Cannot both rename and move a folder at the same time"));
+			g_set_error (
+				error, CAMEL_STORE_ERROR,
+				CAMEL_STORE_ERROR_INVALID,
+				_("Cannot both rename and move a folder at the same time"));
 			g_free (changekey);
 			goto out;
 		}
@@ -764,8 +2019,12 @@ ews_rename_folder_sync	(CamelStore *stor
 		rename_data->folder_id = fid;
 		rename_data->change_key = changekey;
 
-		if (!e_ews_connection_update_folder (ews_store->priv->cnc, EWS_PRIORITY_MEDIUM,
-						     rename_folder_cb, rename_data, cancellable, error)) {
+		res = e_ews_connection_update_folder_sync (
+			connection, EWS_PRIORITY_MEDIUM,
+			rename_folder_cb, rename_data,
+			cancellable, &local_error);
+
+		if (!res) {
 			g_free (rename_data);
 			goto out;
 		}
@@ -776,22 +2035,27 @@ ews_rename_folder_sync	(CamelStore *stor
 		gchar *parent_name;
 
 		/* If we are not moving to the root folder, work out the ItemId of
-		   the new parent folder */
+		 * the new parent folder */
 		if (new_slash != new_name) {
 			parent_name = g_strndup (new_name, new_slash - new_name - 1);
-			pfid = camel_ews_store_summary_get_folder_id_from_name (ews_summary,
-										parent_name);
+			pfid = camel_ews_store_summary_get_folder_id_from_name (
+				ews_summary, parent_name);
 			g_free (parent_name);
 			if (!pfid) {
-				g_set_error (error, CAMEL_STORE_ERROR,
-					     CAMEL_STORE_ERROR_NO_FOLDER,
-					     _("Cannot find folder ID for parent folder %s"),
-					     parent_name);
+				g_set_error (
+					error, CAMEL_STORE_ERROR,
+					CAMEL_STORE_ERROR_NO_FOLDER,
+					_("Cannot find folder ID for parent folder %s"),
+					parent_name);
 				goto out;
 			}
 		}
-		if (!e_ews_connection_move_folder (ews_store->priv->cnc, EWS_PRIORITY_MEDIUM,
-						   pfid, fid, cancellable, error)) {
+
+		res = e_ews_connection_move_folder_sync (
+			connection, EWS_PRIORITY_MEDIUM,
+			pfid, fid, cancellable, &local_error);
+
+		if (!res) {
 			g_free (pfid);
 			goto out;
 		}
@@ -801,6 +2065,13 @@ ews_rename_folder_sync	(CamelStore *stor
 
 	res = TRUE;
  out:
+	if (local_error) {
+		camel_ews_store_maybe_disconnect (ews_store, local_error);
+		g_propagate_error (error, local_error);
+	}
+
+	g_object_unref (connection);
+
 	g_free (changekey);
 	g_free (fid);
 	return res;
@@ -821,18 +2092,116 @@ ews_get_name (CamelService *service, gbo
 }
 
 EEwsConnection *
-camel_ews_store_get_connection (CamelEwsStore *ews_store)
+camel_ews_store_ref_connection (CamelEwsStore *ews_store)
 {
-	return g_object_ref (ews_store->priv->cnc);
+	EEwsConnection *connection = NULL;
+
+	g_return_val_if_fail (CAMEL_IS_EWS_STORE (ews_store), NULL);
+
+	g_mutex_lock (ews_store->priv->connection_lock);
+
+	if (ews_store->priv->connection != NULL)
+		connection = g_object_ref (ews_store->priv->connection);
+
+	g_mutex_unlock (ews_store->priv->connection_lock);
+
+	return connection;
 }
 
-#if EDS_CHECK_VERSION (2,33,0)
 static CamelFolder *
-ews_get_trash_folder_sync (CamelStore *store, EVO3(GCancellable *cancellable,) GError **error)
+ews_get_trash_folder_sync (CamelStore *store,
+                           EVO3(GCancellable *cancellable,)
+                           GError **error)
 {
-	return NULL;
+	CamelEwsStore *ews_store;
+	CamelFolder *folder = NULL;
+	gchar *folder_id, *folder_name;
+
+	g_return_val_if_fail (CAMEL_IS_EWS_STORE (store), NULL);
+
+	ews_store = CAMEL_EWS_STORE (store);
+	folder_id = camel_ews_store_summary_get_folder_id_from_folder_type (
+		ews_store->summary, CAMEL_FOLDER_TYPE_TRASH);
+
+	if (folder_id == NULL) {
+		g_set_error (
+			error, CAMEL_STORE_ERROR,
+			CAMEL_STORE_ERROR_NO_FOLDER,
+			_("Could not locate Trash folder"));
+		return NULL;
+	}
+
+	folder_name = camel_ews_store_summary_get_folder_full_name (
+		ews_store->summary, folder_id, NULL);
+
+	folder = EVO3_sync (camel_store_get_folder) (
+		store, folder_name, 0, EVO3 (cancellable,) error);
+
+	g_free (folder_name);
+	g_free (folder_id);
+
+	if (folder) {
+		GPtrArray *folders;
+		gboolean can = TRUE;
+		gint ii;
+
+		/* Save content of all opened folders, thus any messages deleted in them
+		   are moved to the Deleted Items folder first, thus in case of the trash
+		   folder instance being used to expunge messages will contain all of them.
+		*/
+		folders = camel_object_bag_list (store->folders);
+		for (ii = 0; ii < folders->len; ii++) {
+			CamelFolder *secfolder = folders->pdata[ii];
+
+			if (secfolder != folder && can)
+			    can = camel_folder_sync (secfolder, FALSE, NULL);
+
+			g_object_unref (secfolder);
+		}
+		g_ptr_array_free (folders, TRUE);
+
+		/* To return 'Deleted Items' folder with current content,
+		   not with possibly stale locally cached copy. */
+		camel_folder_refresh_info (folder, NULL);
+	}
+
+	return folder;
+}
+
+static CamelFolder *
+ews_get_junk_folder_sync (CamelStore *store,
+                          EVO3(GCancellable *cancellable,)
+                          GError **error)
+{
+	CamelEwsStore *ews_store;
+	CamelFolder *folder = NULL;
+	gchar *folder_id, *folder_name;
+
+	g_return_val_if_fail (CAMEL_IS_EWS_STORE (store), NULL);
+
+	ews_store = CAMEL_EWS_STORE (store);
+	folder_id = camel_ews_store_summary_get_folder_id_from_folder_type (
+		ews_store->summary, CAMEL_FOLDER_TYPE_JUNK);
+
+	if (folder_id == NULL) {
+		g_set_error (
+			error, CAMEL_STORE_ERROR,
+			CAMEL_STORE_ERROR_NO_FOLDER,
+			_("Could not locate Junk folder"));
+		return NULL;
+	}
+
+	folder_name = camel_ews_store_summary_get_folder_full_name (
+		ews_store->summary, folder_id, NULL);
+
+	folder = EVO3_sync (camel_store_get_folder) (
+		store, folder_name, 0, EVO3(cancellable,) error);
+
+	g_free (folder_name);
+	g_free (folder_id);
+
+	return folder;
 }
-#endif
 
 static gboolean
 ews_can_refresh_folder (CamelStore *store, CamelFolderInfo *info, GError **error)
@@ -841,12 +2210,420 @@ ews_can_refresh_folder (CamelStore *stor
 	if (info && (info->flags & CAMEL_FOLDER_NOSELECT) != 0) return FALSE;
 
 	/* Delegate decision to parent class */
-	return CAMEL_STORE_CLASS(camel_ews_store_parent_class)->can_refresh_folder (store, info, error) ||
-			(camel_url_get_param (camel_service_get_camel_url ((CamelService *)store), "check_all") != NULL);
+	return (camel_url_get_param (camel_service_get_camel_url ((CamelService *)store), "check_all") != NULL) ||
+		CAMEL_STORE_CLASS(camel_ews_store_parent_class)->can_refresh_folder (store, info, error);
+}
+
+static gboolean
+ews_store_folder_is_subscribed (CamelStore *store,
+                                const gchar *folder_name)
+{
+	CamelEwsStore *ews_store = CAMEL_EWS_STORE (store);
+	gchar *fid;
+	gboolean truth = FALSE;
+	GError *error = NULL;
+
+	fid = camel_ews_store_summary_get_folder_id_from_name (ews_store->summary, folder_name);
+	if (!fid)
+		return FALSE;
+
+	if (camel_ews_store_summary_get_foreign (ews_store->summary, fid, &error) && !error) {
+		truth = TRUE;
+	}
+	g_clear_error (&error);
+
+	if (!truth && camel_ews_store_summary_get_public (ews_store->summary, fid, &error) && !error) {
+		truth = TRUE;
+	}
+	g_clear_error (&error);
+
+	g_free (fid);
+
+	return truth;
+}
+
+/* caller should hold ews_store->priv->get_finfo_lock already */
+static EEwsFolder *
+ews_store_find_public_folder (CamelEwsStore *ews_store,
+			      const gchar *folder_name)
+{
+	EEwsFolder *folder = NULL;
+	GSList *piter;
+	gchar **folders;
+	gint ii;
+
+	g_return_val_if_fail (CAMEL_IS_EWS_STORE (ews_store), NULL);
+	g_return_val_if_fail (folder_name != NULL, NULL);
+
+	folders = g_strsplit (folder_name, "/", -1);
+	if (!folders || !folders[0] || g_strcmp0 (folders[0], EWS_PUBLIC_FOLDER_ROOT_DISPLAY_NAME) != 0) {
+		g_strfreev (folders);
+		return NULL;
+	}
+
+	/* they are stored in public_folders from top level to bottom level */
+	piter = ews_store->priv->public_folders;
+	for (ii = 1; folders[ii] && piter; ii++) {
+		const gchar *fname = folders[ii];
+
+		while (piter) {
+			EEwsFolder *subf = piter->data;
+			const EwsFolderId *parent_id;
+
+			if (!subf) {
+				piter = NULL;
+				break;
+			}
+
+			if (g_strcmp0 (e_ews_folder_get_name (subf), fname) == 0) {
+				parent_id = e_ews_folder_get_parent_id (subf);
+				if (!folder && (!parent_id || g_strcmp0 (parent_id->id, EWS_PUBLIC_FOLDER_ROOT_ID) == 0)) {
+					folder = subf;
+					break;
+				} else if (parent_id && folder) {
+					const EwsFolderId *fid = e_ews_folder_get_id (folder);
+
+					if (fid && g_strcmp0 (fid->id, parent_id->id) == 0) {
+						folder = subf;
+						break;
+					}
+				}
+			}
+
+			piter = piter->next;
+		}
+	}
+
+	if (!piter || folders[ii])
+		folder = NULL;
+
+	g_strfreev (folders);
+
+	return folder;
+}
+
+/* ppath contains proposed path, this only makes sure that it's a unique path */
+static void
+ews_store_ensure_unique_path (CamelEwsStore *ews_store,
+			      gchar **ppath)
+{
+	gboolean done;
+	guint counter = 0;
+	gchar *base_path = NULL;
+
+	g_return_if_fail (ews_store != NULL);
+	g_return_if_fail (ews_store->summary != NULL);
+	g_return_if_fail (ppath != NULL);
+	g_return_if_fail (*ppath != NULL);
+
+	done = FALSE;
+	while (!done) {
+		gchar *fid;
+
+		done = TRUE;
+
+		fid = camel_ews_store_summary_get_folder_id_from_name (ews_store->summary, *ppath);
+		if (fid) {
+			g_free (fid);
+
+			done = FALSE;
+			counter++;
+			if (!counter) {
+				g_debug ("%s: Counter overflow", G_STRFUNC);
+				break;
+			}
+
+			if (!base_path)
+				base_path = *ppath;
+			else
+				g_free (*ppath);
+
+			*ppath = g_strdup_printf ("%s_%u", base_path, counter);
+		}
+	}
+
+	g_free (base_path);
+}
+
+static gchar *
+find_account_name (CamelEwsStore *ews_store)
+{
+	CamelService *service = (CamelService *) ews_store;
+	GConfClient *gconf_client;
+	EAccountList *account_list;
+	EAccount *account;
+	EIterator *it;
+	gchar *account_name = NULL;
+
+	g_return_val_if_fail (CAMEL_IS_EWS_STORE (ews_store), NULL);
+	g_return_val_if_fail (service->url != NULL, NULL);
+	g_return_val_if_fail (service->provider != NULL, NULL);
+
+	gconf_client = gconf_client_get_default ();
+	account_list = e_account_list_new (gconf_client);
+	g_object_unref (gconf_client);
+	g_return_val_if_fail (account_list != NULL, NULL);
+
+	for (it = e_list_get_iterator ((EList *) account_list); e_iterator_is_valid (it); e_iterator_next (it)) {
+		CamelURL *url;
+
+		account = (EAccount *) e_iterator_get (it);
+
+		if (!account || !account->enabled)
+			continue;
+
+		if (!account->source->url || g_ascii_strncasecmp (account->source->url, "ews://", 6) != 0)
+			continue;
+
+		url = camel_url_new (account->source->url, NULL);
+		if (!url)
+			continue;
+
+		if (service->provider->url_equal (url, service->url)) {
+			account_name = g_strdup (e_account_get_string (account, E_ACCOUNT_NAME));
+			camel_url_free (url);
+			break;
+		}
+
+		camel_url_free (url);
+	}
+
+	g_object_unref (account_list);
+
+	return account_name;
+}
+
+static gboolean
+ews_store_subscribe_folder_sync (CamelStore *store,
+                                 const gchar *folder_name,
+                                 EVO3(GCancellable *cancellable,)
+                                 GError **error)
+{
+	EVO2(GCancellable *cancellable = NULL;)
+	CamelEwsStore *ews_store = CAMEL_EWS_STORE (store);
+	EEwsFolder *folder;
+	const EwsFolderId *fid;
+	gboolean res = TRUE;
+	gchar *tmp;
+
+	if (!camel_offline_store_get_online (CAMEL_OFFLINE_STORE (ews_store))) {
+		g_set_error_literal (
+			error, CAMEL_SERVICE_ERROR, CAMEL_SERVICE_ERROR_UNAVAILABLE,
+			_("Cannot subscribe EWS folders in offline mode"));
+		return FALSE;
+	}
+
+	/* Folder's name is not stored with the "/" in the beginning, even when the
+	   folder is in the root (same level as "Inbox", "Drafts", etc. */
+	if (*folder_name == '/')
+		folder_name++;
+
+	/* can subscribe only public folders,
+	   thus skip anything known */
+	tmp = camel_ews_store_summary_get_folder_id_from_name (ews_store->summary, folder_name);
+	if (tmp) {
+		g_free (tmp);
+		return TRUE;
+	}
+
+	g_mutex_lock (ews_store->priv->get_finfo_lock);
+	if (!ews_store->priv->public_folders) {
+		g_mutex_unlock (ews_store->priv->get_finfo_lock);
+
+		g_set_error (
+			error, CAMEL_STORE_ERROR, CAMEL_STORE_ERROR_NO_FOLDER,
+			_("Cannot subscribe folder '%s', no public folder available"), folder_name);
+		return FALSE;
+	}
+
+	folder = ews_store_find_public_folder (ews_store, folder_name);
+	if (!folder) {
+		g_mutex_unlock (ews_store->priv->get_finfo_lock);
+
+		g_set_error (
+			error, CAMEL_STORE_ERROR, CAMEL_STORE_ERROR_NO_FOLDER,
+			_("Cannot subscribe folder '%s', folder not found"), folder_name);
+		return FALSE;
+	}
+
+	fid = e_ews_folder_get_id (folder);
+
+	g_return_val_if_fail (fid != NULL, FALSE);
+
+	if (camel_ews_store_summary_has_folder (ews_store->summary, EWS_PUBLIC_FOLDER_ROOT_ID)) {
+		gchar *parent_name = camel_ews_store_summary_get_folder_name (ews_store->summary, EWS_PUBLIC_FOLDER_ROOT_ID, NULL);
+
+		g_return_val_if_fail (parent_name != NULL, FALSE);
+
+		tmp = g_strconcat (parent_name, "/", e_ews_folder_get_name (folder), NULL);
+		g_free (parent_name);
+	} else {
+		tmp = g_strconcat (EWS_PUBLIC_FOLDER_ROOT_DISPLAY_NAME, "/", e_ews_folder_get_name (folder), NULL);
+	}
+
+	if (e_ews_folder_get_folder_type (folder) != E_EWS_FOLDER_TYPE_MAILBOX) {
+		CamelURL *url = camel_service_get_camel_url (CAMEL_SERVICE (store));
+		gchar *account_name = find_account_name (ews_store);
+
+		res = e_ews_folder_utils_add_as_esource (
+			url,
+			account_name,
+			folder,
+			E_EWS_ESOURCE_FLAG_OFFLINE_SYNC | E_EWS_ESOURCE_FLAG_PUBLIC_FOLDER,
+			0,
+			cancellable,
+			error);
+
+		g_free (account_name);
+	}
+
+	if (res) {
+		ews_store_ensure_unique_path (ews_store, &tmp);
+
+		camel_ews_store_summary_new_folder (ews_store->summary, fid->id, EWS_PUBLIC_FOLDER_ROOT_ID,
+			NULL,
+			strrchr (tmp, '/') + 1,
+			e_ews_folder_get_folder_type (folder),
+			CAMEL_FOLDER_SUBSCRIBED,
+			e_ews_folder_get_total_count (folder),
+			FALSE, TRUE);
+
+		if (e_ews_folder_get_folder_type (folder) == E_EWS_FOLDER_TYPE_MAILBOX) {
+			CamelFolderInfo *fi;
+
+			camel_ews_store_ensure_virtual_folders (ews_store);
+
+			fi = camel_ews_utils_build_folder_info (ews_store, fid->id);
+			camel_store_folder_created (CAMEL_STORE (ews_store), fi);
+			camel_subscribable_folder_subscribed (CAMEL_SUBSCRIBABLE (ews_store), fi);
+			camel_folder_info_free (fi);
+		}
+	}
+
+	camel_ews_store_summary_save (ews_store->summary, NULL);
+
+	g_free (tmp);
+	g_mutex_unlock (ews_store->priv->get_finfo_lock);
+
+	return res;
+}
+
+static gboolean
+ews_store_unsubscribe_folder_sync (CamelStore *store,
+                                   const gchar *folder_name,
+                                   EVO3(GCancellable *cancellable,)
+                                   GError **error)
+{
+	EVO2(GCancellable *cancellable = NULL;)
+	CamelEwsStore *ews_store = CAMEL_EWS_STORE (store);
+	EEwsFolderType folder_type;
+	EEwsFolder *folder;
+	gboolean is_public;
+	gboolean res = TRUE;
+	gchar *fid = NULL;
+
+	if (!camel_offline_store_get_online (CAMEL_OFFLINE_STORE (ews_store))) {
+		g_set_error_literal (
+			error, CAMEL_SERVICE_ERROR, CAMEL_SERVICE_ERROR_UNAVAILABLE,
+			_("Cannot unsubscribe EWS folders in offline mode"));
+		return FALSE;
+	}
+
+	folder = ews_store_find_public_folder (ews_store, folder_name);
+	if (folder) {
+		const EwsFolderId *folder_id = e_ews_folder_get_id (folder);
+
+		if (folder_id) {
+			fid = g_strdup (folder_id->id);
+			folder_type = e_ews_folder_get_folder_type (folder);
+		}
+	}
+
+	if (!fid) {
+		fid = camel_ews_store_summary_get_folder_id_from_name (ews_store->summary, folder_name);
+		if (fid)
+			folder_type = camel_ews_store_summary_get_folder_type (ews_store->summary, fid, NULL);
+	}
+
+	if (!fid) {
+		/* no such folder in the cache, might be unsubscribed already */
+		return TRUE;
+	}
+
+	is_public = camel_ews_store_summary_get_public (ews_store->summary, fid, NULL);
+	if (!is_public && !camel_ews_store_summary_get_foreign (ews_store->summary, fid, NULL)) {
+		/* nothing to do for regular folders */
+		res = TRUE;
+	} else {
+		CamelFolderInfo *fi;
+
+		if (!is_public && camel_ews_store_summary_get_foreign_subfolders (ews_store->summary, fid, NULL)) {
+			/* when subscribed with subfolders, then unsubscribe with subfolders as well */
+			GSList *local_folders = NULL, *ii;
+			gchar *full_name = camel_ews_store_summary_get_folder_full_name (ews_store->summary, fid, NULL);
+			if (full_name) {
+				local_folders = camel_ews_store_summary_get_folders (ews_store->summary, full_name);
+			}
+			g_free (full_name);
+
+			for (ii = local_folders; ii != NULL; ii = ii->next) {
+				const gchar *lfid = ii->data;
+				EEwsFolderType ftype;
+
+				if (g_strcmp0 (lfid, fid) == 0)
+					continue;
+
+				ftype = camel_ews_store_summary_get_folder_type (ews_store->summary, lfid, NULL);
+				if (ftype != E_EWS_FOLDER_TYPE_MAILBOX)
+					continue;
+
+				fi = camel_ews_utils_build_folder_info (ews_store, lfid);
+				camel_ews_store_summary_remove_folder (ews_store->summary, lfid, NULL);
+
+				camel_subscribable_folder_unsubscribed (CAMEL_SUBSCRIBABLE (ews_store), fi);
+				camel_store_folder_deleted (CAMEL_STORE (ews_store), fi);
+				camel_folder_info_free (fi);
+			}
+
+			g_slist_free_full (local_folders, g_free);
+		}
+
+		if (folder_type != E_EWS_FOLDER_TYPE_MAILBOX) {
+			CamelURL *url = camel_service_get_camel_url (CAMEL_SERVICE (store));
+
+			res = e_ews_folder_utils_remove_as_esource (
+				camel_url_get_param (url, "hosturl"),
+				url->user,
+				fid,
+				cancellable,
+				error);
+		}
+
+		if (res) {
+			fi = camel_ews_utils_build_folder_info (ews_store, fid);
+			camel_ews_store_summary_remove_folder (ews_store->summary, fid, error);
+
+			if (folder_type == E_EWS_FOLDER_TYPE_MAILBOX) {
+				camel_subscribable_folder_unsubscribed (CAMEL_SUBSCRIBABLE (ews_store), fi);
+				camel_store_folder_deleted (CAMEL_STORE (ews_store), fi);
+				camel_folder_info_free (fi);
+
+				camel_ews_store_ensure_virtual_folders (ews_store);
+			}
+		}
+
+		camel_ews_store_summary_save (ews_store->summary, NULL);
+	}
+
+	g_free (fid);
+
+	return res;
 }
 
 gboolean
-camel_ews_store_connected (CamelEwsStore *ews_store, GError **error)
+camel_ews_store_connected (CamelEwsStore *ews_store,
+                           GCancellable *cancellable,
+                           GError **error)
 {
 
 	if (!camel_offline_store_get_online (CAMEL_OFFLINE_STORE (ews_store))) {
@@ -857,12 +2634,33 @@ camel_ews_store_connected (CamelEwsStore
 		return FALSE;
 	}
 
-	if (!EVO3_sync(camel_service_connect) ((CamelService *) ews_store, error))
+	if (!EVO3_sync(camel_service_connect) ((CamelService *) ews_store, EVO3(cancellable,) error))
 		return FALSE;
 
 	return TRUE;
 }
 
+void
+camel_ews_store_maybe_disconnect (CamelEwsStore *store,
+                                  const GError *error)
+{
+	CamelService *service;
+
+	g_return_if_fail (store != NULL);
+
+	if (!error)
+		return;
+
+	service = CAMEL_SERVICE (store);
+
+	if (camel_service_get_connection_status (service) != CAMEL_SERVICE_CONNECTED)
+		return;
+
+	if (g_error_matches (error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_NORESPONSE) ||
+	    g_error_matches (error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_AUTHENTICATION_FAILED))
+		EVO3_sync(camel_service_disconnect) (service, FALSE, EVO3(NULL,) NULL);
+}
+
 static void
 ews_store_dispose (GObject *object)
 {
@@ -876,9 +2674,14 @@ ews_store_dispose (GObject *object)
 		ews_store->summary = NULL;
 	}
 
-	if (ews_store->priv->cnc != NULL) {
-		g_object_unref (ews_store->priv->cnc);
-		ews_store->priv->cnc = NULL;
+	if (ews_store->priv->connection != NULL) {
+		g_object_unref (ews_store->priv->connection);
+		ews_store->priv->connection = NULL;
+	}
+
+	if (ews_store->priv->public_folders) {
+		g_slist_free_full (ews_store->priv->public_folders, g_object_unref);
+		ews_store->priv->public_folders = NULL;
 	}
 
 	/* Chain up to parent's dispose() method. */
@@ -893,8 +2696,8 @@ ews_store_finalize (GObject *object)
 	ews_store = CAMEL_EWS_STORE (object);
 
 	g_free (ews_store->storage_path);
-	g_free (ews_store->priv->host_url);
 	g_mutex_free (ews_store->priv->get_finfo_lock);
+	g_mutex_free (ews_store->priv->connection_lock);
 
 	/* Chain up to parent's finalize() method. */
 	G_OBJECT_CLASS (camel_ews_store_parent_class)->finalize (object);
@@ -934,7 +2737,14 @@ camel_ews_store_class_init (CamelEwsStor
 	store_class->free_folder_info = camel_store_free_folder_info_full;
 
 	EVO3(store_class->get_trash_folder_sync = ews_get_trash_folder_sync;)
+	EVO2(store_class->get_trash = ews_get_trash_folder_sync;)
+	EVO3(store_class->get_junk_folder_sync = ews_get_junk_folder_sync;)
+	EVO2(store_class->get_junk = ews_get_junk_folder_sync;)
 	store_class->can_refresh_folder = ews_can_refresh_folder;
+
+	EVO2(store_class->subscribe_folder = ews_store_subscribe_folder_sync;)
+	EVO2(store_class->unsubscribe_folder = ews_store_unsubscribe_folder_sync;)
+	EVO2(store_class->folder_is_subscribed = ews_store_folder_is_subscribed;)
 }
 
 static void
@@ -943,7 +2753,10 @@ camel_ews_store_init (CamelEwsStore *ews
 	ews_store->priv =
 		CAMEL_EWS_STORE_GET_PRIVATE (ews_store);
 
-	ews_store->priv->cnc = NULL;
+	ews_store->priv->connection = NULL;
 	ews_store->priv->last_refresh_time = time (NULL) - (FINFO_REFRESH_INTERVAL + 10);
 	ews_store->priv->get_finfo_lock = g_mutex_new ();
+	ews_store->priv->connection_lock = g_mutex_new ();
+
+	((CamelStore *) ews_store)->flags |= CAMEL_STORE_SUBSCRIPTIONS;
 }
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/camel/camel-ews-store.h evolution-ews.sync-with-3.8.2/src/camel/camel-ews-store.h
--- evolution-ews.git-gnome-3-0/src/camel/camel-ews-store.h	2013-05-17 14:36:16.350669728 +0200
+++ evolution-ews.sync-with-3.8.2/src/camel/camel-ews-store.h	2013-05-28 08:59:53.267712492 +0200
@@ -50,6 +50,11 @@
 
 #define GW_PARAM_FILTER_INBOX		(1 << 0)
 
+#define EWS_FOREIGN_FOLDER_ROOT_ID		"ForeignRoot"
+#define EWS_FOREIGN_FOLDER_ROOT_DISPLAY_NAME	_("Foreign Folders")
+#define EWS_PUBLIC_FOLDER_ROOT_ID		"PublicRoot"
+#define EWS_PUBLIC_FOLDER_ROOT_DISPLAY_NAME	_("Public Folders")
+
 G_BEGIN_DECLS
 
 typedef struct _CamelEwsStore CamelEwsStore;
@@ -71,10 +76,22 @@ struct _CamelEwsStoreClass {
 GType camel_ews_store_get_type (void);
 gchar *		ews_get_name	(CamelService *service, gboolean brief);
 EEwsConnection *
-		camel_ews_store_get_connection	(CamelEwsStore *ews_store);
+		camel_ews_store_ref_connection	(CamelEwsStore *ews_store);
 
 gboolean	camel_ews_store_connected	(CamelEwsStore *store,
+						 GCancellable *cancellable,
 						 GError **error);
+void		camel_ews_store_maybe_disconnect
+						(CamelEwsStore *store,
+						 const GError *error);
+void		camel_ews_store_ensure_virtual_folders
+						(CamelEwsStore *ews_store);
+void		camel_ews_store_ensure_unique_path
+						(CamelEwsStore *ews_store,
+						 gchar **ppath);
+void		camel_ews_store_update_foreign_subfolders
+						(CamelEwsStore *ews_store,
+						 const gchar *fid);
 
 G_END_DECLS
 
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/camel/camel-ews-store-summary.c evolution-ews.sync-with-3.8.2/src/camel/camel-ews-store-summary.c
--- evolution-ews.git-gnome-3-0/src/camel/camel-ews-store-summary.c	2013-05-17 14:36:16.349670053 +0200
+++ evolution-ews.sync-with-3.8.2/src/camel/camel-ews-store-summary.c	2013-05-28 08:59:53.266712262 +0200
@@ -1,13 +1,21 @@
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include <glib.h>
 #include <glib/gstdio.h>
 #include <gio/gio.h>
 #include <string.h>
 #include "camel-ews-store-summary.h"
 
+#include "server/e-ews-folder.h"
+#include <e-ews-gnome-3-8-compat.h>
+
 #define S_LOCK(x) (g_static_rec_mutex_lock(&(x)->priv->s_lock))
 #define S_UNLOCK(x) (g_static_rec_mutex_unlock(&(x)->priv->s_lock))
 
 #define STORE_GROUP_NAME "##storepriv"
+#define CURRENT_SUMMARY_VERSION 1
 
 struct _CamelEwsStoreSummaryPrivate {
 	GKeyFile *key_file;
@@ -101,6 +109,9 @@ load_id_fname_hash (CamelEwsStoreSummary
 {
 	GSList *folders, *l;
 
+	g_hash_table_remove_all (ews_summary->priv->fname_id_hash);
+	g_hash_table_remove_all (ews_summary->priv->id_fname_hash);
+
 	folders = camel_ews_store_summary_get_folders (ews_summary, NULL);
 
 	for (l = folders; l != NULL; l = g_slist_next (l)) {
@@ -124,17 +135,21 @@ load_id_fname_hash (CamelEwsStoreSummary
 
 /* we only care about delete and ignore create */
 static void
-monitor_delete_cb (GFileMonitor *monitor, GFile *file, GFile *other_file, GFileMonitorEvent event, gpointer user_data)
+monitor_delete_cb (GFileMonitor *monitor,
+                   GFile *file,
+                   GFile *other_file,
+                   GFileMonitorEvent event,
+                   gpointer user_data)
 {
 	CamelEwsStoreSummary *ews_summary = (CamelEwsStoreSummary *) user_data;
 
 	if (event == G_FILE_MONITOR_EVENT_DELETED) {
-		S_LOCK(ews_summary);
+		S_LOCK (ews_summary);
 
 		if (ews_summary->priv->key_file)
 			camel_ews_store_summary_clear (ews_summary);
 
-		S_UNLOCK(ews_summary);
+		S_UNLOCK (ews_summary);
 	}
 }
 
@@ -149,13 +164,20 @@ camel_ews_store_summary_new (const gchar
 
 	ews_summary->priv->path = g_strdup (path);
 	file = g_file_new_for_path (path);
-	ews_summary->priv->monitor_delete = g_file_monitor_file (file, G_FILE_MONITOR_SEND_MOVED, NULL, &error);
+	ews_summary->priv->monitor_delete = g_file_monitor_file (
+		file, G_FILE_MONITOR_SEND_MOVED, NULL, &error);
 
-	/* Remove this once we have camel_store_remove_storage api, which should be available from 3.2 */
-	if (!error)
-		g_signal_connect (ews_summary->priv->monitor_delete, "changed", G_CALLBACK (monitor_delete_cb), ews_summary);
-	else {
-		g_warning ("CamelEwsStoreSummary: Error create monitor_delete: %s \n", error->message);
+	/* Remove this once we have camel_store_remove_storage api,
+	 * which should be available from 3.2 */
+	if (!error) {
+		g_signal_connect (
+			ews_summary->priv->monitor_delete, "changed",
+			G_CALLBACK (monitor_delete_cb), ews_summary);
+	} else {
+		g_warning (
+			"CamelEwsStoreSummary: "
+			"Error create monitor_delete: %s \n",
+			error->message);
 		g_clear_error (&error);
 	}
 
@@ -166,48 +188,62 @@ camel_ews_store_summary_new (const gchar
 
 gboolean
 camel_ews_store_summary_load (CamelEwsStoreSummary *ews_summary,
-			      GError **error)
+                              GError **error)
 {
 	CamelEwsStoreSummaryPrivate *priv = ews_summary->priv;
 	gboolean ret;
+	gint version;
+
+	S_LOCK (ews_summary);
 
-	S_LOCK(ews_summary);
+	ret = g_key_file_load_from_file (
+		priv->key_file, priv->path, 0, error);
 
-	ret = g_key_file_load_from_file	(priv->key_file,
-					 priv->path,
-					 0, error);
+	version = g_key_file_get_integer (
+		priv->key_file, STORE_GROUP_NAME, "Version", NULL);
+
+	if (version != CURRENT_SUMMARY_VERSION) {
+		/* version doesn't match, get folders again */
+		camel_ews_store_summary_clear (ews_summary);
+
+		g_key_file_set_integer (
+			priv->key_file, STORE_GROUP_NAME,
+			"Version", CURRENT_SUMMARY_VERSION);
+	}
 
 	load_id_fname_hash (ews_summary);
-	S_UNLOCK(ews_summary);
+
+	S_UNLOCK (ews_summary);
 
 	return ret;
 }
 
 gboolean
 camel_ews_store_summary_save (CamelEwsStoreSummary *ews_summary,
-			      GError **error)
+                              GError **error)
 {
 	CamelEwsStoreSummaryPrivate *priv = ews_summary->priv;
 	gboolean ret = TRUE;
 	GFile *file;
 	gchar *contents = NULL;
 
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
 	if (!priv->dirty)
 		goto exit;
 
-	contents = g_key_file_to_data	(priv->key_file, NULL,
-		       			 NULL);
-	file = g_file_new_for_path	(priv->path);
-	ret = g_file_replace_contents	(file, contents, strlen (contents),
-					 NULL, FALSE, G_FILE_CREATE_PRIVATE,
-					 NULL, NULL, error);
+	contents = g_key_file_to_data (
+		priv->key_file, NULL, NULL);
+	file = g_file_new_for_path (priv->path);
+	ret = g_file_replace_contents (
+		file, contents, strlen (contents),
+		NULL, FALSE, G_FILE_CREATE_PRIVATE,
+		NULL, NULL, error);
 	g_object_unref (file);
 	priv->dirty = FALSE;
 
 exit:
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 
 	g_free (contents);
 	return ret;
@@ -217,13 +253,13 @@ gboolean
 camel_ews_store_summary_clear (CamelEwsStoreSummary *ews_summary)
 {
 
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
 	g_key_file_free (ews_summary->priv->key_file);
 	ews_summary->priv->key_file = g_key_file_new ();
 	ews_summary->priv->dirty = TRUE;
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 
 	return TRUE;
 }
@@ -233,18 +269,28 @@ camel_ews_store_summary_remove (CamelEws
 {
 	gint ret;
 
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
 	if (ews_summary->priv->key_file)
 		camel_ews_store_summary_clear (ews_summary);
 
 	ret = g_unlink (ews_summary->priv->path);
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 
 	return (ret == 0);
 }
 
+void
+camel_ews_store_summary_rebuild_hashes (CamelEwsStoreSummary *ews_summary)
+{
+	g_return_if_fail (CAMEL_IS_EWS_STORE_SUMMARY (ews_summary));
+
+	S_LOCK (ews_summary);
+	load_id_fname_hash (ews_summary);
+	S_UNLOCK (ews_summary);
+}
+
 struct subfolder_match {
 	GSList *ids;
 	gchar *match;
@@ -252,7 +298,9 @@ struct subfolder_match {
 };
 
 static void
-match_subfolder (gpointer key, gpointer value, gpointer user_data)
+match_subfolder (gpointer key,
+                 gpointer value,
+                 gpointer user_data)
 {
 	struct subfolder_match *sm = user_data;
 
@@ -261,10 +309,12 @@ match_subfolder (gpointer key, gpointer 
 }
 
 /* Must be called with the summary lock held, and gets to keep
-   both its string arguments */
-static void ews_ss_hash_replace (CamelEwsStoreSummary *ews_summary,
-				 gchar *folder_id, gchar *full_name,
-				 gboolean recurse)
+ * both its string arguments */
+static void
+ews_ss_hash_replace (CamelEwsStoreSummary *ews_summary,
+                     gchar *folder_id,
+                     gchar *full_name,
+                     gboolean recurse)
 {
 	const gchar *ofname;
 	struct subfolder_match sm = { NULL, NULL };
@@ -272,16 +322,16 @@ static void ews_ss_hash_replace (CamelEw
 	if (!full_name)
 		full_name = build_full_name (ews_summary, folder_id);
 
-	ofname = g_hash_table_lookup (ews_summary->priv->id_fname_hash,
-				      folder_id);
+	ofname = g_hash_table_lookup (
+		ews_summary->priv->id_fname_hash, folder_id);
 	/* Remove the old fullname->id hash entry *iff* it's pointing
-	   to this folder id. */
+	 * to this folder id. */
 	if (ofname) {
-		char *ofid = g_hash_table_lookup (ews_summary->priv->fname_id_hash,
-						  ofname);
+		gchar *ofid = g_hash_table_lookup (
+			ews_summary->priv->fname_id_hash, ofname);
 		if (!strcmp (folder_id, ofid)) {
-			g_hash_table_remove (ews_summary->priv->fname_id_hash,
-					     ofname);
+			g_hash_table_remove (
+				ews_summary->priv->fname_id_hash, ofname);
 			if (recurse)
 				sm.match = g_strdup_printf ("%s/", ofname);
 		}
@@ -290,7 +340,7 @@ static void ews_ss_hash_replace (CamelEw
 	g_hash_table_insert (ews_summary->priv->fname_id_hash, full_name, folder_id);
 
 	/* Replace, not insert. The difference is that it frees the *old* folder_id
-	   key, not the new one which we just inserted into fname_id_hash too. */
+	 * key, not the new one which we just inserted into fname_id_hash too. */
 	g_hash_table_replace (ews_summary->priv->id_fname_hash, folder_id, full_name);
 
 	if (sm.match) {
@@ -298,8 +348,9 @@ static void ews_ss_hash_replace (CamelEw
 
 		sm.matchlen = strlen (sm.match);
 
-		g_hash_table_foreach (ews_summary->priv->fname_id_hash,
-				      match_subfolder, &sm);
+		g_hash_table_foreach (
+			ews_summary->priv->fname_id_hash,
+			match_subfolder, &sm);
 
 		for (l = sm.ids; l; l = g_slist_next (l))
 			ews_ss_hash_replace (ews_summary, l->data, NULL, FALSE);
@@ -311,398 +362,597 @@ static void ews_ss_hash_replace (CamelEw
 
 void
 camel_ews_store_summary_set_folder_name (CamelEwsStoreSummary *ews_summary,
-					 const gchar *folder_id,
-					 const gchar *display_name)
+                                         const gchar *folder_id,
+                                         const gchar *display_name)
 {
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
-	g_key_file_set_string	(ews_summary->priv->key_file, folder_id,
-				 "DisplayName", display_name);
+	g_key_file_set_string (
+		ews_summary->priv->key_file,
+		folder_id, "DisplayName", display_name);
 
 	ews_ss_hash_replace (ews_summary, g_strdup (folder_id), NULL, TRUE);
 	ews_summary->priv->dirty = TRUE;
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 }
 
-
 void
 camel_ews_store_summary_new_folder (CamelEwsStoreSummary *ews_summary,
-				    const gchar *folder_id,
-				    const gchar *parent_fid,
-				    const gchar *change_key,
-				    const gchar *display_name,
-				    guint64 folder_type,
-				    guint64 folder_flags,
-				    guint64 total)
-{
-	S_LOCK(ews_summary);
-
-	g_key_file_set_string (ews_summary->priv->key_file, folder_id,
-			       "ParentFolderId", parent_fid);
-	g_key_file_set_string (ews_summary->priv->key_file, folder_id,
-			       "ChangeKey", change_key);
-	g_key_file_set_string (ews_summary->priv->key_file, folder_id,
-			       "DisplayName", display_name);
-	g_key_file_set_uint64 (ews_summary->priv->key_file, folder_id,
-			       "FolderType", folder_type);
-	g_key_file_set_uint64 (ews_summary->priv->key_file, folder_id,
-			       "Flags", folder_flags);
-	g_key_file_set_uint64 (ews_summary->priv->key_file, folder_id,
-			       "Total", total);
+                                    const gchar *folder_id,
+                                    const gchar *parent_fid,
+                                    const gchar *change_key,
+                                    const gchar *display_name,
+                                    EEwsFolderType folder_type,
+                                    guint64 folder_flags,
+                                    guint64 total,
+                                    gboolean foreign,
+				    gboolean public_folder)
+{
+	const gchar *folder_type_nick;
+
+	/* Store the folder type by its nickname. */
+	folder_type_nick = e_ews_folder_type_to_nick (folder_type);
+	g_return_if_fail (folder_type_nick != NULL);
+
+	S_LOCK (ews_summary);
+
+	if (parent_fid)
+		g_key_file_set_string (
+			ews_summary->priv->key_file,
+			folder_id, "ParentFolderId", parent_fid);
+	if (change_key)
+		g_key_file_set_string (
+			ews_summary->priv->key_file,
+			folder_id, "ChangeKey", change_key);
+	g_key_file_set_string (
+		ews_summary->priv->key_file,
+		folder_id, "DisplayName", display_name);
+	g_key_file_set_string (
+		ews_summary->priv->key_file,
+		folder_id, "FolderType", folder_type_nick);
+	if (folder_flags)
+		g_key_file_set_uint64 (
+			ews_summary->priv->key_file,
+			folder_id, "Flags", folder_flags);
+	g_key_file_set_uint64 (
+		ews_summary->priv->key_file,
+		folder_id, "Total", total);
+	g_key_file_set_boolean (
+		ews_summary->priv->key_file,
+		folder_id, "Foreign", foreign);
+	g_key_file_set_boolean (
+		ews_summary->priv->key_file,
+		folder_id, "Public", public_folder);
 
 	ews_ss_hash_replace (ews_summary, g_strdup (folder_id), NULL, FALSE);
 
 	ews_summary->priv->dirty = TRUE;
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 }
 
-
 void
 camel_ews_store_summary_set_parent_folder_id (CamelEwsStoreSummary *ews_summary,
-					      const gchar *folder_id,
-					      const gchar *parent_id)
+                                              const gchar *folder_id,
+                                              const gchar *parent_id)
 {
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
 	if (parent_id)
-		g_key_file_set_string (ews_summary->priv->key_file, folder_id,
-				       "ParentFolderId", parent_id);
+		g_key_file_set_string (
+			ews_summary->priv->key_file,
+			folder_id, "ParentFolderId", parent_id);
 	else
-		g_key_file_remove_key (ews_summary->priv->key_file, folder_id,
-				       "ParentFolderId", NULL);
+		g_key_file_remove_key (
+			ews_summary->priv->key_file,
+			folder_id, "ParentFolderId", NULL);
 
 	ews_ss_hash_replace (ews_summary, g_strdup (folder_id), NULL, TRUE);
 
 	ews_summary->priv->dirty = TRUE;
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 }
 
 void
-camel_ews_store_summary_set_change_key	(CamelEwsStoreSummary *ews_summary,
-					 const gchar *folder_id,
-					 const gchar *change_key)
-{
-	S_LOCK(ews_summary);
-
-	g_key_file_set_string	(ews_summary->priv->key_file, folder_id,
-				 "ChangeKey", change_key);
+camel_ews_store_summary_set_change_key (CamelEwsStoreSummary *ews_summary,
+                                         const gchar *folder_id,
+                                         const gchar *change_key)
+{
+	S_LOCK (ews_summary);
+
+	g_key_file_set_string (
+		ews_summary->priv->key_file,
+		folder_id, "ChangeKey", change_key);
 	ews_summary->priv->dirty = TRUE;
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 }
 
 void
 camel_ews_store_summary_set_sync_state (CamelEwsStoreSummary *ews_summary,
-					const gchar *folder_id,
-					const gchar *sync_state)
+                                        const gchar *folder_id,
+                                        const gchar *sync_state)
 {
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
-	g_key_file_set_string	(ews_summary->priv->key_file, folder_id,
-				 "SyncState", sync_state);
+	g_key_file_set_string (
+		ews_summary->priv->key_file,
+		folder_id, "SyncState", sync_state);
 	ews_summary->priv->dirty = TRUE;
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 }
 
 void
 camel_ews_store_summary_set_folder_flags (CamelEwsStoreSummary *ews_summary,
-					  const gchar *folder_id,
-					  guint64 flags)
+                                          const gchar *folder_id,
+                                          guint64 flags)
 {
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
-	g_key_file_set_uint64	(ews_summary->priv->key_file, folder_id,
-				 "Flags", flags);
+	g_key_file_set_uint64 (
+		ews_summary->priv->key_file,
+		folder_id, "Flags", flags);
 	ews_summary->priv->dirty = TRUE;
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 }
 
 void
 camel_ews_store_summary_set_folder_unread (CamelEwsStoreSummary *ews_summary,
-					   const gchar *folder_id,
-					   guint64 unread)
+                                           const gchar *folder_id,
+                                           guint64 unread)
 {
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
-	g_key_file_set_uint64	(ews_summary->priv->key_file, folder_id,
-				 "UnRead", unread);
+	g_key_file_set_uint64 (
+		ews_summary->priv->key_file,
+		folder_id, "UnRead", unread);
 	ews_summary->priv->dirty = TRUE;
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 }
 
 void
 camel_ews_store_summary_set_folder_total (CamelEwsStoreSummary *ews_summary,
-					  const gchar *folder_id,
-					  guint64 total)
+                                          const gchar *folder_id,
+                                          guint64 total)
 {
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
-	g_key_file_set_uint64	(ews_summary->priv->key_file, folder_id,
-				 "Total", total);
+	g_key_file_set_uint64 (
+		ews_summary->priv->key_file,
+		folder_id, "Total", total);
 	ews_summary->priv->dirty = TRUE;
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 }
 
 void
 camel_ews_store_summary_set_folder_type (CamelEwsStoreSummary *ews_summary,
-					 const gchar *folder_id,
-					 guint64 ews_folder_type)
+                                         const gchar *folder_id,
+                                         EEwsFolderType folder_type)
 {
-	S_LOCK(ews_summary);
+	const gchar *folder_type_nick;
+
+	/* Store the folder type by its nickname. */
+	folder_type_nick = e_ews_folder_type_to_nick (folder_type);
+	g_return_if_fail (folder_type_nick != NULL);
+
+	S_LOCK (ews_summary);
+
+	g_key_file_set_string (
+		ews_summary->priv->key_file,
+		folder_id, "FolderType", folder_type_nick);
+	ews_summary->priv->dirty = TRUE;
 
-	g_key_file_set_uint64	(ews_summary->priv->key_file, folder_id,
-				 "FolderType", ews_folder_type);
+	S_UNLOCK (ews_summary);
+}
+
+void
+camel_ews_store_summary_set_foreign (CamelEwsStoreSummary *ews_summary,
+                                     const gchar *folder_id,
+                                     gboolean is_foreign)
+{
+	S_LOCK (ews_summary);
+
+	g_key_file_set_boolean (
+		ews_summary->priv->key_file,
+		folder_id, "Foreign", is_foreign);
+	ews_summary->priv->dirty = TRUE;
+
+	S_UNLOCK (ews_summary);
+}
+
+void
+camel_ews_store_summary_set_foreign_subfolders (CamelEwsStoreSummary *ews_summary,
+						const gchar *folder_id,
+						gboolean foreign_subfolders)
+{
+	S_LOCK (ews_summary);
+
+	g_key_file_set_boolean (
+		ews_summary->priv->key_file,
+		folder_id, "ForeignSubfolders", foreign_subfolders);
 	ews_summary->priv->dirty = TRUE;
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
+}
+
+void
+camel_ews_store_summary_set_public (CamelEwsStoreSummary *ews_summary,
+                                    const gchar *folder_id,
+                                    gboolean is_public)
+{
+	S_LOCK (ews_summary);
+
+	g_key_file_set_boolean (
+		ews_summary->priv->key_file,
+		folder_id, "Public", is_public);
+	ews_summary->priv->dirty = TRUE;
+
+	S_UNLOCK (ews_summary);
 }
 
 void
 camel_ews_store_summary_store_string_val (CamelEwsStoreSummary *ews_summary,
-					  const gchar *key,
-					  const gchar *value)
+                                          const gchar *key,
+                                          const gchar *value)
 {
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
-	g_key_file_set_string	(ews_summary->priv->key_file, STORE_GROUP_NAME,
-				 key, value);
+	g_key_file_set_string (
+		ews_summary->priv->key_file,
+		STORE_GROUP_NAME, key, value);
 	ews_summary->priv->dirty = TRUE;
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 }
 
 gchar *
 camel_ews_store_summary_get_folder_name (CamelEwsStoreSummary *ews_summary,
-					 const gchar *folder_id,
-					 GError **error)
+                                         const gchar *folder_id,
+                                         GError **error)
 {
 	gchar *ret;
 
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
-	ret = g_key_file_get_string	(ews_summary->priv->key_file, folder_id,
-					 "DisplayName", error);
+	ret = g_key_file_get_string (
+		ews_summary->priv->key_file, folder_id,
+		"DisplayName", error);
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 
 	return ret;
 }
 
 gchar *
 camel_ews_store_summary_get_folder_full_name (CamelEwsStoreSummary *ews_summary,
-					      const gchar *folder_id,
-					      GError **error)
+                                              const gchar *folder_id,
+                                              GError **error)
 {
 	gchar *ret;
 
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
 	ret = g_hash_table_lookup (ews_summary->priv->id_fname_hash, folder_id);
 
 	if (ret)
 		ret = g_strdup (ret);
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 
 	return ret;
 }
 
 gchar *
 camel_ews_store_summary_get_parent_folder_id (CamelEwsStoreSummary *ews_summary,
-					      const gchar *folder_id,
-					      GError **error)
+                                              const gchar *folder_id,
+                                              GError **error)
 {
 	gchar *ret;
 
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
-	ret = g_key_file_get_string	(ews_summary->priv->key_file, folder_id,
-					 "ParentFolderId", error);
+	ret = g_key_file_get_string (
+		ews_summary->priv->key_file, folder_id,
+		"ParentFolderId", error);
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 
 	return ret;
 }
 
 gchar *
 camel_ews_store_summary_get_change_key (CamelEwsStoreSummary *ews_summary,
-					const gchar *folder_id,
-					GError **error)
+                                        const gchar *folder_id,
+                                        GError **error)
 {
 	gchar *ret;
 
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
-	ret = g_key_file_get_string	(ews_summary->priv->key_file, folder_id,
-					 "ChangeKey", error);
+	ret = g_key_file_get_string (
+		ews_summary->priv->key_file, folder_id,
+		"ChangeKey", error);
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 
 	return ret;
 }
 
 gchar *
 camel_ews_store_summary_get_sync_state (CamelEwsStoreSummary *ews_summary,
-					const gchar *folder_id,
-					GError **error)
+                                        const gchar *folder_id,
+                                        GError **error)
 {
 	gchar *ret;
 
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
-	ret = g_key_file_get_string	(ews_summary->priv->key_file, folder_id,
-					 "SyncState", error);
+	ret = g_key_file_get_string (
+		ews_summary->priv->key_file, folder_id,
+		"SyncState", error);
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 
 	return ret;
 }
 
 guint64
 camel_ews_store_summary_get_folder_flags (CamelEwsStoreSummary *ews_summary,
-					  const gchar *folder_id,
-					  GError **error)
+                                          const gchar *folder_id,
+                                          GError **error)
 {
 	guint64 ret;
 
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
-	ret = g_key_file_get_uint64	(ews_summary->priv->key_file, folder_id,
-					 "Flags", error);
+	ret = g_key_file_get_uint64 (
+		ews_summary->priv->key_file, folder_id,
+		"Flags", error);
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 
 	return ret;
 }
 
-
 guint64
 camel_ews_store_summary_get_folder_unread (CamelEwsStoreSummary *ews_summary,
-					   const gchar *folder_id,
-					   GError **error)
+                                           const gchar *folder_id,
+                                           GError **error)
 {
 	guint64 ret;
 
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
-	ret = g_key_file_get_uint64	(ews_summary->priv->key_file, folder_id,
-					 "UnRead", error);
+	ret = g_key_file_get_uint64 (
+		ews_summary->priv->key_file, folder_id,
+		"UnRead", error);
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 
 	return ret;
 }
 
 guint64
 camel_ews_store_summary_get_folder_total (CamelEwsStoreSummary *ews_summary,
-					  const gchar *folder_id,
-					  GError **error)
+                                          const gchar *folder_id,
+                                          GError **error)
 {
 	guint64 ret;
 
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
-	ret = g_key_file_get_uint64	(ews_summary->priv->key_file, folder_id,
-					 "Total", error);
+	ret = g_key_file_get_uint64 (
+		ews_summary->priv->key_file, folder_id,
+		"Total", error);
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 
 	return ret;
 }
 
-guint64
+EEwsFolderType
 camel_ews_store_summary_get_folder_type (CamelEwsStoreSummary *ews_summary,
-					 const gchar *folder_id,
-					 GError **error)
+                                         const gchar *folder_id,
+                                         GError **error)
 {
-	guint64 ret;
+	EEwsFolderType folder_type;
+	gchar *folder_type_nick;
+
+	S_LOCK (ews_summary);
+
+	folder_type_nick = g_key_file_get_string (
+		ews_summary->priv->key_file,
+		folder_id, "FolderType", error);
+
+	S_UNLOCK (ews_summary);
+
+	/* Look up the folder type by its nickname. */
+	if (folder_type_nick != NULL)
+		folder_type = e_ews_folder_type_from_nick (folder_type_nick);
+	else
+		folder_type = E_EWS_FOLDER_TYPE_UNKNOWN;
+
+	g_free (folder_type_nick);
+
+	return folder_type;
+}
+
+gboolean
+camel_ews_store_summary_get_foreign (CamelEwsStoreSummary *ews_summary,
+                                     const gchar *folder_id,
+                                     GError **error)
+{
+	gboolean ret;
+
+	S_LOCK (ews_summary);
+
+	ret = g_key_file_get_boolean (
+		ews_summary->priv->key_file, folder_id, "Foreign", error);
+
+	S_UNLOCK (ews_summary);
+
+	return ret;
+}
+
+gboolean
+camel_ews_store_summary_get_foreign_subfolders (CamelEwsStoreSummary *ews_summary,
+						const gchar *folder_id,
+						GError **error)
+{
+	gboolean ret;
+
+	S_LOCK (ews_summary);
 
-	S_LOCK(ews_summary);
+	ret = g_key_file_get_boolean (
+		ews_summary->priv->key_file, folder_id, "ForeignSubfolders", error);
 
-	ret = g_key_file_get_uint64	(ews_summary->priv->key_file, folder_id,
-					 "FolderType", error);
+	S_UNLOCK (ews_summary);
 
-	S_UNLOCK(ews_summary);
+	return ret;
+}
+
+gboolean
+camel_ews_store_summary_get_public (CamelEwsStoreSummary *ews_summary,
+                                    const gchar *folder_id,
+                                    GError **error)
+{
+	gboolean ret;
+
+	S_LOCK (ews_summary);
+
+	ret = g_key_file_get_boolean (
+		ews_summary->priv->key_file, folder_id, "Public", error);
+
+	S_UNLOCK (ews_summary);
 
 	return ret;
 }
 
 gchar *
-camel_ews_store_summary_get_string_val	(CamelEwsStoreSummary *ews_summary,
-					 const gchar *key,
-					 GError **error)
+camel_ews_store_summary_get_string_val (CamelEwsStoreSummary *ews_summary,
+                                         const gchar *key,
+                                         GError **error)
 {
 	gchar *ret;
 
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
-	ret = g_key_file_get_string	(ews_summary->priv->key_file, STORE_GROUP_NAME,
-					 key, error);
+	ret = g_key_file_get_string (
+		ews_summary->priv->key_file, STORE_GROUP_NAME,
+		key, error);
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 
 	return ret;
 }
 
 GSList *
 camel_ews_store_summary_get_folders (CamelEwsStoreSummary *ews_summary,
-				     const gchar *prefix)
+                                     const gchar *prefix)
 {
 	GSList *folders = NULL;
 	gchar **groups = NULL;
 	gsize length;
-	int prefixlen = 0;
+	gint prefixlen = 0;
 	gint i;
 
 	if (prefix)
-		prefixlen = strlen(prefix);
+		prefixlen = strlen (prefix);
 
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
 	groups = g_key_file_get_groups (ews_summary->priv->key_file, &length);
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 
 	for (i = 0; i < length; i++) {
-		if (!g_ascii_strcasecmp (groups [i], STORE_GROUP_NAME))
+		if (!g_ascii_strcasecmp (groups[i], STORE_GROUP_NAME))
 			continue;
 		if (prefixlen) {
-			const gchar *fname = g_hash_table_lookup (ews_summary->priv->id_fname_hash, groups[i]);
+			const gchar *fname;
+
+			fname = g_hash_table_lookup (
+				ews_summary->priv->id_fname_hash, groups[i]);
 
-			if (!fname || strncmp(fname, prefix, prefixlen) ||
+			if (!fname || strncmp (fname, prefix, prefixlen) ||
 			    (fname[prefixlen] && fname[prefixlen] != '/'))
 				continue;
 		}
-		folders = g_slist_append (folders, g_strdup (groups [i]));
+		folders = g_slist_append (folders, g_strdup (groups[i]));
 	}
 
 	g_strfreev (groups);
 	return folders;
 }
 
+/* get list of folder IDs, which are foreign folders */
+GSList *
+camel_ews_store_summary_get_foreign_folders (CamelEwsStoreSummary *ews_summary,
+					     const gchar *prefix)
+{
+	GSList *folders = NULL;
+	gchar **groups = NULL;
+	gsize length;
+	gint prefixlen = 0;
+	gint i;
+
+	if (prefix)
+		prefixlen = strlen (prefix);
+
+	S_LOCK (ews_summary);
+
+	groups = g_key_file_get_groups (ews_summary->priv->key_file, &length);
+
+	S_UNLOCK (ews_summary);
+
+	for (i = 0; i < length; i++) {
+		if (!g_ascii_strcasecmp (groups[i], STORE_GROUP_NAME))
+			continue;
+
+		if (!camel_ews_store_summary_get_foreign (ews_summary, groups[i], NULL))
+			continue;
+
+		if (prefixlen) {
+			const gchar *fname;
+
+			fname = g_hash_table_lookup (
+				ews_summary->priv->id_fname_hash, groups[i]);
+
+			if (!fname || strncmp (fname, prefix, prefixlen) ||
+			    (fname[prefixlen] && fname[prefixlen] != '/'))
+				continue;
+		}
+
+		folders = g_slist_append (folders, g_strdup (groups[i]));
+	}
+
+	g_strfreev (groups);
+
+	return folders;
+}
+
 gboolean
 camel_ews_store_summary_remove_folder (CamelEwsStoreSummary *ews_summary,
-				       const gchar *folder_id,
-				       GError **error)
+                                       const gchar *folder_id,
+                                       GError **error)
 {
 	gboolean ret = FALSE;
 	gchar *full_name;
 
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
 	full_name = g_hash_table_lookup (ews_summary->priv->id_fname_hash, folder_id);
 	if (!full_name)
 		goto unlock;
 
-	ret = g_key_file_remove_group (ews_summary->priv->key_file, folder_id,
-				       error);
+	ret = g_key_file_remove_group (
+		ews_summary->priv->key_file, folder_id, error);
 
 	g_hash_table_remove (ews_summary->priv->fname_id_hash, full_name);
 	g_hash_table_remove (ews_summary->priv->id_fname_hash, folder_id);
@@ -710,38 +960,79 @@ camel_ews_store_summary_remove_folder (C
 	ews_summary->priv->dirty = TRUE;
 
  unlock:
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 
 	return ret;
 }
 
 gchar *
 camel_ews_store_summary_get_folder_id_from_name (CamelEwsStoreSummary *ews_summary,
-						 const gchar *folder_name)
+                                                 const gchar *folder_name)
 {
 	gchar *folder_id;
 
-	S_LOCK(ews_summary);
+	g_return_val_if_fail (ews_summary != NULL, NULL);
+	g_return_val_if_fail (folder_name != NULL, NULL);
+
+	S_LOCK (ews_summary);
 
 	folder_id = g_hash_table_lookup (ews_summary->priv->fname_id_hash, folder_name);
 	if (folder_id)
 		folder_id = g_strdup (folder_id);
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
+
+	return folder_id;
+}
+
+gchar *
+camel_ews_store_summary_get_folder_id_from_folder_type (CamelEwsStoreSummary *ews_summary,
+                                                        guint64 folder_type)
+{
+	gchar *folder_id = NULL;
+	GSList *folders, *l;
+
+	g_return_val_if_fail (ews_summary != NULL, NULL);
+	g_return_val_if_fail ((folder_type & CAMEL_FOLDER_TYPE_MASK) != 0, NULL);
+
+	folder_type = folder_type & CAMEL_FOLDER_TYPE_MASK;
+
+	S_LOCK (ews_summary);
+
+	folders = camel_ews_store_summary_get_folders (ews_summary, NULL);
+
+	for (l = folders; l != NULL; l = g_slist_next (l)) {
+		gchar *id = l->data;
+		guint64 folder_flags;
+
+		folder_flags = camel_ews_store_summary_get_folder_flags (
+			ews_summary, id, NULL);
+		if ((folder_flags & CAMEL_FOLDER_TYPE_MASK) == folder_type &&
+		    (folder_flags & CAMEL_FOLDER_SYSTEM) != 0) {
+			folder_id = id;
+			l->data = NULL;
+			break;
+		}
+	}
+
+	g_slist_free_full (folders, g_free);
+
+	S_UNLOCK (ews_summary);
 
 	return folder_id;
 }
 
 gboolean
-camel_ews_store_summary_has_folder (CamelEwsStoreSummary *ews_summary, const gchar *folder_id)
+camel_ews_store_summary_has_folder (CamelEwsStoreSummary *ews_summary,
+                                    const gchar *folder_id)
 {
 	gboolean ret;
 
-	S_LOCK(ews_summary);
+	S_LOCK (ews_summary);
 
 	ret = g_key_file_has_group (ews_summary->priv->key_file, folder_id);
 
-	S_UNLOCK(ews_summary);
+	S_UNLOCK (ews_summary);
 
 	return ret;
 }
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/camel/camel-ews-store-summary.h evolution-ews.sync-with-3.8.2/src/camel/camel-ews-store-summary.h
--- evolution-ews.git-gnome-3-0/src/camel/camel-ews-store-summary.h	2013-05-17 14:36:16.349670053 +0200
+++ evolution-ews.sync-with-3.8.2/src/camel/camel-ews-store-summary.h	2013-05-28 08:59:53.266712262 +0200
@@ -3,6 +3,8 @@
 
 #include <camel/camel.h>
 
+#include "server/e-ews-enums.h"
+
 /* Standard GObject macros */
 #define CAMEL_TYPE_EWS_STORE_SUMMARY \
 	(camel_ews_store_summary_get_type ())
@@ -22,6 +24,11 @@
 	(G_TYPE_INSTANCE_GET_CLASS \
 	((obj), CAMEL_TYPE_EWS_STORE_SUMMARY, CamelEwsStoreSummaryClass))
 
+/* the last possible value from CAMEL_FOLDER_TYPE_MASK range */
+#define CAMEL_EWS_FOLDER_TYPE_JOURNAL \
+	(((CAMEL_FOLDER_TYPE_MASK >> CAMEL_FOLDER_TYPE_BIT) - 1) << \
+	CAMEL_FOLDER_TYPE_BIT)
+
 G_BEGIN_DECLS
 
 typedef struct _CamelEwsStoreSummary CamelEwsStoreSummary;
@@ -47,6 +54,8 @@ gboolean	camel_ews_store_summary_save	(C
 						 GError **error);
 gboolean	camel_ews_store_summary_clear	(CamelEwsStoreSummary *ews_summary);
 gboolean	camel_ews_store_summary_remove	(CamelEwsStoreSummary *ews_summary);
+void		camel_ews_store_summary_rebuild_hashes
+						(CamelEwsStoreSummary *ews_summary);
 
 void		camel_ews_store_summary_set_folder_name
 						(CamelEwsStoreSummary *ews_summary,
@@ -79,7 +88,19 @@ void		camel_ews_store_summary_set_folder
 void		camel_ews_store_summary_set_folder_type
 						(CamelEwsStoreSummary *ews_summary,
 						 const gchar *folder_id,
-						 guint64 folder_type);
+						 EEwsFolderType folder_type);
+void		camel_ews_store_summary_set_foreign
+						(CamelEwsStoreSummary *ews_summary,
+						 const gchar *folder_id,
+						 gboolean is_foreign);
+void		camel_ews_store_summary_set_foreign_subfolders
+						(CamelEwsStoreSummary *ews_summary,
+						 const gchar *folder_id,
+						 gboolean foreign_subfolders);
+void		camel_ews_store_summary_set_public
+						(CamelEwsStoreSummary *ews_summary,
+						 const gchar *folder_id,
+						 gboolean is_public);
 
 gchar *	camel_ews_store_summary_get_folder_name
 						(CamelEwsStoreSummary *ews_summary,
@@ -113,7 +134,19 @@ guint64		camel_ews_store_summary_get_fol
 						(CamelEwsStoreSummary *ews_summary,
 						 const gchar *folder_id,
 						 GError **error);
-guint64		camel_ews_store_summary_get_folder_type
+EEwsFolderType	camel_ews_store_summary_get_folder_type
+						(CamelEwsStoreSummary *ews_summary,
+						 const gchar *folder_id,
+						 GError **error);
+gboolean	camel_ews_store_summary_get_foreign
+						(CamelEwsStoreSummary *ews_summary,
+						 const gchar *folder_id,
+						 GError **error);
+gboolean	camel_ews_store_summary_get_foreign_subfolders
+						(CamelEwsStoreSummary *ews_summary,
+						 const gchar *folder_id,
+						 GError **error);
+gboolean	camel_ews_store_summary_get_public
 						(CamelEwsStoreSummary *ews_summary,
 						 const gchar *folder_id,
 						 GError **error);
@@ -121,7 +154,9 @@ guint64		camel_ews_store_summary_get_fol
 GSList *	camel_ews_store_summary_get_folders
 						(CamelEwsStoreSummary *ews_summary,
 						 const gchar *prefix);
-
+GSList *	camel_ews_store_summary_get_foreign_folders
+						(CamelEwsStoreSummary *ews_summary,
+						 const gchar *prefix);
 
 void		camel_ews_store_summary_store_string_val
 						(CamelEwsStoreSummary *ews_summary,
@@ -144,14 +179,20 @@ void		camel_ews_store_summary_new_folder
 						 const gchar *parent_fid,
 						 const gchar *change_key,
 						 const gchar *display_name,
-						 guint64 folder_type,
+						 EEwsFolderType folder_type,
 						 guint64 folder_flags,
-						 guint64 total);
+						 guint64 total,
+						 gboolean foreign,
+						 gboolean public_folder);
 
 gchar *		camel_ews_store_summary_get_folder_id_from_name
 						(CamelEwsStoreSummary *ews_summary,
 						 const gchar *folder_name);
 
+gchar *		camel_ews_store_summary_get_folder_id_from_folder_type
+						(CamelEwsStoreSummary *ews_summary,
+						 guint64 folder_type);
+
 gboolean	camel_ews_store_summary_has_folder
 						(CamelEwsStoreSummary *ews_summary,
 						 const gchar *id);
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/camel/camel-ews-summary.c evolution-ews.sync-with-3.8.2/src/camel/camel-ews-summary.c
--- evolution-ews.git-gnome-3-0/src/camel/camel-ews-summary.c	2013-05-17 14:36:16.350669728 +0200
+++ evolution-ews.sync-with-3.8.2/src/camel/camel-ews-summary.c	2013-05-28 08:59:53.267712492 +0200
@@ -36,6 +36,8 @@
 #include "camel-ews-folder.h"
 #include "camel-ews-summary.h"
 
+#include "server/e-ews-gnome-3-8-compat.h"
+
 #define CAMEL_EWS_SUMMARY_VERSION (1)
 
 #define EXTRACT_FIRST_DIGIT(val) part ? val=strtoul (part, &part, 10) : 0;
@@ -44,19 +46,13 @@
 #define d(x)
 
 /*Prototypes*/
-static gint ews_summary_header_load (CamelFolderSummary *, FILE *);
-static gint ews_summary_header_save (CamelFolderSummary *, FILE *);
-
-static CamelMessageInfo *ews_message_info_migrate (CamelFolderSummary *s, FILE *in);
-
-static CamelMessageContentInfo * ews_content_info_migrate (CamelFolderSummary *s, FILE *in);
-static gboolean ews_info_set_flags(CamelMessageInfo *info, guint32 flags, guint32 set);
+static gboolean ews_info_set_flags (CamelMessageInfo *info, guint32 flags, guint32 set);
 
-static gint summary_header_from_db (CamelFolderSummary *s, CamelFIRecord *mir);
+static gboolean summary_header_from_db (CamelFolderSummary *s, CamelFIRecord *mir);
 static CamelFIRecord * summary_header_to_db (CamelFolderSummary *s, GError **error);
 static CamelMIRecord * message_info_to_db (CamelFolderSummary *s, CamelMessageInfo *info);
 static CamelMessageInfo * message_info_from_db (CamelFolderSummary *s, CamelMIRecord *mir);
-static gint content_info_to_db (CamelFolderSummary *s, CamelMessageContentInfo *info, CamelMIRecord *mir);
+static gboolean content_info_to_db (CamelFolderSummary *s, CamelMessageContentInfo *info, CamelMIRecord *mir);
 static CamelMessageContentInfo * content_info_from_db (CamelFolderSummary *s, CamelMIRecord *mir);
 
 /*End of Prototypes*/
@@ -64,26 +60,28 @@ static CamelMessageContentInfo * content
 G_DEFINE_TYPE (CamelEwsSummary, camel_ews_summary, CAMEL_TYPE_FOLDER_SUMMARY)
 
 static CamelMessageInfo *
-ews_message_info_clone(CamelFolderSummary *s, const CamelMessageInfo *mi)
+ews_message_info_clone (CamelFolderSummary *s,
+                        const CamelMessageInfo *mi)
 {
 	CamelEwsMessageInfo *to;
-	const CamelEwsMessageInfo *from = (const CamelEwsMessageInfo *)mi;
+	const CamelEwsMessageInfo *from = (const CamelEwsMessageInfo *) mi;
 
-	to = (CamelEwsMessageInfo *)CAMEL_FOLDER_SUMMARY_CLASS (camel_ews_summary_parent_class)->message_info_clone(s, mi);
+	to = (CamelEwsMessageInfo *) CAMEL_FOLDER_SUMMARY_CLASS (camel_ews_summary_parent_class)->message_info_clone (s, mi);
 	to->server_flags = from->server_flags;
 	to->item_type = from->item_type;
 	to->change_key = g_strdup (from->change_key);
 
 	/* FIXME: parent clone should do this */
-	to->info.content = camel_folder_summary_content_info_new(s);
+	to->info.content = camel_folder_summary_content_info_new (s);
 
-	return (CamelMessageInfo *)to;
+	return (CamelMessageInfo *) to;
 }
 
 static void
-ews_message_info_free (CamelFolderSummary *s, CamelMessageInfo *mi)
+ews_message_info_free (CamelFolderSummary *s,
+                       CamelMessageInfo *mi)
 {
-	CamelEwsMessageInfo *emi = (void *)mi;
+	CamelEwsMessageInfo *emi = (gpointer) mi;
 
 	g_free (emi->change_key);
 	CAMEL_FOLDER_SUMMARY_CLASS (camel_ews_summary_parent_class)->message_info_free (s, mi);
@@ -114,10 +112,6 @@ camel_ews_summary_class_init (CamelEwsSu
 	folder_summary_class->content_info_size = sizeof (CamelEwsMessageContentInfo);
 	folder_summary_class->message_info_clone = ews_message_info_clone;
 	folder_summary_class->message_info_free = ews_message_info_free;
-	folder_summary_class->summary_header_load = ews_summary_header_load;
-	folder_summary_class->summary_header_save = ews_summary_header_save;
-	folder_summary_class->message_info_migrate = ews_message_info_migrate;
-	folder_summary_class->content_info_migrate = ews_content_info_migrate;
 	folder_summary_class->info_set_flags = ews_info_set_flags;
 	folder_summary_class->summary_header_to_db = summary_header_to_db;
 	folder_summary_class->summary_header_from_db = summary_header_from_db;
@@ -130,15 +124,10 @@ camel_ews_summary_class_init (CamelEwsSu
 static void
 camel_ews_summary_init (CamelEwsSummary *ews_summary)
 {
-	CamelFolderSummary *summary = CAMEL_FOLDER_SUMMARY (ews_summary);
-
-	/* Meta-summary - Overriding UID len */
-	summary->meta_summary->uid_len = 2048;
 }
 
 /**
  * camel_ews_summary_new:
- * @filename: the file to store the summary in.
  *
  * This will create a new CamelEwsSummary object and read in the
  * summary data from disk, if it exists.
@@ -161,7 +150,8 @@ camel_ews_summary_new (struct _CamelFold
 }
 
 static gint
-summary_header_from_db (CamelFolderSummary *s, CamelFIRecord *mir)
+summary_header_from_db (CamelFolderSummary *s,
+                        CamelFIRecord *mir)
 {
 	CamelEwsSummary *gms = CAMEL_EWS_SUMMARY (s);
 	gchar *part;
@@ -172,7 +162,7 @@ summary_header_from_db (CamelFolderSumma
 	part = mir->bdata;
 
 	if (part)
-		EXTRACT_FIRST_DIGIT(gms->version);
+		EXTRACT_FIRST_DIGIT (gms->version);
 
 	if (part && part++ && strcmp (part, "(null)")) {
 		gms->sync_state = g_strdup (part);
@@ -181,26 +171,11 @@ summary_header_from_db (CamelFolderSumma
 	return 0;
 }
 
-static gint
-ews_summary_header_load (CamelFolderSummary *s, FILE *in)
-{
-	CamelEwsSummary *gms = CAMEL_EWS_SUMMARY (s);
-
-	if (CAMEL_FOLDER_SUMMARY_CLASS (camel_ews_summary_parent_class)->summary_header_load (s, in) == -1)
-		return -1;
-
-	if (camel_file_util_decode_fixed_int32(in, &gms->version) == -1)
-		return -1;
-
-	if (camel_file_util_decode_string (in, &gms->sync_state) == -1)
-		return -1;
-	return 0;
-}
-
 static CamelFIRecord *
-summary_header_to_db (CamelFolderSummary *s, GError **error)
+summary_header_to_db (CamelFolderSummary *s,
+                      GError **error)
 {
-	CamelEwsSummary *ims = CAMEL_EWS_SUMMARY(s);
+	CamelEwsSummary *ims = CAMEL_EWS_SUMMARY (s);
 	struct _CamelFIRecord *fir;
 
 	fir = CAMEL_FOLDER_SUMMARY_CLASS (camel_ews_summary_parent_class)->summary_header_to_db (s, error);
@@ -213,20 +188,9 @@ summary_header_to_db (CamelFolderSummary
 
 }
 
-static gint
-ews_summary_header_save (CamelFolderSummary *s, FILE *out)
-{
-	CamelEwsSummary *gms = CAMEL_EWS_SUMMARY(s);
-
-	if (CAMEL_FOLDER_SUMMARY_CLASS (camel_ews_summary_parent_class)->summary_header_save (s, out) == -1)
-		return -1;
-
-	camel_file_util_encode_fixed_int32(out, CAMEL_EWS_SUMMARY_VERSION);
-	return camel_file_util_encode_string (out, gms->sync_state);
-}
-
 static CamelMessageInfo *
-message_info_from_db (CamelFolderSummary *s, CamelMIRecord *mir)
+message_info_from_db (CamelFolderSummary *s,
+                      CamelMIRecord *mir)
 {
 	CamelMessageInfo *info;
 	CamelEwsMessageInfo *iinfo;
@@ -236,42 +200,28 @@ message_info_from_db (CamelFolderSummary
 		gchar *part = mir->bdata;
 		gchar **values;
 
-		iinfo = (CamelEwsMessageInfo *)info;
-		values = g_strsplit (part, " ", -1);
-
-		iinfo->server_flags = g_ascii_strtoll (values [0], NULL, 10);
-		iinfo->item_type = g_ascii_strtoll (values [1], NULL, 10);
-		iinfo->change_key = g_strdup (values [2]);
+		iinfo = (CamelEwsMessageInfo *) info;
+		if (part) {
+			values = g_strsplit (part, " ", -1);
 
-		g_strfreev (values);
-	}
+			if (values && values[0] && values[1] && values[2]) {
+				iinfo->server_flags = g_ascii_strtoll (values[0], NULL, 10);
+				iinfo->item_type = g_ascii_strtoll (values[1], NULL, 10);
+				iinfo->change_key = g_strdup (values[2]);
+			}
 
-	return info;
-}
-
-static CamelMessageInfo *
-ews_message_info_migrate (CamelFolderSummary *s, FILE *in)
-{
-	CamelMessageInfo *info;
-	CamelEwsMessageInfo *ews_info;
-
-	info = CAMEL_FOLDER_SUMMARY_CLASS (camel_ews_summary_parent_class)->message_info_migrate (s,in);
-	if (info) {
-		ews_info = (CamelEwsMessageInfo*) info;
-		if (camel_file_util_decode_uint32 (in, &ews_info->server_flags) == -1)
-			goto error;
+			g_strfreev (values);
+		}
 	}
 
 	return info;
-error:
-	camel_message_info_free (info);
-	return NULL;
 }
 
 static CamelMIRecord *
-message_info_to_db (CamelFolderSummary *s, CamelMessageInfo *info)
+message_info_to_db (CamelFolderSummary *s,
+                    CamelMessageInfo *info)
 {
-	CamelEwsMessageInfo *iinfo = (CamelEwsMessageInfo *)info;
+	CamelEwsMessageInfo *iinfo = (CamelEwsMessageInfo *) info;
 	struct _CamelMIRecord *mir;
 
 	mir = CAMEL_FOLDER_SUMMARY_CLASS (camel_ews_summary_parent_class)->message_info_to_db (s, info);
@@ -282,10 +232,11 @@ message_info_to_db (CamelFolderSummary *
 }
 
 static CamelMessageContentInfo *
-content_info_from_db (CamelFolderSummary *s, CamelMIRecord *mir)
+content_info_from_db (CamelFolderSummary *s,
+                      CamelMIRecord *mir)
 {
 	gchar *part = mir->cinfo;
-	guint32 type=0;
+	guint32 type = 0;
 
 	if (part) {
 		if (*part == ' ')
@@ -301,17 +252,10 @@ content_info_from_db (CamelFolderSummary
 		return camel_folder_summary_content_info_new (s);
 }
 
-static CamelMessageContentInfo *
-ews_content_info_migrate (CamelFolderSummary *s, FILE *in)
-{
-	if (fgetc (in))
-		return CAMEL_FOLDER_SUMMARY_CLASS (camel_ews_summary_parent_class)->content_info_migrate (s, in);
-	else
-		return camel_folder_summary_content_info_new (s);
-}
-
 static gint
-content_info_to_db (CamelFolderSummary *s, CamelMessageContentInfo *info, CamelMIRecord *mir)
+content_info_to_db (CamelFolderSummary *s,
+                    CamelMessageContentInfo *info,
+                    CamelMIRecord *mir)
 {
 
 	if (info->type) {
@@ -324,192 +268,52 @@ content_info_to_db (CamelFolderSummary *
 }
 
 static gboolean
-ews_info_set_flags (CamelMessageInfo *info, guint32 flags, guint32 set)
+ews_info_set_flags (CamelMessageInfo *info,
+                    guint32 flags,
+                    guint32 set)
 {
-		guint32 old;
-		CamelMessageInfoBase *mi = (CamelMessageInfoBase *)info;
-		gint read = 0 , deleted = 0;
-
-		gint junk_flag = 0, junk_learn_flag = 0;
-
-		/* TODO: locking? */
-
-		if (flags & CAMEL_MESSAGE_SEEN && ((set & CAMEL_MESSAGE_SEEN) != (mi->flags & CAMEL_MESSAGE_SEEN)))
-		{ read = set & CAMEL_MESSAGE_SEEN ? 1 : -1; d(printf("Setting read as %d\n", set & CAMEL_MESSAGE_SEEN ? 1 : 0));}
-
-		if (flags & CAMEL_MESSAGE_DELETED && ((set & CAMEL_MESSAGE_DELETED) != (mi->flags & CAMEL_MESSAGE_DELETED)))
-		{ deleted = set & CAMEL_MESSAGE_DELETED ? 1 : -1; d(printf("Setting deleted as %d\n", set & CAMEL_MESSAGE_DELETED ? 1 : 0));}
-
-		old = mi->flags;
-		mi->flags = (old & ~flags) | (set & flags);
-
-		if (old != mi->flags) {
-				mi->flags |= CAMEL_MESSAGE_FOLDER_FLAGGED;
-				mi->dirty = TRUE;
-
-				if (((old & ~CAMEL_MESSAGE_SYSTEM_MASK) == (mi->flags & ~CAMEL_MESSAGE_SYSTEM_MASK)) )
-						return FALSE;
-
-				if (mi->summary) {
-						mi->summary->deleted_count += deleted;
-						mi->summary->unread_count -= read;
-						camel_folder_summary_touch(mi->summary);
-				}
-		}
-
-		junk_flag = ((flags & CAMEL_MESSAGE_JUNK) && (set & CAMEL_MESSAGE_JUNK));
-		junk_learn_flag = ((flags & CAMEL_MESSAGE_JUNK_LEARN) && (set & CAMEL_MESSAGE_JUNK_LEARN));
-
-		/* This is a hack, we are using CAMEL_MESSAGE_JUNK justo to hide the item
-		 * we make sure this doesn't have any side effects*/
-
-		if (junk_learn_flag && !junk_flag  && (old & CAMEL_GW_MESSAGE_JUNK)) {
-				/*
-				   This has ugly side-effects. Evo will never learn unjunk.
-				   We need to create one CAMEL_MESSAGE_HIDDEN flag which must be
-				   used for all hiding operations. We must also get rid of the seperate file
-				   that is maintained somewhere in evolution/mail/em-folder-browser.c for hidden messages
-				 */
-				mi->flags |= CAMEL_GW_MESSAGE_NOJUNK | CAMEL_MESSAGE_JUNK | CAMEL_MESSAGE_JUNK_LEARN;
-		} else if (junk_learn_flag && junk_flag && !(old & CAMEL_GW_MESSAGE_JUNK)) {
-				mi->flags |= CAMEL_GW_MESSAGE_JUNK | CAMEL_MESSAGE_JUNK | CAMEL_MESSAGE_JUNK_LEARN;
-		}
-
-		if (mi->summary && mi->summary->folder && mi->uid) {
-				CamelFolderChangeInfo *changes = camel_folder_change_info_new();
-
-				camel_folder_change_info_change_uid(changes, camel_message_info_uid(info));
-				camel_folder_changed (mi->summary->folder, changes);
-				camel_folder_change_info_free(changes);
-				camel_folder_summary_touch(mi->summary);
-		}
-
-		return TRUE;
+	return CAMEL_FOLDER_SUMMARY_CLASS (camel_ews_summary_parent_class)->info_set_flags (info, flags, set);
 }
 
 void
-camel_ews_summary_add_message	(CamelFolderSummary *summary,
-				 const gchar *uid,
-				 CamelMimeMessage *message)
+camel_ews_summary_add_message (CamelFolderSummary *summary,
+                               const gchar *uid,
+                               CamelMimeMessage *message)
 {
 	CamelEwsMessageInfo *mi;
 	CamelMessageInfo *info;
 	const CamelFlag *flag;
 	const CamelTag *tag;
 
-	info = camel_folder_summary_uid (summary, uid);
+	info = camel_folder_summary_get (summary, uid);
 
 	/* Create summary entry */
-	mi = (CamelEwsMessageInfo *)camel_folder_summary_info_new_from_message (summary, message, NULL);
+	mi = (CamelEwsMessageInfo *) camel_folder_summary_info_new_from_message (summary, message, NULL);
 
 	/* Copy flags 'n' tags */
-	mi->info.flags = camel_message_info_flags(info);
+	mi->info.flags = camel_message_info_flags (info);
 
-	flag = camel_message_info_user_flags(info);
+	flag = camel_message_info_user_flags (info);
 	while (flag) {
-		camel_message_info_set_user_flag((CamelMessageInfo *)mi, flag->name, TRUE);
+		camel_message_info_set_user_flag ((CamelMessageInfo *) mi, flag->name, TRUE);
 		flag = flag->next;
 	}
-	tag = camel_message_info_user_tags(info);
+	tag = camel_message_info_user_tags (info);
 	while (tag) {
-		camel_message_info_set_user_tag((CamelMessageInfo *)mi, tag->name, tag->value);
+		camel_message_info_set_user_tag ((CamelMessageInfo *) mi, tag->name, tag->value);
 		tag = tag->next;
 	}
 
-	mi->info.size = camel_message_info_size(info);
+	mi->info.size = camel_message_info_size (info);
 	mi->info.uid = camel_pstring_strdup (uid);
 
-	camel_folder_summary_add (summary, (CamelMessageInfo *)mi);
+	camel_folder_summary_add (summary, (CamelMessageInfo *) mi);
 	camel_message_info_free (info);
 }
 
-void
-camel_ews_summary_add_message_info	(CamelFolderSummary *summary,
-					 guint32 server_flags,
-					 CamelMessageInfo *mi)
-{
-	CamelMessageInfoBase *binfo = (CamelMessageInfoBase *) mi;
-	CamelEwsMessageInfo *einfo = (CamelEwsMessageInfo *) mi;
-	gint unread=0, junk=0;
-	guint32 flags;
-
-	binfo->flags |= server_flags;
-	einfo->server_flags = server_flags;
-
-	/* TODO update user flags */
-
-	/* update the summary count */
-	flags = binfo->flags;
-
-	if (!(flags & CAMEL_MESSAGE_SEEN))
-		unread = 1;
-
-	if (flags & CAMEL_MESSAGE_JUNK)
-		junk = 1;
-
-	if (summary) {
-		if (unread)
-			summary->unread_count += unread;
-		if (junk)
-			summary->junk_count += junk;
-		summary->visible_count++;
-		if (junk)
-			summary->visible_count -= junk;
-
-		summary->saved_count++;
-		camel_folder_summary_touch (summary);
-	}
-
-	binfo->flags &= ~CAMEL_MESSAGE_FOLDER_FLAGGED;
-	camel_folder_summary_add (summary, (CamelMessageInfo *)mi);
-}
-
-/* Caller should use camel_db_delete_uids to permanently delete the mi
-   from summary */
-void
-camel_ews_summary_delete_id	(CamelFolderSummary *summary,
-				 const gchar *uid)
-{
-	CamelMessageInfo *mi;
-
-	mi = camel_folder_summary_uid (summary, uid);
-	if (mi) {
-		CamelMessageInfoBase *dinfo = (CamelMessageInfoBase *) mi;
-		gint unread=0, deleted=0, junk=0;
-		guint32 flags;
-
-		flags = dinfo->flags;
-		if (!(flags & CAMEL_MESSAGE_SEEN))
-			unread = 1;
-
-		if (flags & CAMEL_MESSAGE_DELETED)
-			deleted = 1;
-
-		if (flags & CAMEL_MESSAGE_JUNK)
-			junk = 1;
-
-		if (unread)
-			summary->unread_count--;
-
-		if (deleted)
-			summary->deleted_count--;
-		if (junk)
-			summary->junk_count--;
-
-		if (junk && !deleted)
-			summary->junk_not_deleted_count--;
-
-		if (!junk &&  !deleted)
-			summary->visible_count--;
-
-		summary->saved_count--;
-		camel_message_info_free (mi);
-	}
-	camel_folder_summary_remove_uid_fast (summary, uid);
-}
-
 static gboolean
-ews_update_user_flags (CamelMessageInfo *info, CamelFlag *server_user_flags)
+ews_update_user_flags (CamelMessageInfo *info,
+                       CamelFlag *server_user_flags)
 {
 	gboolean changed = FALSE;
 	CamelMessageInfoBase *binfo = (CamelMessageInfoBase *) info;
@@ -528,52 +332,22 @@ ews_update_user_flags (CamelMessageInfo 
 }
 
 gboolean
-camel_ews_update_message_info_flags	(CamelFolderSummary *summary,
-					 CamelMessageInfo *info,
-					 guint32 server_flags,
-					 CamelFlag *server_user_flags)
+camel_ews_update_message_info_flags (CamelFolderSummary *summary,
+                                     CamelMessageInfo *info,
+                                     guint32 server_flags,
+                                     CamelFlag *server_user_flags)
 {
 	CamelEwsMessageInfo *einfo = (CamelEwsMessageInfo *) info;
 	gboolean changed = FALSE;
 
-	if (server_flags != einfo->server_flags)
-	{
+	if (server_flags != einfo->server_flags) {
 		guint32 server_set, server_cleared;
-		gint read=0, deleted=0, junk=0;
 
 		server_set = server_flags & ~einfo->server_flags;
 		server_cleared = einfo->server_flags & ~server_flags;
 
-		if (server_set & CAMEL_MESSAGE_SEEN)
-			read = 1;
-		else if (server_cleared & CAMEL_MESSAGE_SEEN)
-			read = -1;
-
-		if (server_set & CAMEL_MESSAGE_DELETED)
-			deleted = 1;
-		else if (server_cleared & CAMEL_MESSAGE_DELETED)
-			deleted = -1;
-
-		if (server_set & CAMEL_MESSAGE_JUNK)
-			junk = 1;
-		else if (server_cleared & CAMEL_MESSAGE_JUNK)
-			junk = -1;
-
-		if (read) {
-			summary->unread_count -= read;
-		}
-		if (deleted)
-			summary->deleted_count += deleted;
-		if (junk)
-			summary->junk_count += junk;
-		if (junk && !deleted)
-			summary->junk_not_deleted_count += junk;
-		if (junk ||  deleted)
-			summary->visible_count -= junk ? junk : deleted;
-
-		einfo->info.flags = (einfo->info.flags | server_set) & ~server_cleared;
+		camel_message_info_set_flags (info, server_set | server_cleared, (einfo->info.flags | server_set) & ~server_cleared);
 		einfo->server_flags = server_flags;
-		einfo->info.dirty = TRUE;
 		if (info->summary)
 			camel_folder_summary_touch (info->summary);
 		changed = TRUE;
@@ -587,31 +361,31 @@ camel_ews_update_message_info_flags	(Cam
 }
 
 void
-ews_summary_clear	(CamelFolderSummary *summary,
-			 gboolean uncache)
+ews_summary_clear (CamelFolderSummary *summary,
+                   gboolean uncache)
 {
 	CamelFolderChangeInfo *changes;
-	CamelMessageInfo *info;
-	gint i, count;
-	const gchar *uid;
+	GPtrArray *known_uids;
+	gint i;
 
 	changes = camel_folder_change_info_new ();
-	count = camel_folder_summary_count (summary);
-	for (i = 0; i < count; i++) {
-		if (!(info = camel_folder_summary_index (summary, i)))
+	known_uids = camel_folder_summary_get_array (summary);
+	for (i = 0; i < known_uids->len; i++) {
+		const gchar *uid = g_ptr_array_index (known_uids, i);
+
+		if (!uid)
 			continue;
 
-		uid = camel_message_info_uid (info);
 		camel_folder_change_info_remove_uid (changes, uid);
 		camel_folder_summary_remove_uid (summary, uid);
-		camel_message_info_free(info);
 	}
 
-	camel_folder_summary_clear_db (summary);
+	camel_folder_summary_clear (summary);
 	/*camel_folder_summary_save (summary);*/
 
 	if (camel_folder_change_info_changed (changes))
 		camel_folder_changed (summary->folder, changes);
 	camel_folder_change_info_free (changes);
+	camel_folder_summary_free_array (known_uids);
 }
 
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/camel/camel-ews-summary.h evolution-ews.sync-with-3.8.2/src/camel/camel-ews-summary.h
--- evolution-ews.git-gnome-3-0/src/camel/camel-ews-summary.h	2013-05-17 14:36:16.350669728 +0200
+++ evolution-ews.sync-with-3.8.2/src/camel/camel-ews-summary.h	2013-05-28 08:59:53.268712513 +0200
@@ -93,16 +93,9 @@ gboolean
 void	camel_ews_summary_add_message	(CamelFolderSummary *summary,
 					 const gchar *uid,
 					 CamelMimeMessage *message);
-void	camel_ews_summary_add_message_info
-					(CamelFolderSummary *summary,
-					 guint32 server_flags,
-					 CamelMessageInfo *info);
-void
-camel_ews_summary_delete_id		(CamelFolderSummary *summary,
-					 const gchar *id);
 void	ews_summary_clear		(CamelFolderSummary *summary,
 					 gboolean uncache);
 
 G_END_DECLS
 
-#endif /* CAMEL_GW_SUMMARY_H */
+#endif /* CAMEL_EWS_SUMMARY_H */
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/camel/camel-ews-transport.c evolution-ews.sync-with-3.8.2/src/camel/camel-ews-transport.c
--- evolution-ews.git-gnome-3-0/src/camel/camel-ews-transport.c	2013-05-17 14:36:16.351670594 +0200
+++ evolution-ews.sync-with-3.8.2/src/camel/camel-ews-transport.c	2013-05-28 08:59:53.267712492 +0200
@@ -52,7 +52,7 @@ ews_transport_connect_sync (CamelService
 
 static gchar *
 ews_transport_get_name (CamelService *service,
-                              gboolean brief)
+                        gboolean brief)
 {
 	CamelURL *url = camel_service_get_camel_url (service);
 
@@ -75,15 +75,64 @@ ews_send_to_sync (CamelTransport *transp
 		  GError **error)
 {
 	EVO2(GCancellable *cancellable = NULL;)
+	CamelInternetAddress *used_from;
 	CamelService *service;
 	EEwsConnection *cnc;
 	const gchar *host_url;
+	const gchar *ews_email;
 	CamelURL *url;
-	gboolean res;
+	gboolean success = FALSE;
 
 	service = CAMEL_SERVICE (transport);
 	url = camel_service_get_camel_url (service);
 	host_url = camel_url_get_param (url, "hosturl");
+	ews_email = camel_url_get_param (url, "email");
+
+	used_from = camel_mime_message_get_from (message);
+
+	if (!used_from && CAMEL_IS_INTERNET_ADDRESS (from))
+		used_from = CAMEL_INTERNET_ADDRESS (from);
+
+	if (!used_from || camel_address_length (CAMEL_ADDRESS (used_from)) == 0) {
+		g_set_error_literal (
+			error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
+			_("Cannot send message with no From address"));
+		goto exit;
+
+	} else if (camel_address_length (CAMEL_ADDRESS (used_from)) > 1) {
+		g_set_error_literal (
+			error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
+			_("Exchange server cannot send message with "
+			"multiple From addresses"));
+		goto exit;
+
+	} else {
+		const gchar *used_email = NULL;
+		gboolean addresses_match;
+
+		if (!camel_internet_address_get (used_from, 0, NULL, &used_email)) {
+			g_set_error_literal (
+				error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
+				_("Failed to read From address"));
+			goto exit;
+		}
+
+		addresses_match =
+			(ews_email != NULL) &&
+			(used_email != NULL) &&
+			(g_ascii_strcasecmp (ews_email, used_email) == 0);
+
+		if (!addresses_match) {
+			g_set_error (
+				error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
+				_("Exchange server cannot send message as "
+				"'%s', when the account was configured for "
+				"address '%s'"),
+				used_email ? used_email : "NULL",
+				ews_email ? ews_email : "NULL");
+			goto exit;
+		}
+	}
 
 	cnc = e_ews_connection_find (host_url, url->user);
 	if (!cnc) {
@@ -93,12 +142,15 @@ ews_send_to_sync (CamelTransport *transp
 		return FALSE;
 	}
 
-	res = camel_ews_utils_create_mime_message (cnc, "SendOnly", NULL,
-						   message, 0, from,
-						   NULL, NULL,
-						   cancellable, error);
+	success = camel_ews_utils_create_mime_message (
+		cnc, "SendOnly", NULL, message, 0,
+		from, NULL, NULL, cancellable, error);
+
 	g_object_unref (cnc);
-	return res;
+
+exit:
+
+	return success;
 }
 
 static void
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/camel/camel-ews-utils.c evolution-ews.sync-with-3.8.2/src/camel/camel-ews-utils.c
--- evolution-ews.git-gnome-3-0/src/camel/camel-ews-utils.c	2013-05-17 14:36:16.351670594 +0200
+++ evolution-ews.sync-with-3.8.2/src/camel/camel-ews-utils.c	2013-05-28 08:59:53.267712492 +0200
@@ -31,271 +31,65 @@
 #include <glib/gstdio.h>
 
 #include "camel-ews-utils.h"
-#include "ews-esource-utils.h"
 #include "e-ews-compat.h"
 #include "ews-camel-compat.h"
 #include "e-ews-message.h"
 
+#include "server/e-ews-gnome-3-8-compat.h"
+
 #define SUBFOLDER_DIR_NAME     "subfolders"
 #define SUBFOLDER_DIR_NAME_LEN 10
 
-/**
- * e_path_to_physical:
- * @prefix: a prefix to prepend to the path, or %NULL
- * @path: the virtual path to convert to a filesystem path.
- *
- * This converts the "virtual" path @path into an expanded form that
- * allows a given name to refer to both a file and a directory. The
- * expanded path will have a "subfolders" directory inserted between
- * each path component. If the path ends with "/", the returned
- * physical path will end with "/subfolders"
- *
- * If @prefix is non-%NULL, it will be prepended to the returned path.
- *
- * Returns: the expanded path
- **/
 gchar *
-e_path_to_physical (const gchar *prefix, const gchar *vpath)
-{
-	const gchar *p, *newp;
-	gchar *dp;
-	gchar *ppath;
-	gint ppath_len;
-	gint prefix_len;
-
-	while (*vpath == '/')
-		vpath++;
-	if (!prefix)
-		prefix = "";
-
-	/* Calculate the length of the real path. */
-	ppath_len = strlen (vpath);
-	ppath_len++;	/* For the ending zero.  */
-
-	prefix_len = strlen (prefix);
-	ppath_len += prefix_len;
-	ppath_len++;	/* For the separating slash.  */
-
-	/* Take account of the fact that we need to translate every
-	 * separator into 'subfolders/'.
-	 */
-	p = vpath;
-	while (1) {
-		newp = strchr (p, '/');
-		if (newp == NULL)
-			break;
-
-		ppath_len += SUBFOLDER_DIR_NAME_LEN;
-		ppath_len++; /* For the separating slash.  */
-
-		/* Skip consecutive slashes.  */
-		while (*newp == '/')
-			newp++;
-
-		p = newp;
-	};
-
-	ppath = g_malloc (ppath_len);
-	dp = ppath;
-
-	memcpy (dp, prefix, prefix_len);
-	dp += prefix_len;
-	*(dp++) = '/';
-
-	/* Copy the mangled path.  */
-	p = vpath;
-	while (1) {
-		newp = strchr (p, '/');
-		if (newp == NULL) {
-			strcpy (dp, p);
-			break;
-		}
-
-		memcpy (dp, p, newp - p + 1); /* '+ 1' to copy the slash too.  */
-		dp += newp - p + 1;
-
-		memcpy (dp, SUBFOLDER_DIR_NAME, SUBFOLDER_DIR_NAME_LEN);
-		dp += SUBFOLDER_DIR_NAME_LEN;
-
-		*(dp++) = '/';
-
-		/* Skip consecutive slashes.  */
-		while (*newp == '/')
-			newp++;
-
-		p = newp;
-	}
-
-	return ppath;
-}
-
-static gboolean
-find_folders_recursive (const gchar *physical_path, const gchar *path,
-			EPathFindFoldersCallback callback, gpointer data)
-{
-	GDir *dir;
-	gchar *subfolder_directory_path;
-	gboolean ok;
-
-	if (*path) {
-		if (!callback (physical_path, path, data))
-			return FALSE;
-
-		subfolder_directory_path = g_strdup_printf ("%s/%s", physical_path, SUBFOLDER_DIR_NAME);
-	} else {
-		/* On the top level, we have no folders and,
-		 * consequently, no subfolder directory.
-		 */
-
-		subfolder_directory_path = g_strdup (physical_path);
-	}
-
-	/* Now scan the subfolders and load them. */
-	dir = g_dir_open (subfolder_directory_path, 0, NULL);
-	if (dir == NULL) {
-		g_free (subfolder_directory_path);
-		return TRUE;
-	}
-
-	ok = TRUE;
-	while (ok) {
-		struct stat file_stat;
-		const gchar *dirent;
-		gchar *file_path;
-		gchar *new_path;
-
-		dirent = g_dir_read_name (dir);
-		if (dirent == NULL)
-			break;
-
-		file_path = g_strdup_printf ("%s/%s", subfolder_directory_path, dirent);
-
-		if (g_stat (file_path, &file_stat) < 0 ||
-		    !S_ISDIR (file_stat.st_mode)) {
-			g_free (file_path);
-			continue;
-		}
-
-		new_path = g_strdup_printf ("%s/%s", path, dirent);
-
-		ok = find_folders_recursive (file_path, new_path, callback, data);
-
-		g_free (file_path);
-		g_free (new_path);
-	}
-
-	g_dir_close (dir);
-	g_free (subfolder_directory_path);
-
-	return ok;
-}
-
-/**
- * e_path_find_folders:
- * @prefix: directory to start from
- * @callback: Callback to invoke on each folder
- * @data: Data for @callback
- *
- * Walks the folder tree starting at @prefix and calls @callback
- * on each folder.
- *
- * Returns: %TRUE on success, %FALSE if an error occurs at any point
- **/
-gboolean
-e_path_find_folders (const gchar *prefix,
-		     EPathFindFoldersCallback callback,
-		     gpointer data)
+camel_ews_utils_build_folder_uri (CamelEwsStore *ews_store,
+				  const gchar *fid)
 {
-	return find_folders_recursive (prefix, "", callback, data);
-}
-
-/**
- * e_path_rmdir:
- * @prefix: a prefix to prepend to the path, or %NULL
- * @path: the virtual path to convert to a filesystem path.
- *
- * This removes the directory pointed to by @prefix and @path
- * and attempts to remove its parent "subfolders" directory too
- * if it's empty.
- *
- * Returns: -1 (with errno set) if it failed to rmdir the
- * specified directory. 0 otherwise, whether or not it removed
- * the parent directory.
- **/
-gint
-e_path_rmdir (const gchar *prefix, const gchar *vpath)
-{
-	gchar *physical_path, *p;
+	gchar *url, *full_name, *uri;
+	CamelURL *curl;
 
-	/* Remove the directory itself */
-	physical_path = e_path_to_physical (prefix, vpath);
-	if (g_rmdir (physical_path) == -1) {
-		g_free (physical_path);
-		return -1;
-	}
+	curl = camel_service_get_camel_url (CAMEL_SERVICE (ews_store));
+	url = camel_url_to_string (curl,
+			(CAMEL_URL_HIDE_PASSWORD|
+			 CAMEL_URL_HIDE_PARAMS|
+			 CAMEL_URL_HIDE_AUTH) );
 
-	/* Attempt to remove its parent "subfolders" directory,
-	 * ignoring errors since it might not be empty.
-	 */
+	if (url[strlen (url) - 1] != '/') {
+		gchar *temp_url;
 
-	p = strrchr (physical_path, '/');
-	if (p[1] == '\0') {
-		g_free (physical_path);
-		return 0;
-	}
-	*p = '\0';
-	p = strrchr (physical_path, '/');
-	if (!p || strcmp (p + 1, SUBFOLDER_DIR_NAME) != 0) {
-		g_free (physical_path);
-		return 0;
+		temp_url = g_strconcat (url, "/", NULL);
+		g_free ((gchar *)url);
+		url = temp_url;
 	}
 
-	g_rmdir (physical_path);
-	g_free (physical_path);
-	return 0;
-}
-
-void
-do_flags_diff (flags_diff_t *diff, guint32 old, guint32 _new)
-{
-	diff->changed = old ^ _new;
-	diff->bits = _new & diff->changed;
-}
-
-gchar *
-ews_concat ( const gchar *prefix, const gchar *suffix)
-{
-	gsize len;
-
-	len = strlen (prefix);
-	if (len == 0 || prefix[len - 1] == '/')
-		return g_strdup_printf ("%s%s", prefix, suffix);
-	else
-		return g_strdup_printf ("%s%c%s", prefix, '/', suffix);
-}
-
-void
-strip_lt_gt (gchar **string, gint s_offset, gint e_offset)
-{
-	gchar *temp = NULL;
-	gint len;
+	full_name = camel_ews_store_summary_get_folder_full_name (ews_store->summary, fid, NULL);
+	uri = g_strconcat (url, full_name, NULL);
 
-	temp = g_strdup (*string);
-	len = strlen (*string);
+	g_free (full_name);
+	g_free (url);
 
-	*string = (gchar *)g_malloc0 (len-1);
-	*string = memcpy(*string, temp+s_offset, len-e_offset);
-	g_free (temp);
+	return uri;
 }
 
 CamelFolderInfo *
-camel_ews_utils_build_folder_info (CamelEwsStore *store, const gchar *fid)
+camel_ews_utils_build_folder_info (CamelEwsStore *store,
+                                   const gchar *fid)
 {
 	CamelEwsStoreSummary *ews_summary = store->summary;
 	CamelFolderInfo *fi;
 	gchar *url;
 	CamelURL *curl;
 
+	fi = camel_folder_info_new ();
+	fi->full_name = camel_ews_store_summary_get_folder_full_name (
+		ews_summary, fid, NULL);
+
+	if (!fi->full_name) {
+		camel_folder_info_free (fi);
+		g_warn_if_reached ();
+
+		return NULL;
+	}
+
 	curl = camel_service_get_camel_url (CAMEL_SERVICE (store));
 	url = camel_url_to_string (curl,
 			(CAMEL_URL_HIDE_PASSWORD|
@@ -310,139 +104,130 @@ camel_ews_utils_build_folder_info (Camel
 		url = temp_url;
 	}
 
-	fi = camel_folder_info_new ();
-	fi->full_name = camel_ews_store_summary_get_folder_full_name (ews_summary,
-								      fid, NULL);
-#if ! EDS_CHECK_VERSION(3,1,0)	
-	fi->name = camel_ews_store_summary_get_folder_name (ews_summary,
-							    fid, NULL);
+	fi->name = camel_ews_store_summary_get_folder_name (
+		ews_summary, fid, NULL);
 	fi->uri = g_strconcat (url, fi->full_name, NULL);
-#else
-	fi->display_name = camel_ews_store_summary_get_folder_name (ews_summary, fid, NULL);
-#endif
-
-	fi->flags = camel_ews_store_summary_get_folder_flags (ews_summary,
-							      fid, NULL);
-	fi->unread = camel_ews_store_summary_get_folder_unread (ews_summary,
-								fid, NULL);
-	fi->total = camel_ews_store_summary_get_folder_total (ews_summary,
-							      fid, NULL);
+	fi->flags = camel_ews_store_summary_get_folder_flags (
+		ews_summary, fid, NULL);
+	fi->unread = camel_ews_store_summary_get_folder_unread (
+		ews_summary, fid, NULL);
+	fi->total = camel_ews_store_summary_get_folder_total (
+		ews_summary, fid, NULL);
+
+	if (!(fi->flags & CAMEL_FOLDER_TYPE_MASK)) {
+		switch (camel_ews_store_summary_get_folder_type (ews_summary, fid, NULL)) {
+		case E_EWS_FOLDER_TYPE_CALENDAR:
+			fi->flags |= CAMEL_FOLDER_TYPE_EVENTS;
+			break;
+		case E_EWS_FOLDER_TYPE_CONTACTS:
+			fi->flags |= CAMEL_FOLDER_TYPE_CONTACTS;
+			break;
+		case E_EWS_FOLDER_TYPE_TASKS:
+			fi->flags |= CAMEL_FOLDER_TYPE_TASKS;
+			break;
+		case E_EWS_FOLDER_TYPE_MEMOS:
+			fi->flags |= CAMEL_FOLDER_TYPE_MEMOS;
+			break;
+		default:
+			break;
+		}
+	}
 
 	g_free (url);
 
 	return fi;
 }
 
-struct remove_esrc_data {
-	gchar *fid;
-	gchar *account_name;
-	EwsFolderType ftype;
-};
-
-static gboolean ews_do_remove_esource (gpointer user_data)
-{
-	struct remove_esrc_data *remove_data = user_data;
-
-
-	ews_esource_utils_remove_esource (remove_data->fid,
-					  remove_data->account_name,
-					  remove_data->ftype);
-	g_free (remove_data->fid);
-	g_free (remove_data->account_name);
-	g_free (remove_data);
-
-	return FALSE;
-}
-
 static void
-sync_deleted_folders (CamelEwsStore *store, GSList *deleted_folders)
+sync_deleted_folders (CamelEwsStore *store,
+                      GSList *deleted_folders)
 {
 	CamelEwsStoreSummary *ews_summary = store->summary;
 	GSList *l;
 
 	for (l = deleted_folders; l != NULL; l = g_slist_next (l)) {
 		const gchar *fid = l->data;
-		EwsFolderType ftype;
+		EEwsFolderType ftype;
 		CamelFolderInfo *fi;
 		GError *error = NULL;
 
 		if (!camel_ews_store_summary_has_folder (ews_summary, fid))
 			continue;
 
-		ftype = camel_ews_store_summary_get_folder_type (ews_summary, fid, NULL);
-		if (ftype == EWS_FOLDER_TYPE_MAILBOX) {
+		ftype = camel_ews_store_summary_get_folder_type (
+			ews_summary, fid, NULL);
+		if (ftype == E_EWS_FOLDER_TYPE_MAILBOX) {
 			fi = camel_ews_utils_build_folder_info (store, fid);
 
 			camel_ews_store_summary_remove_folder (ews_summary, fid, &error);
-			camel_store_folder_deleted ((CamelStore *) store, fi);
 
-			g_clear_error (&error);
-		} else {
-			struct remove_esrc_data *remove_data = g_new0(struct remove_esrc_data, 1);
-			CamelURL *url = camel_service_get_camel_url (CAMEL_SERVICE (store));
-
-			remove_data->fid = g_strdup (fid);
-			remove_data->account_name = g_strdup (camel_url_get_param (url, "email"));
-			remove_data->ftype = ftype;
+			if ((fi->flags & CAMEL_FOLDER_SUBSCRIBED) != 0) {
+				camel_subscribable_folder_unsubscribed (CAMEL_SUBSCRIBABLE (store), fi);
+				camel_store_folder_deleted (CAMEL_STORE (store), fi);
+			}
 
-			/* This uses GConf so has to be done in the main thread */
-			g_idle_add_full (G_PRIORITY_DEFAULT, ews_do_remove_esource, remove_data, NULL);
+			g_clear_error (&error);
 		}
 	}
 }
 
-static gboolean ews_utils_rename_folder (CamelEwsStore *store, EwsFolderType ftype,
-					 const gchar *fid, const gchar *changekey,
-					 const gchar *pfid, const gchar *display_name,
-					 const gchar *old_fname, GError **error)
+static gboolean
+ews_utils_rename_folder (CamelEwsStore *store,
+                         EEwsFolderType ftype,
+                         const gchar *fid,
+                         const gchar *changekey,
+                         const gchar *pfid,
+                         const gchar *display_name,
+                         const gchar *old_fname,
+                         GError **error)
 {
 	CamelEwsStoreSummary *ews_summary = store->summary;
 	CamelFolderInfo *fi;
 
 	camel_ews_store_summary_set_change_key (ews_summary, fid, changekey);
 	if (display_name)
-		camel_ews_store_summary_set_folder_name (ews_summary, fid, display_name);
+		camel_ews_store_summary_set_folder_name (
+			ews_summary, fid, display_name);
 	if (pfid)
-		camel_ews_store_summary_set_parent_folder_id (ews_summary, fid, pfid);
+		camel_ews_store_summary_set_parent_folder_id (
+			ews_summary, fid, pfid);
 
-	if (ftype == EWS_FOLDER_TYPE_MAILBOX) {
+	if (ftype == E_EWS_FOLDER_TYPE_MAILBOX) {
 		fi = camel_ews_utils_build_folder_info (store, fid);
-		camel_store_folder_renamed ((CamelStore *) store, old_fname, fi);
+		camel_store_folder_renamed (CAMEL_STORE (store), old_fname, fi);
 	}
 
 	return TRUE;
 }
 
 static void
-sync_updated_folders (CamelEwsStore *store, GSList *updated_folders)
+sync_updated_folders (CamelEwsStore *store,
+                      GSList *updated_folders)
 {
 	CamelEwsStoreSummary *ews_summary = store->summary;
 	GSList *l;
 
 	for (l = updated_folders; l != NULL; l = g_slist_next (l)) {
-		EEwsFolder *ews_folder = (EEwsFolder *)	l->data;
-		EwsFolderType ftype;
+		EEwsFolder *ews_folder = (EEwsFolder *) l->data;
+		EEwsFolderType ftype;
 		gchar *folder_name;
 		gchar *display_name;
 		const EwsFolderId *fid, *pfid;
 
 		ftype = e_ews_folder_get_folder_type (ews_folder);
-		if (ftype == EWS_FOLDER_TYPE_CALENDAR ||
-		    ftype == EWS_FOLDER_TYPE_TASKS ||
-		    ftype == EWS_FOLDER_TYPE_CONTACTS) {
-			/* TODO Update esource */
-		} else 	if (ftype != EWS_FOLDER_TYPE_MAILBOX)
+		if (ftype != E_EWS_FOLDER_TYPE_MAILBOX)
 			continue;
 
 		fid = e_ews_folder_get_id (ews_folder);
-		folder_name = camel_ews_store_summary_get_folder_full_name (ews_summary, fid->id, NULL);
+		folder_name = camel_ews_store_summary_get_folder_full_name (
+			ews_summary, fid->id, NULL);
 
 		pfid = e_ews_folder_get_parent_id (ews_folder);
 		display_name = g_strdup (e_ews_folder_get_name (ews_folder));
 
 		/* If the folder is moved or renamed (which are separate
-		   operations in Exchange, unfortunately, then the name
-		   or parent folder will change. Handle both... */
+		 * operations in Exchange, unfortunately, then the name
+		 * or parent folder will change. Handle both... */
 		if (pfid || display_name) {
 			GError *error = NULL;
 			gchar *new_fname = NULL;
@@ -451,19 +236,21 @@ sync_updated_folders (CamelEwsStore *sto
 				gchar *pfname;
 
 				/* If the display name wasn't changed, its basename is still
-				   the same as it was before... */
+				 * the same as it was before... */
 				if (!display_name)
-					display_name = camel_ews_store_summary_get_folder_name (ews_summary,
-										fid->id, NULL);
+					display_name = camel_ews_store_summary_get_folder_name (
+						ews_summary, fid->id, NULL);
 				if (!display_name)
 					goto done;
 
-				pfname = camel_ews_store_summary_get_folder_full_name (ews_summary, pfid->id, NULL);
+				pfname = camel_ews_store_summary_get_folder_full_name (
+					ews_summary, pfid->id, NULL);
 
 				/* If the lookup failed, it'll be because the new parent folder
-				   is the message folder root. */
+				 * is the message folder root. */
 				if (pfname) {
-					new_fname = g_strconcat (pfname, "/", display_name, NULL);
+					new_fname = g_strconcat (
+						pfname, "/", display_name, NULL);
 					g_free (pfname);
 				} else
 					new_fname = g_strdup (display_name);
@@ -474,17 +261,20 @@ sync_updated_folders (CamelEwsStore *sto
 				/* Append new display_name to old parent directory name... */
 				last_slash = g_strrstr (folder_name, "/");
 				if (last_slash)
-					new_fname = g_strdup_printf ("%.*s/%s", (int)(last_slash - folder_name),
-								     folder_name, display_name);
+					new_fname = g_strdup_printf (
+						"%.*s/%s",
+						(gint)(last_slash - folder_name),
+						folder_name, display_name);
 				else /* ...unless it was a child of the root folder */
 					new_fname = g_strdup (display_name);
 			}
 
-			if (strcmp(new_fname, folder_name))
-				ews_utils_rename_folder (store, ftype,
-							 fid->id, fid->change_key,
-							 pfid?pfid->id:NULL,
-							 display_name, folder_name, &error);
+			if (strcmp (new_fname, folder_name))
+				ews_utils_rename_folder (
+					store, ftype,
+					fid->id, fid->change_key,
+					pfid ? pfid->id : NULL,
+					display_name, folder_name, &error);
 			g_free (new_fname);
 			g_clear_error (&error);
 		}
@@ -495,15 +285,16 @@ sync_updated_folders (CamelEwsStore *sto
 }
 
 /* FIXME get the real folder ids of the system folders using
-   by fetching them using distinguished folder ids once */
+ * by fetching them using distinguished folder ids once */
 static void
-add_folder_to_summary (CamelEwsStore *store, EEwsFolder *folder)
+add_folder_to_summary (CamelEwsStore *store,
+                       EEwsFolder *folder)
 {
 	CamelEwsStoreSummary *ews_summary = store->summary;
 	const EwsFolderId *pfid, *fid;
 	const gchar *dname;
-	gchar *fname;
-	gint64 flags = 0, unread, total, ftype;
+	gint64 unread, total;
+	EEwsFolderType ftype;
 
 	fid = e_ews_folder_get_id (folder);
 	pfid = e_ews_folder_get_parent_id (folder);
@@ -512,156 +303,131 @@ add_folder_to_summary (CamelEwsStore *st
 	unread = e_ews_folder_get_unread_count (folder);
 	ftype = e_ews_folder_get_folder_type (folder);
 
-	camel_ews_store_summary_new_folder (ews_summary, fid->id,
-					    pfid->id, fid->change_key,
-					    dname, ftype, 0, total);
-	camel_ews_store_summary_set_folder_unread (ews_summary, fid->id, unread);
-
-	fname = camel_ews_store_summary_get_folder_full_name (ews_summary, fid->id, NULL);
-	if (!g_ascii_strcasecmp (fname, "Inbox")) {
-		flags |= CAMEL_FOLDER_SYSTEM | CAMEL_FOLDER_TYPE_INBOX;
-	} else if (!g_ascii_strcasecmp (fname, "Drafts")) {
-		flags |= CAMEL_FOLDER_SYSTEM;
-	} else if (!g_ascii_strcasecmp (fname, "Deleted items")) {
-		flags |= CAMEL_FOLDER_SYSTEM |CAMEL_FOLDER_TYPE_TRASH;
-	} else if (!g_ascii_strcasecmp (fname, "Outbox")) {
-		flags |= CAMEL_FOLDER_SYSTEM | CAMEL_FOLDER_TYPE_OUTBOX;
-	}
-	g_free (fname);
-
-	camel_ews_store_summary_set_folder_flags (ews_summary, fid->id, flags);
-}
-
-struct add_esrc_data {
-	EEwsFolder *folder;
-	gchar *account_uri;
-	gchar *account_name;
-	gchar *username;
-	gchar *email_id;
-	gchar *hosturl;
-	gint refresh_timeout;
-};
-
-static gboolean ews_do_add_esource (gpointer user_data)
-{
-	struct add_esrc_data *add_data = user_data;
-
-
-	ews_esource_utils_add_esource (add_data->folder, add_data->account_uri,
-				       add_data->account_name,
-				       add_data->username, add_data->email_id,
-				       add_data->hosturl, add_data->refresh_timeout);
-
-	g_object_unref (add_data->folder);
-	g_free (add_data->account_uri);
-	g_free (add_data->account_name);
-	g_free (add_data->username);
-	g_free (add_data->email_id);
-	g_free (add_data->hosturl);
-	g_free (add_data);
-
-	return FALSE;
+	camel_ews_store_summary_new_folder (
+		ews_summary, fid->id,
+		pfid ? pfid->id : NULL, fid->change_key,
+		dname, ftype, 0, total,
+		e_ews_folder_get_foreign (folder),
+		FALSE);
+	camel_ews_store_summary_set_folder_unread (
+		ews_summary, fid->id, unread);
 }
 
-
 static void
-sync_created_folders (CamelEwsStore *ews_store, GSList *created_folders)
+sync_created_folders (CamelEwsStore *ews_store,
+                      GSList *created_folders,
+		      GSList **created_folder_ids)
 {
 	GSList *l;
 
 	for (l = created_folders; l != NULL; l = g_slist_next (l)) {
 		EEwsFolder *folder = (EEwsFolder *) l->data;
-		EwsFolderType ftype;
+		EEwsFolderType ftype;
 		CamelFolderInfo *fi;
 		const EwsFolderId *fid;
 
 		ftype = e_ews_folder_get_folder_type (folder);
-		if (ftype == EWS_FOLDER_TYPE_CALENDAR ||
-		    ftype == EWS_FOLDER_TYPE_TASKS ||
-		    ftype == EWS_FOLDER_TYPE_CONTACTS) {
-			struct add_esrc_data *add_data = g_new0 (struct add_esrc_data, 1);
-			CamelURL *url = camel_service_get_camel_url (CAMEL_SERVICE (ews_store));
-
-			add_data->folder = g_object_ref (folder);
-			add_data->account_uri = camel_url_to_string (url, CAMEL_URL_HIDE_PASSWORD | CAMEL_URL_HIDE_PARAMS);
-			add_data->account_name = g_strdup (camel_url_get_param (url, "email"));
-			add_data->username = g_strdup (url->user);
-			/* Duplicate... for now */
-			add_data->email_id = g_strdup (camel_url_get_param (url, "email"));
-			add_data->hosturl = g_strdup (camel_url_get_param (url, "hosturl"));
-			/* FIXME pass right refresh timeout */
-
-			/* This uses GConf so has to be done in the main thread */
-			g_idle_add_full (G_PRIORITY_DEFAULT, ews_do_add_esource, add_data, NULL);
-
-		} else 	if (ftype != EWS_FOLDER_TYPE_MAILBOX)
+		if (ftype != E_EWS_FOLDER_TYPE_MAILBOX)
 			continue;
 
 		fid = e_ews_folder_get_id (folder);
 
 		/* FIXME: Sort folders so that a child is always added *after*
-		   its parent. But since the old code was already completely
-		   broken and would just go into an endless loop if the server
-		   didn't return the folders in the 'right' order for that,
-		   let's worry about that in a later commit. */
+		 * its parent. But since the old code was already completely
+		 * broken and would just go into an endless loop if the server
+		 * didn't return the folders in the 'right' order for that,
+		 * let's worry about that in a later commit. */
 		add_folder_to_summary (ews_store, folder);
 
-		if (ftype == EWS_FOLDER_TYPE_MAILBOX) {
-			fi = camel_ews_utils_build_folder_info (ews_store, fid->id);
-			camel_store_folder_created ((CamelStore *) ews_store, fi);
+		if (ftype != E_EWS_FOLDER_TYPE_MAILBOX)
+			continue;
+
+		if (created_folder_ids) {
+			*created_folder_ids = g_slist_append (*created_folder_ids, g_strdup (fid->id));
+		} else {
+			fi = camel_ews_utils_build_folder_info (
+				ews_store, fid->id);
+			camel_store_folder_created (
+				CAMEL_STORE (ews_store), fi);
+			camel_subscribable_folder_subscribed (
+				CAMEL_SUBSCRIBABLE (ews_store), fi);
+			camel_folder_info_free (fi);
 		}
 	}
 }
 
 void
-ews_utils_sync_folders (CamelEwsStore *ews_store, GSList *created_folders, GSList *deleted_folders, GSList *updated_folders)
+ews_utils_sync_folders (CamelEwsStore *ews_store,
+                        GSList *created_folders,
+                        GSList *deleted_folders,
+                        GSList *updated_folders,
+			GSList **created_folder_ids)
 {
 	GError *error = NULL;
 
 	sync_deleted_folders (ews_store, deleted_folders);
 	sync_updated_folders (ews_store, updated_folders);
-	sync_created_folders (ews_store, created_folders);
+	sync_created_folders (ews_store, created_folders, created_folder_ids);
 
 	camel_ews_store_summary_save (ews_store->summary, &error);
 	if (error != NULL) {
-		g_print ("Error while saving store summary %s \n", error->message);
+		g_print (
+			"Error while saving store summary %s \n",
+			error->message);
 		g_clear_error (&error);
 	}
-	return;
 }
 
 void
-camel_ews_utils_sync_deleted_items (CamelEwsFolder *ews_folder, GSList *items_deleted)
+camel_ews_utils_sync_deleted_items (CamelEwsFolder *ews_folder,
+                                    GSList *items_deleted)
 {
+	CamelStore *store;
 	CamelFolder *folder;
 	const gchar *full_name;
 	CamelFolderChangeInfo *ci;
 	CamelEwsStore *ews_store;
 	GSList *l;
+	GSList *items_deleted_list = NULL;
 
 	ci = camel_folder_change_info_new ();
-	ews_store = (CamelEwsStore *) camel_folder_get_parent_store ((CamelFolder *) ews_folder);
 
-	folder = (CamelFolder *) ews_folder;
+	folder = CAMEL_FOLDER (ews_folder);
 	full_name = camel_folder_get_full_name (folder);
 
+	store = camel_folder_get_parent_store (folder);
+	ews_store = CAMEL_EWS_STORE (store);
+
 	for (l = items_deleted; l != NULL; l = g_slist_next (l)) {
-		gchar *id = (gchar *) l->data;
+		const gchar *id = l->data;
 
-		camel_ews_summary_delete_id (folder->summary, id);
+		items_deleted_list = g_slist_prepend (
+			items_deleted_list, (gpointer) id);
+
+		camel_folder_summary_remove_uid (folder->summary, id);
 		camel_folder_change_info_remove_uid (ci, id);
 	}
-	camel_db_delete_uids (((CamelStore *)ews_store)->cdb_w, full_name, items_deleted, NULL);
 
-	camel_folder_changed ((CamelFolder *) ews_folder, ci);
+	items_deleted_list = g_slist_reverse (items_deleted_list);
+	camel_db_delete_uids (
+		CAMEL_STORE (ews_store)->cdb_w,
+		full_name, items_deleted_list, NULL);
+	g_slist_free (items_deleted_list);
+
+	if (camel_folder_change_info_changed (ci)) {
+		camel_folder_summary_touch (folder->summary);
+		camel_folder_summary_save_to_db (folder->summary, NULL);
+		camel_folder_changed (folder, ci);
+	}
 	camel_folder_change_info_free (ci);
 
 	g_slist_foreach (items_deleted, (GFunc) g_free, NULL);
 	g_slist_free (items_deleted);
 }
 
-static const gchar*
-ews_utils_rename_label (const gchar *cat, int from_cat)
+static const gchar *
+ews_utils_rename_label (const gchar *cat,
+                        gint from_cat)
 {
 	gint i;
 
@@ -692,7 +458,8 @@ ews_utils_rename_label (const gchar *cat
 }
 
 void
-ews_utils_replace_server_user_flags (ESoapMessage *msg, CamelEwsMessageInfo *mi)
+ews_utils_replace_server_user_flags (ESoapMessage *msg,
+                                     CamelEwsMessageInfo *mi)
 {
 	const CamelFlag *flag;
 
@@ -715,7 +482,8 @@ ews_utils_replace_server_user_flags (ESo
 }
 
 static void
-ews_utils_merge_server_user_flags (EEwsItem *item, CamelEwsMessageInfo *mi)
+ews_utils_merge_server_user_flags (EEwsItem *item,
+                                   CamelEwsMessageInfo *mi)
 {
 	GSList *list = NULL;
 	const GSList *p;
@@ -724,19 +492,20 @@ ews_utils_merge_server_user_flags (EEwsI
 	/* transfer camel flags to a list */
 	for (flag = camel_message_info_user_flags (&mi->info); flag;
 	     flag = flag->next)
-		list = g_slist_append (list, (gchar *)flag->name);
+		list = g_slist_append (list, (gchar *) flag->name);
 
 	/* we're transferring from server only, so just dump them */
 	for (p = list; p; p = p->next) {
 		camel_flag_set (&mi->info.user_flags, p->data, 0);
 	}
-	//g_slist_foreach(list, (GFunc)g_free, NULL);
-	g_slist_free(list);
+	//g_slist_foreach (list, (GFunc) g_free, NULL);
+	g_slist_free (list);
 
 	/* now transfer over all the categories */
 	for (p = e_ews_item_get_categories (item); p; p = p->next) {
-		camel_flag_set (&mi->info.user_flags,
-				ews_utils_rename_label(p->data, 1), 1);
+		camel_flag_set (
+			&mi->info.user_flags,
+			ews_utils_rename_label (p->data, 1), 1);
 	}
 }
 
@@ -775,38 +544,38 @@ ews_utils_get_server_flags (EEwsItem *it
 }
 
 static const gchar *
-form_email_string_from_mb (const EwsMailbox *mb)
+form_email_string_from_mb (EEwsConnection *cnc,
+                           const EwsMailbox *mb,
+                           GCancellable *cancellable)
 {
-	const gchar *ret = NULL;
-
 	if (mb) {
 		GString *str;
+		const gchar *email = NULL;
+
+		if (g_strcmp0 (mb->routing_type, "EX") == 0)
+			email = e_ews_item_util_strip_ex_address (mb->email);
 
 		str = g_string_new ("");
 		if (mb->name && mb->name[0]) {
-			str = g_string_append (str, mb->name);
-			str = g_string_append (str, " ");
-		} else {
-			str = g_string_append (str, mb->email);
-			str = g_string_append (str, " ");
+			g_string_append (str, mb->name);
+			g_string_append (str, " ");
 		}
 
-		if (mb->email) {
+		if (mb->email || email) {
 			g_string_append (str, "<");
-			str = g_string_append (str, mb->email);
+			g_string_append (str, email ? email : mb->email);
 			g_string_append (str, ">");
 		}
 
-		ret = camel_pstring_add (str->str, TRUE);
-		g_string_free (str, FALSE);
-
-		return ret;
+		return camel_pstring_add (g_string_free (str, FALSE), TRUE);
 	} else
 	       return camel_pstring_strdup ("");
 }
 
 static const gchar *
-form_recipient_list (const GSList *recipients)
+form_recipient_list (EEwsConnection *cnc,
+                     const GSList *recipients,
+                     GCancellable *cancellable)
 {
 	const GSList *l;
 	GString *str = NULL;
@@ -817,7 +586,7 @@ form_recipient_list (const GSList *recip
 
 	for (l = recipients; l != NULL; l = g_slist_next (l)) {
 		EwsMailbox *mb = (EwsMailbox *) l->data;
-		const gchar *mb_str = form_email_string_from_mb (mb);
+		const gchar *mb_str = form_email_string_from_mb (cnc, mb, cancellable);
 
 		if (!str)
 			str = g_string_new ("");
@@ -852,7 +621,8 @@ get_md5_digest (const guchar *str)
 }
 
 static void
-ews_set_threading_data (CamelEwsMessageInfo *mi, EEwsItem *item)
+ews_set_threading_data (CamelEwsMessageInfo *mi,
+                        EEwsItem *item)
 {
 	const gchar *references, *inreplyto;
 	gint count = 0;
@@ -865,8 +635,10 @@ ews_set_threading_data (CamelEwsMessageI
 	message_id = e_ews_item_get_msg_id (item);
 	msgid = camel_header_msgid_decode (message_id);
 	if (msgid) {
-		digest = get_md5_digest ((const guchar *)msgid);
-		memcpy (mi->info.message_id.id.hash, digest, sizeof (mi->info.message_id.id.hash));
+		digest = get_md5_digest ((const guchar *) msgid);
+		memcpy (
+			mi->info.message_id.id.hash,
+			digest, sizeof (mi->info.message_id.id.hash));
 		g_free (digest);
 		g_free (msgid);
 	}
@@ -886,13 +658,17 @@ ews_set_threading_data (CamelEwsMessageI
 		return;
 
 	count = camel_header_references_list_size (&refs);
-	mi->info.references = g_malloc (sizeof (*mi->info.references) + ((count-1) * sizeof (mi->info.references->references[0])));
+	mi->info.references = g_malloc (
+		sizeof (*mi->info.references) + ((count - 1) *
+		sizeof (mi->info.references->references[0])));
 	scan = refs;
 	count = 0;
 
 	while (scan) {
 		digest = get_md5_digest ((const guchar *) scan->id);
-		memcpy (mi->info.references->references[count].id.hash, digest, sizeof (mi->info.message_id.id.hash));
+		memcpy (
+			mi->info.references->references[count].id.hash,
+			digest, sizeof (mi->info.message_id.id.hash));
 		g_free (digest);
 
 		count++;
@@ -904,29 +680,37 @@ ews_set_threading_data (CamelEwsMessageI
 }
 
 void
-camel_ews_utils_sync_updated_items (CamelEwsFolder *ews_folder, GSList *items_updated)
+camel_ews_utils_sync_updated_items (CamelEwsFolder *ews_folder,
+                                    GSList *items_updated)
 {
 	CamelFolder *folder;
 	CamelFolderChangeInfo *ci;
 	GSList *l;
 
 	ci = camel_folder_change_info_new ();
-	folder = (CamelFolder *) ews_folder;
+	folder = CAMEL_FOLDER (ews_folder);
 
 	for (l = items_updated; l != NULL; l = g_slist_next (l)) {
 		EEwsItem *item = (EEwsItem *) l->data;
 		const EwsId *id;
 		CamelEwsMessageInfo *mi;
 
+		if (e_ews_item_get_item_type (item) == E_EWS_ITEM_TYPE_ERROR) {
+			g_object_unref (item);
+			continue;
+		}
+
 		id = e_ews_item_get_id (item);
-		mi = (CamelEwsMessageInfo *) camel_folder_summary_uid (folder->summary, id->id);
+		mi = (CamelEwsMessageInfo *)
+			camel_folder_summary_get (folder->summary, id->id);
 		if (mi) {
 			gint server_flags;
 
 			server_flags = ews_utils_get_server_flags (item);
 			ews_utils_merge_server_user_flags (item, mi);
-			if (camel_ews_update_message_info_flags (folder->summary, (CamelMessageInfo *)mi,
-								 server_flags, NULL))
+			if (camel_ews_update_message_info_flags (
+				folder->summary, (CamelMessageInfo *) mi,
+				server_flags, NULL))
 				camel_folder_change_info_change_uid (ci, mi->info.uid);
 
 			g_free (mi->change_key);
@@ -941,14 +725,20 @@ camel_ews_utils_sync_updated_items (Came
 		g_object_unref (item);
 	}
 
-	camel_folder_summary_save_to_db (folder->summary, NULL);
-	camel_folder_changed ((CamelFolder *) ews_folder, ci);
+	if (camel_folder_change_info_changed (ci)) {
+		camel_folder_summary_touch (folder->summary);
+		camel_folder_summary_save_to_db (folder->summary, NULL);
+		camel_folder_changed (CAMEL_FOLDER (ews_folder), ci);
+	}
 	camel_folder_change_info_free (ci);
 	g_slist_free (items_updated);
 }
 
 void
-camel_ews_utils_sync_created_items (CamelEwsFolder *ews_folder, GSList *items_created)
+camel_ews_utils_sync_created_items (CamelEwsFolder *ews_folder,
+                                    EEwsConnection *cnc,
+                                    GSList *items_created,
+                                    GCancellable *cancellable)
 {
 	CamelFolder *folder;
 	CamelFolderChangeInfo *ci;
@@ -958,7 +748,7 @@ camel_ews_utils_sync_created_items (Came
 		return;
 
 	ci = camel_folder_change_info_new ();
-	folder = (CamelFolder *) ews_folder;
+	folder = CAMEL_FOLDER (ews_folder);
 
 	for (l = items_created; l != NULL; l = g_slist_next (l)) {
 		EEwsItem *item = (EEwsItem *) l->data;
@@ -973,32 +763,44 @@ camel_ews_utils_sync_created_items (Came
 		if (!item)
 			continue;
 
+		if (e_ews_item_get_item_type (item) == E_EWS_ITEM_TYPE_ERROR) {
+			g_object_unref (item);
+			continue;
+		}
+
 		id = e_ews_item_get_id (item);
-		mi = (CamelEwsMessageInfo *) camel_folder_summary_uid (folder->summary, id->id);
+		mi = (CamelEwsMessageInfo *)
+			camel_folder_summary_get (folder->summary, id->id);
 		if (mi) {
 			camel_message_info_free (mi);
 			g_object_unref (item);
 			continue;
 		}
 
-		mi = (CamelEwsMessageInfo *)camel_message_info_new (folder->summary);
+		mi = (CamelEwsMessageInfo *)
+			camel_message_info_new (folder->summary);
 
 		if (mi->info.content == NULL) {
-			mi->info.content = camel_folder_summary_content_info_new (folder->summary);
-			mi->info.content->type = camel_content_type_new ("multipart", "mixed");
+			mi->info.content =
+				camel_folder_summary_content_info_new (
+				folder->summary);
+			mi->info.content->type =
+				camel_content_type_new ("multipart", "mixed");
 		}
 
 		item_type = e_ews_item_get_item_type (item);
-		if	(item_type == E_EWS_ITEM_TYPE_CALENDAR_ITEM ||
+		if (item_type == E_EWS_ITEM_TYPE_EVENT ||
 			 item_type == E_EWS_ITEM_TYPE_MEETING_MESSAGE ||
 			 item_type == E_EWS_ITEM_TYPE_MEETING_REQUEST ||
 			 item_type == E_EWS_ITEM_TYPE_MEETING_RESPONSE ||
 			 item_type == E_EWS_ITEM_TYPE_MEETING_RESPONSE)
-			camel_message_info_set_user_flag ((CamelMessageInfo*)mi, "$has_cal", TRUE);
+			camel_message_info_set_user_flag (
+				(CamelMessageInfo *) mi, "$has_cal", TRUE);
 
 		mi->info.uid = camel_pstring_strdup (id->id);
 		mi->info.size = e_ews_item_get_size (item);
-		mi->info.subject = camel_pstring_strdup (e_ews_item_get_subject (item));
+		mi->info.subject = camel_pstring_strdup (
+			e_ews_item_get_subject (item));
 		mi->item_type = item_type;
 		mi->change_key = g_strdup (id->change_key);
 
@@ -1006,13 +808,15 @@ camel_ews_utils_sync_created_items (Came
 		mi->info.date_received = e_ews_item_get_date_received (item);
 
 		from = e_ews_item_get_from (item);
-		mi->info.from = form_email_string_from_mb (from);
+		if (!from)
+			from = e_ews_item_get_sender (item);
+		mi->info.from = form_email_string_from_mb (cnc, from, cancellable);
 
 		to = e_ews_item_get_to_recipients (item);
-		mi->info.to = form_recipient_list (to);
+		mi->info.to = form_recipient_list (cnc, to, cancellable);
 
 		cc = e_ews_item_get_cc_recipients (item);
-		mi->info.cc = form_recipient_list (cc);
+		mi->info.cc = form_recipient_list (cnc, cc, cancellable);
 
 		e_ews_item_has_attachments (item, &has_attachments);
 		if (has_attachments)
@@ -1022,16 +826,30 @@ camel_ews_utils_sync_created_items (Came
 		server_flags = ews_utils_get_server_flags (item);
 		ews_utils_merge_server_user_flags (item, mi);
 
-		camel_ews_summary_add_message_info (folder->summary, server_flags,
-						    (CamelMessageInfo *) mi);
+		mi->info.flags |= server_flags;
+		mi->server_flags = server_flags;
+
+		camel_folder_summary_add (
+			folder->summary, (CamelMessageInfo *) mi);
+
+		/* camel_folder_summary_add() sets folder_flagged flag
+		 * on the message info, but this is a fresh item downloaded
+		 * from the server, thus unset it, to avoid resync up to the server
+		 * on folder leave/store
+		*/
+		mi->info.flags &= ~CAMEL_MESSAGE_FOLDER_FLAGGED;
+
 		camel_folder_change_info_add_uid (ci, id->id);
 		camel_folder_change_info_recent_uid (ci, id->id);
 
 		g_object_unref (item);
 	}
 
-	camel_folder_summary_save_to_db (folder->summary, NULL);
-	camel_folder_changed ((CamelFolder *) ews_folder, ci);
+	if (camel_folder_change_info_changed (ci)) {
+		camel_folder_summary_touch (folder->summary);
+		camel_folder_summary_save_to_db (folder->summary, NULL);
+		camel_folder_changed (CAMEL_FOLDER (ews_folder), ci);
+	}
 	camel_folder_change_info_free (ci);
 	g_slist_free (items_created);
 }
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/camel/camel-ews-utils.h evolution-ews.sync-with-3.8.2/src/camel/camel-ews-utils.h
--- evolution-ews.git-gnome-3-0/src/camel/camel-ews-utils.h	2013-05-17 14:36:16.352669671 +0200
+++ evolution-ews.sync-with-3.8.2/src/camel/camel-ews-utils.h	2013-05-28 08:59:53.268712513 +0200
@@ -49,50 +49,32 @@
 
 G_BEGIN_DECLS
 
-/*for syncing flags back to server*/
-typedef struct {
-	guint32 changed;
-	guint32 bits;
-} flags_diff_t;
-
-/* FIXME: deprecated
-   This is used exclusively for the legacy imap cache code.  DO NOT use this in any new code */
-
-typedef gboolean (*EPathFindFoldersCallback) (const gchar *physical_path,
-					      const gchar *path,
-					      gpointer user_data);
-
-gchar *   e_path_to_physical  (const gchar *prefix, const gchar *vpath);
-
-gboolean e_path_find_folders (const gchar *prefix,
-			      EPathFindFoldersCallback callback,
-			      gpointer data);
-
-gint      e_path_rmdir        (const gchar *prefix, const gchar *vpath);
-
-void do_flags_diff (flags_diff_t *diff, guint32 old, guint32 _new);
-gchar *ews_concat ( const gchar *prefix, const gchar *suffix);
-void strip_lt_gt (gchar **string, gint s_offset, gint e_offset);
-
-void	ews_utils_sync_folders	(CamelEwsStore *ews_store,
-				 GSList *created_folders,
-				 GSList *deleted_folders,
-				 GSList *updated_folders);
-
+gchar *	camel_ews_utils_build_folder_uri	(CamelEwsStore *ews_store,
+						 const gchar *fid);
+void		ews_utils_sync_folders		(CamelEwsStore *ews_store,
+						 GSList *created_folders,
+						 GSList *deleted_folders,
+						 GSList *updated_folders,
+						 GSList **created_folder_ids);
 CamelFolderInfo *
-	camel_ews_utils_build_folder_info	(CamelEwsStore *store,
-						 const gchar *fname);
-
-void	camel_ews_utils_sync_deleted_items	(CamelEwsFolder *ews_folder,
+		camel_ews_utils_build_folder_info
+						(CamelEwsStore *store,
+						 const gchar *fid);
+void		camel_ews_utils_sync_deleted_items
+						(CamelEwsFolder *ews_folder,
 						 GSList *items_deleted);
-void	camel_ews_utils_sync_created_items	(CamelEwsFolder *ews_folder,
-						 GSList *items_created);
-void	camel_ews_utils_sync_updated_items	(CamelEwsFolder *ews_folder,
+void		camel_ews_utils_sync_created_items
+						(CamelEwsFolder *ews_folder,
+						 EEwsConnection *cnc,
+						 GSList *items_created,
+						 GCancellable *cancellable);
+void		camel_ews_utils_sync_updated_items
+						(CamelEwsFolder *ews_folder,
 						 GSList *items_updated);
-void	ews_utils_replace_server_user_flags	(ESoapMessage *msg,
+void		ews_utils_replace_server_user_flags
+						(ESoapMessage *msg,
 						 CamelEwsMessageInfo *mi);
 
-
 G_END_DECLS
 
 #endif
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/camel/Makefile.am evolution-ews.sync-with-3.8.2/src/camel/Makefile.am
--- evolution-ews.git-gnome-3-0/src/camel/Makefile.am	2013-05-17 14:36:16.347669869 +0200
+++ evolution-ews.sync-with-3.8.2/src/camel/Makefile.am	2013-05-28 08:59:53.268712513 +0200
@@ -7,6 +7,7 @@ libcamelews_la_CPPFLAGS = \
 	-I$(top_srcdir)/src/camel		\
 	-I$(top_srcdir)/src/server	        \
 	-I$(top_srcdir)/src/utils	        \
+	-DEXCHANGE_EWS_LOCALEDIR=\"$(localedir)\" \
 	$(CAMEL_CFLAGS)				\
 	$(LIBEDATASERVER_CFLAGS)		\
 	$(LIBECAL_CFLAGS)			\
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-ews-connection.c evolution-ews.sync-with-3.8.2/src/server/e-ews-connection.c
--- evolution-ews.git-gnome-3-0/src/server/e-ews-connection.c	2013-05-17 14:36:16.355671150 +0200
+++ evolution-ews.sync-with-3.8.2/src/server/e-ews-connection.c	2013-05-28 08:59:53.428713196 +0200
@@ -38,14 +38,19 @@
 #include "e-ews-item-change.h"
 #include "ews-marshal.h"
 
+#include "e-ews-gnome-3-8-compat.h"
+
 #define d(x) x
 
 /* For the number of connections */
-#define EWS_CONNECTION_MAX_REQUESTS 10
+#define EWS_CONNECTION_MAX_REQUESTS 1
 
 #define QUEUE_LOCK(x) (g_static_rec_mutex_lock(&(x)->priv->queue_lock))
 #define QUEUE_UNLOCK(x) (g_static_rec_mutex_unlock(&(x)->priv->queue_lock))
 
+#define CHECK_ELEMENT(element_name, expected_name) \
+	(check_element (G_STRFUNC, (element_name), (expected_name)))
+
 G_DEFINE_TYPE (EEwsConnection, e_ews_connection, G_TYPE_OBJECT)
 
 struct _EwsNode;
@@ -70,11 +75,13 @@ struct _EEwsConnectionPrivate {
 	GThread *soup_thread;
 	GMainLoop *soup_loop;
 	GMainContext *soup_context;
+	GMutex *password_lock;
 
 	gchar *uri;
 	gchar *username;
 	gchar *password;
 	gchar *email;
+	gchar *impersonate_user;
 
 	GSList *jobs;
 	GSList *active_job_queue;
@@ -96,30 +103,27 @@ struct _EwsAsyncData {
 	GSList *items_updated;
 	GSList *items_deleted;
 
+	gint total_items;
 	const gchar *directory;
 	GSList *items;
 	gchar *sync_state;
 	gboolean includes_last_item;
+	EwsDelegateDeliver deliver_to;
+	EEwsFolderType folder_type;
 };
 
 struct _EwsNode {
 	ESoapMessage *msg;
 	EEwsConnection *cnc;
 	GSimpleAsyncResult *simple;
-	gboolean complete_sync;
 
-	gint pri;		/* the command priority */
-	response_cb cb;
+	gint pri;                /* the command priority */
+	EEwsResponseCallback cb;
 
 	GCancellable *cancellable;
 	gulong cancel_handler_id;
 };
 
-typedef struct {
-  GAsyncResult *res;
-  EFlag *eflag;
-} EwsSyncData;
-
 /* Static Functions */
 
 GQuark
@@ -135,22 +139,47 @@ ews_connection_error_quark (void)
 	return quark;
 }
 
+static gpointer
+ews_unref_in_thread_func (gpointer data)
+{
+	g_object_unref (G_OBJECT (data));
+
+	return NULL;
+}
+
 static void
-async_data_free (EwsAsyncData *async_data)
+ews_unref_in_thread (gpointer object)
 {
-	g_free (async_data);
+	g_return_if_fail (G_IS_OBJECT (object));
+
+	g_thread_create (ews_unref_in_thread_func, object, FALSE, NULL);
 }
 
 static void
-ews_sync_reply_cb	(GObject *object,
-			 GAsyncResult *res,
-			 gpointer user_data)
+async_data_free (EwsAsyncData *async_data)
 {
+	g_free (async_data);
+}
 
-  EwsSyncData *sync_data = user_data;
+static gboolean
+check_element (const gchar *function_name,
+               const gchar *element_name,
+               const gchar *expected_name)
+{
+	/* Do not call this directory, use CHECK_ELEMENT macro instead. */
+
+	g_return_val_if_fail (function_name != NULL, FALSE);
+	g_return_val_if_fail (element_name != NULL, FALSE);
+	g_return_val_if_fail (expected_name != NULL, FALSE);
+
+	if (!g_str_equal (element_name, expected_name)) {
+		g_warning (
+			"%s: Expected <%s> but got <%s>",
+			function_name, expected_name, element_name);
+		return FALSE;
+	}
 
-  sync_data->res = g_object_ref (res);
-  e_flag_set (sync_data->eflag);
+	return TRUE;
 }
 
 static EwsNode *
@@ -163,16 +192,17 @@ ews_node_new ()
 }
 
 static gboolean
-autodiscover_parse_protocol (xmlNode *node, EwsUrls *urls)
+autodiscover_parse_protocol (xmlNode *node,
+                             EwsUrls *urls)
 {
 	for (node = node->children; node; node = node->next) {
 		if (node->type == XML_ELEMENT_NODE &&
-		    !strcmp((char *)node->name, "ASUrl")) {
-			urls->as_url = (gchar *) xmlNodeGetContent(node);
+		    !strcmp ((gchar *) node->name, "ASUrl")) {
+			urls->as_url = (gchar *) xmlNodeGetContent (node);
 		} else if (node->type == XML_ELEMENT_NODE &&
-		    !strcmp((char *)node->name, "OABUrl"))
-			urls->oab_url = (gchar *) xmlNodeGetContent(node);
-			
+		    !strcmp ((gchar *) node->name, "OABUrl"))
+			urls->oab_url = (gchar *) xmlNodeGetContent (node);
+
 		if (urls->as_url && urls->oab_url)
 			return TRUE;
 	}
@@ -194,73 +224,121 @@ comp_func (gconstpointer a, gconstpointe
 		return 0;
 }
 
-static void
-ews_parse_soap_fault (ESoapResponse *response, GError **error)
+typedef enum _EwsScheduleOp {
+	EWS_SCHEDULE_OP_QUEUE_MESSAGE,
+	EWS_SCHEDULE_OP_CANCEL,
+	EWS_SCHEDULE_OP_ABORT
+} EwsScheduleOp;
+
+typedef struct _EwsScheduleData
 {
-	ESoapParameter *param;
-	gchar *faultstring = NULL;
+	EEwsConnection *cnc;
+	SoupMessage *message;
+
+	EwsScheduleOp op;
 
-	param = e_soap_response_get_first_parameter_by_name(response, "faultstring");
-	if (param)
-		faultstring = e_soap_parameter_get_string_value(param);
+	SoupSessionCallback queue_callback;
+	gpointer queue_user_data;
+} EwsScheduleData;
 
+/* this is run in priv->soup_thread */
+static gboolean
+ews_connection_scheduled_cb (gpointer user_data)
+{
+	EwsScheduleData *sd = user_data;
 
-	g_set_error (error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_UNKNOWN,
-		     "%s", faultstring?:"No <ResponseMessages> or <FreeBusyResponseArray> or SOAP <faultstring> in response");
+	g_return_val_if_fail (sd != NULL, FALSE);
 
-	g_free(faultstring);
+	switch (sd->op) {
+	case EWS_SCHEDULE_OP_QUEUE_MESSAGE:
+		soup_session_queue_message (
+			sd->cnc->priv->soup_session, sd->message,
+			sd->queue_callback, sd->queue_user_data);
+		break;
+	case EWS_SCHEDULE_OP_CANCEL:
+		soup_session_cancel_message (sd->cnc->priv->soup_session, sd->message, SOUP_STATUS_CANCELLED);
+		break;
+	case EWS_SCHEDULE_OP_ABORT:
+		soup_session_abort (sd->cnc->priv->soup_session);
+		break;
+	}
+
+	if (sd->message)
+		g_object_unref (sd->message);
+	/* in case this is the last reference */
+	ews_unref_in_thread (sd->cnc);
+	g_free (sd);
+
+	return FALSE;
 }
 
-static gboolean
-ews_get_response_status (ESoapParameter *param, GError **error)
+static void
+ews_connection_schedule_queue_message (EEwsConnection *cnc,
+                                       SoupMessage *message,
+                                       SoupSessionCallback callback,
+                                       gpointer user_data)
 {
-	ESoapParameter *subparam;
-	gchar *value;
-	gboolean ret = TRUE;
+	EwsScheduleData *sd;
+	GSource *source;
 
-	value = e_soap_parameter_get_property (param, "ResponseClass");
+	g_return_if_fail (E_IS_EWS_CONNECTION (cnc));
+	g_return_if_fail (SOUP_IS_MESSAGE (message));
 
-	if (!g_ascii_strcasecmp (value, "Error")) {
-		gchar *desc, *res;
-		gint error_code = EWS_CONNECTION_ERROR_UNKNOWN;
-
-		subparam = e_soap_parameter_get_first_child_by_name (param, "MessageText");
-		desc = e_soap_parameter_get_string_value (subparam);
-
-		subparam = e_soap_parameter_get_first_child_by_name (param, "ResponseCode");
-		res = e_soap_parameter_get_string_value (subparam);
-
-		error_code = ews_get_error_code ((const gchar *) res);
-
-		/* FIXME: This happens because of a bug in the Exchange server,
-		   which doesn't like returning <Recurrence> for any appointment
-		   without a timezone, even if it's an all day event like a
-		   birthday. We need to handle the error and correctly report it
-		   to the user, but for now we'll just ignore it... */
-		if (error_code != EWS_CONNECTION_ERROR_CORRUPTDATA &&
-		/* Ick, another one. If we try to set the IsRead flag on certain
-		   types of item (task requests, those stupid 'recall' requests),
-		   it complains. We really need to find a better way to return
-		   individual errors for each response to a multiple request; it
-		   isn't necessarily the case that a single error should be reported
-		   as an error for the whole transaction */
-		    error_code != EWS_CONNECTION_ERROR_INVALIDPROPERTYREQUEST) {
-			g_set_error	(error,
-					 EWS_CONNECTION_ERROR,
-					 error_code,
-					 "%s", desc);
-			ret = FALSE;
-		}
+	sd = g_new0 (EwsScheduleData, 1);
+	sd->cnc = g_object_ref (cnc);
+	sd->message = g_object_ref (message);
+	sd->op = EWS_SCHEDULE_OP_QUEUE_MESSAGE;
+	sd->queue_callback = callback;
+	sd->queue_user_data = user_data;
 
-		g_free (desc);
-		g_free (res);
-	}
+	source = g_idle_source_new ();
+	g_source_set_priority (source, G_PRIORITY_DEFAULT);
+	g_source_set_callback (source, ews_connection_scheduled_cb, sd, NULL);
+	g_source_attach (source, cnc->priv->soup_context);
+}
 
-	g_free (value);
+static void
+ews_connection_schedule_cancel_message (EEwsConnection *cnc,
+                                        SoupMessage *message)
+{
+	EwsScheduleData *sd;
+	GSource *source;
+
+	g_return_if_fail (E_IS_EWS_CONNECTION (cnc));
+	g_return_if_fail (SOUP_IS_MESSAGE (message));
+
+	sd = g_new0 (EwsScheduleData, 1);
+	sd->cnc = g_object_ref (cnc);
+	sd->message = g_object_ref (message);
+	sd->op = EWS_SCHEDULE_OP_CANCEL;
+
+	source = g_idle_source_new ();
+	g_source_set_priority (source, G_PRIORITY_DEFAULT);
+	g_source_set_callback (source, ews_connection_scheduled_cb, sd, NULL);
+	g_source_attach (source, cnc->priv->soup_context);
+}
+
+static void
+ews_connection_schedule_abort (EEwsConnection *cnc)
+{
+	EwsScheduleData *sd;
+	GSource *source;
 
-	return ret;
+	g_return_if_fail (E_IS_EWS_CONNECTION (cnc));
+
+	sd = g_new0 (EwsScheduleData, 1);
+	sd->cnc = g_object_ref (cnc);
+	sd->op = EWS_SCHEDULE_OP_ABORT;
+
+	source = g_idle_source_new ();
+	g_source_set_priority (source, G_PRIORITY_DEFAULT);
+	g_source_set_callback (source, ews_connection_scheduled_cb, sd, NULL);
+	g_source_attach (source, cnc->priv->soup_context);
 }
 
+static void ews_cancel_request (GCancellable *cancellable, gpointer user_data);
+
+/* this is run in priv->soup_thread */
 static gboolean
 ews_next_request (gpointer _cnc)
 {
@@ -279,7 +357,7 @@ ews_next_request (gpointer _cnc)
 
 	node = (EwsNode *) l->data;
 
-	if (g_getenv ("EWS_DEBUG") && (atoi (g_getenv ("EWS_DEBUG")) >= 1)) {
+	if (g_getenv ("EWS_DEBUG") && (atoi (g_getenv ("EWS_DEBUG")) == 1)) {
 		soup_buffer_free (soup_message_body_flatten (SOUP_MESSAGE (node->msg)->request_body));
 		/* print request's body */
 		printf ("\n The request headers");
@@ -294,20 +372,33 @@ ews_next_request (gpointer _cnc)
 	/* Add to active job queue */
 	cnc->priv->active_job_queue = g_slist_append (cnc->priv->active_job_queue, node);
 
-	soup_session_queue_message (cnc->priv->soup_session, SOUP_MESSAGE (node->msg), ews_response_cb, node);
+	if (cnc->priv->soup_session) {
+		soup_session_queue_message (cnc->priv->soup_session, SOUP_MESSAGE (node->msg), ews_response_cb, node);
+		QUEUE_UNLOCK (cnc);
+	} else {
+		QUEUE_UNLOCK (cnc);
+
+		ews_cancel_request (NULL, node);
+	}
 
-	QUEUE_UNLOCK (cnc);
 	return FALSE;
 }
 
-static void ews_trigger_next_request(EEwsConnection *cnc)
+static void
+ews_trigger_next_request (EEwsConnection *cnc)
 {
 	GSource *source;
 
-	source = g_idle_source_new ();
-	g_source_set_priority (source, G_PRIORITY_DEFAULT);
-	g_source_set_callback (source, ews_next_request, cnc, NULL);
-	g_source_attach (source, cnc->priv->soup_context);
+	g_return_if_fail (cnc != NULL);
+
+	if (cnc->priv->soup_session) {
+		source = g_idle_source_new ();
+		g_source_set_priority (source, G_PRIORITY_DEFAULT);
+		g_source_set_callback (source, ews_next_request, cnc, NULL);
+		g_source_attach (source, cnc->priv->soup_context);
+	} else {
+		ews_next_request (cnc);
+	}
 }
 
 /**
@@ -319,24 +410,35 @@ static void ews_trigger_next_request(EEw
  * Returns:
  **/
 static void
-ews_active_job_done (EEwsConnection *cnc, EwsNode *ews_node)
+ews_active_job_done (EEwsConnection *cnc,
+                     EwsNode *ews_node)
 {
+	g_return_if_fail (cnc != NULL);
+	g_return_if_fail (ews_node != NULL);
+
 	QUEUE_LOCK (cnc);
 
 	cnc->priv->active_job_queue = g_slist_remove (cnc->priv->active_job_queue, ews_node);
-	if (ews_node->cancellable)
+	if (ews_node->cancellable && ews_node->cancel_handler_id)
 		g_signal_handler_disconnect (ews_node->cancellable, ews_node->cancel_handler_id);
 
 	QUEUE_UNLOCK (cnc);
 
-	ews_trigger_next_request(cnc);
-	g_object_unref (ews_node->simple);
+	ews_trigger_next_request (cnc);
+
+	if (ews_node->cancellable)
+		g_object_unref (ews_node->cancellable);
+
+	/* the 'simple' holds reference on 'cnc' and this function
+	 * is called in a dedicated thread, which 'cnc' joins on dispose,
+	 * thus to avoid race condition, unref the object in its own thread */
+	ews_unref_in_thread (ews_node->simple);
 	g_free (ews_node);
 }
 
 static void
 ews_cancel_request (GCancellable *cancellable,
-		   gpointer user_data)
+                    gpointer user_data)
 {
 	EwsNode *node = user_data;
 	EEwsConnection *cnc = node->cnc;
@@ -348,13 +450,14 @@ ews_cancel_request (GCancellable *cancel
 	found = g_slist_find (cnc->priv->active_job_queue, node);
 	QUEUE_UNLOCK (cnc);
 
-	g_simple_async_result_set_error	(simple,
-			EWS_CONNECTION_ERROR,
-			EWS_CONNECTION_ERROR_CANCELLED,
-			_("Operation Cancelled"));
-	if (found)
-		soup_session_cancel_message (cnc->priv->soup_session, SOUP_MESSAGE (msg), SOUP_STATUS_CANCELLED);
-	else {
+	g_simple_async_result_set_error (
+		simple,
+		EWS_CONNECTION_ERROR,
+		EWS_CONNECTION_ERROR_CANCELLED,
+		_("Operation Cancelled"));
+	if (found) {
+		ews_connection_schedule_cancel_message (cnc, SOUP_MESSAGE (msg));
+	} else {
 		QUEUE_LOCK (cnc);
 		cnc->priv->jobs = g_slist_remove (cnc->priv->jobs, (gconstpointer) node);
 		QUEUE_UNLOCK (cnc);
@@ -363,125 +466,104 @@ ews_cancel_request (GCancellable *cancel
 	}
 }
 
-static void
-ews_connection_queue_request (EEwsConnection *cnc, ESoapMessage *msg, response_cb cb, gint pri, GCancellable *cancellable, GSimpleAsyncResult *simple, gboolean complete_sync)
+void
+e_ews_connection_queue_request (EEwsConnection *cnc,
+                                ESoapMessage *msg,
+                                EEwsResponseCallback cb,
+                                gint pri,
+                                GCancellable *cancellable,
+                                GSimpleAsyncResult *simple)
 {
 	EwsNode *node;
 
+	g_return_if_fail (cnc != NULL);
+	g_return_if_fail (cb != NULL);
+	g_return_if_fail (G_IS_SIMPLE_ASYNC_RESULT (simple));
+
 	node = ews_node_new ();
 	node->msg = msg;
 	node->pri = pri;
 	node->cb = cb;
 	node->cnc = cnc;
-	node->complete_sync = complete_sync;
-	node->simple = simple;
+	node->simple = g_object_ref (simple);
 
 	QUEUE_LOCK (cnc);
 	cnc->priv->jobs = g_slist_insert_sorted (cnc->priv->jobs, (gpointer *) node, (GCompareFunc) comp_func);
- 	QUEUE_UNLOCK (cnc);
+	QUEUE_UNLOCK (cnc);
 
 	if (cancellable) {
-		node->cancellable = cancellable;
-		node->cancel_handler_id = g_cancellable_connect	(cancellable,
-								 G_CALLBACK (ews_cancel_request),
-								 (gpointer) node, NULL);
+		node->cancellable = g_object_ref (cancellable);
+		if (g_cancellable_is_cancelled (cancellable))
+			ews_cancel_request (cancellable, node);
+		else
+			node->cancel_handler_id = g_cancellable_connect (
+				cancellable,
+				G_CALLBACK (ews_cancel_request),
+				(gpointer) node, NULL);
 	}
 
-	ews_trigger_next_request(cnc);
+	ews_trigger_next_request (cnc);
 }
 
 /* Response callbacks */
 
 static void
-ews_response_cb (SoupSession *session, SoupMessage *msg, gpointer data)
+ews_response_cb (SoupSession *session,
+                 SoupMessage *msg,
+                 gpointer data)
 {
 	EwsNode *enode = (EwsNode *) data;
 	ESoapResponse *response;
 
-	if (enode->cancellable && g_cancellable_is_cancelled (enode->cancellable))
+	if (g_cancellable_is_cancelled (enode->cancellable))
 		goto exit;
 
 	if (msg->status_code == SOUP_STATUS_UNAUTHORIZED) {
-		g_simple_async_result_set_error (enode->simple,
-						 EWS_CONNECTION_ERROR,
-						 EWS_CONNECTION_ERROR_AUTHENTICATION_FAILED,
-						 _("Authentication failed"));
+		g_simple_async_result_set_error (
+			enode->simple,
+			EWS_CONNECTION_ERROR,
+			EWS_CONNECTION_ERROR_AUTHENTICATION_FAILED,
+			_("Authentication failed"));
 		goto exit;
 	}
+
 	response = e_soap_message_parse_response ((ESoapMessage *) msg);
-	if (!response) {
-		g_simple_async_result_set_error	(enode->simple,
-						 EWS_CONNECTION_ERROR,
-						 EWS_CONNECTION_ERROR_NORESPONSE,
-						 _("No response: %s"), msg->reason_phrase);
-	} else {
-		ESoapParameter *param, *subparam;
-		GError *error = NULL;
 
-		/* TODO: The stdout can be replaced with Evolution's
-		   Logging framework also */
-		if (response && g_getenv ("EWS_DEBUG") && (atoi (g_getenv ("EWS_DEBUG")) >= 1))
-			e_soap_response_dump_response (response, stdout);
-
-		param = e_soap_response_get_first_parameter_by_name (response, "ResponseMessages");
-		if (!param) param = e_soap_response_get_first_parameter_by_name (response, "FreeBusyResponseArray");
-		if (param) {
-			/* Iterate over all "*ResponseMessage" elements. */
-			for (subparam = e_soap_parameter_get_first_child (param);
-			     subparam;
-			     subparam = e_soap_parameter_get_next_child (subparam)) {
-				int l = strlen ((char *)subparam->name);
-				if (l < 15 || (strcmp((char *)subparam->name + l - 15, "ResponseMessage") &&
-				    strcmp((char *)subparam->name, "FreeBusyResponse"))) {
-					g_warning ("Unexpected element '%s' in place of ResponseMessage or FreeBusyResponse",
-						   subparam->name);
-					continue;
-				}
+	if (response == NULL) {
+		g_simple_async_result_set_error (
+			enode->simple,
+			EWS_CONNECTION_ERROR,
+			EWS_CONNECTION_ERROR_NORESPONSE,
+			_("No response: %s"), msg->reason_phrase);
+		goto exit;
+	}
 
-				if ((strcmp((char *)subparam->name, "FreeBusyResponse") == 0 && !ews_get_response_status (e_soap_parameter_get_first_child (subparam), &error)) ||
-				 (strcmp((char *)subparam->name, "FreeBusyResponse") && !ews_get_response_status (subparam, &error))) {
-					g_simple_async_result_set_from_error (enode->simple, error);
-					break;
-				}
-				if (enode->cb)
-					enode->cb (subparam, enode);
-			}
-		} else
-			ews_parse_soap_fault (response, &error);
+	/* TODO: The stdout can be replaced with Evolution's
+	 * Logging framework also */
+	if (g_getenv ("EWS_DEBUG") && (atoi (g_getenv ("EWS_DEBUG")) >= 1))
+		e_soap_response_dump_response (response, stdout);
 
-		if (error) {
-			g_simple_async_result_set_from_error (enode->simple, error);
-			g_clear_error (&error);
-		}
+	if (enode->cb != NULL)
+		enode->cb (response, enode->simple);
 
-		g_object_unref (response);
-	}
+	g_object_unref (response);
 
 exit:
-	if (enode->complete_sync) {
-		GAsyncResult *async = G_ASYNC_RESULT (enode->simple);
+	g_simple_async_result_complete_in_idle (enode->simple);
 
-		/* If we just call g_simple_async_result_complete() then it
-		   will bitch about being called in the wrong context, even
-		   though we *know* it's OK. So instead, just call the
-		   callback directly. We *know* it's ews_sync_reply_cb(),
-		   because that's the only way the complete_sync flag gets
-		   set */
-		ews_sync_reply_cb (NULL, async, g_async_result_get_user_data (async));
-	} else {
-		g_simple_async_result_complete_in_idle (enode->simple);
-	}
 	ews_active_job_done (enode->cnc, enode);
 }
 
 typedef gpointer (*ItemParser) (ESoapParameter *param);
 
 static void
-sync_xxx_response_cb (ESoapParameter *subparam, EwsNode *enode, ItemParser parser,
-		      const gchar *last_tag, const gchar *delete_id_tag)
+sync_xxx_response_cb (ESoapParameter *subparam,
+                      EwsAsyncData *async_data,
+                      ItemParser parser,
+                      const gchar *last_tag,
+                      const gchar *delete_id_tag)
 {
 	ESoapParameter *node;
-	EwsAsyncData *async_data;
 	gchar *new_sync_state = NULL, *value, *last;
 	GSList *items_created = NULL, *items_updated = NULL, *items_deleted = NULL;
 	gboolean includes_last_item = FALSE;
@@ -538,7 +620,6 @@ sync_xxx_response_cb (ESoapParameter *su
 		}
 	}
 
-	async_data = g_simple_async_result_get_op_res_gpointer (enode->simple);
 	async_data->items_created = items_created;
 	async_data->items_updated = items_updated;
 	async_data->items_deleted = items_deleted;
@@ -547,45 +628,299 @@ sync_xxx_response_cb (ESoapParameter *su
 }
 
 static void
-sync_hierarchy_response_cb (ESoapParameter *subparam, EwsNode *enode)
+sync_hierarchy_response_cb (ESoapResponse *response,
+                            GSimpleAsyncResult *simple)
 {
-	sync_xxx_response_cb (subparam, enode, (ItemParser)e_ews_folder_new_from_soap_parameter,
-			      "IncludesLastFolderInRange", "FolderId");
+	EwsAsyncData *async_data;
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	GError *error = NULL;
+
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessages", &error);
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	subparam = e_soap_parameter_get_first_child (param);
+
+	while (subparam != NULL) {
+		const gchar *name = (const gchar *) subparam->name;
+
+		if (!ews_get_response_status (subparam, &error)) {
+			g_simple_async_result_take_error (simple, error);
+			return;
+		}
+
+		if (CHECK_ELEMENT (name, "SyncFolderHierarchyResponseMessage"))
+			sync_xxx_response_cb (
+				subparam, async_data,
+				(ItemParser) e_ews_folder_new_from_soap_parameter,
+				"IncludesLastFolderInRange", "FolderId");
+
+		subparam = e_soap_parameter_get_next_child (subparam);
+	}
 }
 
 static void
-sync_folder_items_response_cb (ESoapParameter *subparam, EwsNode *enode)
+sync_folder_items_response_cb (ESoapResponse *response,
+                               GSimpleAsyncResult *simple)
 {
-	sync_xxx_response_cb (subparam, enode, (ItemParser) e_ews_item_new_from_soap_parameter,
-			      "IncludesLastItemInRange", "ItemId");
+	EwsAsyncData *async_data;
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	GError *error = NULL;
+
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessages", &error);
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	subparam = e_soap_parameter_get_first_child (param);
+
+	while (subparam != NULL) {
+		const gchar *name = (const gchar *) subparam->name;
+
+		if (!ews_get_response_status (subparam, &error)) {
+			g_simple_async_result_take_error (simple, error);
+			return;
+		}
+
+		if (CHECK_ELEMENT (name, "SyncFolderItemsResponseMessage"))
+			sync_xxx_response_cb (
+				subparam, async_data,
+				(ItemParser) e_ews_item_new_from_soap_parameter,
+				"IncludesLastItemInRange", "ItemId");
+
+		subparam = e_soap_parameter_get_next_child (subparam);
+	}
 }
 
-/* Used for CreateItems and GetItems */
 static void
-get_items_response_cb (ESoapParameter *subparam, EwsNode *enode)
+ews_handle_folders_param (ESoapParameter *subparam,
+                          EwsAsyncData *async_data)
 {
 	ESoapParameter *node;
+	EEwsFolder *folder;
+
+	for (node = e_soap_parameter_get_first_child_by_name (subparam, "Folders");
+	     node; node = e_soap_parameter_get_next_child_by_name (subparam, "Folders")) {
+		folder = e_ews_folder_new_from_soap_parameter (node);
+		if (!folder) continue;
+		async_data->items = g_slist_append (async_data->items, folder);
+	}
+}
+
+static void
+get_folder_response_cb (ESoapResponse *response,
+                        GSimpleAsyncResult *simple)
+{
 	EwsAsyncData *async_data;
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	GError *error = NULL;
+
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessages", &error);
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	subparam = e_soap_parameter_get_first_child (param);
+
+	while (subparam != NULL) {
+		const gchar *name = (const gchar *) subparam->name;
+
+		if (!ews_get_response_status (subparam, &error)) {
+			if (g_strcmp0 (name, "GetFolderResponseMessage") == 0) {
+				async_data->items = g_slist_append (async_data->items, e_ews_folder_new_from_error (error));
+				g_clear_error (&error);
+			} else {
+				g_simple_async_result_take_error (simple, error);
+				return;
+			}
+		} else if (CHECK_ELEMENT (name, "GetFolderResponseMessage"))
+			ews_handle_folders_param (subparam, async_data);
+
+		subparam = e_soap_parameter_get_next_child (subparam);
+	}
+}
+
+static void
+ews_handle_root_folder_param_items (ESoapParameter *subparam,
+				    EwsAsyncData *async_data)
+{
+	ESoapParameter *node, *subparam1;
+	gchar *last, *total;
+	gint total_items;
 	EEwsItem *item;
+	gboolean includes_last_item = FALSE;
+
+	node = e_soap_parameter_get_first_child_by_name (subparam, "RootFolder");
+	total = e_soap_parameter_get_property (node, "TotalItemsInView");
+	total_items = atoi (total);
+	g_free (total);
+	last = e_soap_parameter_get_property (node, "IncludesLastItemInRange");
+	if (!strcmp (last, "true"))
+		includes_last_item = TRUE;
+	g_free (last);
+
+	node = e_soap_parameter_get_first_child_by_name (node, "Items");
+	for (subparam1 = e_soap_parameter_get_first_child (node);
+	     subparam1; subparam1 = e_soap_parameter_get_next_child (subparam1)) {
+		item = e_ews_item_new_from_soap_parameter (subparam1);
+		if (!item) continue;
+		async_data->items = g_slist_append (async_data->items, item);
+	}
+	async_data->total_items = total_items;
+	async_data->includes_last_item = includes_last_item;
+}
+
+static void
+find_folder_items_response_cb (ESoapResponse *response,
+                               GSimpleAsyncResult *simple)
+{
+	EwsAsyncData *async_data;
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	GError *error = NULL;
+
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessages", &error);
 
-	async_data = g_simple_async_result_get_op_res_gpointer (enode->simple);
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	subparam = e_soap_parameter_get_first_child (param);
+
+	while (subparam != NULL) {
+		const gchar *name = (const gchar *) subparam->name;
+
+		if (!ews_get_response_status (subparam, &error)) {
+			g_simple_async_result_take_error (simple, error);
+			return;
+		}
+
+		if (CHECK_ELEMENT (name, "FindItemResponseMessage"))
+			ews_handle_root_folder_param_items (subparam, async_data);
+
+		subparam = e_soap_parameter_get_next_child (subparam);
+	}
+}
+
+/* Used for CreateItems and GetItems */
+static void
+ews_handle_items_param (ESoapParameter *subparam,
+                        EwsAsyncData *async_data,
+                        const GError *error)
+{
+	ESoapParameter *node;
+	EEwsItem *item;
 
 	for (node = e_soap_parameter_get_first_child_by_name (subparam, "Items");
 	     node; node = e_soap_parameter_get_next_child_by_name (subparam, "Items")) {
-		item = e_ews_item_new_from_soap_parameter (node);
+		if (node->children)
+			item = e_ews_item_new_from_soap_parameter (node);
+		else
+			item = NULL;
+		if (!item && error != NULL)
+			item = e_ews_item_new_from_error (error);
 		if (!item) continue;
 		async_data->items = g_slist_append (async_data->items, item);
 	}
 }
 
 static void
-resolve_names_response_cb (ESoapParameter *subparam, EwsNode *enode)
+get_items_response_cb (ESoapResponse *response,
+                       GSimpleAsyncResult *simple)
+{
+	EwsAsyncData *async_data;
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	GError *error = NULL;
+
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessages", &error);
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	subparam = e_soap_parameter_get_first_child (param);
+
+	while (subparam != NULL) {
+		const gchar *name = (const gchar *) subparam->name;
+
+		if (g_str_has_suffix (name, "ResponseMessage")) {
+			ews_get_response_status (subparam, &error);
+			ews_handle_items_param (subparam, async_data, error);
+		} else {
+			g_warning (
+				"%s: Unexpected element <%s>",
+				G_STRFUNC, name);
+		}
+
+		/* Do not stop on errors. */
+		if (error != NULL)
+			g_clear_error (&error);
+
+		subparam = e_soap_parameter_get_next_child (subparam);
+	}
+}
+
+static void
+ews_handle_resolution_set_param (ESoapParameter *subparam,
+                                 EwsAsyncData *async_data)
 {
 	ESoapParameter *node;
+	gchar *prop;
 	gboolean includes_last_item;
 	GSList *mailboxes = NULL, *contact_items = NULL;
-	EwsAsyncData *async_data;
-	gchar *prop;
 
 	subparam = e_soap_parameter_get_first_child_by_name (subparam, "ResolutionSet");
 	prop = e_soap_parameter_get_property (subparam, "IncludesLastItemInRange");
@@ -601,37 +936,83 @@ resolve_names_response_cb (ESoapParamete
 
 		node = e_soap_parameter_get_first_child_by_name (subparam, "Mailbox");
 		mb = e_ews_item_mailbox_from_soap_param (node);
-		if (mb)
-			mailboxes = g_slist_append (mailboxes, mb);
+		if (mb) {
+			EwsResolveContact *rc;
 
-		/* TODO parse contacts */
-	}
+			mailboxes = g_slist_prepend (mailboxes, mb);
 
-	async_data = g_simple_async_result_get_op_res_gpointer (enode->simple);
+			/* 'mailboxes' and 'contact_items' match 1:1, but if the contact information
+			 * wasn't found, then NULL is stored in the corresponding position */
+			node = e_soap_parameter_get_first_child_by_name (subparam, "Contact");
+			rc = e_ews_item_resolve_contact_from_soap_param (node);
+			contact_items = g_slist_prepend (contact_items, rc);
+		}
+	}
 
 	/* Reuse existing variables */
-	async_data->items = mailboxes;
+	async_data->items = g_slist_reverse (mailboxes);
 	async_data->includes_last_item = includes_last_item;
-	async_data->items_created = contact_items;
+	async_data->items_created = g_slist_reverse (contact_items);
 }
 
 static void
-expand_dl_response_cb (ESoapParameter *subparam, EwsNode *enode)
+resolve_names_response_cb (ESoapResponse *response,
+                           GSimpleAsyncResult *simple)
 {
-	gboolean includes_last_item;
-	GSList *mailboxes = NULL;
 	EwsAsyncData *async_data;
-	gchar *prop;
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	GError *error = NULL;
 
-	subparam = e_soap_parameter_get_first_child_by_name (subparam, "DLExpansion");
-	prop = e_soap_parameter_get_property (subparam, "IncludesLastItemInRange");
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
 
-	if (prop && !strcmp (prop, "true"))
-		includes_last_item = TRUE;
-	g_free (prop);
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessages", &error);
 
-	for (subparam = e_soap_parameter_get_first_child_by_name (subparam, "Mailbox");
-		subparam != NULL;
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	subparam = e_soap_parameter_get_first_child (param);
+
+	while (subparam != NULL) {
+		const gchar *name = (const gchar *) subparam->name;
+
+		if (!ews_get_response_status (subparam, &error)) {
+			g_simple_async_result_take_error (simple, error);
+			return;
+		}
+
+		if (CHECK_ELEMENT (name, "ResolveNamesResponseMessage"))
+			ews_handle_resolution_set_param (subparam, async_data);
+
+		subparam = e_soap_parameter_get_next_child (subparam);
+	}
+}
+
+static void
+ews_handle_dl_expansion_param (ESoapParameter *subparam,
+                               EwsAsyncData *async_data)
+{
+	gboolean includes_last_item;
+	GSList *mailboxes = NULL;
+	gchar *prop;
+
+	subparam = e_soap_parameter_get_first_child_by_name (subparam, "DLExpansion");
+	prop = e_soap_parameter_get_property (subparam, "IncludesLastItemInRange");
+
+	if (prop && !strcmp (prop, "true"))
+		includes_last_item = TRUE;
+	g_free (prop);
+
+	for (subparam = e_soap_parameter_get_first_child_by_name (subparam, "Mailbox");
+		subparam != NULL;
 		subparam = e_soap_parameter_get_next_child_by_name (subparam, "Mailbox")) {
 		EwsMailbox *mb;
 
@@ -640,24 +1021,86 @@ expand_dl_response_cb (ESoapParameter *s
 			mailboxes = g_slist_append (mailboxes, mb);
 	}
 
-	async_data = g_simple_async_result_get_op_res_gpointer (enode->simple);
-
 	/* Reuse existing variables */
 	async_data->items = mailboxes;
 	async_data->includes_last_item = includes_last_item;
 }
 
+static void
+expand_dl_response_cb (ESoapResponse *response,
+                       GSimpleAsyncResult *simple)
+{
+	EwsAsyncData *async_data;
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	GError *error = NULL;
+
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessages", &error);
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	subparam = e_soap_parameter_get_first_child (param);
+
+	while (subparam != NULL) {
+		const gchar *name = (const gchar *) subparam->name;
+
+		if (!ews_get_response_status (subparam, &error)) {
+			g_simple_async_result_take_error (simple, error);
+			return;
+		}
+
+		if (CHECK_ELEMENT (name, "ExpandDLResponseMessage"))
+			ews_handle_dl_expansion_param (subparam, async_data);
+
+		subparam = e_soap_parameter_get_next_child (subparam);
+	}
+}
+
 /* TODO scan all folders if we support creating multiple folders in the request */
 static void
-ews_create_folder_cb (ESoapParameter *soapparam, EwsNode *enode)
+ews_handle_create_folders_param (ESoapParameter *soapparam,
+                                 EwsAsyncData *async_data)
 {
 	ESoapParameter *param, *node;
-	EwsAsyncData *async_data;
 	EwsFolderId *fid = NULL;
 	GSList *fids = NULL;
+	const gchar *folder_element;
+
+	switch (async_data->folder_type) {
+		case E_EWS_FOLDER_TYPE_MAILBOX:
+			folder_element = "Folder";
+			break;
+		case E_EWS_FOLDER_TYPE_CALENDAR:
+			folder_element = "CalendarFolder";
+			break;
+		case E_EWS_FOLDER_TYPE_CONTACTS:
+			folder_element = "ContactsFolder";
+			break;
+		case E_EWS_FOLDER_TYPE_SEARCH:
+			folder_element = "SearchFolder";
+			break;
+		case E_EWS_FOLDER_TYPE_TASKS:
+			folder_element = "TasksFolder";
+			break;
+		default:
+			g_warn_if_reached ();
+			folder_element = "Folder";
+			break;
+	}
 
 	node = e_soap_parameter_get_first_child_by_name (soapparam, "Folders");
-	node = e_soap_parameter_get_first_child_by_name (node, "Folder");
+	node = e_soap_parameter_get_first_child_by_name (node, folder_element);
 	param = e_soap_parameter_get_first_child_by_name (node, "FolderId");
 
 	fid = g_new0 (EwsFolderId, 1);
@@ -665,11 +1108,51 @@ ews_create_folder_cb (ESoapParameter *so
 	fid->change_key = e_soap_parameter_get_property (param, "ChangeKey");
 	fids = g_slist_append (fids, fid);
 
-	async_data = g_simple_async_result_get_op_res_gpointer (enode->simple);
 	async_data->items_created = fids;
 }
 
 static void
+create_folder_response_cb (ESoapResponse *response,
+                           GSimpleAsyncResult *simple)
+{
+	EwsAsyncData *async_data;
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	GError *error = NULL;
+
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessages", &error);
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	subparam = e_soap_parameter_get_first_child (param);
+
+	while (subparam != NULL) {
+		const gchar *name = (const gchar *) subparam->name;
+
+		if (!ews_get_response_status (subparam, &error)) {
+			g_simple_async_result_take_error (simple, error);
+			return;
+		}
+
+		if (CHECK_ELEMENT (name, "CreateFolderResponseMessage"))
+			ews_handle_create_folders_param (subparam, async_data);
+
+		subparam = e_soap_parameter_get_next_child (subparam);
+	}
+}
+
+static void
 e_ews_connection_dispose (GObject *object)
 {
 	EEwsConnection *cnc = (EEwsConnection *) object;
@@ -693,7 +1176,7 @@ e_ews_connection_dispose (GObject *objec
 		g_free (hash_key);
 	}
 
-	g_signal_handlers_disconnect_by_func	(priv->soup_session, ews_connection_authenticate, cnc);
+	g_signal_handlers_disconnect_by_func (priv->soup_session, ews_connection_authenticate, cnc);
 
 	if (priv->soup_session) {
 		g_object_unref (priv->soup_session);
@@ -719,16 +1202,18 @@ e_ews_connection_dispose (GObject *objec
 		priv->username = NULL;
 	}
 
-	if (priv->password) {
-		g_free (priv->password);
-		priv->password = NULL;
-	}
+	e_ews_connection_set_password (cnc, NULL);
 
 	if (priv->email) {
 		g_free (priv->email);
 		priv->email = NULL;
 	}
 
+	if (priv->impersonate_user) {
+		g_free (priv->impersonate_user);
+		priv->impersonate_user = NULL;
+	}
+
 	if (priv->jobs) {
 		g_slist_free (priv->jobs);
 		priv->jobs = NULL;
@@ -753,6 +1238,7 @@ e_ews_connection_finalize (GObject *obje
 
 	priv = cnc->priv;
 	g_static_rec_mutex_free (&priv->queue_lock);
+	g_mutex_free (priv->password_lock);
 
 	g_free (priv);
 	cnc->priv = NULL;
@@ -824,6 +1310,7 @@ e_ews_connection_init (EEwsConnection *c
 
 
 	g_static_rec_mutex_init (&priv->queue_lock);
+	priv->password_lock = g_mutex_new ();
 
 	g_signal_connect (priv->soup_session, "authenticate", G_CALLBACK(ews_connection_authenticate), cnc);
 }
@@ -871,6 +1358,51 @@ e_ews_connection_authenticate (EEwsConne
 	soup_auth_authenticate (auth, cnc->priv->username,
 				cnc->priv->password);
 }
+
+void
+ews_oal_free (EwsOAL *oal)
+{
+	if (oal != NULL) {
+		g_free (oal->id);
+		g_free (oal->dn);
+		g_free (oal->name);
+		g_free (oal);
+	}
+}
+
+void
+ews_oal_details_free (EwsOALDetails *details)
+{
+	if (details != NULL) {
+		g_free (details->sha);
+		g_free (details->filename);
+		g_free (details);
+	}
+}
+
+void
+ews_user_id_free (EwsUserId *id)
+{
+	if (id) {
+		g_free (id->sid);
+		g_free (id->primary_smtp);
+		g_free (id->display_name);
+		g_free (id->distinguished_user);
+		g_free (id->external_user);
+		g_free (id);
+	}
+}
+
+void
+ews_delegate_info_free (EwsDelegateInfo *info)
+{
+	if (!info)
+		return;
+
+	ews_user_id_free (info->user_id);
+	g_free (info);
+}
+
 /* Connection APIS */
 
 /**
@@ -924,6 +1456,10 @@ e_ews_connection_find (const gchar *uri,
  **/
 EEwsConnection *
 e_ews_connection_new (const gchar *uri, const gchar *username, const gchar *password,
+		      const gchar *default_email,
+		      const gchar *impersonate_user,
+		      gint timeout,
+		      gboolean use_ntlm,
 		      GCallback authenticate_cb, gpointer authenticate_ctx,
 		      GError **error)
 {
@@ -942,6 +1478,10 @@ e_ews_connection_new (const gchar *uri, 
 
 		if (E_IS_EWS_CONNECTION (cnc)) {
 			g_object_ref (cnc);
+			if (default_email && *default_email && (!cnc->priv->email || !*cnc->priv->email)) {
+				g_free (cnc->priv->email);
+				cnc->priv->email = g_strdup (default_email);
+			}
 			g_static_mutex_unlock (&connecting);
 			return cnc;
 		}
@@ -953,12 +1493,19 @@ e_ews_connection_new (const gchar *uri, 
 	cnc->priv->username = g_strdup (username);
 	cnc->priv->password = g_strdup (password);
 	cnc->priv->uri = g_strdup (uri);
+	cnc->priv->email = g_strdup (default_email);
+	cnc->priv->impersonate_user = g_strdup (impersonate_user);
 
 	/* register a handler to the authenticate signal */
 	if (authenticate_cb)
 		g_signal_connect (cnc, "authenticate",
 				  authenticate_cb, authenticate_ctx);
 
+	g_object_set (G_OBJECT (cnc->priv->soup_session),
+		SOUP_SESSION_USE_NTLM, use_ntlm,
+		SOUP_SESSION_TIMEOUT, timeout > 0 ? timeout : 120,
+		NULL);
+
 	/* add the connection to the loaded_connections_permissions hash table */
 	hash_key = g_strdup_printf ("%s@%s",
 			cnc->priv->username ? cnc->priv->username : "",
@@ -974,24 +1521,95 @@ e_ews_connection_new (const gchar *uri, 
 
 }
 
+const gchar *
+e_ews_connection_get_uri (EEwsConnection *cnc)
+{
+	g_return_val_if_fail (E_IS_EWS_CONNECTION (cnc), NULL);
+
+	return cnc->priv->uri;
+}
+
+const gchar *
+e_ews_connection_get_password (EEwsConnection *cnc)
+{
+	g_return_val_if_fail (E_IS_EWS_CONNECTION (cnc), NULL);
+
+	return cnc->priv->password;
+}
+
+gchar *
+e_ews_connection_dup_password (EEwsConnection *cnc)
+{
+	const gchar *protected;
+	gchar *duplicate;
+
+	g_return_val_if_fail (E_IS_EWS_CONNECTION (cnc), NULL);
+
+	g_mutex_lock (cnc->priv->password_lock);
+
+	protected = e_ews_connection_get_password (cnc);
+	duplicate = g_strdup (protected);
+
+	g_mutex_unlock (cnc->priv->password_lock);
+
+	return duplicate;
+}
+
+void
+e_ews_connection_set_password (EEwsConnection *cnc,
+                               const gchar *password)
+{
+	g_return_if_fail (E_IS_EWS_CONNECTION (cnc));
+
+	g_mutex_lock (cnc->priv->password_lock);
+
+	/* Zero-fill the old password before freeing it. */
+	if (cnc->priv->password != NULL && *cnc->priv->password != '\0')
+		memset (cnc->priv->password, 0, strlen (cnc->priv->password));
+
+	g_free (cnc->priv->password);
+	cnc->priv->password = g_strdup (password);
+
+	g_mutex_unlock (cnc->priv->password_lock);
+}
+
+const gchar *
+e_ews_connection_get_impersonate_user (EEwsConnection *cnc)
+{
+	g_return_val_if_fail (E_IS_EWS_CONNECTION (cnc), NULL);
+
+	return cnc->priv->impersonate_user;
+}
+
+SoupSession *
+e_ews_connection_ref_soup_session (EEwsConnection *cnc)
+{
+	g_return_val_if_fail (E_IS_EWS_CONNECTION (cnc), NULL);
+
+	return g_object_ref (cnc->priv->soup_session);
+}
+
 static xmlDoc *
-e_ews_autodiscover_ws_xml(const gchar *email)
+e_ews_autodiscover_ws_xml (const gchar *email_address)
 {
 	xmlDoc *doc;
 	xmlNode *node;
 	xmlNs *ns;
 
-	doc = xmlNewDoc((xmlChar *) "1.0");
-	node = xmlNewDocNode(doc, NULL, (xmlChar *)"Autodiscover", NULL);
-	xmlDocSetRootElement(doc, node);
-	ns = xmlNewNs (node,
-		       (xmlChar *)"http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006", NULL);
-
-	node = xmlNewChild(node, ns, (xmlChar *)"Request", NULL);
-	xmlNewChild(node, ns, (xmlChar *)"EMailAddress",
-			    (xmlChar *)email);
-	xmlNewChild(node, ns, (xmlChar *)"AcceptableResponseSchema",
-			    (xmlChar *)"http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a");
+	doc = xmlNewDoc ((xmlChar *) "1.0");
+	node = xmlNewDocNode (doc, NULL, (xmlChar *)"Autodiscover", NULL);
+	xmlDocSetRootElement (doc, node);
+	ns = xmlNewNs (
+		node,
+		(xmlChar *)"http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006", NULL);
+
+	node = xmlNewChild (node, ns, (xmlChar *)"Request", NULL);
+	xmlNewChild (
+		node, ns, (xmlChar *)"EMailAddress",
+		(xmlChar *) email_address);
+	xmlNewChild (
+		node, ns, (xmlChar *)"AcceptableResponseSchema",
+		(xmlChar *)"http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a");
 
 	return doc;
 }
@@ -999,30 +1617,31 @@ e_ews_autodiscover_ws_xml(const gchar *e
 struct _autodiscover_data {
 	EEwsConnection *cnc;
 	xmlOutputBuffer *buf;
-	GSimpleAsyncResult *simple;
-	SoupMessage *msgs[2];
-	EEwsAutoDiscoverCallback cb;
-	gpointer cbdata;
+	SoupMessage *msgs[4];
+
+	GCancellable *cancellable;
+	gulong cancel_id;
+
+	/* Results */
+	gchar *as_url;
+	gchar *oab_url;
 };
 
-/* Called in the context e_ews_autodiscover_ws_url() was called from,
-   with the final result. */
-static void autodiscover_done_cb (GObject *cnc, GAsyncResult *res,
-				  gpointer user_data)
+static void
+autodiscover_data_free (struct _autodiscover_data *ad)
 {
-	struct _autodiscover_data *ad = user_data;
-	EwsUrls *urls = NULL;
-	GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (res);
-	GError *error = NULL;
+	g_object_unref (ad->cnc);
+	xmlOutputBufferClose (ad->buf);
 
-	if (!g_simple_async_result_propagate_error (simple, &error))
-		urls = g_simple_async_result_get_op_res_gpointer (simple);
+	if (ad->cancellable != NULL) {
+		g_cancellable_disconnect (ad->cancellable, ad->cancel_id);
+		g_object_unref (ad->cancellable);
+	}
 
-	xmlOutputBufferClose (ad->buf);
+	g_free (ad->as_url);
+	g_free (ad->oab_url);
 
-	ad->cb (urls, ad->cbdata, error);
-	g_object_unref (G_OBJECT (ad->cnc));
-	g_free (ad);
+	g_slice_free (struct _autodiscover_data, ad);
 }
 
 static void
@@ -1040,88 +1659,96 @@ ews_dump_raw_soup_response (SoupMessage 
 
 }
 
+static void
+autodiscover_cancelled_cb (GCancellable *cancellable,
+                           EEwsConnection *cnc)
+{
+	ews_connection_schedule_abort (cnc);
+}
+
 /* Called when each soup message completes */
 static void
-autodiscover_response_cb (SoupSession *session, SoupMessage *msg, gpointer data)
+autodiscover_response_cb (SoupSession *session,
+                          SoupMessage *msg,
+                          gpointer data)
 
 {
-	GError *error = NULL;
-	struct _autodiscover_data *ad = data;
+	GSimpleAsyncResult *simple = data;
+	struct _autodiscover_data *ad;
 	EwsUrls *urls = NULL;
 	guint status = msg->status_code;
 	xmlDoc *doc;
 	xmlNode *node;
-	int idx;
+	gint idx;
 	gboolean success = FALSE;
+	GError *error = NULL;
 
-	for (idx = 0; idx < 2; idx++) {
+	ad = g_simple_async_result_get_op_res_gpointer (simple);
+
+	for (idx = 0; idx < 4; idx++) {
 		if (ad->msgs[idx] == msg)
 			break;
 	}
-	if (idx == 2) {
+	if (idx == 4) {
 		/* We already got removed (cancelled). Do nothing */
-		return;
+		goto unref;
 	}
 
 	ad->msgs[idx] = NULL;
 
 	if (status != 200) {
 		g_set_error (
-			     &error, EWS_CONNECTION_ERROR,
-			     status,
-			     _("Code: %d - Unexpected response from server"),
-			     status);
+			&error, SOUP_HTTP_ERROR, status,
+			"%d %s", status, msg->reason_phrase);
 		goto failed;
 	}
 
 	ews_dump_raw_soup_response (msg);
-	doc = xmlReadMemory (msg->response_body->data, msg->response_body->length,
-			     "autodiscover.xml", NULL, 0);
+	doc = xmlReadMemory (
+		msg->response_body->data,
+		msg->response_body->length,
+		"autodiscover.xml", NULL, 0);
 	if (!doc) {
 		g_set_error (
-			     &error, EWS_CONNECTION_ERROR,
-			     -1,
-			     _("Failed to parse autodiscover response XML"));
+			&error, EWS_CONNECTION_ERROR, -1,
+			_("Failed to parse autodiscover response XML"));
 		goto failed;
 	}
-	node = xmlDocGetRootElement(doc);
-	if (strcmp((char *)node->name, "Autodiscover")) {
+	node = xmlDocGetRootElement (doc);
+	if (strcmp ((gchar *) node->name, "Autodiscover")) {
 		g_set_error (
-			     &error, EWS_CONNECTION_ERROR,
-			     -1,
-			     _("Failed to find <Autodiscover> element\n"));
+			&error, EWS_CONNECTION_ERROR, -1,
+			_("Failed to find <Autodiscover> element"));
 		goto failed;
 	}
 	for (node = node->children; node; node = node->next) {
 		if (node->type == XML_ELEMENT_NODE &&
-		    !strcmp((char *)node->name, "Response"))
+		    !strcmp ((gchar *) node->name, "Response"))
 			break;
 	}
 	if (!node) {
 		g_set_error (
-			     &error, EWS_CONNECTION_ERROR,
-			     -1,
-			     _("Failed to find <Response> element\n"));
+			&error, EWS_CONNECTION_ERROR, -1,
+			_("Failed to find <Response> element"));
 		goto failed;
 	}
 	for (node = node->children; node; node = node->next) {
 		if (node->type == XML_ELEMENT_NODE &&
-		    !strcmp((char *)node->name, "Account"))
+		    !strcmp ((gchar *) node->name, "Account"))
 			break;
 	}
 	if (!node) {
 		g_set_error (
-			     &error, EWS_CONNECTION_ERROR,
-			     -1,
-			     _("Failed to find <Account> element\n"));
+			&error, EWS_CONNECTION_ERROR, -1,
+			_("Failed to find <Account> element"));
 		goto failed;
 	}
 
 	urls = g_new0 (EwsUrls, 1);
 	for (node = node->children; node; node = node->next) {
 		if (node->type == XML_ELEMENT_NODE &&
-		    !strcmp((char *)node->name, "Protocol")) {
-		    	success = autodiscover_parse_protocol(node, urls);
+		    !strcmp ((gchar *) node->name, "Protocol")) {
+			success = autodiscover_parse_protocol (node, urls);
 			break;
 		}
 	}
@@ -1130,43 +1757,58 @@ autodiscover_response_cb (SoupSession *s
 		g_free (urls->as_url);
 		g_free (urls->oab_url);
 		g_free (urls);
-		g_set_error	(&error, EWS_CONNECTION_ERROR,
-				-1,
-				_("Failed to find <ASUrl> and <OABUrl> in autodiscover response"));
+		g_set_error (
+			&error, EWS_CONNECTION_ERROR, -1,
+			_("Failed to find <ASUrl> and <OABUrl> in autodiscover response"));
 		goto failed;
 	}
 
 	/* We have a good response; cancel all the others */
-	for (idx = 0; idx < 2; idx++) {
+	for (idx = 0; idx < 4; idx++) {
 		if (ad->msgs[idx]) {
 			SoupMessage *m = ad->msgs[idx];
 			ad->msgs[idx] = NULL;
-			soup_session_cancel_message (ad->cnc->priv->soup_session,
-						     m, SOUP_STATUS_CANCELLED);
+			ews_connection_schedule_cancel_message (ad->cnc, m);
 		}
 	}
-	
-	
-	g_simple_async_result_set_op_res_gpointer (ad->simple, urls, NULL);
-	g_simple_async_result_complete_in_idle (ad->simple);
-	return;
 
-failed:
-	for (idx = 0; idx < 2; idx++) {
+	ad->as_url = urls->as_url;
+	urls->as_url = NULL;
+
+	ad->oab_url = urls->oab_url;
+	urls->oab_url = NULL;
+
+	g_free (urls);
+
+	goto exit;
+
+ failed:
+	for (idx = 0; idx < 4; idx++) {
 		if (ad->msgs[idx]) {
 			/* There's another request outstanding.
-			   Hope that it has better luck. */
+			 * Hope that it has better luck. */
 			g_clear_error (&error);
-			return;
+			goto unref;
 		}
 	}
 
 	/* FIXME: We're actually returning the *last* error here,
-	   and in some cases (stupid firewalls causing timeouts)
-	   that's going to be the least interesting one. We probably
-	   want the *first* error */
-	g_simple_async_result_set_from_error (ad->simple, error);
-	g_simple_async_result_complete_in_idle (ad->simple);
+	 * and in some cases (stupid firewalls causing timeouts)
+	 * that's going to be the least interesting one. We probably
+	 * want the *first* error */
+	g_simple_async_result_take_error (simple, error);
+
+ exit:
+	g_simple_async_result_complete_in_idle (simple);
+
+ unref:
+	/* This function is processed within e_ews_soup_thread() and the 'simple'
+	 * holds reference to EEwsConnection. For cases when this is the last
+	 * reference to 'simple' the unref would cause crash, because of g_thread_join()
+	 * in connection's dispose, trying to wait on the end of itself, thus it's
+	 * safer to unref the 'simple' in a dedicated thread.
+	*/
+	ews_unref_in_thread (simple);
 }
 
 static void post_restarted (SoupMessage *msg, gpointer data)
@@ -1174,35 +1816,66 @@ static void post_restarted (SoupMessage 
 	xmlOutputBuffer *buf = data;
 
 	/* In violation of RFC2616, libsoup will change a POST request to
-	   a GET on receiving a 302 redirect. */
-	printf("Working around libsoup bug with redirect\n");
+	 * a GET on receiving a 302 redirect. */
+	printf ("Working around libsoup bug with redirect\n");
 	g_object_set (msg, SOUP_MESSAGE_METHOD, "POST", NULL);
 
-	soup_message_set_request(msg, "text/xml", SOUP_MEMORY_COPY,
-				 (gchar *)buf->buffer->content,
-				 buf->buffer->use);
+	soup_message_set_request (
+		msg, "text/xml; charset=utf-8", SOUP_MEMORY_COPY,
+		(gchar *)
+			#ifdef LIBXML2_NEW_BUFFER
+			xmlOutputBufferGetContent (buf), xmlOutputBufferGetSize (buf)
+			#else
+			buf->buffer->content, buf->buffer->use
+			#endif
+		);
 }
 
 static SoupMessage *
-e_ews_get_msg_for_url (const gchar *url, xmlOutputBuffer *buf)
+e_ews_get_msg_for_url (const gchar *url,
+                       xmlOutputBuffer *buf,
+                       GError **error)
 {
 	SoupMessage *msg;
 
-	msg = soup_message_new(buf?"POST":"GET", url);
-	soup_message_headers_append (msg->request_headers,
-				     "User-Agent", "libews/0.1");
+	if (url == NULL) {
+		g_set_error_literal (
+			error, G_IO_ERROR, G_IO_ERROR_INVALID_ARGUMENT,
+			_("URL cannot be NULL"));
+		return NULL;
+	}
 
+	msg = soup_message_new (buf != NULL ? "POST" : "GET", url);
+	if (!msg) {
+		g_set_error (
+			error, G_IO_ERROR, G_IO_ERROR_INVALID_ARGUMENT,
+			_("URL '%s' is not valid"), url);
+		return NULL;
+	}
 
-	if (buf) {
-		soup_message_set_request (msg, "application/xml", SOUP_MEMORY_COPY,
-					  (gchar *)buf->buffer->content,
-					  buf->buffer->use);
-		g_signal_connect (msg, "restarted",
-				  G_CALLBACK (post_restarted), buf);
+	soup_message_headers_append (
+		msg->request_headers,
+		"User-Agent", "libews/0.1");
+
+	if (buf != NULL) {
+		soup_message_set_request (
+			msg, "text/xml; charset=utf-8", SOUP_MEMORY_COPY,
+			(gchar *)
+			#ifdef LIBXML2_NEW_BUFFER
+			xmlOutputBufferGetContent (buf), xmlOutputBufferGetSize (buf)
+			#else
+			buf->buffer->content, buf->buffer->use
+			#endif
+			);
+		g_signal_connect (
+			msg, "restarted",
+			G_CALLBACK (post_restarted), buf);
 	}
 
 	if (g_getenv ("EWS_DEBUG") && (atoi (g_getenv ("EWS_DEBUG")) >= 1)) {
-		soup_buffer_free (soup_message_body_flatten (SOUP_MESSAGE (msg)->request_body));
+		soup_buffer_free (
+			soup_message_body_flatten (
+			SOUP_MESSAGE (msg)->request_body));
 		/* print request's body */
 		printf ("\n The request headers");
 		printf ("\n ===================");
@@ -1214,47 +1887,122 @@ e_ews_get_msg_for_url (const gchar *url,
 	return msg;
 }
 
+gboolean
+e_ews_autodiscover_ws_url_sync (GObject *on_object,
+				const gchar *uri,
+				const gchar *username,
+				const gchar *email_address,
+				const gchar *password,
+				gint timeout,
+				gboolean use_ntlm,
+				gchar **as_url,
+				gchar **oab_url,
+				GCancellable *cancellable,
+				GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (username != NULL, FALSE);
+	g_return_val_if_fail (email_address != NULL, FALSE);
+	g_return_val_if_fail (password != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_autodiscover_ws_url (
+		on_object, uri, username, email_address, password, timeout, use_ntlm, cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_autodiscover_ws_url_finish (on_object, result, as_url, oab_url, error);
+
+	e_async_closure_free (closure);
+
+	return success;
+}
+
 void
-e_ews_autodiscover_ws_url (EEwsAutoDiscoverCallback cb, gpointer cbdata,
-			   const gchar *email, const gchar *password)
+e_ews_autodiscover_ws_url (GObject *on_object,
+			   const gchar *uri,
+			   const gchar *username,
+			   const gchar *email_address,
+			   const gchar *password,
+			   gint timeout,
+			   gboolean use_ntlm,
+			   GCancellable *cancellable,
+			   GAsyncReadyCallback callback,
+			   gpointer user_data)
 {
+	GSimpleAsyncResult *simple;
 	struct _autodiscover_data *ad;
 	xmlOutputBuffer *buf;
-	GError *error = NULL;
-	gchar *url;
+	gchar *url1, *url2, *url3, *url4;
 	gchar *domain;
 	xmlDoc *doc;
 	EEwsConnection *cnc;
+	SoupURI *soup_uri = NULL;
+	gboolean use_secure = TRUE;
+	const gchar *host_url;
+	const gchar *user;
+	GError *error = NULL;
 
-	if (!password || !email) {
-		g_set_error (&error, EWS_CONNECTION_ERROR,
-			     -1, _("Both email and password must be provided"));
-		goto err;
-	}
-
-	domain = strchr(email, '@');
-	if (!(domain && *domain)) {
-		g_set_error (&error, EWS_CONNECTION_ERROR,
-			     -1, _("Wrong email id"));
-		goto err;
+	g_return_if_fail (username != NULL);
+	g_return_if_fail (email_address != NULL);
+	g_return_if_fail (password != NULL);
+
+	simple = g_simple_async_result_new (
+		on_object, callback,
+		user_data, e_ews_autodiscover_ws_url);
+
+	domain = strchr (email_address, '@');
+	if (domain == NULL || *domain == '\0') {
+		g_simple_async_result_set_error (
+			simple, EWS_CONNECTION_ERROR, -1,
+			"%s", _("Email address is missing a domain part"));
+		g_simple_async_result_complete_in_idle (simple);
+		g_object_unref (simple);
+		return;
 	}
 	domain++;
 
-	doc = e_ews_autodiscover_ws_xml(email);
-	buf = xmlAllocOutputBuffer(NULL);
-	xmlNodeDumpOutput(buf, doc, xmlDocGetRootElement(doc), 0, 1, NULL);
-	xmlOutputBufferFlush(buf);
-
-	url = g_strdup_printf("https://%s/autodiscover/autodiscover.xml", domain);
-
-	/* FIXME: Get username from config; don't assume same as email */
-	cnc = e_ews_connection_new (url, email, password, NULL, NULL, &error);
-	if (!cnc) {
-	err:
-		cb (NULL, cbdata, error);
-		return;
+	doc = e_ews_autodiscover_ws_xml (email_address);
+	buf = xmlAllocOutputBuffer (NULL);
+	xmlNodeDumpOutput (buf, doc, xmlDocGetRootElement (doc), 0, 1, NULL);
+	xmlOutputBufferFlush (buf);
+
+	url1 = NULL;
+	url2 = NULL;
+	url3 = NULL;
+	url4 = NULL;
+
+	host_url = uri;
+	if (host_url != NULL)
+		soup_uri = soup_uri_new (host_url);
+
+	if (soup_uri != NULL) {
+		const gchar *host = soup_uri_get_host (soup_uri);
+		const gchar *scheme = soup_uri_get_scheme (soup_uri);
+
+		use_secure = g_strcmp0 (scheme, "https") == 0;
+
+		url1 = g_strdup_printf ("http%s://%s/autodiscover/autodiscover.xml", use_secure ? "s" : "", host);
+		url2 = g_strdup_printf ("http%s://autodiscover.%s/autodiscover/autodiscover.xml", use_secure ? "s" : "", host);
+
+		soup_uri_free (soup_uri);
 	}
 
+	url3 = g_strdup_printf ("http%s://%s/autodiscover/autodiscover.xml", use_secure ? "s" : "", domain);
+	url4 = g_strdup_printf ("http%s://autodiscover.%s/autodiscover/autodiscover.xml", use_secure ? "s" : "", domain);
+
+	user = username;
+	if (user == NULL || *user == '\0')
+		user = email_address;
+
+	cnc = e_ews_connection_new (url1 ? url1 : url3, username, password, email_address, NULL, timeout, use_ntlm,
+		NULL, NULL, NULL);
+
 	/*
 	 * http://msdn.microsoft.com/en-us/library/ee332364.aspx says we are
 	 * supposed to try $domain and then autodiscover.$domain. But some
@@ -1263,98 +2011,220 @@ e_ews_autodiscover_ws_url (EEwsAutoDisco
 	 * to time out. So run both queries in parallel and let the fastest
 	 * (successful) one win.
 	 */
-	ad = g_new0 (struct _autodiscover_data, 1);
-	ad->cb = cb;
-	ad->cbdata = cbdata;
-	ad->cnc = cnc;
-	ad->buf = buf;
-	ad->simple = g_simple_async_result_new (G_OBJECT (cnc), autodiscover_done_cb,
-					    ad, e_ews_autodiscover_ws_url);
-	ad->msgs[0] = e_ews_get_msg_for_url (url, buf);
-	g_free (url);
-
-	url = g_strdup_printf("https://autodiscover.%s/autodiscover/autodiscover.xml", domain);
-	ad->msgs[1] = e_ews_get_msg_for_url (url, buf);
-	g_free (url);
+	ad = g_slice_new0 (struct _autodiscover_data);
+	ad->cnc = cnc;  /* takes ownership */
+	ad->buf = buf;  /* takes ownership */
+
+	if (G_IS_CANCELLABLE (cancellable)) {
+		ad->cancellable = g_object_ref (cancellable);
+		ad->cancel_id = g_cancellable_connect (
+			ad->cancellable,
+			G_CALLBACK (autodiscover_cancelled_cb),
+			g_object_ref (cnc),
+			(GDestroyNotify) g_object_unref);
+	}
 
-	/* These have to be submitted only after they're both set in ad->msgs[]
-	   or there will be races with fast completion */
-	soup_session_queue_message (cnc->priv->soup_session, ad->msgs[0],
-				    autodiscover_response_cb, ad);
-	soup_session_queue_message (cnc->priv->soup_session, ad->msgs[1],
-				    autodiscover_response_cb, ad);
+	g_simple_async_result_set_op_res_gpointer (
+		simple, ad, (GDestroyNotify) autodiscover_data_free);
+
+	/* Passing a NULL URL string returns NULL. */
+	ad->msgs[0] = e_ews_get_msg_for_url (url1, buf, &error);
+	ad->msgs[1] = e_ews_get_msg_for_url (url2, buf, NULL);
+	ad->msgs[2] = e_ews_get_msg_for_url (url3, buf, NULL);
+	ad->msgs[3] = e_ews_get_msg_for_url (url4, buf, NULL);
 
-	g_object_unref (cnc); /* the GSimpleAsyncResult holds it now */
+	/* These have to be submitted only after they're both set in ad->msgs[]
+	 * or there will be races with fast completion */
+	if (ad->msgs[0] != NULL)
+		ews_connection_schedule_queue_message (cnc, ad->msgs[0], autodiscover_response_cb, g_object_ref (simple));
+	if (ad->msgs[1] != NULL)
+		ews_connection_schedule_queue_message (cnc, ad->msgs[1], autodiscover_response_cb, g_object_ref (simple));
+	if (ad->msgs[2] != NULL)
+		ews_connection_schedule_queue_message (cnc, ad->msgs[2], autodiscover_response_cb, g_object_ref (simple));
+	if (ad->msgs[3] != NULL)
+		ews_connection_schedule_queue_message (cnc, ad->msgs[3], autodiscover_response_cb, g_object_ref (simple));
 
 	xmlFreeDoc (doc);
+	g_free (url1);
+	g_free (url2);
+	g_free (url3);
+	g_free (url4);
+
+	if (error && !ad->msgs[0] && !ad->msgs[1] && !ad->msgs[2] && !ad->msgs[3]) {
+		g_simple_async_result_take_error (simple, error);
+		g_simple_async_result_complete_in_idle (simple);
+	} else {
+		g_clear_error (&error);
+
+		/* each request holds a reference to 'simple',
+		 * thus remove one, to have it actually freed */
+		g_object_unref (simple);
+	}
 }
 
+static gboolean
+has_suffix_icmp (const gchar *text,
+                 const gchar *suffix)
+{
+	gint ii, tlen, slen;
 
-struct _oal_req_data {
-	EEwsConnection *cnc;
-	GSimpleAsyncResult *simple;
-	SoupMessage *msg;
-	GCancellable *cancellable;
-	gulong cancel_handler_id;
-	gchar *oal_id;
-	gchar *oal_element;
-	
-	/* for dowloading oal file */
-	gchar *cache_filename;
-	GError *error;
-	EwsProgressFn progress_fn;
-	gpointer progress_data;
-	gsize response_size;
-	gsize received_size;
-};
+	g_return_val_if_fail (text != NULL, FALSE);
+	g_return_val_if_fail (suffix != NULL, FALSE);
 
-static gchar *
-get_property (xmlNodePtr node_ptr, const gchar *name)
-{
-	xmlChar *xml_s;
-	gchar *s;
-	
-	xml_s = xmlGetProp (node_ptr, (const xmlChar *) name);
-	s = g_strdup ((gchar *)xml_s);
-	xmlFree (xml_s);
+	tlen = strlen (text);
+	slen = strlen (suffix);
 
-	return s;
-}
+	if (!*text || !*suffix || tlen < slen)
+		return FALSE;
 
-static guint32
-get_property_as_uint32 (xmlNodePtr node_ptr, const gchar *name)
-{
-	gchar *s;
-	guint32 val = -1;
-	
-	s = get_property (node_ptr, name);
-	if (s)
-		sscanf (s,"%"G_GUINT32_FORMAT, &val);
-	g_free (s);
+	for (ii = 0; ii < slen; ii++) {
+		if (g_ascii_tolower (text[tlen - ii - 1]) !=
+		    g_ascii_tolower (suffix[slen - ii - 1]))
+			break;
+	}
 
-	return val;
+	return ii == slen;
 }
 
-static gchar *
-get_content (xmlNodePtr node_ptr)
+gboolean
+e_ews_autodiscover_ws_url_finish (GObject *on_object,
+				  GAsyncResult *result,
+				  gchar **as_url,
+				  gchar **oab_url,
+				  GError **error)
+{
+	GSimpleAsyncResult *simple;
+	struct _autodiscover_data *ad;
+
+	g_return_val_if_fail (
+		g_simple_async_result_is_valid (
+		result, on_object,
+		e_ews_autodiscover_ws_url), FALSE);
+
+	simple = G_SIMPLE_ASYNC_RESULT (result);
+	ad = g_simple_async_result_get_op_res_gpointer (simple);
+
+	if (g_simple_async_result_propagate_error (simple, error))
+		return FALSE;
+
+	g_warn_if_fail (ad->as_url != NULL);
+	g_warn_if_fail (ad->oab_url != NULL);
+
+	if (as_url)
+		*as_url = g_strdup (ad->as_url);
+
+	if (oab_url) {
+		if (!has_suffix_icmp (ad->oab_url, "oab.xml")) {
+			gchar *tmp;
+
+			if (g_str_has_suffix (ad->oab_url, "/"))
+				tmp = g_strconcat (ad->oab_url, "oab.xml", NULL);
+			else
+				tmp = g_strconcat (ad->oab_url, "/", "oab.xml", NULL);
+
+			*oab_url = g_strdup (tmp);
+			g_free (tmp);
+		} else {
+			*oab_url = g_strdup (ad->oab_url);
+		}
+	}
+
+	return TRUE;
+}
+
+struct _oal_req_data {
+	EEwsConnection *cnc;
+	SoupMessage *soup_message;
+	gchar *oal_id;
+	gchar *oal_element;
+
+	GSList *oals;
+	GSList *elements;
+
+	GCancellable *cancellable;
+	gulong cancel_id;
+
+	/* for dowloading oal file */
+	gchar *cache_filename;
+	GError *error;
+	EwsProgressFn progress_fn;
+	gpointer progress_data;
+	gsize response_size;
+	gsize received_size;
+};
+
+static void
+oal_req_data_free (struct _oal_req_data *data)
+{
+	/* The SoupMessage is owned by the SoupSession. */
+	g_object_unref (data->cnc);
+
+	g_free (data->oal_id);
+	g_free (data->oal_element);
+
+	g_slist_free_full (data->oals, (GDestroyNotify) ews_oal_free);
+	g_slist_free_full (data->elements, (GDestroyNotify) ews_oal_details_free);
+
+	if (data->cancellable != NULL) {
+		g_cancellable_disconnect (data->cancellable, data->cancel_id);
+		g_object_unref (data->cancellable);
+	}
+
+	g_free (data->cache_filename);
+
+	g_slice_free (struct _oal_req_data, data);
+}
+
+static gchar *
+get_property (xmlNodePtr node_ptr,
+              const gchar *name)
+{
+	xmlChar *xml_s;
+	gchar *s;
+
+	xml_s = xmlGetProp (node_ptr, (const xmlChar *) name);
+	s = g_strdup ((gchar *) xml_s);
+	xmlFree (xml_s);
+
+	return s;
+}
+
+static guint32
+get_property_as_uint32 (xmlNodePtr node_ptr,
+                        const gchar *name)
+{
+	gchar *s;
+	guint32 val = -1;
+
+	s = get_property (node_ptr, name);
+	if (s)
+		sscanf (s,"%"G_GUINT32_FORMAT, &val);
+	g_free (s);
+
+	return val;
+}
+
+static gchar *
+get_content (xmlNodePtr node_ptr)
 {
 	xmlChar *xml_s;
 	gchar *s;
 
 	xml_s = xmlNodeGetContent (node_ptr);
-	s = g_strdup ((gchar *)xml_s);
+	s = g_strdup ((gchar *) xml_s);
 	xmlFree (xml_s);
 
 	return s;
 }
 
 static GSList *
-parse_oal_full_details (xmlNode *node, const gchar *element)
+parse_oal_full_details (xmlNode *node,
+                        const gchar *element)
 {
 	GSList *elements = NULL;
-	
+
 	for (node = node->children; node; node = node->next) {
-		if (node->type == XML_ELEMENT_NODE && !strcmp((char *)node->name, element)) {
+		if (node->type == XML_ELEMENT_NODE && !strcmp ((gchar *) node->name, element)) {
 			EwsOALDetails *det = g_new0 (EwsOALDetails, 1);
 
 			det->seq = get_property_as_uint32 (node, "seq");
@@ -1363,65 +2233,77 @@ parse_oal_full_details (xmlNode *node, c
 			det->uncompressed_size = get_property_as_uint32 (node, "uncompressedsize");
 			det->sha = get_property (node, "uncompressedsize");
 			det->filename = g_strstrip (get_content (node));
-			
+
 			elements = g_slist_prepend (elements, det);
 			if (!strcmp (element, "Full"))
-				break; 
+				break;
 		}
 	}
 
 	return elements;
 }
 
+/* this is run in cnc->priv->soup_thread */
 static void
-oal_response_cb (SoupSession *session, SoupMessage *msg, gpointer user_data)
+oal_response_cb (SoupSession *soup_session,
+                 SoupMessage *soup_message,
+                 gpointer user_data)
 {
-	GError *error = NULL;
-	guint status = msg->status_code;
+	GSimpleAsyncResult *simple;
+	struct _oal_req_data *data;
 	xmlDoc *doc;
 	xmlNode *node;
-	struct _oal_req_data *data = (struct _oal_req_data *) user_data;
-	GSList *oals = NULL;
 
-	if (status != 200) {
-		g_set_error (&error, EWS_CONNECTION_ERROR, status,
-			     _("Code: %d - Unexpected response from server"),
-			     status);
+	simple = G_SIMPLE_ASYNC_RESULT (user_data);
+	data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	if (soup_message->status_code != 200) {
+		g_simple_async_result_set_error (
+			simple, SOUP_HTTP_ERROR,
+			soup_message->status_code,
+			"%d %s",
+			soup_message->status_code,
+			soup_message->reason_phrase);
 		goto exit;
 	}
-	ews_dump_raw_soup_response (msg);
-	
-	doc = xmlReadMemory (msg->response_body->data, msg->response_body->length,
-			     "oab.xml", NULL, 0);
-	if (!doc) {
-		g_set_error (&error, EWS_CONNECTION_ERROR,
-			     -1, _("Failed to parse oab XML"));
+
+	ews_dump_raw_soup_response (soup_message);
+
+	doc = xmlReadMemory (
+		soup_message->response_body->data,
+		soup_message->response_body->length,
+		"oab.xml", NULL, 0);
+	if (doc == NULL) {
+		g_simple_async_result_set_error (
+			simple, EWS_CONNECTION_ERROR, -1,
+			"%s", _("Failed to parse oab XML"));
 		goto exit;
 	}
 
-	node = xmlDocGetRootElement(doc);
-	if (strcmp((char *)node->name, "OAB")) {
-		g_set_error (&error, EWS_CONNECTION_ERROR, -1,
-			     _("Failed to find <OAB> element\n"));
+	node = xmlDocGetRootElement (doc);
+	if (strcmp ((gchar *) node->name, "OAB") != 0) {
+		g_simple_async_result_set_error (
+			simple, EWS_CONNECTION_ERROR, -1,
+			"%s", _("Failed to find <OAB> element\n"));
 		goto exit;
 	}
 
 	for (node = node->children; node; node = node->next) {
-		if (node->type == XML_ELEMENT_NODE && !strcmp((char *)node->name, "OAL")) {
-			if (!data->oal_id) {
+		if (node->type == XML_ELEMENT_NODE && strcmp ((gchar *) node->name, "OAL") == 0) {
+			if (data->oal_id == NULL) {
 				EwsOAL *oal = g_new0 (EwsOAL, 1);
 
 				oal->id = get_property (node, "id");
 				oal->dn = get_property (node, "dn");
 				oal->name = get_property (node, "name");
 
-				oals = g_slist_prepend (oals, oal);
+				data->oals = g_slist_prepend (data->oals, oal);
 			} else {
 				gchar *id = get_property (node, "id");
-				
-				if (!strcmp (id, data->oal_id)) {
+
+				if (strcmp (id, data->oal_id) == 0) {
 					/* parse details of full_details file */
-					oals = parse_oal_full_details (node, data->oal_element);
+					data->elements = parse_oal_full_details (node, data->oal_element);
 
 					g_free (id);
 					break;
@@ -1432,141 +2314,122 @@ oal_response_cb (SoupSession *session, S
 		}
 	}
 
-	oals = g_slist_reverse (oals);
-	g_simple_async_result_set_op_res_gpointer (data->simple, oals, NULL);
+	data->oals = g_slist_reverse (data->oals);
 
 exit:
-	if (data->cancellable)
-		g_signal_handler_disconnect (data->cancellable, data->cancel_handler_id);
-
-	if (error) {
-		g_simple_async_result_set_from_error (data->simple, error);
-		g_clear_error (&error);
-	}
-
-	g_simple_async_result_complete_in_idle (data->simple);
-	g_free (data->oal_id);
-	g_free (data->oal_element);
-	g_free (data);
+	g_simple_async_result_complete_in_idle (simple);
+	/* This is run in cnc->priv->soup_thread, and the cnc is held by simple, thus
+	 * for cases when the complete_in_idle is finished before the unref call, when
+	 * the cnc will be left with the last reference and thus cannot join the soup_thread
+	 * while still in it, the unref is done in a dedicated thread. */
+	ews_unref_in_thread (simple);
 }
 
 static void
 ews_cancel_msg (GCancellable *cancellable,
-		gpointer user_data)
+                struct _oal_req_data *data)
 {
-	struct _oal_req_data *data = (struct _oal_req_data *) user_data;
-
-	soup_session_cancel_message (data->cnc->priv->soup_session, SOUP_MESSAGE (data->msg), SOUP_STATUS_CANCELLED);
+	ews_connection_schedule_cancel_message (data->cnc, data->soup_message);
 }
 
-void		
-e_ews_connection_get_oal_list_start	(EEwsConnection *cnc,
-					 GAsyncReadyCallback cb,
-					 GCancellable *cancellable,
-					 gpointer user_data)
+gboolean
+e_ews_connection_get_oal_list_sync (EEwsConnection *cnc,
+                                    GSList **oals,
+                                    GCancellable *cancellable,
+                                    GError **error)
 {
-	GSimpleAsyncResult *simple;
-	SoupMessage *msg;
-	struct _oal_req_data *data;
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
 
-	msg = e_ews_get_msg_for_url (cnc->priv->uri, NULL);
- 	
-	simple = g_simple_async_result_new (G_OBJECT (cnc),
-                                      cb,
-                                      user_data,
-                                      e_ews_connection_get_oal_list_start);
-	data = g_new0 (struct _oal_req_data, 1);
-	data->cnc = cnc;
-	data->simple = simple;
-	data->cancellable = cancellable;
-	data->msg = msg;
-	
-	if (cancellable)
-		data->cancel_handler_id = g_cancellable_connect	(cancellable,
-							 	 G_CALLBACK (ews_cancel_msg), (gpointer) data, NULL);
-	soup_session_queue_message (cnc->priv->soup_session, msg,
-				    oal_response_cb, data);
-}
+	g_return_val_if_fail (E_IS_EWS_CONNECTION (cnc), FALSE);
 
-gboolean	
-e_ews_connection_get_oal_list_finish	(EEwsConnection *cnc,
-					 GAsyncResult *result,
-					 GSList **oals,
-					 GError **error)
-{
-	GSimpleAsyncResult *simple;
+	closure = e_async_closure_new ();
 
-	g_return_val_if_fail (
-		g_simple_async_result_is_valid (
-		result, G_OBJECT (cnc), e_ews_connection_get_oal_list_start),
-		FALSE);
+	e_ews_connection_get_oal_list (
+		cnc, cancellable, e_async_closure_callback, closure);
 
-	simple = G_SIMPLE_ASYNC_RESULT (result);
+	result = e_async_closure_wait (closure);
 
-	if (g_simple_async_result_propagate_error (simple, error))
-		return FALSE;
-	
-	*oals= g_simple_async_result_get_op_res_gpointer (simple);
+	success = e_ews_connection_get_oal_list_finish (
+		cnc, result, oals, error);
 
-	return TRUE;
+	e_async_closure_free (closure);
+
+	return success;
 }
 
-void		
-e_ews_connection_get_oal_detail_start	(EEwsConnection *cnc,
-					 const gchar *oal_id,
-					 const gchar *oal_element,
-					 GAsyncReadyCallback cb,
-					 GCancellable *cancellable,
-					 gpointer user_data)
+void
+e_ews_connection_get_oal_list (EEwsConnection *cnc,
+                               GCancellable *cancellable,
+                               GAsyncReadyCallback callback,
+                               gpointer user_data)
 {
 	GSimpleAsyncResult *simple;
-	SoupMessage *msg;
+	SoupMessage *soup_message;
 	struct _oal_req_data *data;
+	GError *error = NULL;
 
-	msg = e_ews_get_msg_for_url (cnc->priv->uri, NULL);
- 	
-	simple = g_simple_async_result_new (G_OBJECT (cnc),
-                                      cb,
-                                      user_data,
-                                      e_ews_connection_get_oal_detail_start);
-	data = g_new0 (struct _oal_req_data, 1);
-	data->cnc = cnc;
-	data->simple = simple;
-	data->cancellable = cancellable;
-	data->msg = msg;
-	data->oal_id = g_strdup (oal_id);
-	data->oal_element = g_strdup (oal_element);
-	
-	if (cancellable)
-		data->cancel_handler_id = g_cancellable_connect	(cancellable,
-							 	 G_CALLBACK (ews_cancel_msg), (gpointer) data, NULL);
-	soup_session_queue_message (cnc->priv->soup_session, msg,
-				    oal_response_cb, data);
+	g_return_if_fail (E_IS_EWS_CONNECTION (cnc));
+
+	soup_message = e_ews_get_msg_for_url (cnc->priv->uri, NULL, &error);
+
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_get_oal_list);
+
+	if (!soup_message) {
+		g_simple_async_result_take_error (simple, error);
+		g_simple_async_result_complete_in_idle (simple);
+		return;
+	}
+
+	data = g_slice_new0 (struct _oal_req_data);
+	data->cnc = g_object_ref (cnc);
+	data->soup_message = soup_message;  /* the session owns this */
+
+	if (G_IS_CANCELLABLE (cancellable)) {
+		data->cancellable = g_object_ref (cancellable);
+		data->cancel_id = g_cancellable_connect (
+			data->cancellable,
+			G_CALLBACK (ews_cancel_msg),
+			data, (GDestroyNotify) NULL);
+	}
+
+	g_simple_async_result_set_op_res_gpointer (
+		simple, data, (GDestroyNotify) oal_req_data_free);
 
+	ews_connection_schedule_queue_message (cnc, soup_message, oal_response_cb, simple);
 }
 
-gboolean	
-e_ews_connection_get_oal_detail_finish	(EEwsConnection *cnc,
-					 GAsyncResult *result,
-					 GSList **elements,
-					 GError **error)
+gboolean
+e_ews_connection_get_oal_list_finish (EEwsConnection *cnc,
+                                      GAsyncResult *result,
+                                      GSList **oals,
+                                      GError **error)
 {
 	GSimpleAsyncResult *simple;
+	struct _oal_req_data *data;
+
+	g_return_val_if_fail (E_IS_EWS_CONNECTION (cnc), FALSE);
 
 	g_return_val_if_fail (
 		g_simple_async_result_is_valid (
-		result, G_OBJECT (cnc), e_ews_connection_get_oal_detail_start),
+		result, G_OBJECT (cnc), e_ews_connection_get_oal_list),
 		FALSE);
 
 	simple = G_SIMPLE_ASYNC_RESULT (result);
+	data = g_simple_async_result_get_op_res_gpointer (simple);
 
 	if (g_simple_async_result_propagate_error (simple, error))
 		return FALSE;
-	
-	*elements = g_simple_async_result_get_op_res_gpointer (simple);
 
-	return TRUE;
+	if (oals != NULL) {
+		*oals = data->oals;
+		data->oals = NULL;
+	}
 
+	return TRUE;
 }
 
 /**
@@ -1581,85 +2444,167 @@ e_ews_connection_get_oal_detail_finish	(
  * 
  * Returns: 
  **/
-gboolean	
-e_ews_connection_get_oal_detail	(EEwsConnection *cnc,
-				 const gchar *oal_id,
-				 const gchar *oal_element,
-				 GSList **elements,
-				 GCancellable *cancellable,
-				 GError **error)
+gboolean
+e_ews_connection_get_oal_detail_sync (EEwsConnection *cnc,
+                                      const gchar *oal_id,
+                                      const gchar *oal_element,
+                                      GSList **elements,
+                                      GCancellable *cancellable,
+                                      GError **error)
 {
-	EwsSyncData *sync_data;
-	gboolean result;
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
 
-	sync_data = g_new0 (EwsSyncData, 1);
-	sync_data->eflag = e_flag_new ();
+	g_return_val_if_fail (E_IS_EWS_CONNECTION (cnc), FALSE);
 
-	e_ews_connection_get_oal_detail_start	(cnc, oal_id, oal_element,
-						 ews_sync_reply_cb,
-						 cancellable,
-						 (gpointer) sync_data);
+	closure = e_async_closure_new ();
 
-	e_flag_wait (sync_data->eflag);
+	e_ews_connection_get_oal_detail (
+		cnc, oal_id, oal_element, cancellable,
+		e_async_closure_callback, closure);
 
-	result = e_ews_connection_get_oal_detail_finish 
-						(cnc, sync_data->res,
-						 elements, error);
+	result = e_async_closure_wait (closure);
 
-	e_flag_free (sync_data->eflag);
-	g_object_unref (sync_data->res);
-	g_free (sync_data);
+	success = e_ews_connection_get_oal_detail_finish (
+		cnc, result, elements, error);
 
-	return result;
+	e_async_closure_free (closure);
+
+	return success;
 }
 
-static void
-oal_download_response_cb (SoupSession *session, SoupMessage *msg, gpointer user_data)
+void
+e_ews_connection_get_oal_detail (EEwsConnection *cnc,
+                                 const gchar *oal_id,
+                                 const gchar *oal_element,
+                                 GCancellable *cancellable,
+                                 GAsyncReadyCallback callback,
+                                 gpointer user_data)
 {
+	GSimpleAsyncResult *simple;
+	SoupMessage *soup_message;
+	struct _oal_req_data *data;
+	gchar *sep;
 	GError *error = NULL;
-	guint status = msg->status_code;
-	struct _oal_req_data *data = (struct _oal_req_data *) user_data;
 
-	if (status != 200) {
-		g_set_error (&error, EWS_CONNECTION_ERROR, status,
-			     _("Code: %d - Unexpected response from server"),
-			     status);
-		g_unlink (data->cache_filename);
-		goto exit;
-	} else if (data->error != NULL) {
-		g_propagate_error (&error, data->error);
-		g_unlink (data->cache_filename);
-		goto exit;
+	g_return_if_fail (E_IS_EWS_CONNECTION (cnc));
+
+	soup_message = e_ews_get_msg_for_url (cnc->priv->uri, NULL, &error);
+
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_get_oal_detail);
+
+	if (!soup_message) {
+		g_simple_async_result_take_error (simple, error);
+		g_simple_async_result_complete_in_idle (simple);
+		return;
 	}
 
-	g_simple_async_result_set_op_res_gpointer (data->simple, NULL, NULL);
+	data = g_slice_new0 (struct _oal_req_data);
+	data->cnc = g_object_ref (cnc);
+	data->soup_message = soup_message;  /* the session owns this */
+	data->oal_id = g_strdup (oal_id);
+	data->oal_element = g_strdup (oal_element);
 
-exit:
-	if (error) {
-		g_simple_async_result_set_from_error (data->simple, error);
-		g_clear_error (&error);
+	/* oal_id can be of form "GUID:name", but here is compared only GUID */
+	sep = strchr (data->oal_id, ':');
+	if (sep)
+		*sep = '\0';
+
+	if (G_IS_CANCELLABLE (cancellable)) {
+		data->cancellable = g_object_ref (cancellable);
+		data->cancel_id = g_cancellable_connect (
+			data->cancellable,
+			G_CALLBACK (ews_cancel_msg),
+			data, (GDestroyNotify) NULL);
 	}
 
-	g_simple_async_result_complete_in_idle (data->simple);
-	g_free (data->cache_filename);
-	g_free (data);
+	g_simple_async_result_set_op_res_gpointer (
+		simple, data, (GDestroyNotify) oal_req_data_free);
+
+	ews_connection_schedule_queue_message (cnc, soup_message, oal_response_cb, simple);
+}
+
+gboolean
+e_ews_connection_get_oal_detail_finish (EEwsConnection *cnc,
+                                        GAsyncResult *result,
+                                        GSList **elements,
+                                        GError **error)
+{
+	GSimpleAsyncResult *simple;
+	struct _oal_req_data *data;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+	g_return_val_if_fail (
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (cnc), e_ews_connection_get_oal_detail),
+		FALSE);
+
+	simple = G_SIMPLE_ASYNC_RESULT (result);
+	data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	if (g_simple_async_result_propagate_error (simple, error))
+		return FALSE;
+
+	if (elements != NULL) {
+		*elements = data->elements;
+		data->elements = NULL;
+	}
+
+	return TRUE;
+
+}
+
+static void
+oal_download_response_cb (SoupSession *soup_session,
+                          SoupMessage *soup_message,
+                          gpointer user_data)
+{
+	GSimpleAsyncResult *simple;
+	struct _oal_req_data *data;
+
+	simple = G_SIMPLE_ASYNC_RESULT (user_data);
+	data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	if (soup_message->status_code != 200) {
+		g_simple_async_result_set_error (
+			simple, SOUP_HTTP_ERROR,
+			soup_message->status_code,
+			"%d %s",
+			soup_message->status_code,
+			soup_message->reason_phrase);
+		g_unlink (data->cache_filename);
+
+	} else if (data->error != NULL) {
+		g_simple_async_result_take_error (simple, data->error);
+		data->error = NULL;
+		g_unlink (data->cache_filename);
+	}
+
+	g_simple_async_result_complete_in_idle (simple);
+	ews_unref_in_thread (simple);
 }
 
-static void 
-ews_soup_got_headers (SoupMessage *msg, gpointer user_data)
+static void
+ews_soup_got_headers (SoupMessage *msg,
+                      gpointer user_data)
 {
 	struct _oal_req_data *data = (struct _oal_req_data *) user_data;
-	const char *size;
+	const gchar *size;
 
-	size = soup_message_headers_get_one (msg->response_headers,
-					     "Content-Length");
+	size = soup_message_headers_get_one (
+		msg->response_headers,
+		"Content-Length");
 
 	if (size)
-		data->response_size = strtol(size, NULL, 10);
+		data->response_size = strtol (size, NULL, 10);
 }
 
-static void 
-ews_soup_restarted (SoupMessage *msg, gpointer user_data)
+static void
+ews_soup_restarted (SoupMessage *msg,
+                    gpointer user_data)
 {
 	struct _oal_req_data *data = (struct _oal_req_data *) user_data;
 
@@ -1667,8 +2612,10 @@ ews_soup_restarted (SoupMessage *msg, gp
 	data->received_size = 0;
 }
 
-static void 
-ews_soup_got_chunk (SoupMessage *msg, SoupBuffer *chunk, gpointer user_data)
+static void
+ews_soup_got_chunk (SoupMessage *msg,
+                    SoupBuffer *chunk,
+                    gpointer user_data)
 {
 	struct _oal_req_data *data = (struct _oal_req_data *) user_data;
 	gint fd;
@@ -1679,15 +2626,16 @@ ews_soup_got_chunk (SoupMessage *msg, So
 	data->received_size += chunk->length;
 
 	if (data->response_size && data->progress_fn) {
-		int pc = data->received_size * 100 / data->response_size;
+		gint pc = data->received_size * 100 / data->response_size;
 		data->progress_fn (data->progress_data, pc);
 	}
 
 	fd = g_open (data->cache_filename, O_RDONLY | O_WRONLY | O_APPEND | O_CREAT, 0600);
 	if (fd != -1) {
-		if (write (fd, (const gchar*)chunk->data, chunk->length) != chunk->length) {
-			g_set_error (&data->error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_UNKNOWN,
-					"Failed to write streaming data to file : %d ", errno);
+		if (write (fd, (const gchar *) chunk->data, chunk->length) != chunk->length) {
+			g_set_error (
+				&data->error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_UNKNOWN,
+				"Failed to write streaming data to file : %d ", errno);
 		}
 #ifdef G_OS_WIN32
 		closesocket (fd);
@@ -1695,149 +2643,283 @@ ews_soup_got_chunk (SoupMessage *msg, So
 		close (fd);
 #endif
 	} else {
-		g_set_error (&data->error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_UNKNOWN,
+		g_set_error (
+			&data->error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_UNKNOWN,
 			"Failed to open the cache file : %d ", errno);
 	}
 }
 
-void		
-e_ews_connection_download_oal_file_start	(EEwsConnection *cnc,
-						 const gchar *cache_filename,
-						 GAsyncReadyCallback cb,
-						 EwsProgressFn progress_fn,
-						 gpointer progress_data,
-						 GCancellable *cancellable,
-						 gpointer user_data)
+gboolean
+e_ews_connection_download_oal_file_sync (EEwsConnection *cnc,
+                                         const gchar *cache_filename,
+                                         EwsProgressFn progress_fn,
+                                         gpointer progress_data,
+                                         GCancellable *cancellable,
+                                         GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (E_IS_EWS_CONNECTION (cnc), FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_download_oal_file (
+		cnc, cache_filename,
+		progress_fn, progress_data, cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_connection_download_oal_file_finish (
+		cnc, result, error);
+
+	e_async_closure_free (closure);
+
+	return success;
+}
+
+void
+e_ews_connection_download_oal_file (EEwsConnection *cnc,
+                                    const gchar *cache_filename,
+                                    EwsProgressFn progress_fn,
+                                    gpointer progress_data,
+                                    GCancellable *cancellable,
+                                    GAsyncReadyCallback callback,
+                                    gpointer user_data)
 {
 	GSimpleAsyncResult *simple;
-	SoupMessage *msg;
+	SoupMessage *soup_message;
 	struct _oal_req_data *data;
+	GError *error = NULL;
+
+	g_return_if_fail (E_IS_EWS_CONNECTION (cnc));
+
+	soup_message = e_ews_get_msg_for_url (cnc->priv->uri, NULL, &error);
 
-	msg = e_ews_get_msg_for_url (cnc->priv->uri, NULL);
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_download_oal_file);
+
+	if (!soup_message) {
+		g_simple_async_result_take_error (simple, error);
+		g_simple_async_result_complete_in_idle (simple);
+		return;
+	}
 
-	simple = g_simple_async_result_new (G_OBJECT (cnc),
-			cb,
-			user_data,
-			e_ews_connection_download_oal_file_start);
-	data = g_new0 (struct _oal_req_data, 1);
-	data->cnc = cnc;
-	data->simple = simple;
-	data->cancellable = cancellable;
-	data->msg = SOUP_MESSAGE (msg);
+	data = g_slice_new0 (struct _oal_req_data);
+	data->cnc = g_object_ref (cnc);
+	data->soup_message = soup_message;  /* the session owns this */
 	data->cache_filename = g_strdup (cache_filename);
 	data->progress_fn = progress_fn;
 	data->progress_data = progress_data;
 
-	if (cancellable)
-		data->cancel_handler_id = g_cancellable_connect	(cancellable,
-						G_CALLBACK (ews_cancel_msg), (gpointer) data, NULL);
-	
-	soup_message_body_set_accumulate (SOUP_MESSAGE (msg)->response_body,
-					  FALSE);
-	g_signal_connect (msg, "got-headers", G_CALLBACK (ews_soup_got_headers), data);
-	g_signal_connect (msg, "got-chunk", G_CALLBACK (ews_soup_got_chunk), data);
-	g_signal_connect (msg, "restarted", G_CALLBACK (ews_soup_restarted), data);
+	if (G_IS_CANCELLABLE (cancellable)) {
+		data->cancellable = g_object_ref (cancellable);
+		data->cancel_id = g_cancellable_connect (
+			data->cancellable,
+			G_CALLBACK (ews_cancel_msg),
+			data, (GDestroyNotify) NULL);
+	}
+
+	g_simple_async_result_set_op_res_gpointer (
+		simple, data, (GDestroyNotify) oal_req_data_free);
+
+	soup_message_body_set_accumulate (soup_message->response_body, FALSE);
 
-	soup_session_queue_message	(cnc->priv->soup_session, SOUP_MESSAGE (msg),
-					 oal_download_response_cb, data);
+	g_signal_connect (
+		soup_message, "got-headers",
+		G_CALLBACK (ews_soup_got_headers), data);
+	g_signal_connect (
+		soup_message, "got-chunk",
+		G_CALLBACK (ews_soup_got_chunk), data);
+	g_signal_connect (
+		soup_message, "restarted",
+		G_CALLBACK (ews_soup_restarted), data);
+
+	ews_connection_schedule_queue_message (cnc, soup_message, oal_download_response_cb, simple);
 }
 
-gboolean	
-e_ews_connection_download_oal_file_finish	(EEwsConnection *cnc,
-						 GAsyncResult *result,
-						 GError **error)
+gboolean
+e_ews_connection_download_oal_file_finish (EEwsConnection *cnc,
+                                           GAsyncResult *result,
+                                           GError **error)
 {
 	GSimpleAsyncResult *simple;
 
+	g_return_val_if_fail (cnc != NULL, FALSE);
 	g_return_val_if_fail (
-			g_simple_async_result_is_valid (
-				result, G_OBJECT (cnc), e_ews_connection_download_oal_file_start),
-			FALSE);
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (cnc),
+		e_ews_connection_download_oal_file), FALSE);
 
 	simple = G_SIMPLE_ASYNC_RESULT (result);
 
-	if (g_simple_async_result_propagate_error (simple, error))
-		return FALSE;
-
-	return TRUE;
+	/* Assume success unless a GError is set. */
+	return !g_simple_async_result_propagate_error (simple, error);
 }
 
-gboolean	
-e_ews_connection_download_oal_file	(EEwsConnection *cnc,
-					 const gchar *cache_filename,
-					 EwsProgressFn progress_fn,
-					 gpointer progress_data,
-					 GCancellable *cancellable,
-					 GError **error)
+const gchar *
+e_ews_connection_get_mailbox (EEwsConnection *cnc)
 {
-	EwsSyncData *sync_data;
-	gboolean result;
-
-	sync_data = g_new0 (EwsSyncData, 1);
-	sync_data->eflag = e_flag_new ();
+	g_return_val_if_fail (E_IS_EWS_CONNECTION (cnc), NULL);
 
-	e_ews_connection_download_oal_file_start
-						(cnc, cache_filename, 
-						 ews_sync_reply_cb,
-						 progress_fn, progress_data,
-						 cancellable, sync_data);
-
-	e_flag_wait (sync_data->eflag);
-
-	result = e_ews_connection_download_oal_file_finish
-						(cnc, sync_data->res,
-						 error);
-
-	e_flag_free (sync_data->eflag);
-	g_object_unref (sync_data->res);
-	g_free (sync_data);
-
-	return result;
+	return cnc->priv->email;
 }
 
 void
-e_ews_connection_set_mailbox	(EEwsConnection *cnc,
-				 const gchar *email)
+e_ews_connection_set_mailbox (EEwsConnection *cnc,
+                              const gchar *email)
 {
-
+	g_return_if_fail (E_IS_EWS_CONNECTION (cnc));
 	g_return_if_fail (email != NULL);
 
 	g_free (cnc->priv->email);
 	cnc->priv->email = g_strdup (email);
 }
 
-/**
- * e_ews_connection_sync_folder_items_start
- * @cnc: The EWS Connection
- * @pri: The priority associated with the request
- * @sync_state: To sync with the previous requests
- * @folder_id: The folder to which the items belong
- * @default_props: Can take one of the values: IdOnly,Default or AllProperties
- * @additional_props: Specify any additional properties to be fetched
- * @max_entries: Maximum number of items to be returned
- * @cb: Responses are parsed and returned to this callback
- * @cancellable: a GCancellable to monitor cancelled operations
- * @user_data: user data passed to callback
- **/
-void
-e_ews_connection_sync_folder_items_start	(EEwsConnection *cnc,
-						 gint pri,
-						 const gchar *sync_state,
-						 const gchar *fid,
-						 const gchar *default_props,
-						 const gchar *additional_props,
-						 guint max_entries,
-						 GAsyncReadyCallback cb,
-						 GCancellable *cancellable,
-						 gpointer user_data)
+static void
+ews_append_additional_props_to_msg (ESoapMessage *msg,
+                                    EwsAdditionalProps *add_props)
 {
-	ESoapMessage *msg;
-	GSimpleAsyncResult *simple;
-	EwsAsyncData *async_data;
+	GSList *l;
 
-	msg = e_ews_message_new_with_header (cnc->priv->uri, "SyncFolderItems", NULL, NULL, EWS_EXCHANGE_2007_SP1);
-	e_soap_message_start_element (msg, "ItemShape", "messages", NULL);
-	e_ews_message_write_string_parameter (msg, "BaseShape", NULL, default_props);
+	if (!add_props)
+		return;
+
+	e_soap_message_start_element (msg, "AdditionalProperties", NULL, NULL);
+
+	if (add_props->field_uri) {
+		gchar **prop = g_strsplit (add_props->field_uri, " ", 0);
+		gint i = 0;
+
+		while (prop[i]) {
+			e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL, "FieldURI", prop[i]);
+			i++;
+		}
+
+		g_strfreev (prop);
+	}
+
+	if (add_props->extended_furis) {
+		for (l = add_props->extended_furis; l != NULL; l = g_slist_next (l)) {
+			EwsExtendedFieldURI *ex_furi = (EwsExtendedFieldURI *) l->data;
+
+			e_soap_message_start_element (msg, "ExtendedFieldURI", NULL, NULL);
+
+			if (ex_furi->distinguished_prop_set_id)
+				e_soap_message_add_attribute (msg, "DistinguishedPropertySetId", ex_furi->distinguished_prop_set_id, NULL, NULL);
+
+			if (ex_furi->prop_set_id)
+				e_soap_message_add_attribute (msg, "PropertySetId", ex_furi->prop_set_id, NULL, NULL);
+
+			if (ex_furi->prop_name)
+				e_soap_message_add_attribute (msg, "PropertyName", ex_furi->prop_name, NULL, NULL);
+
+			if (ex_furi->prop_id)
+				e_soap_message_add_attribute (msg, "PropertyId", ex_furi->prop_id, NULL, NULL);
+
+			if (ex_furi->prop_type)
+				e_soap_message_add_attribute (msg, "PropertyType", ex_furi->prop_type, NULL, NULL);
+
+			e_soap_message_end_element (msg);
+		}
+	}
+
+	if (add_props->indexed_furis) {
+		for (l = add_props->indexed_furis; l != NULL; l = g_slist_next (l)) {
+			EwsIndexedFieldURI *in_furi = (EwsIndexedFieldURI *) l->data;
+
+			e_soap_message_start_element (msg, "IndexedFieldURI", NULL, NULL);
+
+			e_soap_message_add_attribute (msg, "FieldURI", in_furi->field_uri, NULL, NULL);
+			e_soap_message_add_attribute (msg, "FieldIndex", in_furi->field_index, NULL, NULL);
+
+			e_soap_message_end_element (msg);
+		}
+	}
+
+	e_soap_message_end_element (msg);
+}
+
+static void
+ews_write_sort_order_to_msg (ESoapMessage *msg,
+                             EwsSortOrder *sort_order)
+{
+	if (!sort_order)
+		return;
+
+	e_soap_message_start_element (msg, "SortOrder", NULL, NULL);
+	e_soap_message_start_element (msg, "FieldOrder", NULL, NULL);
+	e_soap_message_add_attribute (msg, "Order", sort_order->order, NULL, NULL);
+
+	if (sort_order->uri_type == NORMAL_FIELD_URI)
+		e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL, "FieldURI", (gchar *) sort_order->field_uri);
+	else if (sort_order->uri_type == INDEXED_FIELD_URI) {
+		EwsIndexedFieldURI *in_furi = (EwsIndexedFieldURI *) sort_order->field_uri;
+
+		e_soap_message_start_element (msg, "IndexedFieldURI", NULL, NULL);
+		e_soap_message_add_attribute (msg, "FieldURI", in_furi->field_uri, NULL, NULL);
+		e_soap_message_add_attribute (msg, "FieldIndex", in_furi->field_index, NULL, NULL);
+		e_soap_message_end_element (msg);
+	} else if (sort_order->uri_type == EXTENDED_FIELD_URI) {
+		EwsExtendedFieldURI *ex_furi = (EwsExtendedFieldURI *) sort_order->field_uri;
+
+		e_soap_message_start_element (msg, "ExtendedFieldURI", NULL, NULL);
+
+		if (ex_furi->distinguished_prop_set_id)
+			e_soap_message_add_attribute (msg, "DistinguishedPropertySetId", ex_furi->distinguished_prop_set_id, NULL, NULL);
+		if (ex_furi->prop_set_id)
+			e_soap_message_add_attribute (msg, "PropertySetId", ex_furi->prop_set_id, NULL, NULL);
+		if (ex_furi->prop_name)
+			e_soap_message_add_attribute (msg, "PropertyName", ex_furi->prop_name, NULL, NULL);
+		if (ex_furi->prop_id)
+			e_soap_message_add_attribute (msg, "PropertyId", ex_furi->prop_id, NULL, NULL);
+		if (ex_furi->prop_type)
+			e_soap_message_add_attribute (msg, "PropertyType", ex_furi->prop_type, NULL, NULL);
+
+		e_soap_message_end_element (msg);
+	}
+
+	e_soap_message_end_element (msg);
+	e_soap_message_end_element (msg);
+}
+
+/**
+ * e_ews_connection_sync_folder_items:
+ * @cnc: The EWS Connection
+ * @pri: The priority associated with the request
+ * @last_sync_state: To sync with the previous requests
+ * @folder_id: The folder to which the items belong
+ * @default_props: Can take one of the values: IdOnly,Default or AllProperties
+ * @additional_props: Specify any additional properties to be fetched
+ * @max_entries: Maximum number of items to be returned
+ * @cancellable: a GCancellable to monitor cancelled operations
+ * @callback: Responses are parsed and returned to this callback
+ * @user_data: user data passed to callback
+ **/
+void
+e_ews_connection_sync_folder_items (EEwsConnection *cnc,
+                                    gint pri,
+                                    const gchar *last_sync_state,
+                                    const gchar *fid,
+                                    const gchar *default_props,
+                                    const gchar *additional_props,
+                                    guint max_entries,
+                                    GCancellable *cancellable,
+                                    GAsyncReadyCallback callback,
+                                    gpointer user_data)
+{
+	ESoapMessage *msg;
+	GSimpleAsyncResult *simple;
+	EwsAsyncData *async_data;
+
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "SyncFolderItems", NULL, NULL, EWS_EXCHANGE_2007_SP1);
+	e_soap_message_start_element (msg, "ItemShape", "messages", NULL);
+	e_ews_message_write_string_parameter (msg, "BaseShape", NULL, default_props);
 
 	if (additional_props && *additional_props) {
 		gchar **prop = g_strsplit (additional_props, " ", 0);
@@ -1845,7 +2927,7 @@ e_ews_connection_sync_folder_items_start
 
 		e_soap_message_start_element (msg, "AdditionalProperties", NULL, NULL);
 		while (prop[i]) {
-			e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL, "FieldURI", prop [i]);
+			e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL, "FieldURI", prop[i]);
 			i++;
 		}
 		g_strfreev (prop);
@@ -1858,8 +2940,8 @@ e_ews_connection_sync_folder_items_start
 	e_ews_message_write_string_parameter_with_attribute (msg, "FolderId", NULL, NULL, "Id", fid);
 	e_soap_message_end_element (msg);
 
-	if (sync_state)
-		e_ews_message_write_string_parameter (msg, "SyncState", "messages", sync_state);
+	if (last_sync_state)
+		e_ews_message_write_string_parameter (msg, "SyncState", "messages", last_sync_state);
 
 	/* Max changes requested */
 	e_ews_message_write_int_parameter (msg, "MaxChangesReturned", "messages", max_entries);
@@ -1867,35 +2949,38 @@ e_ews_connection_sync_folder_items_start
 	/* Complete the footer and print the request */
 	e_ews_message_write_footer (msg);
 
-      	simple = g_simple_async_result_new (G_OBJECT (cnc),
-                                      cb,
-                                      user_data,
-                                      e_ews_connection_sync_folder_items_start);
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_sync_folder_items);
 
 	async_data = g_new0 (EwsAsyncData, 1);
 	g_simple_async_result_set_op_res_gpointer (
 		simple, async_data, (GDestroyNotify) async_data_free);
 
-	ews_connection_queue_request (cnc, msg, sync_folder_items_response_cb, pri,
-				      cancellable, simple, cb == ews_sync_reply_cb);
+	e_ews_connection_queue_request (
+		cnc, msg, sync_folder_items_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
 }
 
 gboolean
-e_ews_connection_sync_folder_items_finish	(EEwsConnection *cnc,
-						 GAsyncResult *result,
-					 	 gchar **sync_state,
-						 gboolean *includes_last_item,
-						 GSList **items_created,
-						 GSList **items_updated,
-						 GSList **items_deleted,
-						 GError **error)
+e_ews_connection_sync_folder_items_finish (EEwsConnection *cnc,
+                                           GAsyncResult *result,
+                                           gchar **new_sync_state,
+                                           gboolean *includes_last_item,
+                                           GSList **items_created,
+                                           GSList **items_updated,
+                                           GSList **items_deleted,
+                                           GError **error)
 {
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 
+	g_return_val_if_fail (cnc != NULL, FALSE);
 	g_return_val_if_fail (
 		g_simple_async_result_is_valid (
-		result, G_OBJECT (cnc), e_ews_connection_sync_folder_items_start),
+		result, G_OBJECT (cnc), e_ews_connection_sync_folder_items),
 		FALSE);
 
 	simple = G_SIMPLE_ASYNC_RESULT (result);
@@ -1904,7 +2989,7 @@ e_ews_connection_sync_folder_items_finis
 	if (g_simple_async_result_propagate_error (simple, error))
 		return FALSE;
 
-	*sync_state = async_data->sync_state;
+	*new_sync_state = async_data->sync_state;
 	*includes_last_item = async_data->includes_last_item;
 	*items_created = async_data->items_created;
 	*items_updated = async_data->items_updated;
@@ -1914,62 +2999,244 @@ e_ews_connection_sync_folder_items_finis
 }
 
 gboolean
-e_ews_connection_sync_folder_items	(EEwsConnection *cnc,
-					 gint pri,
-					 gchar **sync_state,
-					 const gchar *fid,
-					 const gchar *default_props,
-					 const gchar *additional_props,
-					 guint max_entries,
-					 gboolean *includes_last_item,
-					 GSList **items_created,
-					 GSList **items_updated,
-					 GSList **items_deleted,
-					 GCancellable *cancellable,
-					 GError **error)
+e_ews_connection_sync_folder_items_sync (EEwsConnection *cnc,
+                                         gint pri,
+                                         const gchar *old_sync_state,
+                                         const gchar *fid,
+                                         const gchar *default_props,
+                                         const gchar *additional_props,
+                                         guint max_entries,
+                                         gchar **new_sync_state,
+                                         gboolean *includes_last_item,
+                                         GSList **items_created,
+                                         GSList **items_updated,
+                                         GSList **items_deleted,
+                                         GCancellable *cancellable,
+                                         GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_sync_folder_items (
+		cnc, pri, old_sync_state, fid, default_props,
+		additional_props, max_entries, cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_connection_sync_folder_items_finish (
+		cnc, result, new_sync_state, includes_last_item,
+		items_created, items_updated, items_deleted, error);
+
+	e_async_closure_free (closure);
+
+	return success;
+}
+
+static void
+ews_append_folder_id_to_msg (ESoapMessage *msg,
+                             const gchar *email,
+                             const EwsFolderId *fid)
+{
+	g_return_if_fail (msg != NULL);
+	g_return_if_fail (fid != NULL);
+
+	if (fid->is_distinguished_id)
+		e_soap_message_start_element (msg, "DistinguishedFolderId", NULL, NULL);
+	else
+		e_soap_message_start_element (msg, "FolderId", NULL, NULL);
+
+	e_soap_message_add_attribute (msg, "Id", fid->id, NULL, NULL);
+	if (fid->change_key)
+		e_soap_message_add_attribute (msg, "ChangeKey", fid->change_key, NULL, NULL);
+
+	if (fid->is_distinguished_id && email) {
+		e_soap_message_start_element (msg, "Mailbox", NULL, NULL);
+		e_ews_message_write_string_parameter (msg, "EmailAddress", NULL, email);
+		e_soap_message_end_element (msg);
+	}
+
+	e_soap_message_end_element (msg);
+}
+
+static void
+ews_append_folder_ids_to_msg (ESoapMessage *msg,
+                              const gchar *email,
+                              GSList *folder_ids)
+{
+	GSList *l;
+
+	for (l = folder_ids; l != NULL; l = g_slist_next (l)) {
+		const EwsFolderId *fid = l->data;
+
+		ews_append_folder_id_to_msg (msg, email, fid);
+	}
+}
+
+/**
+ * e_ews_connection_find_folder_items:
+ * @cnc: The EWS Connection
+ * @pri: The priority associated with the request
+ * @fid: The folder id to which the items belong
+ * @default_props: Can take one of the values: IdOnly,Default or AllProperties
+ * @add_props: Specify any additional properties to be fetched
+ * @sort_order: Specific sorting order for items
+ * @query: evo query based on which items will be fetched
+ * @type: type of folder
+ * @convert_query_cb: a callback method to convert query to ews restiction
+ * @cancellable: a GCancellable to monitor cancelled operations
+ * @callback: Responses are parsed and returned to this callback
+ * @user_data: user data passed to callback
+ **/
+void
+e_ews_connection_find_folder_items (EEwsConnection *cnc,
+                                    gint pri,
+                                    EwsFolderId *fid,
+                                    const gchar *default_props,
+                                    EwsAdditionalProps *add_props,
+                                    EwsSortOrder *sort_order,
+                                    const gchar *query,
+                                    EEwsFolderType type,
+                                    EwsConvertQueryCallback convert_query_cb,
+                                    GCancellable *cancellable,
+                                    GAsyncReadyCallback callback,
+                                    gpointer user_data)
+{
+	ESoapMessage *msg;
+	GSimpleAsyncResult *simple;
+	EwsAsyncData *async_data;
+
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "FindItem", "Traversal", "Shallow", EWS_EXCHANGE_2007_SP1);
+	e_soap_message_start_element (msg, "ItemShape", "messages", NULL);
+	e_ews_message_write_string_parameter (msg, "BaseShape", NULL, default_props);
+
+	ews_append_additional_props_to_msg (msg, add_props);
+
+	e_soap_message_end_element (msg);
+
+	/*write restriction message based on query*/
+	if (convert_query_cb)
+		convert_query_cb (msg, query, type);
+
+	if (sort_order)
+		ews_write_sort_order_to_msg (msg, sort_order);
+
+	e_soap_message_start_element (msg, "ParentFolderIds", "messages", NULL);
+
+	if (fid->is_distinguished_id)
+		e_ews_message_write_string_parameter_with_attribute (msg, "DistinguishedFolderId", NULL, NULL, "Id", fid->id);
+	else
+		e_ews_message_write_string_parameter_with_attribute (msg, "FolderId", NULL, NULL, "Id", fid->id);
+
+	e_soap_message_end_element (msg);
+
+	/* Complete the footer and print the request */
+	e_ews_message_write_footer (msg);
+
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_find_folder_items);
+
+	async_data = g_new0 (EwsAsyncData, 1);
+	g_simple_async_result_set_op_res_gpointer (
+		simple, async_data, (GDestroyNotify) async_data_free);
+
+	e_ews_connection_queue_request (
+		cnc, msg, find_folder_items_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
+}
+
+gboolean
+e_ews_connection_find_folder_items_finish (EEwsConnection *cnc,
+                                           GAsyncResult *result,
+                                           gboolean *includes_last_item,
+                                           GSList **items,
+                                           GError **error)
 {
-	EwsSyncData *sync_data;
-	gboolean result;
+	GSimpleAsyncResult *simple;
+	EwsAsyncData *async_data;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+	g_return_val_if_fail (
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (cnc), e_ews_connection_find_folder_items),
+		FALSE);
+
+	simple = G_SIMPLE_ASYNC_RESULT (result);
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	if (g_simple_async_result_propagate_error (simple, error))
+		return FALSE;
+
+	*includes_last_item = async_data->includes_last_item;
+	*items = async_data->items;
 
-	sync_data = g_new0 (EwsSyncData, 1);
-	sync_data->eflag = e_flag_new ();
+	return TRUE;
+}
 
-	e_ews_connection_sync_folder_items_start	(cnc, pri, *sync_state, fid,
-							 default_props, additional_props,
-							 max_entries,
-							 ews_sync_reply_cb, cancellable,
-							 (gpointer) sync_data);
+gboolean
+e_ews_connection_find_folder_items_sync (EEwsConnection *cnc,
+                                         gint pri,
+                                         EwsFolderId *fid,
+                                         const gchar *default_props,
+                                         EwsAdditionalProps *add_props,
+                                         EwsSortOrder *sort_order,
+                                         const gchar *query,
+                                         EEwsFolderType type,
+                                         gboolean *includes_last_item,
+                                         GSList **items,
+                                         EwsConvertQueryCallback convert_query_cb,
+                                         GCancellable *cancellable,
+                                         GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_find_folder_items (
+		cnc, pri, fid, default_props,
+		add_props, sort_order, query,
+		type, convert_query_cb, NULL,
+		e_async_closure_callback, closure);
 
-	e_flag_wait (sync_data->eflag);
+	result = e_async_closure_wait (closure);
 
-	result = e_ews_connection_sync_folder_items_finish (cnc, sync_data->res,
-							    sync_state,
-							    includes_last_item,
-							    items_created,
-							    items_updated,
-							    items_deleted,
-							    error);
+	success = e_ews_connection_find_folder_items_finish (
+		cnc, result, includes_last_item, items, error);
 
-	e_flag_free (sync_data->eflag);
-	g_object_unref (sync_data->res);
-	g_free (sync_data);
+	e_async_closure_free (closure);
 
-	return result;
+	return success;
 }
 
 void
-e_ews_connection_sync_folder_hierarchy_start	(EEwsConnection *cnc,
-						 gint pri,
-						 const gchar *sync_state,
-						 GAsyncReadyCallback cb,
-						 GCancellable *cancellable,
-						 gpointer user_data)
+e_ews_connection_sync_folder_hierarchy (EEwsConnection *cnc,
+                                        gint pri,
+                                        const gchar *sync_state,
+                                        GCancellable *cancellable,
+                                        GAsyncReadyCallback callback,
+                                        gpointer user_data)
 {
 	ESoapMessage *msg;
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 
-	msg = e_ews_message_new_with_header (cnc->priv->uri, "SyncFolderHierarchy", NULL, NULL, EWS_EXCHANGE_2007_SP1);
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "SyncFolderHierarchy", NULL, NULL, EWS_EXCHANGE_2007_SP1);
 	e_soap_message_start_element (msg, "FolderShape", "messages", NULL);
 	e_ews_message_write_string_parameter (msg, "BaseShape", NULL, "AllProperties");
 	e_soap_message_end_element (msg);
@@ -1979,36 +3246,38 @@ e_ews_connection_sync_folder_hierarchy_s
 
 	e_ews_message_write_footer (msg);
 
-      	simple = g_simple_async_result_new (G_OBJECT (cnc),
-                                      cb,
-                                      user_data,
-                                      e_ews_connection_sync_folder_hierarchy_start);
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_sync_folder_hierarchy);
 
 	async_data = g_new0 (EwsAsyncData, 1);
 	g_simple_async_result_set_op_res_gpointer (
 		simple, async_data, (GDestroyNotify) async_data_free);
 
-	ews_connection_queue_request (cnc, msg, sync_hierarchy_response_cb, pri,
-				      cancellable, simple, cb == ews_sync_reply_cb);
-}
+	e_ews_connection_queue_request (
+		cnc, msg, sync_hierarchy_response_cb,
+		pri, cancellable, simple);
 
+	g_object_unref (simple);
+}
 
 gboolean
-e_ews_connection_sync_folder_hierarchy_finish	(EEwsConnection *cnc,
-						 GAsyncResult *result,
-					 	 gchar **sync_state,
-						 gboolean *includes_last_folder,
-						 GSList **folders_created,
-						 GSList **folders_updated,
-						 GSList **folders_deleted,
-						 GError **error)
+e_ews_connection_sync_folder_hierarchy_finish (EEwsConnection *cnc,
+                                               GAsyncResult *result,
+                                               gchar **sync_state,
+                                               gboolean *includes_last_folder,
+                                               GSList **folders_created,
+                                               GSList **folders_updated,
+                                               GSList **folders_deleted,
+                                               GError **error)
 {
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 
+	g_return_val_if_fail (cnc != NULL, FALSE);
 	g_return_val_if_fail (
 		g_simple_async_result_is_valid (
-		result, G_OBJECT (cnc), e_ews_connection_sync_folder_hierarchy_start),
+		result, G_OBJECT (cnc), e_ews_connection_sync_folder_hierarchy),
 		FALSE);
 
 	simple = G_SIMPLE_ASYNC_RESULT (result);
@@ -2027,63 +3296,67 @@ e_ews_connection_sync_folder_hierarchy_f
 }
 
 gboolean
-e_ews_connection_sync_folder_hierarchy	(EEwsConnection *cnc,
-					 gint pri,
-					 gchar **sync_state,
-					 gboolean *includes_last_folder,
-					 GSList **folders_created,
-					 GSList **folders_updated,
-					 GSList **folders_deleted,
-					 GCancellable *cancellable,
-					 GError **error)
-{
-	EwsSyncData *sync_data;
-	gboolean result;
-
-	sync_data = g_new0 (EwsSyncData, 1);
-	sync_data->eflag = e_flag_new ();
-
-	e_ews_connection_sync_folder_hierarchy_start	(cnc, pri, *sync_state,
-							 ews_sync_reply_cb, cancellable,
-							 (gpointer) sync_data);
-
-	e_flag_wait (sync_data->eflag);
-
-	result = e_ews_connection_sync_folder_hierarchy_finish (cnc, sync_data->res,
-								sync_state,
-								includes_last_folder,
-								folders_created,
-								folders_updated,
-								folders_deleted,
-								error);
-
-	e_flag_free (sync_data->eflag);
-	g_object_unref (sync_data->res);
-	g_free (sync_data);
-
-	return result;
+e_ews_connection_sync_folder_hierarchy_sync (EEwsConnection *cnc,
+                                             gint pri,
+					     const gchar *old_sync_state,
+                                             gchar **new_sync_state,
+                                             gboolean *includes_last_folder,
+                                             GSList **folders_created,
+                                             GSList **folders_updated,
+                                             GSList **folders_deleted,
+                                             GCancellable *cancellable,
+                                             GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_sync_folder_hierarchy (
+		cnc, pri, old_sync_state, cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_connection_sync_folder_hierarchy_finish (
+		cnc, result, new_sync_state,
+		includes_last_folder,
+		folders_created,
+		folders_updated,
+		folders_deleted,
+		error);
+
+	e_async_closure_free (closure);
+
+	return success;
 }
 
 void
-e_ews_connection_get_items_start	(EEwsConnection *cnc,
-					 gint pri,
-					 const GSList *ids,
-					 const gchar *default_props,
-					 const gchar *additional_props,
-					 gboolean include_mime,
-					 const gchar *mime_directory,
-					 GAsyncReadyCallback cb,
-					 ESoapProgressFn progress_fn,
-					 gpointer progress_data,
-					 GCancellable *cancellable,
-					 gpointer user_data)
+e_ews_connection_get_items (EEwsConnection *cnc,
+                            gint pri,
+                            const GSList *ids,
+                            const gchar *default_props,
+                            const gchar *additional_props,
+                            gboolean include_mime,
+                            const gchar *mime_directory,
+			    EEwsBodyType body_type,
+                            ESoapProgressFn progress_fn,
+                            gpointer progress_data,
+                            GCancellable *cancellable,
+                            GAsyncReadyCallback callback,
+                            gpointer user_data)
 {
 	ESoapMessage *msg;
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 	const GSList *l;
 
-	msg = e_ews_message_new_with_header (cnc->priv->uri, "GetItem", NULL, NULL, EWS_EXCHANGE_2007_SP1);
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "GetItem", NULL, NULL, EWS_EXCHANGE_2007_SP1);
 
 	if (progress_fn && progress_data)
 		e_soap_message_set_progress_fn (msg, progress_fn, progress_data);
@@ -2098,6 +3371,20 @@ e_ews_connection_get_items_start	(EEwsCo
 	if (mime_directory)
 		e_soap_message_store_node_data (msg, "MimeContent", mime_directory, TRUE);
 
+	switch (body_type) {
+	case E_EWS_BODY_TYPE_BEST:
+		e_ews_message_write_string_parameter (msg, "BodyType", NULL, "Best");
+		break;
+	case E_EWS_BODY_TYPE_HTML:
+		e_ews_message_write_string_parameter (msg, "BodyType", NULL, "HTML");
+		break;
+	case E_EWS_BODY_TYPE_TEXT:
+		e_ews_message_write_string_parameter (msg, "BodyType", NULL, "Text");
+		break;
+	case E_EWS_BODY_TYPE_ANY:
+		break;
+	}
+
 	if (additional_props && *additional_props) {
 		gchar **prop = g_strsplit (additional_props, " ", 0);
 		gint i = 0;
@@ -2111,7 +3398,7 @@ e_ews_connection_get_items_start	(EEwsCo
 				e_soap_message_add_attribute (msg, "PropertyType", "Integer", NULL, NULL);
 				e_soap_message_end_element (msg);
 			} else {
-				e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL, "FieldURI", prop [i]);
+				e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL, "FieldURI", prop[i]);
 			}
 			i++;
 		}
@@ -2129,31 +3416,34 @@ e_ews_connection_get_items_start	(EEwsCo
 
 	e_ews_message_write_footer (msg);
 
-	simple = g_simple_async_result_new (G_OBJECT (cnc),
-                                      cb,
-                                      user_data,
-                                      e_ews_connection_get_items_start);
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_get_items);
 
 	async_data = g_new0 (EwsAsyncData, 1);
 	g_simple_async_result_set_op_res_gpointer (
 		simple, async_data, (GDestroyNotify) async_data_free);
 
-	ews_connection_queue_request (cnc, msg, get_items_response_cb, pri,
-				      cancellable, simple, cb == ews_sync_reply_cb);
+	e_ews_connection_queue_request (
+		cnc, msg, get_items_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
 }
 
 gboolean
-e_ews_connection_get_items_finish	(EEwsConnection *cnc,
-					 GAsyncResult *result,
-					 GSList **items,
-					 GError **error)
+e_ews_connection_get_items_finish (EEwsConnection *cnc,
+                                   GAsyncResult *result,
+                                   GSList **items,
+                                   GError **error)
 {
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 
+	g_return_val_if_fail (cnc != NULL, FALSE);
 	g_return_val_if_fail (
 		g_simple_async_result_is_valid (
-		result, G_OBJECT (cnc), e_ews_connection_get_items_start),
+		result, G_OBJECT (cnc), e_ews_connection_get_items),
 		FALSE);
 
 	simple = G_SIMPLE_ASYNC_RESULT (result);
@@ -2162,53 +3452,57 @@ e_ews_connection_get_items_finish	(EEwsC
 	if (g_simple_async_result_propagate_error (simple, error))
 		return FALSE;
 
+	if (!async_data->items) {
+		g_set_error_literal (error, EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_ITEMNOTFOUND, _("No items found"));
+		return FALSE;
+	}
+
 	*items = async_data->items;
 
 	return TRUE;
 }
 
 gboolean
-e_ews_connection_get_items	(EEwsConnection *cnc,
-				 gint pri,
-				 const GSList *ids,
-				 const gchar *default_props,
-				 const gchar *additional_props,
-				 gboolean include_mime,
-				 const gchar *mime_directory,
-				 GSList **items,
-				 ESoapProgressFn progress_fn,
-				 gpointer progress_data,
-				 GCancellable *cancellable,
-				 GError **error)
-{
-	EwsSyncData *sync_data;
-	gboolean result;
-
-	sync_data = g_new0 (EwsSyncData, 1);
-	sync_data->eflag = e_flag_new ();
-
-	e_ews_connection_get_items_start	(cnc, pri,ids, default_props,
-						 additional_props, include_mime,
-						 mime_directory, ews_sync_reply_cb,
-						 progress_fn, progress_data,
-						 cancellable,
-						 (gpointer) sync_data);
-
-	e_flag_wait (sync_data->eflag);
-
-	result = e_ews_connection_get_items_finish (cnc,
-						    sync_data->res,
-						    items,
-						    error);
-
-	e_flag_free (sync_data->eflag);
-	g_object_unref (sync_data->res);
-	g_free (sync_data);
+e_ews_connection_get_items_sync (EEwsConnection *cnc,
+                                 gint pri,
+                                 const GSList *ids,
+                                 const gchar *default_props,
+                                 const gchar *additional_props,
+                                 gboolean include_mime,
+                                 const gchar *mime_directory,
+				 EEwsBodyType body_type,
+                                 GSList **items,
+                                 ESoapProgressFn progress_fn,
+                                 gpointer progress_data,
+                                 GCancellable *cancellable,
+                                 GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_get_items (
+		cnc, pri,ids, default_props,
+		additional_props, include_mime,
+		mime_directory, body_type, progress_fn,
+		progress_data, cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
 
-	return result;
+	success = e_ews_connection_get_items_finish (
+		cnc, result, items, error);
+
+	e_async_closure_free (closure);
+
+	return success;
 }
 
-static const char *
+static const gchar *
 ews_delete_type_to_str (EwsDeleteType delete_type)
 {
 	switch (delete_type) {
@@ -2222,7 +3516,7 @@ ews_delete_type_to_str (EwsDeleteType de
 	return NULL;
 }
 
-static const char *
+static const gchar *
 ews_send_cancels_to_str (EwsSendMeetingCancellationsType send_cancels)
 {
 	switch (send_cancels) {
@@ -2236,7 +3530,7 @@ ews_send_cancels_to_str (EwsSendMeetingC
 	return NULL;
 }
 
-static const char *
+static const gchar *
 ews_affected_tasks_to_str (EwsAffectedTaskOccurrencesType affected_tasks)
 {
 	switch (affected_tasks) {
@@ -2248,32 +3542,69 @@ ews_affected_tasks_to_str (EwsAffectedTa
 	return NULL;
 }
 
+static void
+delete_item_response_cb (ESoapResponse *response,
+                         GSimpleAsyncResult *simple)
+{
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	GError *error = NULL;
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessages", &error);
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	subparam = e_soap_parameter_get_first_child (param);
+
+	while (subparam != NULL) {
+		if (!ews_get_response_status (subparam, &error)) {
+			g_simple_async_result_take_error (simple, error);
+			return;
+		}
+
+		subparam = e_soap_parameter_get_next_child (subparam);
+	}
+}
+
 void
-e_ews_connection_delete_items_start	(EEwsConnection *cnc,
-					 gint pri,
-					 GSList *ids,
-					 EwsDeleteType delete_type,
-					 EwsSendMeetingCancellationsType send_cancels,
-					 EwsAffectedTaskOccurrencesType affected_tasks,
-					 GAsyncReadyCallback cb,
-					 GCancellable *cancellable,
-					 gpointer user_data)
+e_ews_connection_delete_items (EEwsConnection *cnc,
+                               gint pri,
+                               GSList *ids,
+                               EwsDeleteType delete_type,
+                               EwsSendMeetingCancellationsType send_cancels,
+                               EwsAffectedTaskOccurrencesType affected_tasks,
+                               GCancellable *cancellable,
+                               GAsyncReadyCallback callback,
+                               gpointer user_data)
 {
 	ESoapMessage *msg;
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 	GSList *l;
 
-	msg = e_ews_message_new_with_header (cnc->priv->uri, "DeleteItem",
-					     "DeleteType", ews_delete_type_to_str (delete_type), EWS_EXCHANGE_2007_SP1);
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "DeleteItem",
+		"DeleteType", ews_delete_type_to_str (delete_type), EWS_EXCHANGE_2007_SP1);
 
 	if (send_cancels)
-		e_soap_message_add_attribute (msg, "SendMeetingCancellations",
-					      ews_send_cancels_to_str (send_cancels), NULL, NULL);
+		e_soap_message_add_attribute (
+			msg, "SendMeetingCancellations",
+			ews_send_cancels_to_str (send_cancels), NULL, NULL);
 
 	if (affected_tasks)
-		e_soap_message_add_attribute (msg, "AffectedTaskOccurrences",
-					      ews_affected_tasks_to_str (affected_tasks), NULL, NULL);
+		e_soap_message_add_attribute (
+			msg, "AffectedTaskOccurrences",
+			ews_affected_tasks_to_str (affected_tasks), NULL, NULL);
 
 	e_soap_message_start_element (msg, "ItemIds", "messages", NULL);
 
@@ -2284,46 +3615,52 @@ e_ews_connection_delete_items_start	(EEw
 
 	e_ews_message_write_footer (msg);
 
-	simple = g_simple_async_result_new (G_OBJECT (cnc),
-                                      cb,
-                                      user_data,
-                                      e_ews_connection_delete_items_start);
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_delete_items);
 
 	async_data = g_new0 (EwsAsyncData, 1);
 	g_simple_async_result_set_op_res_gpointer (
 		simple, async_data, (GDestroyNotify) async_data_free);
 
-	ews_connection_queue_request (cnc, msg, NULL, pri, cancellable, simple,
-				      cb == ews_sync_reply_cb);
+	e_ews_connection_queue_request (
+		cnc, msg, delete_item_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
 }
 
 void
-e_ews_connection_delete_item_start	(EEwsConnection *cnc,
-					 gint pri,
-					 EwsId *item_id,
-					 guint index,
-					 EwsDeleteType delete_type,
-					 EwsSendMeetingCancellationsType send_cancels,
-					 EwsAffectedTaskOccurrencesType affected_tasks,
-					 GAsyncReadyCallback cb,
-					 GCancellable *cancellable,
-					 gpointer user_data)
+e_ews_connection_delete_item (EEwsConnection *cnc,
+                              gint pri,
+                              EwsId *item_id,
+                              guint index,
+                              EwsDeleteType delete_type,
+                              EwsSendMeetingCancellationsType send_cancels,
+                              EwsAffectedTaskOccurrencesType affected_tasks,
+                              GCancellable *cancellable,
+                              GAsyncReadyCallback callback,
+                              gpointer user_data)
 {
 	ESoapMessage *msg;
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 	gchar buffer[32];
 
-	msg = e_ews_message_new_with_header (cnc->priv->uri, "DeleteItem",
-					     "DeleteType", ews_delete_type_to_str (delete_type), EWS_EXCHANGE_2007_SP1);
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "DeleteItem",
+		"DeleteType", ews_delete_type_to_str (delete_type), EWS_EXCHANGE_2007_SP1);
 
 	if (send_cancels)
-		e_soap_message_add_attribute (msg, "SendMeetingCancellations",
-					      ews_send_cancels_to_str (send_cancels), NULL, NULL);
+		e_soap_message_add_attribute (
+			msg, "SendMeetingCancellations",
+			ews_send_cancels_to_str (send_cancels), NULL, NULL);
 
 	if (affected_tasks)
-		e_soap_message_add_attribute (msg, "AffectedTaskOccurrences",
-					      ews_affected_tasks_to_str (affected_tasks), NULL, NULL);
+		e_soap_message_add_attribute (
+			msg, "AffectedTaskOccurrences",
+			ews_affected_tasks_to_str (affected_tasks), NULL, NULL);
 
 	e_soap_message_start_element (msg, "ItemIds", "messages", NULL);
 
@@ -2347,29 +3684,32 @@ e_ews_connection_delete_item_start	(EEws
 
 	e_ews_message_write_footer (msg);
 
-	simple = g_simple_async_result_new (G_OBJECT (cnc),
-                                      cb,
-                                      user_data,
-                                      e_ews_connection_delete_items_start);
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_delete_items);
 
 	async_data = g_new0 (EwsAsyncData, 1);
 	g_simple_async_result_set_op_res_gpointer (
 		simple, async_data, (GDestroyNotify) async_data_free);
 
-	ews_connection_queue_request (cnc, msg, NULL, pri, cancellable, simple,
-				      cb == ews_sync_reply_cb);
+	e_ews_connection_queue_request (
+		cnc, msg, delete_item_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
 }
 
 gboolean
-e_ews_connection_delete_items_finish	(EEwsConnection *cnc,
-					 GAsyncResult *result,
-					 GError **error)
+e_ews_connection_delete_items_finish (EEwsConnection *cnc,
+                                      GAsyncResult *result,
+                                      GError **error)
 {
 	GSimpleAsyncResult *simple;
 
+	g_return_val_if_fail (cnc != NULL, FALSE);
 	g_return_val_if_fail (
 		g_simple_async_result_is_valid (
-		result, G_OBJECT (cnc), e_ews_connection_delete_items_start),
+		result, G_OBJECT (cnc), e_ews_connection_delete_items),
 		FALSE);
 
 	simple = G_SIMPLE_ASYNC_RESULT (result);
@@ -2381,106 +3721,110 @@ e_ews_connection_delete_items_finish	(EE
 }
 
 gboolean
-e_ews_connection_delete_items	(EEwsConnection *cnc,
-				 gint pri,
-				 GSList *ids,
-				 EwsDeleteType delete_type,
-				 EwsSendMeetingCancellationsType send_cancels,
-				 EwsAffectedTaskOccurrencesType affected_tasks,
-				 GCancellable *cancellable,
-				 GError **error)
+e_ews_connection_delete_items_sync (EEwsConnection *cnc,
+                                    gint pri,
+                                    GSList *ids,
+                                    EwsDeleteType delete_type,
+                                    EwsSendMeetingCancellationsType send_cancels,
+                                    EwsAffectedTaskOccurrencesType affected_tasks,
+                                    GCancellable *cancellable,
+                                    GError **error)
 {
-	EwsSyncData *sync_data;
-	gboolean result;
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
 
-	sync_data = g_new0 (EwsSyncData, 1);
-	sync_data->eflag = e_flag_new ();
+	closure = e_async_closure_new ();
 
-	e_ews_connection_delete_items_start (cnc, pri, ids, delete_type,
-					     send_cancels, affected_tasks,
-					     ews_sync_reply_cb, cancellable,
-					     (gpointer) sync_data);
+	e_ews_connection_delete_items (
+		cnc, pri, ids, delete_type,
+		send_cancels, affected_tasks, cancellable,
+		e_async_closure_callback, closure);
 
-	e_flag_wait (sync_data->eflag);
+	result = e_async_closure_wait (closure);
 
-	result = e_ews_connection_delete_items_finish (cnc, sync_data->res,
-						       error);
+	success = e_ews_connection_delete_items_finish (cnc, result, error);
 
-	e_flag_free (sync_data->eflag);
-	g_object_unref (sync_data->res);
-	g_free (sync_data);
+	e_async_closure_free (closure);
 
-	return result;
+	return success;
 }
 
 gboolean
-e_ews_connection_delete_item	(EEwsConnection *cnc,
-				 gint pri,
-				 EwsId *id,
-				 guint index,
-				 EwsDeleteType delete_type,
-				 EwsSendMeetingCancellationsType send_cancels,
-				 EwsAffectedTaskOccurrencesType affected_tasks,
-				 GCancellable *cancellable,
-				 GError **error)
+e_ews_connection_delete_item_sync (EEwsConnection *cnc,
+                                   gint pri,
+                                   EwsId *id,
+                                   guint index,
+                                   EwsDeleteType delete_type,
+                                   EwsSendMeetingCancellationsType send_cancels,
+                                   EwsAffectedTaskOccurrencesType affected_tasks,
+                                   GCancellable *cancellable,
+                                   GError **error)
 {
-	EwsSyncData *sync_data;
-	gboolean result;
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
 
-	sync_data = g_new0 (EwsSyncData, 1);
-	sync_data->eflag = e_flag_new ();
+	g_return_val_if_fail (cnc != NULL, FALSE);
 
-	e_ews_connection_delete_item_start (cnc, pri, id, index, delete_type,
-					     send_cancels, affected_tasks,
-					     ews_sync_reply_cb, cancellable,
-					     (gpointer) sync_data);
+	closure = e_async_closure_new ();
 
-	e_flag_wait (sync_data->eflag);
+	e_ews_connection_delete_item (
+		cnc, pri, id, index, delete_type,
+		send_cancels, affected_tasks, cancellable,
+		e_async_closure_callback, closure);
 
-	result = e_ews_connection_delete_items_finish (cnc, sync_data->res,
-						       error);
+	result = e_async_closure_wait (closure);
 
-	e_flag_free (sync_data->eflag);
-	g_object_unref (sync_data->res);
-	g_free (sync_data);
+	success = e_ews_connection_delete_items_finish (cnc, result, error);
 
-	return result;
+	e_async_closure_free (closure);
+
+	return success;
 }
 
 void
-e_ews_connection_update_items_start	(EEwsConnection *cnc,
-					 gint pri,
-					 const gchar *conflict_res,
-					 const gchar *msg_disposition,
-					 const gchar *send_invites,
-					 const gchar *folder_id,
-					 EEwsRequestCreationCallback create_cb,
-					 gpointer create_user_data,
-					 GAsyncReadyCallback cb,
-					 GCancellable *cancellable,
-					 gpointer user_data)
+e_ews_connection_update_items (EEwsConnection *cnc,
+                               gint pri,
+                               const gchar *conflict_res,
+                               const gchar *msg_disposition,
+                               const gchar *send_invites,
+                               const gchar *folder_id,
+                               EEwsRequestCreationCallback create_cb,
+                               gpointer create_user_data,
+                               GCancellable *cancellable,
+                               GAsyncReadyCallback callback,
+                               gpointer user_data)
 {
 	ESoapMessage *msg;
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 
-	msg = e_ews_message_new_with_header (cnc->priv->uri, "UpdateItem",
-					     NULL, NULL, EWS_EXCHANGE_2007_SP1);
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "UpdateItem",
+		NULL, NULL, EWS_EXCHANGE_2007_SP1);
 
 	if (conflict_res)
-		e_soap_message_add_attribute (msg, "ConflictResolution",
-					      conflict_res, NULL, NULL);
+		e_soap_message_add_attribute (
+			msg, "ConflictResolution",
+			conflict_res, NULL, NULL);
 	if (msg_disposition)
-		e_soap_message_add_attribute (msg, "MessageDisposition",
-					      msg_disposition, NULL, NULL);
+		e_soap_message_add_attribute (
+			msg, "MessageDisposition",
+			msg_disposition, NULL, NULL);
 	if (send_invites)
-		e_soap_message_add_attribute (msg, "SendMeetingInvitationsOrCancellations",
-					      send_invites, NULL, NULL);
+		e_soap_message_add_attribute (
+			msg, "SendMeetingInvitationsOrCancellations",
+			send_invites, NULL, NULL);
 
 	if (folder_id) {
 		e_soap_message_start_element (msg, "SavedItemFolderId", "messages", NULL);
-		e_ews_message_write_string_parameter_with_attribute (msg, "FolderId",
-						     NULL, NULL, "Id", folder_id);
+		e_ews_message_write_string_parameter_with_attribute (
+			msg, "FolderId",
+			NULL, NULL, "Id", folder_id);
 		e_soap_message_end_element (msg);
 	}
 
@@ -2492,31 +3836,34 @@ e_ews_connection_update_items_start	(EEw
 
 	e_ews_message_write_footer (msg);
 
-	simple = g_simple_async_result_new (G_OBJECT (cnc),
-                                      cb,
-                                      user_data,
-                                      e_ews_connection_update_items_start);
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_update_items);
 
 	async_data = g_new0 (EwsAsyncData, 1);
 	g_simple_async_result_set_op_res_gpointer (
 		simple, async_data, (GDestroyNotify) async_data_free);
 
-	ews_connection_queue_request (cnc, msg, get_items_response_cb, pri, cancellable, simple,
-				      cb == ews_sync_reply_cb);
+	e_ews_connection_queue_request (
+		cnc, msg, get_items_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
 }
 
 gboolean
-e_ews_connection_update_items_finish	(EEwsConnection *cnc,
-					 GAsyncResult *result,
-					 GSList **ids,
-					 GError **error)
+e_ews_connection_update_items_finish (EEwsConnection *cnc,
+                                      GAsyncResult *result,
+                                      GSList **ids,
+                                      GError **error)
 {
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 
+	g_return_val_if_fail (cnc != NULL, FALSE);
 	g_return_val_if_fail (
 		g_simple_async_result_is_valid (
-		result, G_OBJECT (cnc), e_ews_connection_update_items_start),
+		result, G_OBJECT (cnc), e_ews_connection_update_items),
 		FALSE);
 
 	simple = G_SIMPLE_ASYNC_RESULT (result);
@@ -2524,86 +3871,106 @@ e_ews_connection_update_items_finish	(EE
 
 	if (g_simple_async_result_propagate_error (simple, error))
 		return FALSE;
+
+	/* if there is only one item, then check whether it's an error */
+	if (async_data->items && !async_data->items->next) {
+		EEwsItem *item = async_data->items->data;
+
+		if (item && e_ews_item_get_item_type (item) == E_EWS_ITEM_TYPE_ERROR) {
+			if (error)
+				*error = g_error_copy (e_ews_item_get_error (item));
+
+			g_slist_free_full (async_data->items, g_object_unref);
+			async_data->items = NULL;
+
+			return FALSE;
+		}
+	}
+
 	if (ids)
 		*ids = async_data->items;
 	else {
 		while (async_data->items) {
 			g_object_unref (async_data->items->data);
-			async_data->items = g_slist_remove (async_data->items,
-							    async_data->items->data);
+			async_data->items = g_slist_remove (
+				async_data->items,
+				async_data->items->data);
 		}
 	}
 	return TRUE;
 }
 
 gboolean
-e_ews_connection_update_items	(EEwsConnection *cnc,
-				 gint pri,
-				 const gchar *conflict_res,
-				 const gchar *msg_disposition,
-				 const gchar *send_invites,
-				 const gchar *folder_id,
-				 EEwsRequestCreationCallback create_cb,
-				 gpointer create_user_data,
-				 GSList **ids,
-				 GCancellable *cancellable,
-				 GError **error)
-{
-	EwsSyncData *sync_data;
-	gboolean result;
-
-	sync_data = g_new0 (EwsSyncData, 1);
-	sync_data->eflag = e_flag_new ();
-
-	e_ews_connection_update_items_start (cnc, pri, conflict_res,
-					     msg_disposition, send_invites,
-					     folder_id,
-					     create_cb, create_user_data,
-					     ews_sync_reply_cb, cancellable,
-					     (gpointer) sync_data);
+e_ews_connection_update_items_sync (EEwsConnection *cnc,
+                                    gint pri,
+                                    const gchar *conflict_res,
+                                    const gchar *msg_disposition,
+                                    const gchar *send_invites,
+                                    const gchar *folder_id,
+                                    EEwsRequestCreationCallback create_cb,
+                                    gpointer create_user_data,
+                                    GSList **ids,
+                                    GCancellable *cancellable,
+                                    GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_update_items (
+		cnc, pri, conflict_res,
+		msg_disposition, send_invites,
+		folder_id, create_cb,
+		create_user_data, cancellable,
+		e_async_closure_callback, closure);
 
-	e_flag_wait (sync_data->eflag);
+	result = e_async_closure_wait (closure);
 
-	result = e_ews_connection_update_items_finish (cnc, sync_data->res,
-						       ids, error);
+	success = e_ews_connection_update_items_finish (
+		cnc, result, ids, error);
 
-	e_flag_free (sync_data->eflag);
-	g_object_unref (sync_data->res);
-	g_free (sync_data);
+	e_async_closure_free (closure);
 
-	return result;
+	return success;
 }
 
 void
-e_ews_connection_create_items_start	(EEwsConnection *cnc,
-					 gint pri,
-					 const gchar *msg_disposition,
-					 const gchar *send_invites,
-					 const gchar *folder_id,
-					 EEwsRequestCreationCallback create_cb,
-					 gpointer create_user_data,
-					 GAsyncReadyCallback cb,
-					 GCancellable *cancellable,
-					 gpointer user_data)
+e_ews_connection_create_items (EEwsConnection *cnc,
+                               gint pri,
+                               const gchar *msg_disposition,
+                               const gchar *send_invites,
+                               const EwsFolderId *fid,
+                               EEwsRequestCreationCallback create_cb,
+                               gpointer create_user_data,
+                               GCancellable *cancellable,
+                               GAsyncReadyCallback callback,
+                               gpointer user_data)
 {
 	ESoapMessage *msg;
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 
-	msg = e_ews_message_new_with_header (cnc->priv->uri, "CreateItem",
-					     NULL, NULL, EWS_EXCHANGE_2007_SP1);
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "CreateItem",
+		NULL, NULL, EWS_EXCHANGE_2007_SP1);
 
 	if (msg_disposition)
-		e_soap_message_add_attribute (msg, "MessageDisposition",
-					      msg_disposition, NULL, NULL);
+		e_soap_message_add_attribute (
+			msg, "MessageDisposition",
+			msg_disposition, NULL, NULL);
 	if (send_invites)
-		e_soap_message_add_attribute (msg, "SendMeetingInvitations",
-					      send_invites, NULL, NULL);
+		e_soap_message_add_attribute (
+			msg, "SendMeetingInvitations",
+			send_invites, NULL, NULL);
 
-	if (folder_id) {
+	if (fid) {
 		e_soap_message_start_element (msg, "SavedItemFolderId", "messages", NULL);
-		e_ews_message_write_string_parameter_with_attribute (msg, "FolderId",
-						     NULL, NULL, "Id", folder_id);
+		ews_append_folder_id_to_msg (msg, cnc->priv->email, fid);
 		e_soap_message_end_element (msg);
 	}
 
@@ -2615,31 +3982,34 @@ e_ews_connection_create_items_start	(EEw
 
 	e_ews_message_write_footer (msg); /* CreateItem */
 
-	simple = g_simple_async_result_new (G_OBJECT (cnc),
-                                      cb,
-                                      user_data,
-                                      e_ews_connection_create_items_start);
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_create_items);
 
 	async_data = g_new0 (EwsAsyncData, 1);
 	g_simple_async_result_set_op_res_gpointer (
 		simple, async_data, (GDestroyNotify) async_data_free);
 
-	ews_connection_queue_request (cnc, msg, get_items_response_cb, pri,
-				      cancellable, simple, cb == ews_sync_reply_cb);
+	e_ews_connection_queue_request (
+		cnc, msg, get_items_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
 }
 
 gboolean
-e_ews_connection_create_items_finish	(EEwsConnection *cnc,
-					 GAsyncResult *result,
-					 GSList **ids,
-					 GError **error)
+e_ews_connection_create_items_finish (EEwsConnection *cnc,
+                                      GAsyncResult *result,
+                                      GSList **ids,
+                                      GError **error)
 {
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 
+	g_return_val_if_fail (cnc != NULL, FALSE);
 	g_return_val_if_fail (
 		g_simple_async_result_is_valid (
-		result, G_OBJECT (cnc), e_ews_connection_create_items_start),
+		result, G_OBJECT (cnc), e_ews_connection_create_items),
 		FALSE);
 
 	simple = G_SIMPLE_ASYNC_RESULT (result);
@@ -2647,45 +4017,62 @@ e_ews_connection_create_items_finish	(EE
 
 	if (g_simple_async_result_propagate_error (simple, error))
 		return FALSE;
+
+	/* if there is only one item, then check whether it's an error */
+	if (async_data->items && !async_data->items->next) {
+		EEwsItem *item = async_data->items->data;
+
+		if (item && e_ews_item_get_item_type (item) == E_EWS_ITEM_TYPE_ERROR) {
+			if (error)
+				*error = g_error_copy (e_ews_item_get_error (item));
+
+			g_slist_free_full (async_data->items, g_object_unref);
+			async_data->items = NULL;
+
+			return FALSE;
+		}
+	}
+
 	*ids = async_data->items;
 
 	return TRUE;
 }
 
 gboolean
-e_ews_connection_create_items	(EEwsConnection *cnc,
-				 gint pri,
-				 const gchar *msg_disposition,
-				 const gchar *send_invites,
-				 const gchar *folder_id,
-				 EEwsRequestCreationCallback create_cb,
-				 gpointer create_user_data,
-				 GSList **ids,
-				 GCancellable *cancellable,
-				 GError **error)
-{
-	EwsSyncData *sync_data;
-	gboolean result;
-
-	sync_data = g_new0 (EwsSyncData, 1);
-	sync_data->eflag = e_flag_new ();
-
-	e_ews_connection_create_items_start (cnc, pri, msg_disposition,
-					     send_invites, folder_id,
-					     create_cb, create_user_data,
-					     ews_sync_reply_cb, cancellable,
-					     (gpointer) sync_data);
-
-	e_flag_wait (sync_data->eflag);
-
-	result = e_ews_connection_create_items_finish (cnc, sync_data->res,
-						       ids, error);
-
-	e_flag_free (sync_data->eflag);
-	g_object_unref (sync_data->res);
-	g_free (sync_data);
+e_ews_connection_create_items_sync (EEwsConnection *cnc,
+                                    gint pri,
+                                    const gchar *msg_disposition,
+                                    const gchar *send_invites,
+                                    const EwsFolderId *fid,
+                                    EEwsRequestCreationCallback create_cb,
+                                    gpointer create_user_data,
+                                    GSList **ids,
+                                    GCancellable *cancellable,
+                                    GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_create_items (
+		cnc, pri, msg_disposition,
+		send_invites, fid,
+		create_cb, create_user_data,
+		cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_connection_create_items_finish (
+		cnc, result, ids, error);
+
+	e_async_closure_free (closure);
 
-	return result;
+	return success;
 }
 
 static const gchar *
@@ -2708,22 +4095,23 @@ get_search_scope_str (EwsContactsSearchS
 }
 
 void
-e_ews_connection_resolve_names_start 	(EEwsConnection *cnc,
-					 gint pri,
-					 const gchar *resolve_name,
-					 EwsContactsSearchScope scope,
-					 GSList *parent_folder_ids,
-					 gboolean fetch_contact_data,
-					 GAsyncReadyCallback cb,
-					 GCancellable *cancellable,
-					 gpointer user_data)
+e_ews_connection_resolve_names (EEwsConnection *cnc,
+                                gint pri,
+                                const gchar *resolve_name,
+                                EwsContactsSearchScope scope,
+                                GSList *parent_folder_ids,
+                                gboolean fetch_contact_data,
+                                GCancellable *cancellable,
+                                GAsyncReadyCallback callback,
+                                gpointer user_data)
 {
 	ESoapMessage *msg;
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
-	GSList *l;
 
-	msg = e_ews_message_new_with_header (cnc->priv->uri, "ResolveNames", NULL, NULL, EWS_EXCHANGE_2007_SP1);
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "ResolveNames", NULL, NULL, EWS_EXCHANGE_2007_SP1);
 
 	e_soap_message_add_attribute (msg, "SearchScope", get_search_scope_str (scope), NULL, NULL);
 
@@ -2734,25 +4122,7 @@ e_ews_connection_resolve_names_start 	(E
 
 	if (parent_folder_ids) {
 		e_soap_message_start_element (msg, "ParentFolderIds", "messages", NULL);
-
-		for (l = parent_folder_ids; l != NULL; l = g_slist_next (l)) {
-			EwsFolderId *fid = (EwsFolderId *) l->data;
-
-			if (fid->is_distinguished_id)
-				e_soap_message_start_element (msg, "DistinguishedFolderId", NULL, NULL);
-			else
-				e_soap_message_start_element (msg, "FolderId", NULL, NULL);
-
-			e_soap_message_add_attribute (msg, "Id", fid->id, NULL, NULL);
-			if (fid->change_key)
-				e_soap_message_add_attribute (msg, "ChangeKey", fid->change_key, NULL, NULL);
-
-			if (fid->is_distinguished_id && cnc->priv->email)
-				e_ews_message_write_string_parameter (msg, "Mailbox", NULL, cnc->priv->email);
-
-			e_soap_message_end_element (msg);
-		}
-
+		ews_append_folder_ids_to_msg (msg, cnc->priv->email, parent_folder_ids);
 		e_soap_message_end_element (msg);
 	}
 
@@ -2760,33 +4130,36 @@ e_ews_connection_resolve_names_start 	(E
 
 	e_ews_message_write_footer (msg);
 
-	simple = g_simple_async_result_new (G_OBJECT (cnc),
-                                      cb,
-                                      user_data,
-                                      e_ews_connection_resolve_names_start);
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_resolve_names);
 
 	async_data = g_new0 (EwsAsyncData, 1);
 	g_simple_async_result_set_op_res_gpointer (
 		simple, async_data, (GDestroyNotify) async_data_free);
 
-	ews_connection_queue_request (cnc, msg, resolve_names_response_cb, pri,
-				      cancellable, simple, cb == ews_sync_reply_cb);
+	e_ews_connection_queue_request (
+		cnc, msg, resolve_names_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
 }
 
 gboolean
-e_ews_connection_resolve_names_finish	(EEwsConnection *cnc,
-					 GAsyncResult *result,
-					 GSList **mailboxes,
-					 GSList **contact_items,
-					 gboolean *includes_last_item,
-					 GError **error)
+e_ews_connection_resolve_names_finish (EEwsConnection *cnc,
+                                       GAsyncResult *result,
+                                       GSList **mailboxes,
+                                       GSList **contact_items,
+                                       gboolean *includes_last_item,
+                                       GError **error)
 {
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 
+	g_return_val_if_fail (cnc != NULL, FALSE);
 	g_return_val_if_fail (
 		g_simple_async_result_is_valid (
-		result, G_OBJECT (cnc), e_ews_connection_resolve_names_start),
+		result, G_OBJECT (cnc), e_ews_connection_resolve_names),
 		FALSE);
 
 	simple = G_SIMPLE_ASYNC_RESULT (result);
@@ -2799,108 +4172,273 @@ e_ews_connection_resolve_names_finish	(E
 
 	if (contact_items)
 		*contact_items = async_data->items_created;
+	else
+		g_slist_free_full (async_data->items_created, e_ews_free_resolve_contact);
 	*mailboxes = async_data->items;
 
 	return TRUE;
 }
 
 gboolean
-e_ews_connection_resolve_names	(EEwsConnection *cnc,
-				 gint pri,
-				 const gchar *resolve_name,
-				 EwsContactsSearchScope scope,
-				 GSList *parent_folder_ids,
-				 gboolean fetch_contact_data,
-				 GSList **mailboxes,
-				 GSList **contact_items,
-				 gboolean *includes_last_item,
-				 GCancellable *cancellable,
-				 GError **error)
-{
-	EwsSyncData *sync_data;
-	gboolean result;
-
-	sync_data = g_new0 (EwsSyncData, 1);
-	sync_data->eflag = e_flag_new ();
-
-	e_ews_connection_resolve_names_start (cnc, pri, resolve_name,
-					     scope, parent_folder_ids,
-					     fetch_contact_data,
-					     ews_sync_reply_cb, cancellable,
-					     (gpointer) sync_data);
+e_ews_connection_resolve_names_sync (EEwsConnection *cnc,
+                                     gint pri,
+                                     const gchar *resolve_name,
+                                     EwsContactsSearchScope scope,
+                                     GSList *parent_folder_ids,
+                                     gboolean fetch_contact_data,
+                                     GSList **mailboxes,
+                                     GSList **contact_items,
+                                     gboolean *includes_last_item,
+                                     GCancellable *cancellable,
+                                     GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_resolve_names (
+		cnc, pri, resolve_name,
+		scope, parent_folder_ids,
+		fetch_contact_data,
+		cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_connection_resolve_names_finish (
+		cnc, result,
+		mailboxes, contact_items,
+		includes_last_item, error);
 
-	e_flag_wait (sync_data->eflag);
+	e_async_closure_free (closure);
 
-	result = e_ews_connection_resolve_names_finish (cnc, sync_data->res,
-						       mailboxes, contact_items,
-						       includes_last_item, error);
-
-	e_flag_free (sync_data->eflag);
-	g_object_unref (sync_data->res);
-	g_free (sync_data);
-
-	return result;
+	return success;
 }
 
-void		
-e_ews_connection_expand_dl_start	(EEwsConnection *cnc,
-					 gint pri,
-					 const EwsMailbox *mb,
-					 GAsyncReadyCallback cb,
-					 GCancellable *cancellable,
-					 gpointer user_data)
+static void
+ews_connection_resolve_by_name (EEwsConnection *cnc,
+                                gint pri,
+                                const gchar *usename,
+                                gboolean is_user_name,
+                                gchar **smtp_address,
+                                GCancellable *cancellable)
 {
-	ESoapMessage *msg;
-	GSimpleAsyncResult *simple;
-	EwsAsyncData *async_data;
+	GSList *mailboxes = NULL;
+	GSList *contacts = NULL;
+	gboolean includes_last_item = FALSE;
+	GSList *miter;
+	gint len;
 
-	msg = e_ews_message_new_with_header (cnc->priv->uri, "ExpandDL", NULL, NULL, EWS_EXCHANGE_2007_SP1);
+	g_return_if_fail (cnc != NULL);
+	g_return_if_fail (usename != NULL);
+	g_return_if_fail (smtp_address != NULL);
 
-	e_soap_message_start_element (msg, "Mailbox", "messages", NULL);
+	if (!*usename)
+		return;
 
-	if (mb->item_id) {
-		e_soap_message_start_element (msg, "ItemId", NULL, NULL);
-		
-		e_soap_message_add_attribute (msg, "Id", mb->item_id->id, NULL, NULL);
-		e_soap_message_add_attribute (msg, "ChangeKey", mb->item_id->change_key, NULL, NULL);
-		
-		e_soap_message_end_element (msg); /* Mailbox */
-		
-	} else if (mb->email)
-		e_ews_message_write_string_parameter (msg, "EmailAddress", NULL, mb->email);
-	
-	e_soap_message_end_element (msg); /* Mailbox */
+	len = strlen (usename);
+	mailboxes = NULL;
+	contacts = NULL;
+
+	/* use the first error, not the guess-part error */
+	e_ews_connection_resolve_names_sync (
+		cnc, pri, usename,
+		EWS_SEARCH_AD_CONTACTS, NULL, TRUE, &mailboxes, &contacts,
+		&includes_last_item, cancellable, NULL);
+
+	for (miter = mailboxes; miter; miter = miter->next) {
+		const EwsMailbox *mailbox = miter->data;
+		if (mailbox->email && *mailbox->email && g_strcmp0 (mailbox->routing_type, "EX") != 0
+		    && ((!is_user_name && g_str_has_prefix (mailbox->email, usename) && mailbox->email[len] == '@') ||
+		    (is_user_name && g_str_equal (usename, mailbox->name)))) {
+			*smtp_address = g_strdup (mailbox->email);
+			break;
+		} else if (contacts && !contacts->next && contacts->data) {
+			const EwsResolveContact *resolved = contacts->data;
+			GList *emails = g_hash_table_get_values (resolved->email_addresses), *iter;
+			gboolean found = FALSE;
+
+			for (iter = emails; iter && !found; iter = iter->next) {
+				const gchar *it_email = iter->data;
+
+				if (it_email && g_str_has_prefix (it_email, "SMTP:")
+				    && ((!is_user_name && g_str_has_prefix (it_email, usename) && it_email[len] == '@') ||
+				    (is_user_name && g_str_equal (usename, resolved->display_name)))) {
+					found = TRUE;
+					break;
+				}
+			}
 
-	e_ews_message_write_footer (msg);
+			g_list_free (emails);
 
-	simple = g_simple_async_result_new (G_OBJECT (cnc),
-                                      cb,
-                                      user_data,
-                                      e_ews_connection_expand_dl_start);
+			if (found) {
+				gint ii;
 
-	async_data = g_new0 (EwsAsyncData, 1);
+				for (ii = 0; ii < g_hash_table_size (resolved->email_addresses); ii++) {
+					gchar *key, *value;
+
+					key = g_strdup_printf ("EmailAddress%d", ii + 1);
+					value = g_hash_table_lookup (resolved->email_addresses, key);
+					g_free (key);
+
+					if (value && g_str_has_prefix (value, "SMTP:")) {
+						/* pick the first available SMTP address */
+						*smtp_address = g_strdup (value + 5);
+						break;
+					}
+				}
+				break;
+			}
+		}
+	}
+
+	g_slist_free_full (mailboxes, (GDestroyNotify) e_ews_mailbox_free);
+	g_slist_free_full (contacts, (GDestroyNotify) e_ews_free_resolve_contact);
+}
+
+gboolean
+e_ews_connection_ex_to_smtp_sync (EEwsConnection *cnc,
+                                  gint pri,
+                                  const gchar *name,
+                                  const gchar *ex_address,
+                                  gchar **smtp_address,
+                                  GCancellable *cancellable,
+                                  GError **error)
+{
+	GSList *mailboxes = NULL;
+	GSList *contacts = NULL;
+	gboolean includes_last_item = FALSE;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+	g_return_val_if_fail (ex_address != NULL, FALSE);
+	g_return_val_if_fail (smtp_address != NULL, FALSE);
+
+	*smtp_address = NULL;
+
+	e_ews_connection_resolve_names_sync (
+		cnc, pri, ex_address,
+		EWS_SEARCH_AD_CONTACTS, NULL, TRUE, &mailboxes, &contacts,
+		&includes_last_item, cancellable, error);
+
+	/* only one mailbox matches */
+	if (mailboxes && !mailboxes->next && mailboxes->data) {
+		const EwsMailbox *mailbox = mailboxes->data;
+		if (mailbox->email && *mailbox->email && g_strcmp0 (mailbox->routing_type, "EX") != 0) {
+			*smtp_address = g_strdup (mailbox->email);
+		} else if (contacts && !contacts->next && contacts->data) {
+			const EwsResolveContact *resolved = contacts->data;
+			gint ii;
+
+			for (ii = 0; ii < g_hash_table_size (resolved->email_addresses); ii++) {
+				gchar *key, *value;
+
+				key = g_strdup_printf ("EmailAddress%d", ii + 1);
+				value = g_hash_table_lookup (resolved->email_addresses, key);
+				g_free (key);
+
+				if (value && g_str_has_prefix (value, "SMTP:")) {
+					/* pick the first available SMTP address */
+					*smtp_address = g_strdup (value + 5);
+					break;
+				}
+			}
+		}
+	}
+
+	g_slist_free_full (mailboxes, (GDestroyNotify) e_ews_mailbox_free);
+	g_slist_free_full (contacts, (GDestroyNotify) e_ews_free_resolve_contact);
+
+	if (!*smtp_address) {
+		const gchar *usename;
+
+		usename = strrchr (ex_address, '/');
+		if (usename && g_ascii_strncasecmp (usename, "/cn=", 4) == 0) {
+			usename += 4;
+
+			/* try to guess from common name of the EX address */
+			ews_connection_resolve_by_name (cnc, pri, usename, FALSE, smtp_address, cancellable);
+		}
+
+		if (!*smtp_address && name && *name) {
+			/* try to guess from mailbox name */
+			ews_connection_resolve_by_name (cnc, pri, name, TRUE, smtp_address, cancellable);
+		}
+	}
+
+	if (*smtp_address)
+		g_clear_error (error);
+
+	return *smtp_address != NULL;
+}
+
+void
+e_ews_connection_expand_dl (EEwsConnection *cnc,
+                            gint pri,
+                            const EwsMailbox *mb,
+                            GCancellable *cancellable,
+                            GAsyncReadyCallback callback,
+                            gpointer user_data)
+{
+	ESoapMessage *msg;
+	GSimpleAsyncResult *simple;
+	EwsAsyncData *async_data;
+
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "ExpandDL", NULL, NULL, EWS_EXCHANGE_2007_SP1);
+
+	e_soap_message_start_element (msg, "Mailbox", "messages", NULL);
+
+	if (mb->item_id) {
+		e_soap_message_start_element (msg, "ItemId", NULL, NULL);
+
+		e_soap_message_add_attribute (msg, "Id", mb->item_id->id, NULL, NULL);
+		e_soap_message_add_attribute (msg, "ChangeKey", mb->item_id->change_key, NULL, NULL);
+
+		e_soap_message_end_element (msg); /* Mailbox */
+
+	} else if (mb->email)
+		e_ews_message_write_string_parameter (msg, "EmailAddress", NULL, mb->email);
+
+	e_soap_message_end_element (msg); /* Mailbox */
+
+	e_ews_message_write_footer (msg);
+
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_expand_dl);
+
+	async_data = g_new0 (EwsAsyncData, 1);
 	g_simple_async_result_set_op_res_gpointer (
 		simple, async_data, (GDestroyNotify) async_data_free);
 
-	ews_connection_queue_request (cnc, msg, expand_dl_response_cb, pri,
-				      cancellable, simple, cb == ews_sync_reply_cb);
+	e_ews_connection_queue_request (
+		cnc, msg, expand_dl_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
 }
 
 /* includes_last_item does not make sense as expand_dl does not support recursive 
-   fetch, wierd */
-gboolean	
-e_ews_connection_expand_dl_finish	(EEwsConnection *cnc,
-					 GAsyncResult *result,
-					 GSList **mailboxes,
-					 gboolean *includes_last_item,
-					 GError **error)
+ * fetch, wierd */
+gboolean
+e_ews_connection_expand_dl_finish (EEwsConnection *cnc,
+                                   GAsyncResult *result,
+                                   GSList **mailboxes,
+                                   gboolean *includes_last_item,
+                                   GError **error)
 {
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 
+	g_return_val_if_fail (cnc != NULL, FALSE);
 	g_return_val_if_fail (
 		g_simple_async_result_is_valid (
-		result, G_OBJECT (cnc), e_ews_connection_expand_dl_start),
+		result, G_OBJECT (cnc), e_ews_connection_expand_dl),
 		FALSE);
 
 	simple = G_SIMPLE_ASYNC_RESULT (result);
@@ -2916,52 +4454,87 @@ e_ews_connection_expand_dl_finish	(EEwsC
 
 }
 
-gboolean	
-e_ews_connection_expand_dl	(EEwsConnection *cnc,
-				 gint pri,
-				 const EwsMailbox *mb,
-				 GSList **mailboxes,
-				 gboolean *includes_last_item,
-				 GCancellable *cancellable,
-				 GError **error)
+gboolean
+e_ews_connection_expand_dl_sync (EEwsConnection *cnc,
+                                 gint pri,
+                                 const EwsMailbox *mb,
+                                 GSList **mailboxes,
+                                 gboolean *includes_last_item,
+                                 GCancellable *cancellable,
+                                 GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_expand_dl (
+		cnc, pri, mb, cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_connection_expand_dl_finish (
+		cnc, result, mailboxes, includes_last_item, error);
+
+	e_async_closure_free (closure);
+
+	return success;
+}
+
+static void
+update_folder_response_cb (ESoapResponse *response,
+                           GSimpleAsyncResult *simple)
 {
-	EwsSyncData *sync_data;
-	gboolean result;
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	GError *error = NULL;
 
-	sync_data = g_new0 (EwsSyncData, 1);
-	sync_data->eflag = e_flag_new ();
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessages", &error);
 
-	e_ews_connection_expand_dl_start (cnc, pri, mb,
-					  ews_sync_reply_cb, cancellable,
-					  (gpointer) sync_data);
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
 
-	e_flag_wait (sync_data->eflag);
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
 
-	result = e_ews_connection_expand_dl_finish (cnc, sync_data->res,
-						       mailboxes, includes_last_item, error);
+	subparam = e_soap_parameter_get_first_child (param);
 
-	e_flag_free (sync_data->eflag);
-	g_object_unref (sync_data->res);
-	g_free (sync_data);
+	while (subparam != NULL) {
+		if (!ews_get_response_status (subparam, &error)) {
+			g_simple_async_result_take_error (simple, error);
+			return;
+		}
 
-	return result;
+		subparam = e_soap_parameter_get_next_child (param);
+	}
 }
 
 void
-e_ews_connection_update_folder_start	(EEwsConnection *cnc,
-					 gint pri,
-					 EEwsRequestCreationCallback create_cb,
-					 gpointer create_user_data,
-					 GAsyncReadyCallback cb,
-					 GCancellable *cancellable,
-					 gpointer user_data)
+e_ews_connection_update_folder (EEwsConnection *cnc,
+                                gint pri,
+                                EEwsRequestCreationCallback create_cb,
+                                gpointer create_user_data,
+                                GCancellable *cancellable,
+                                GAsyncReadyCallback callback,
+                                gpointer user_data)
 {
 	ESoapMessage *msg;
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 
-	msg = e_ews_message_new_with_header (cnc->priv->uri, "UpdateFolder",
-					     NULL, NULL, EWS_EXCHANGE_2007_SP1);
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "UpdateFolder",
+		NULL, NULL, EWS_EXCHANGE_2007_SP1);
 
 	e_soap_message_start_element (msg, "FolderChanges", "messages", NULL);
 
@@ -2971,29 +4544,32 @@ e_ews_connection_update_folder_start	(EE
 
 	e_ews_message_write_footer (msg);
 
-	simple = g_simple_async_result_new (G_OBJECT (cnc),
-                                      cb,
-                                      user_data,
-                                      e_ews_connection_update_folder_start);
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_update_folder);
 
 	async_data = g_new0 (EwsAsyncData, 1);
 	g_simple_async_result_set_op_res_gpointer (
 		simple, async_data, (GDestroyNotify) async_data_free);
 
-	ews_connection_queue_request (cnc, msg, NULL, pri, cancellable, simple,
-				      cb == ews_sync_reply_cb);
+	e_ews_connection_queue_request (
+		cnc, msg, update_folder_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
 }
 
 gboolean
-e_ews_connection_update_folder_finish	(EEwsConnection *cnc,
-					 GAsyncResult *result,
-					 GError **error)
+e_ews_connection_update_folder_finish (EEwsConnection *cnc,
+                                       GAsyncResult *result,
+                                       GError **error)
 {
 	GSimpleAsyncResult *simple;
 
+	g_return_val_if_fail (cnc != NULL, FALSE);
 	g_return_val_if_fail (
 		g_simple_async_result_is_valid (
-		result, G_OBJECT (cnc), e_ews_connection_update_folder_start),
+		result, G_OBJECT (cnc), e_ews_connection_update_folder),
 		FALSE);
 
 	simple = G_SIMPLE_ASYNC_RESULT (result);
@@ -3005,164 +4581,341 @@ e_ews_connection_update_folder_finish	(E
 }
 
 gboolean
-e_ews_connection_update_folder	(EEwsConnection *cnc,
-				 gint pri,
-				 EEwsRequestCreationCallback create_cb,
-				 gpointer create_user_data,
-				 GCancellable *cancellable,
-				 GError **error)
+e_ews_connection_update_folder_sync (EEwsConnection *cnc,
+                                     gint pri,
+                                     EEwsRequestCreationCallback create_cb,
+                                     gpointer create_user_data,
+                                     GCancellable *cancellable,
+                                     GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_update_folder (
+		cnc, pri, create_cb, create_user_data, cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_connection_update_folder_finish (cnc, result, error);
+
+	e_async_closure_free (closure);
+
+	return success;
+}
+
+static void
+move_folder_response_cb (ESoapResponse *response,
+                         GSimpleAsyncResult *simple)
 {
-	EwsSyncData *sync_data;
-	gboolean result;
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	GError *error = NULL;
 
-	sync_data = g_new0 (EwsSyncData, 1);
-	sync_data->eflag = e_flag_new ();
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessages", &error);
 
-	e_ews_connection_update_folder_start (cnc, pri,
-					      create_cb, create_user_data,
-					      ews_sync_reply_cb, cancellable,
-					      (gpointer) sync_data);
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
 
-	e_flag_wait (sync_data->eflag);
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
 
-	result = e_ews_connection_update_folder_finish (cnc, sync_data->res,
-							error);
+	subparam = e_soap_parameter_get_first_child (param);
 
-	e_flag_free (sync_data->eflag);
-	g_object_unref (sync_data->res);
-	g_free (sync_data);
+	while (subparam != NULL) {
+		if (!ews_get_response_status (subparam, &error)) {
+			g_simple_async_result_take_error (simple, error);
+			return;
+		}
 
-	return result;
+		subparam = e_soap_parameter_get_next_child (subparam);
+	}
 }
 
 void
-e_ews_connection_move_folder_start	(EEwsConnection *cnc,
-					 gint pri,
-					 const gchar *to_folder,
-					 const gchar *folder,
-					 GAsyncReadyCallback cb,
-					 GCancellable *cancellable,
-					 gpointer user_data)
+e_ews_connection_move_folder (EEwsConnection *cnc,
+                              gint pri,
+                              const gchar *to_folder,
+                              const gchar *folder,
+                              GCancellable *cancellable,
+                              GAsyncReadyCallback callback,
+                              gpointer user_data)
 {
 	ESoapMessage *msg;
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 
-	msg = e_ews_message_new_with_header (cnc->priv->uri, "MoveFolder",
-					     NULL, NULL, EWS_EXCHANGE_2007_SP1);
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "MoveFolder",
+		NULL, NULL, EWS_EXCHANGE_2007_SP1);
 
 	e_soap_message_start_element (msg, "ToFolderId", "messages", NULL);
 	if (to_folder)
-		e_ews_message_write_string_parameter_with_attribute (msg, "FolderId", NULL,
-								     NULL, "Id", to_folder);
+		e_ews_message_write_string_parameter_with_attribute (
+			msg, "FolderId", NULL,
+			NULL, "Id", to_folder);
 	else
-		e_ews_message_write_string_parameter_with_attribute (msg, "DistinguishedFolderId", NULL,
-								     NULL, "Id", "msgfolderroot");
+		e_ews_message_write_string_parameter_with_attribute (
+			msg, "DistinguishedFolderId", NULL,
+			NULL, "Id", "msgfolderroot");
 
 	e_soap_message_end_element (msg);
 
 	e_soap_message_start_element (msg, "FolderIds", "messages", NULL);
-	e_ews_message_write_string_parameter_with_attribute (msg, "FolderId", NULL,
-							     NULL, "Id", folder);
+	e_ews_message_write_string_parameter_with_attribute (
+		msg, "FolderId", NULL,
+		NULL, "Id", folder);
+	e_soap_message_end_element (msg);
+
+	e_ews_message_write_footer (msg);
+
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_move_folder);
+
+	async_data = g_new0 (EwsAsyncData, 1);
+	g_simple_async_result_set_op_res_gpointer (
+		simple, async_data, (GDestroyNotify) async_data_free);
+
+	e_ews_connection_queue_request (
+		cnc, msg, move_folder_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
+}
+
+gboolean
+e_ews_connection_move_folder_finish (EEwsConnection *cnc,
+                                     GAsyncResult *result,
+                                     GError **error)
+{
+	GSimpleAsyncResult *simple;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+	g_return_val_if_fail (
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (cnc), e_ews_connection_move_folder),
+		FALSE);
+
+	simple = G_SIMPLE_ASYNC_RESULT (result);
+
+	if (g_simple_async_result_propagate_error (simple, error))
+		return FALSE;
+
+	return TRUE;
+}
+
+gboolean
+e_ews_connection_move_folder_sync (EEwsConnection *cnc,
+                                   gint pri,
+                                   const gchar *to_folder,
+                                   const gchar *folder,
+                                   GCancellable *cancellable,
+                                   GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_move_folder (
+		cnc, pri, to_folder, folder, cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_connection_move_folder_finish (cnc, result, error);
+
+	e_async_closure_free (closure);
+
+	return success;
+}
+
+void
+e_ews_connection_get_folder (EEwsConnection *cnc,
+                             gint pri,
+                             const gchar *folder_shape,
+                             EwsAdditionalProps *add_props,
+                             GSList *folder_ids,
+                             GCancellable *cancellable,
+                             GAsyncReadyCallback callback,
+                             gpointer user_data)
+{
+	ESoapMessage *msg;
+	GSimpleAsyncResult *simple;
+	EwsAsyncData *async_data;
+
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "GetFolder",
+		NULL, NULL, EWS_EXCHANGE_2007_SP1);
+
+	e_soap_message_start_element (msg, "FolderShape", "messages", NULL);
+	e_ews_message_write_string_parameter (msg, "BaseShape", NULL, folder_shape);
+
+	ews_append_additional_props_to_msg (msg, add_props);
 	e_soap_message_end_element (msg);
 
+	if (folder_ids) {
+		e_soap_message_start_element (msg, "FolderIds", "messages", NULL);
+		ews_append_folder_ids_to_msg (msg, cnc->priv->email, folder_ids);
+		e_soap_message_end_element (msg);
+	}
+
 	e_ews_message_write_footer (msg);
 
-	simple = g_simple_async_result_new (G_OBJECT (cnc),
-                                      cb,
-                                      user_data,
-                                      e_ews_connection_move_folder_start);
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_get_folder);
 
 	async_data = g_new0 (EwsAsyncData, 1);
 	g_simple_async_result_set_op_res_gpointer (
 		simple, async_data, (GDestroyNotify) async_data_free);
 
-	ews_connection_queue_request (cnc, msg, NULL, pri, cancellable, simple,
-				      cb == ews_sync_reply_cb);
+	e_ews_connection_queue_request (
+		cnc, msg, get_folder_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
 }
 
 gboolean
-e_ews_connection_move_folder_finish	(EEwsConnection *cnc,
-					 GAsyncResult *result,
-					 GError **error)
+e_ews_connection_get_folder_finish (EEwsConnection *cnc,
+                                    GAsyncResult *result,
+                                    GSList **folders,
+                                    GError **error)
 {
 	GSimpleAsyncResult *simple;
+	EwsAsyncData *async_data;
 
+	g_return_val_if_fail (cnc != NULL, FALSE);
 	g_return_val_if_fail (
 		g_simple_async_result_is_valid (
-		result, G_OBJECT (cnc), e_ews_connection_move_folder_start),
+		result, G_OBJECT (cnc), e_ews_connection_get_folder),
 		FALSE);
 
 	simple = G_SIMPLE_ASYNC_RESULT (result);
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
 
 	if (g_simple_async_result_propagate_error (simple, error))
 		return FALSE;
 
+	*folders = async_data->items;
+
 	return TRUE;
 }
 
 gboolean
-e_ews_connection_move_folder	(EEwsConnection *cnc,
-				 gint pri,
-				 const gchar *to_folder,
-				 const gchar *folder,
-				 GCancellable *cancellable,
-				 GError **error)
+e_ews_connection_get_folder_sync (EEwsConnection *cnc,
+                                  gint pri,
+                                  const gchar *folder_shape,
+                                  EwsAdditionalProps *add_props,
+                                  GSList *folder_ids,
+                                  GSList **folders,
+                                  GCancellable *cancellable,
+                                  GError **error)
 {
-	EwsSyncData *sync_data;
-	gboolean result;
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
 
-	sync_data = g_new0 (EwsSyncData, 1);
-	sync_data->eflag = e_flag_new ();
+	closure = e_async_closure_new ();
 
-	e_ews_connection_move_folder_start (cnc, pri, to_folder, folder,
-					    ews_sync_reply_cb, cancellable,
-					    (gpointer) sync_data);
+	e_ews_connection_get_folder (
+		cnc, pri, folder_shape, add_props,
+		folder_ids, cancellable,
+		e_async_closure_callback, closure);
 
-	e_flag_wait (sync_data->eflag);
+	result = e_async_closure_wait (closure);
 
-	result = e_ews_connection_move_folder_finish (cnc, sync_data->res,
-						      error);
+	success = e_ews_connection_get_folder_finish (
+		cnc, result, folders, error);
 
-	e_flag_free (sync_data->eflag);
-	g_object_unref (sync_data->res);
-	g_free (sync_data);
+	e_async_closure_free (closure);
 
-	return result;
+	return success;
 }
 
 void
-e_ews_connection_create_folder_start	(EEwsConnection *cnc,
-					 gint pri,
-					 const gchar *parent_folder_id,
-					 gboolean is_distinguished_id,
-					 const gchar *folder_name,
-					 GAsyncReadyCallback cb,
-					 GCancellable *cancellable,
-					 gpointer user_data)
+e_ews_connection_create_folder (EEwsConnection *cnc,
+                                gint pri,
+                                const gchar *parent_folder_id,
+                                gboolean is_distinguished_id,
+                                const gchar *folder_name,
+                                EEwsFolderType folder_type,
+                                GCancellable *cancellable,
+                                GAsyncReadyCallback callback,
+                                gpointer user_data)
 {
 	ESoapMessage *msg;
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
+	const gchar *folder_element;
 
-	msg = e_ews_message_new_with_header (cnc->priv->uri, "CreateFolder", NULL, NULL, EWS_EXCHANGE_2007_SP1);
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "CreateFolder", NULL, NULL, EWS_EXCHANGE_2007_SP1);
 
 	e_soap_message_start_element (msg, "ParentFolderId", "messages", NULL);
 
 	/* If NULL passed for parent_folder_id, use "msgfolderroot" */
-	if (is_distinguished_id || !parent_folder_id)
-		e_ews_message_write_string_parameter_with_attribute (msg, "DistinguishedFolderId", NULL, NULL, "Id",
-								     parent_folder_id?:"msgfolderroot");
-	else
+	if (is_distinguished_id || !parent_folder_id) {
+		e_soap_message_start_element (msg, "DistinguishedFolderId", NULL, NULL);
+		e_soap_message_add_attribute (
+				msg, "Id", parent_folder_id ?: "msgfolderroot", NULL, NULL);
+		if (is_distinguished_id && cnc->priv->email) {
+			e_soap_message_start_element (msg, "Mailbox", NULL, NULL);
+			e_ews_message_write_string_parameter(
+					msg, "EmailAddress", NULL, cnc->priv->email);
+			e_soap_message_end_element (msg);
+		}
+		e_soap_message_end_element (msg);
+	} else {
 		e_ews_message_write_string_parameter_with_attribute (msg, "FolderId", NULL, NULL, "Id", parent_folder_id);
-
-	if (is_distinguished_id && cnc->priv->email)
-		e_ews_message_write_string_parameter (msg, "Mailbox", NULL, cnc->priv->email);
+	}
 
 	e_soap_message_end_element (msg);
 
+	switch (folder_type) {
+		case E_EWS_FOLDER_TYPE_MAILBOX:
+			folder_element = "Folder";
+			break;
+		case E_EWS_FOLDER_TYPE_CALENDAR:
+			folder_element = "CalendarFolder";
+			break;
+		case E_EWS_FOLDER_TYPE_CONTACTS:
+			folder_element = "ContactsFolder";
+			break;
+		case E_EWS_FOLDER_TYPE_SEARCH:
+			folder_element = "SearchFolder";
+			break;
+		case E_EWS_FOLDER_TYPE_TASKS:
+			folder_element = "TasksFolder";
+			break;
+		default:
+			g_warn_if_reached ();
+			folder_element = "Folder";
+			break;
+	}
+
 	e_soap_message_start_element (msg, "Folders", "messages", NULL);
-	e_soap_message_start_element(msg, "Folder", NULL, NULL);
+	e_soap_message_start_element (msg, folder_element, NULL, NULL);
 	e_ews_message_write_string_parameter (msg, "DisplayName", NULL, folder_name);
 
 	e_soap_message_end_element (msg);
@@ -3170,30 +4923,36 @@ e_ews_connection_create_folder_start	(EE
 
 	e_ews_message_write_footer (msg);
 
-      	simple = g_simple_async_result_new (G_OBJECT (cnc),
-                                      cb,
-				      user_data,
-                                      e_ews_connection_create_folder_start);
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_create_folder);
 
 	async_data = g_new0 (EwsAsyncData, 1);
+	async_data->folder_type = folder_type;
+
 	g_simple_async_result_set_op_res_gpointer (
 		simple, async_data, (GDestroyNotify) async_data_free);
 
-	ews_connection_queue_request (cnc, msg, ews_create_folder_cb, pri, cancellable, simple, cb == ews_sync_reply_cb);
+	e_ews_connection_queue_request (
+		cnc, msg, create_folder_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
 }
 
 gboolean
-e_ews_connection_create_folder_finish	(EEwsConnection *cnc,
-					 GAsyncResult *result,
-					 EwsFolderId **fid,
-					 GError **error)
+e_ews_connection_create_folder_finish (EEwsConnection *cnc,
+                                       GAsyncResult *result,
+                                       EwsFolderId **fid,
+                                       GError **error)
 {
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 
+	g_return_val_if_fail (cnc != NULL, FALSE);
 	g_return_val_if_fail (
 		g_simple_async_result_is_valid (
-		result, G_OBJECT (cnc), e_ews_connection_create_folder_start),
+		result, G_OBJECT (cnc), e_ews_connection_create_folder),
 		FALSE);
 
 	simple = G_SIMPLE_ASYNC_RESULT (result);
@@ -3208,65 +4967,64 @@ e_ews_connection_create_folder_finish	(E
 	return TRUE;
 }
 
-
 gboolean
-e_ews_connection_create_folder	(EEwsConnection *cnc,
-				 gint pri,
-				 const gchar *parent_folder_id,
-				 gboolean is_distinguished_id,
-				 const gchar *folder_name,
-				 EwsFolderId **folder_id,
-				 GCancellable *cancellable,
-				 GError **error)
-{
-	EwsSyncData *sync_data;
-	gboolean result;
-
-	sync_data = g_new0 (EwsSyncData, 1);
-	sync_data->eflag = e_flag_new ();
-
-	e_ews_connection_create_folder_start	(cnc, pri, parent_folder_id,
-						 is_distinguished_id,
-						 folder_name,
-						 ews_sync_reply_cb,
-						 cancellable,
-						 (gpointer) sync_data);
-
-	e_flag_wait (sync_data->eflag);
-
-	result = e_ews_connection_create_folder_finish (cnc, sync_data->res,
-							folder_id,
-							error);
-
-	e_flag_free (sync_data->eflag);
-	g_object_unref (sync_data->res);
-	g_free (sync_data);
-
-	return result;
+e_ews_connection_create_folder_sync (EEwsConnection *cnc,
+                                     gint pri,
+                                     const gchar *parent_folder_id,
+                                     gboolean is_distinguished_id,
+                                     const gchar *folder_name,
+                                     EEwsFolderType folder_type,
+                                     EwsFolderId **folder_id,
+                                     GCancellable *cancellable,
+                                     GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_create_folder (
+		cnc, pri, parent_folder_id,
+		is_distinguished_id, folder_name,
+		folder_type, cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_connection_create_folder_finish (
+		cnc, result, folder_id, error);
 
+	e_async_closure_free (closure);
+
+	return success;
 }
 
 void
-e_ews_connection_move_items_start	(EEwsConnection *cnc,
-					 gint pri,
-					 const gchar *folder_id,
-					 gboolean docopy,
-					 GSList *ids,
-					 GAsyncReadyCallback cb,
-					 GCancellable *cancellable,
-					 gpointer user_data)
+e_ews_connection_move_items (EEwsConnection *cnc,
+                             gint pri,
+                             const gchar *folder_id,
+                             gboolean docopy,
+                             GSList *ids,
+                             GCancellable *cancellable,
+                             GAsyncReadyCallback callback,
+                             gpointer user_data)
 {
 	ESoapMessage *msg;
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 	GSList *l;
 
+	g_return_if_fail (cnc != NULL);
+
 	if (docopy)
-		msg = e_ews_message_new_with_header (cnc->priv->uri, "CopyItem",
-					     NULL, NULL, EWS_EXCHANGE_2007_SP1);
+		msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "CopyItem",
+			NULL, NULL, EWS_EXCHANGE_2007_SP1);
 	else
-		msg = e_ews_message_new_with_header (cnc->priv->uri, "MoveItem",
-					     NULL, NULL, EWS_EXCHANGE_2007_SP1);
+		msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "MoveItem",
+			NULL, NULL, EWS_EXCHANGE_2007_SP1);
 
 	e_soap_message_start_element (msg, "ToFolderId", "messages", NULL);
 	e_soap_message_start_element (msg, "FolderId", NULL, NULL);
@@ -3281,31 +5039,34 @@ e_ews_connection_move_items_start	(EEwsC
 
 	e_ews_message_write_footer (msg);
 
-	simple = g_simple_async_result_new (G_OBJECT (cnc),
-					    cb,
-					    user_data,
-					    e_ews_connection_move_items_start);
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_move_items);
 
 	async_data = g_new0 (EwsAsyncData, 1);
 	g_simple_async_result_set_op_res_gpointer (
 		simple, async_data, (GDestroyNotify) async_data_free);
 
-	ews_connection_queue_request (cnc, msg, get_items_response_cb, pri, cancellable, simple,
-				      cb == ews_sync_reply_cb);
+	e_ews_connection_queue_request (
+		cnc, msg, get_items_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
 }
 
 gboolean
-e_ews_connection_move_items_finish	(EEwsConnection *cnc,
-					 GAsyncResult *result,
-					 GSList **items,
-					 GError **error)
+e_ews_connection_move_items_finish (EEwsConnection *cnc,
+                                    GAsyncResult *result,
+                                    GSList **items,
+                                    GError **error)
 {
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 
+	g_return_val_if_fail (cnc != NULL, FALSE);
 	g_return_val_if_fail (
 		g_simple_async_result_is_valid (
-		result, G_OBJECT (cnc), e_ews_connection_move_items_start),
+		result, G_OBJECT (cnc), e_ews_connection_move_items),
 		FALSE);
 
 	simple = G_SIMPLE_ASYNC_RESULT (result);
@@ -3314,108 +5075,169 @@ e_ews_connection_move_items_finish	(EEws
 	if (g_simple_async_result_propagate_error (simple, error))
 		return FALSE;
 
+	/* if there is only one item, then check whether it's an error */
+	if (async_data->items && !async_data->items->next) {
+		EEwsItem *item = async_data->items->data;
+
+		if (item && e_ews_item_get_item_type (item) == E_EWS_ITEM_TYPE_ERROR) {
+			if (error)
+				*error = g_error_copy (e_ews_item_get_error (item));
+
+			g_slist_free_full (async_data->items, g_object_unref);
+			async_data->items = NULL;
+
+			return FALSE;
+		}
+	}
+
 	*items = async_data->items;
 
 	return TRUE;
 }
 
 gboolean
-e_ews_connection_move_items	(EEwsConnection *cnc,
-				 gint pri,
-				 const gchar *folder_id,
-				 gboolean docopy,
-				 GSList *ids,
-				 GSList **items,
-				 GCancellable *cancellable,
-				 GError **error)
-{
-	EwsSyncData *sync_data;
-	gboolean result;
-
-	sync_data = g_new0 (EwsSyncData, 1);
-	sync_data->eflag = e_flag_new ();
-
-	e_ews_connection_move_items_start (cnc, pri, folder_id, docopy, ids,
-					   ews_sync_reply_cb, cancellable,
-					   (gpointer) sync_data);
-
-	e_flag_wait (sync_data->eflag);
-
-	result = e_ews_connection_move_items_finish (cnc, sync_data->res,
-						     items, error);
-
-	e_flag_free (sync_data->eflag);
-	g_object_unref (sync_data->res);
-	g_free (sync_data);
+e_ews_connection_move_items_sync (EEwsConnection *cnc,
+                                  gint pri,
+                                  const gchar *folder_id,
+                                  gboolean docopy,
+                                  GSList *ids,
+                                  GSList **items,
+                                  GCancellable *cancellable,
+                                  GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_move_items (
+		cnc, pri, folder_id, docopy, ids, cancellable,
+		e_async_closure_callback, closure);
 
-	return result;
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_connection_move_items_finish (
+		cnc, result, items, error);
+
+	e_async_closure_free (closure);
+
+	return success;
+}
+
+static void
+delete_folder_response_cb (ESoapResponse *response,
+                           GSimpleAsyncResult *simple)
+{
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	GError *error = NULL;
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessages", &error);
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	subparam = e_soap_parameter_get_first_child (param);
+
+	while (subparam != NULL) {
+		if (!ews_get_response_status (subparam, &error)) {
+			g_simple_async_result_take_error (simple, error);
+			return;
+		}
+
+		subparam = e_soap_parameter_get_next_child (subparam);
+	}
 }
 
-void
 /**
- * e_ews_connection_delete_folder_start
+ * e_ews_connection_delete_folder:
  * @cnc:
  * @pri:
  * @folder_id: folder to be deleted
  * @is_distinguished_id:
  * @delete_type: "HardDelete", "SoftDelete", "MoveToDeletedItems"
- * @cb:
  * @cancellable:
+ * @callback:
  * @user_data:
  **/
-e_ews_connection_delete_folder_start	(EEwsConnection *cnc,
-					 gint pri,
-					 const gchar *folder_id,
-					 gboolean is_distinguished_id,
-					 const gchar *delete_type,
-					 GAsyncReadyCallback cb,
-					 GCancellable *cancellable,
-					 gpointer user_data)
+void
+e_ews_connection_delete_folder (EEwsConnection *cnc,
+                                gint pri,
+                                const gchar *folder_id,
+                                gboolean is_distinguished_id,
+                                const gchar *delete_type,
+                                GCancellable *cancellable,
+                                GAsyncReadyCallback callback,
+                                gpointer user_data)
 {
 	ESoapMessage *msg;
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 
-	msg = e_ews_message_new_with_header (cnc->priv->uri, "DeleteFolder", "DeleteType", delete_type, EWS_EXCHANGE_2007_SP1);
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "DeleteFolder", "DeleteType", delete_type, EWS_EXCHANGE_2007_SP1);
 
 	e_soap_message_start_element (msg, "FolderIds", "messages", NULL);
 
-	if (is_distinguished_id)
-		e_ews_message_write_string_parameter_with_attribute (msg, "DistinguishedFolderId", NULL, NULL, "Id", folder_id);
-	else
-		e_ews_message_write_string_parameter_with_attribute (msg, "FolderId", NULL, NULL, "Id", folder_id);
+	e_soap_message_start_element (
+			msg,
+			is_distinguished_id ? "DistinguishedFolderId" : "FolderId",
+			NULL,
+			NULL);
+	e_soap_message_add_attribute (msg, "Id", folder_id, NULL, NULL);
 
-	/*This element is required for delegate access*/
-	if (is_distinguished_id && cnc->priv->email)
-		e_ews_message_write_string_parameter (msg, "Mailbox", NULL, cnc->priv->email);
+	/* This element is required for delegate access */
+	if (is_distinguished_id && cnc->priv->email) {
+		e_soap_message_start_element (msg, "Mailbox", NULL, NULL);
+		e_ews_message_write_string_parameter(
+				msg, "EmailAddress", NULL, cnc->priv->email);
+		e_soap_message_end_element (msg);
+	}
 
-	e_soap_message_end_element (msg);
+	e_soap_message_end_element (msg); /* </DistinguishedFolderId> || </FolderId> */
+
+	e_soap_message_end_element (msg); /* </FolderIds> */
 
 	e_ews_message_write_footer (msg);
 
-      	simple = g_simple_async_result_new (G_OBJECT (cnc),
-                                      cb,
-				      user_data,
-                                      e_ews_connection_delete_folder_start);
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_delete_folder);
 
 	async_data = g_new0 (EwsAsyncData, 1);
 	g_simple_async_result_set_op_res_gpointer (
 		simple, async_data, (GDestroyNotify) async_data_free);
 
-	ews_connection_queue_request (cnc, msg, NULL, pri, cancellable, simple, cb == ews_sync_reply_cb);
-}
+	e_ews_connection_queue_request (
+		cnc, msg, delete_folder_response_cb,
+		pri, cancellable, simple);
 
+	g_object_unref (simple);
+}
 
 gboolean
-e_ews_connection_delete_folder_finish	(EEwsConnection *cnc,
-					 GAsyncResult *result,
-					 GError **error)
+e_ews_connection_delete_folder_finish (EEwsConnection *cnc,
+                                       GAsyncResult *result,
+                                       GError **error)
 {
 	GSimpleAsyncResult *simple;
 
+	g_return_val_if_fail (cnc != NULL, FALSE);
 	g_return_val_if_fail (
 		g_simple_async_result_is_valid (
-		result, G_OBJECT (cnc), e_ews_connection_delete_folder_start),
+		result, G_OBJECT (cnc), e_ews_connection_delete_folder),
 		FALSE);
 
 	simple = G_SIMPLE_ASYNC_RESULT (result);
@@ -3426,9 +5248,8 @@ e_ews_connection_delete_folder_finish	(E
 	return TRUE;
 }
 
-gboolean
 /**
- * e_ews_connection_delete_folder
+ * e_ews_connection_delete_folder_sync:
  * @cnc:
  * @pri:
  * @folder_id: folder to be deleted
@@ -3437,54 +5258,50 @@ gboolean
  * @cancellable:
  * @error:
  **/
-e_ews_connection_delete_folder	(EEwsConnection *cnc,
-				 gint pri,
-				 const gchar *folder_id,
-				 gboolean is_distinguished_id,
-				 const gchar *delete_type,
-				 GCancellable *cancellable,
-				 GError **error)
+gboolean
+e_ews_connection_delete_folder_sync (EEwsConnection *cnc,
+                                     gint pri,
+                                     const gchar *folder_id,
+                                     gboolean is_distinguished_id,
+                                     const gchar *delete_type,
+                                     GCancellable *cancellable,
+                                     GError **error)
 {
-	EwsSyncData *sync_data;
-	gboolean result;
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
 
-	sync_data = g_new0 (EwsSyncData, 1);
-	sync_data->eflag = e_flag_new ();
+	g_return_val_if_fail (cnc != NULL, FALSE);
 
-	e_ews_connection_delete_folder_start	(cnc, pri, folder_id,
-						 is_distinguished_id,
-						 delete_type,
-						 ews_sync_reply_cb,
-						 cancellable,
-						 (gpointer) sync_data);
+	closure = e_async_closure_new ();
 
-	e_flag_wait (sync_data->eflag);
+	e_ews_connection_delete_folder (
+		cnc, pri, folder_id,
+		is_distinguished_id,
+		delete_type,
+		cancellable,
+		e_async_closure_callback, closure);
 
-	result = e_ews_connection_delete_folder_finish (cnc, sync_data->res,
-							error);
+	result = e_async_closure_wait (closure);
 
-	e_flag_free (sync_data->eflag);
-	g_object_unref (sync_data->res);
-	g_free (sync_data);
+	success = e_ews_connection_delete_folder_finish (cnc, result, error);
 
-	return result;
+	e_async_closure_free (closure);
 
+	return success;
 }
 
 static void
-create_attachments_response_cb (ESoapParameter *param,
-				EwsNode *enode)
+ews_handle_create_attachments_param (ESoapParameter *param,
+                                     EwsAsyncData *async_data)
 {
 	/* http://msdn.microsoft.com/en-us/library/aa565877%28v=EXCHG.80%29.aspx */
 	ESoapParameter *subparam, *attspara, *last_relevant = NULL, *attparam;
-	EwsAsyncData *async_data;
-
-	async_data = g_simple_async_result_get_op_res_gpointer (enode->simple);
 
 	attspara = e_soap_parameter_get_first_child_by_name (param, "Attachments");
 
 	for (subparam = e_soap_parameter_get_first_child (attspara); subparam != NULL; subparam = e_soap_parameter_get_next_child (subparam)) {
-		if (!g_ascii_strcasecmp (e_soap_parameter_get_name(subparam), "FileAttachment")) {
+		if (!g_ascii_strcasecmp (e_soap_parameter_get_name (subparam), "FileAttachment")) {
 			attparam = e_soap_parameter_get_first_child (subparam);
 			last_relevant = attparam;
 
@@ -3498,15 +5315,56 @@ create_attachments_response_cb (ESoapPar
 }
 
 static void
+create_attachments_response_cb (ESoapResponse *response,
+                                GSimpleAsyncResult *simple)
+{
+	EwsAsyncData *async_data;
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	GError *error = NULL;
+
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessages", &error);
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	subparam = e_soap_parameter_get_first_child (param);
+
+	while (subparam != NULL) {
+		const gchar *name = (const gchar *) subparam->name;
+
+		if (!ews_get_response_status (subparam, &error)) {
+			g_simple_async_result_take_error (simple, error);
+			return;
+		}
+
+		if (CHECK_ELEMENT (name, "CreateAttachmentResponseMessage"))
+			ews_handle_create_attachments_param (subparam, async_data);
+
+		subparam = e_soap_parameter_get_next_child (subparam);
+	}
+}
+
+static void
 e_ews_connection_attach_file (ESoapMessage *msg,
-				const char *uri)
+                              const gchar *uri)
 {
 	/* TODO - handle a situation where the file isnt accessible/other problem with it */
 	/* TODO - This is a naive implementation that just uploads the whole content into memory, ie very inefficient */
 	struct stat st;
-	char *buffer, *filepath;
-	const char *filename;
-	int fd;
+	gchar *buffer, *filepath;
+	const gchar *filename;
+	gint fd;
 
 	/* convert uri to actual file path */
 	filepath = g_filename_from_uri (uri, NULL, NULL);
@@ -3524,7 +5382,7 @@ e_ews_connection_attach_file (ESoapMessa
 
 	buffer = malloc (st.st_size);
 	if (read (fd, buffer, st.st_size) != st.st_size) {
-		g_warning ("Error reading %u bytes from %s\n", (unsigned int)st.st_size, filepath);
+		g_warning ("Error reading %u bytes from %s\n", (guint) st.st_size, filepath);
 		close (fd);
 		return;
 	}
@@ -3540,35 +5398,37 @@ e_ews_connection_attach_file (ESoapMessa
 
 	e_soap_message_start_element (msg, "Content", NULL, NULL);
 	e_soap_message_write_base64 (msg, buffer, st.st_size);
-	e_soap_message_end_element(msg); /* "Content" */
+	e_soap_message_end_element (msg); /* "Content" */
 
-	e_soap_message_end_element(msg); /* "FileAttachment" */
+	e_soap_message_end_element (msg); /* "FileAttachment" */
 
 	free (filepath);
 	free (buffer);
 }
 
 void
-e_ews_connection_create_attachments_start (EEwsConnection *cnc,
-					   gint pri,
-					   const EwsId *parent,
-					   const GSList *files,
-					   GAsyncReadyCallback cb,
-					   GCancellable *cancellable,
-					   gpointer user_data)
+e_ews_connection_create_attachments (EEwsConnection *cnc,
+                                     gint pri,
+                                     const EwsId *parent,
+                                     const GSList *files,
+                                     GCancellable *cancellable,
+                                     GAsyncReadyCallback callback,
+                                     gpointer user_data)
 {
 	ESoapMessage *msg;
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 	const GSList *l;
 
-	msg = e_ews_message_new_with_header (cnc->priv->uri, "CreateAttachment", NULL, NULL, EWS_EXCHANGE_2007_SP1);
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "CreateAttachment", NULL, NULL, EWS_EXCHANGE_2007_SP1);
 
 	e_soap_message_start_element (msg, "ParentItemId", "messages", NULL);
 	e_soap_message_add_attribute (msg, "Id", parent->id, NULL, NULL);
 	if (parent->change_key)
 		e_soap_message_add_attribute (msg, "ChangeKey", parent->change_key, NULL, NULL);
-	e_soap_message_end_element(msg);
+	e_soap_message_end_element (msg);
 
 	/* start interation over all items to get the attachemnts */
 	e_soap_message_start_element (msg, "Attachments", "messages", NULL);
@@ -3580,33 +5440,36 @@ e_ews_connection_create_attachments_star
 
 	e_ews_message_write_footer (msg);
 
-	simple = g_simple_async_result_new (G_OBJECT (cnc),
-				      cb,
-				      user_data,
-				      e_ews_connection_create_attachments_start);
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_create_attachments);
 
 	async_data = g_new0 (EwsAsyncData, 1);
 	g_simple_async_result_set_op_res_gpointer (
 		simple, async_data, (GDestroyNotify) async_data_free);
 
-	ews_connection_queue_request (cnc, msg, create_attachments_response_cb, pri,
-				      cancellable, simple, cb == ews_sync_reply_cb);
+	e_ews_connection_queue_request (
+		cnc, msg, create_attachments_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
 }
 
 GSList *
 e_ews_connection_create_attachments_finish (EEwsConnection *cnc,
-					    gchar **change_key,
-					    GAsyncResult *result,
-					    GError **error)
+                                            gchar **change_key,
+                                            GAsyncResult *result,
+                                            GError **error)
 {
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 	GSList *ids = NULL;
 
+	g_return_val_if_fail (cnc != NULL, NULL);
 	g_return_val_if_fail (
-			g_simple_async_result_is_valid (
-					result, G_OBJECT (cnc), e_ews_connection_create_attachments_start),
-			NULL);
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (cnc), e_ews_connection_create_attachments),
+		NULL);
 
 	simple = G_SIMPLE_ASYNC_RESULT (result);
 	async_data = g_simple_async_result_get_op_res_gpointer (simple);
@@ -3621,70 +5484,112 @@ e_ews_connection_create_attachments_fini
 }
 
 GSList *
-e_ews_connection_create_attachments (EEwsConnection *cnc,
-				     gint pri,
-				     const EwsId *parent,
-				     const GSList *files,
-				     gchar **change_key,
-				     GCancellable *cancellable,
-				     GError **error)
+e_ews_connection_create_attachments_sync (EEwsConnection *cnc,
+                                          gint pri,
+                                          const EwsId *parent,
+                                          const GSList *files,
+                                          gchar **change_key,
+                                          GCancellable *cancellable,
+                                          GError **error)
 {
-	EwsSyncData *sync_data;
+	EAsyncClosure *closure;
+	GAsyncResult *result;
 	GSList *ids;
 
-	sync_data = g_new0 (EwsSyncData, 1);
-	sync_data->eflag = e_flag_new ();
+	g_return_val_if_fail (cnc != NULL, NULL);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_create_attachments (
+		cnc, pri, parent, files, cancellable,
+		e_async_closure_callback, closure);
 
-	e_ews_connection_create_attachments_start (cnc, pri,
-						 parent,
-						 files,
-						 ews_sync_reply_cb,
-						 cancellable,
-						 (gpointer) sync_data);
-
-	e_flag_wait (sync_data->eflag);
-
-	ids = e_ews_connection_create_attachments_finish (cnc, change_key, sync_data->res,
-							error);
-
-	e_flag_free (sync_data->eflag);
-	g_object_unref (sync_data->res);
-	g_free (sync_data);
+	result = e_async_closure_wait (closure);
+
+	ids = e_ews_connection_create_attachments_finish (
+		cnc, change_key, result, error);
+
+	e_async_closure_free (closure);
 
 	return ids;
 }
 
 /* Delete attachemnts */
 static void
-delete_attachments_response_cb (ESoapParameter *subparam, EwsNode *enode)
+ews_handle_root_item_id_param (ESoapParameter *subparam,
+                               EwsAsyncData *async_data)
 {
 	/* http://msdn.microsoft.com/en-us/library/aa580782%28v=EXCHG.80%29.aspx */
 	ESoapParameter *attspara;
+
+	attspara = e_soap_parameter_get_first_child_by_name (
+		subparam, "RootItemId");
+
+	if (attspara == NULL)
+		return;
+
+	async_data->items = g_slist_append (
+		async_data->items,
+		e_soap_parameter_get_property (attspara, "RootItemChangeKey"));
+}
+
+static void
+delete_attachments_response_cb (ESoapResponse *response,
+                                GSimpleAsyncResult *simple)
+{
 	EwsAsyncData *async_data;
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	GError *error = NULL;
+
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessages", &error);
 
-	async_data = g_simple_async_result_get_op_res_gpointer (enode->simple);
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
 
-	attspara = e_soap_parameter_get_first_child_by_name (subparam, "RootItemId");
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	subparam = e_soap_parameter_get_first_child (param);
+
+	while (subparam != NULL) {
+		const gchar *name = (const gchar *) subparam->name;
 
-	if (!attspara) return;
+		if (!ews_get_response_status (subparam, &error)) {
+			g_simple_async_result_take_error (simple, error);
+			return;
+		}
 
-	async_data->items = g_slist_append (async_data->items, e_soap_parameter_get_property (attspara, "RootItemChangeKey"));
+		if (CHECK_ELEMENT (name, "DeleteAttachmentResponseMessage"))
+			ews_handle_root_item_id_param (subparam, async_data);
+
+		subparam = e_soap_parameter_get_next_child (subparam);
+	}
 }
 
 void
-e_ews_connection_delete_attachments_start (EEwsConnection *cnc,
-					 gint pri,
-					 const GSList *ids,
-					 GAsyncReadyCallback cb,
-					 GCancellable *cancellable,
-					 gpointer user_data)
+e_ews_connection_delete_attachments (EEwsConnection *cnc,
+                                     gint pri,
+                                     const GSList *ids,
+                                     GCancellable *cancellable,
+                                     GAsyncReadyCallback callback,
+                                     gpointer user_data)
 {
 	ESoapMessage *msg;
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 	const GSList *l;
 
-	msg = e_ews_message_new_with_header (cnc->priv->uri, "DeleteAttachment", NULL, NULL, EWS_EXCHANGE_2007_SP1);
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "DeleteAttachment", NULL, NULL, EWS_EXCHANGE_2007_SP1);
 
 	/* start interation over all items to get the attachemnts */
 	e_soap_message_start_element (msg, "AttachmentIds", "messages", NULL);
@@ -3697,32 +5602,35 @@ e_ews_connection_delete_attachments_star
 
 	e_ews_message_write_footer (msg);
 
-	simple = g_simple_async_result_new (G_OBJECT (cnc),
-				      cb,
-				      user_data,
-				      e_ews_connection_delete_attachments_start);
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_delete_attachments);
 
 	async_data = g_new0 (EwsAsyncData, 1);
 	g_simple_async_result_set_op_res_gpointer (
 		simple, async_data, (GDestroyNotify) async_data_free);
 
-	ews_connection_queue_request (cnc, msg, delete_attachments_response_cb, pri,
-				      cancellable, simple, cb == ews_sync_reply_cb);
+	e_ews_connection_queue_request (
+		cnc, msg, delete_attachments_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
 }
 
 GSList *
 e_ews_connection_delete_attachments_finish (EEwsConnection *cnc,
-					 GAsyncResult *result,
-					 GError **error)
+                                            GAsyncResult *result,
+                                            GError **error)
 {
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 	GSList *ids = NULL;
 
+	g_return_val_if_fail (cnc != NULL, NULL);
 	g_return_val_if_fail (
-			g_simple_async_result_is_valid (
-					result, G_OBJECT (cnc), e_ews_connection_delete_attachments_start),
-			NULL);
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (cnc), e_ews_connection_delete_attachments),
+		NULL);
 
 	simple = G_SIMPLE_ASYNC_RESULT (result);
 	async_data = g_simple_async_result_get_op_res_gpointer (simple);
@@ -3736,57 +5644,128 @@ e_ews_connection_delete_attachments_fini
 }
 
 GSList *
-e_ews_connection_delete_attachments (EEwsConnection *cnc,
-				 gint pri,
-				 const GSList *ids,
-				 GCancellable *cancellable,
-				 GError **error)
+e_ews_connection_delete_attachments_sync (EEwsConnection *cnc,
+                                          gint pri,
+                                          const GSList *ids,
+                                          GCancellable *cancellable,
+                                          GError **error)
 {
-	EwsSyncData *sync_data;
+	EAsyncClosure *closure;
+	GAsyncResult *result;
 	GSList *parents;
 
-	sync_data = g_new0 (EwsSyncData, 1);
-	sync_data->eflag = e_flag_new ();
+	g_return_val_if_fail (cnc != NULL, NULL);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_delete_attachments (
+		cnc, pri, ids, cancellable,
+		e_async_closure_callback, closure);
 
-	e_ews_connection_delete_attachments_start (cnc, pri,
-						 ids,
-						 ews_sync_reply_cb,
-						 cancellable,
-						 (gpointer) sync_data);
-
-	e_flag_wait (sync_data->eflag);
-
-	parents = e_ews_connection_delete_attachments_finish (cnc, sync_data->res,
-							error);
-
-	e_flag_free (sync_data->eflag);
-	g_object_unref (sync_data->res);
-	g_free (sync_data);
+	result = e_async_closure_wait (closure);
+
+	parents = e_ews_connection_delete_attachments_finish (
+		cnc, result, error);
+
+	e_async_closure_free (closure);
 
 	return parents;
 }
 
-static void get_attachments_response_cb (ESoapParameter *subparam, EwsNode *enode);
+static void
+ews_handle_attachments_param (ESoapParameter *param,
+                              EwsAsyncData *async_data)
+{
+	ESoapParameter *subparam, *attspara;
+	gchar *uri = NULL, *attach_id = NULL;
+	EEwsItem *item;
+	const gchar *name;
+
+	attspara = e_soap_parameter_get_first_child_by_name (param, "Attachments");
+
+	for (subparam = e_soap_parameter_get_first_child (attspara); subparam != NULL; subparam = e_soap_parameter_get_next_child (subparam)) {
+		name = e_soap_parameter_get_name (subparam);
+
+		if (!g_ascii_strcasecmp (name, "ItemAttachment")) {
+			item = e_ews_item_new_from_soap_parameter (subparam);
+			attach_id = g_strdup (e_ews_item_get_attachment_id (item)->id);
+			uri = e_ews_item_dump_mime_content (item, async_data->directory);
+
+		}
+		else if (!g_ascii_strcasecmp (name, "FileAttachment")) {
+			uri = e_ews_dump_file_attachment_from_soap_parameter (subparam, async_data->directory, async_data->sync_state, &attach_id);
+		}
+		if (uri && attach_id) {
+			async_data->items = g_slist_append (async_data->items, uri);
+			async_data->items_created = g_slist_append (async_data->items_created, attach_id);
+			uri = NULL;
+			attach_id = NULL;
+		}
+	}
+}
+
+static void
+get_attachments_response_cb (ESoapResponse *response,
+                             GSimpleAsyncResult *simple)
+{
+	EwsAsyncData *async_data;
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	GError *error = NULL;
+
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessages", &error);
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	subparam = e_soap_parameter_get_first_child (param);
+
+	while (subparam != NULL) {
+		const gchar *name = (const gchar *) subparam->name;
+
+		if (!ews_get_response_status (subparam, &error)) {
+			g_simple_async_result_take_error (simple, error);
+			return;
+		}
+
+		if (CHECK_ELEMENT (name, "GetAttachmentResponseMessage"))
+			ews_handle_attachments_param (subparam, async_data);
+
+		subparam = e_soap_parameter_get_next_child (subparam);
+	}
+}
 
 void
-e_ews_connection_get_attachments_start	(EEwsConnection *cnc,
-					 gint pri,
-					 const gchar *uid,
-					 const GSList *ids,
-					 const gchar *cache,
-					 gboolean include_mime,
-					 GAsyncReadyCallback cb,
-					 ESoapProgressFn progress_fn,
-					 gpointer progress_data,
-					 GCancellable *cancellable,
-					 gpointer user_data)
+e_ews_connection_get_attachments (EEwsConnection *cnc,
+                                  gint pri,
+                                  const gchar *uid,
+                                  const GSList *ids,
+                                  const gchar *cache,
+                                  gboolean include_mime,
+                                  ESoapProgressFn progress_fn,
+                                  gpointer progress_data,
+                                  GCancellable *cancellable,
+                                  GAsyncReadyCallback callback,
+                                  gpointer user_data)
 {
 	ESoapMessage *msg;
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 	const GSList *l;
 
-	msg = e_ews_message_new_with_header (cnc->priv->uri, "GetAttachment", NULL, NULL, EWS_EXCHANGE_2007_SP1);
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "GetAttachment", NULL, NULL, EWS_EXCHANGE_2007_SP1);
 
 	/* not sure why I need it, need to check */
 	if (progress_fn && progress_data)
@@ -3798,7 +5777,7 @@ e_ews_connection_get_attachments_start	(
 	/* wrtie empty attachments shape, need to discover maybe usefull in some cases*/
 	e_soap_message_start_element (msg, "AttachmentShape", "messages", NULL);
 	e_ews_message_write_string_parameter (msg, "IncludeMimeContent", NULL, "true");
-	e_soap_message_end_element(msg);
+	e_soap_message_end_element (msg);
 
 	/* start interation over all items to get the attachemnts */
 	e_soap_message_start_element (msg, "AttachmentIds", "messages", NULL);
@@ -3810,34 +5789,37 @@ e_ews_connection_get_attachments_start	(
 
 	e_ews_message_write_footer (msg);
 
-	simple = g_simple_async_result_new (G_OBJECT (cnc),
-				      cb,
-				      user_data,
-				      e_ews_connection_get_attachments_start);
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_get_attachments);
 
 	async_data = g_new0 (EwsAsyncData, 1);
 	async_data->directory = cache;
-	async_data->sync_state = (gchar *)uid;
+	async_data->sync_state = (gchar *) uid;
 	g_simple_async_result_set_op_res_gpointer (
 		simple, async_data, (GDestroyNotify) async_data_free);
 
-	ews_connection_queue_request (cnc, msg, get_attachments_response_cb, pri,
-				      cancellable, simple, cb == ews_sync_reply_cb);
+	e_ews_connection_queue_request (
+		cnc, msg, get_attachments_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
 }
 
 GSList *
-e_ews_connection_get_attachments_finish(EEwsConnection *cnc,
-					 GAsyncResult *result,
-					 GSList **items,
-					 GError **error)
+e_ews_connection_get_attachments_finish (EEwsConnection *cnc,
+                                         GAsyncResult *result,
+                                         GSList **items,
+                                         GError **error)
 {
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 
+	g_return_val_if_fail (cnc != NULL, NULL);
 	g_return_val_if_fail (
-			g_simple_async_result_is_valid (
-					result, G_OBJECT (cnc), e_ews_connection_get_attachments_start),
-			NULL);
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (cnc), e_ews_connection_get_attachments),
+		NULL);
 
 	simple = G_SIMPLE_ASYNC_RESULT (result);
 	async_data = g_simple_async_result_get_op_res_gpointer (simple);
@@ -3851,91 +5833,54 @@ e_ews_connection_get_attachments_finish(
 }
 
 GSList *
-e_ews_connection_get_attachments(EEwsConnection *cnc,
-				 gint pri,
-				 const gchar *uid,
-				 GSList *ids,
-				 const gchar *cache,
-				 gboolean include_mime,
-				 GSList **items,
-				 ESoapProgressFn progress_fn,
-				 gpointer progress_data,
-				 GCancellable *cancellable,
-				 GError **error)
+e_ews_connection_get_attachments_sync (EEwsConnection *cnc,
+                                       gint pri,
+                                       const gchar *uid,
+                                       const GSList *ids,
+                                       const gchar *cache,
+                                       gboolean include_mime,
+                                       GSList **items,
+                                       ESoapProgressFn progress_fn,
+                                       gpointer progress_data,
+                                       GCancellable *cancellable,
+                                       GError **error)
 {
-	EwsSyncData *sync_data;
+	EAsyncClosure *closure;
+	GAsyncResult *result;
 	GSList *attachments_ids;
 
-	sync_data = g_new0 (EwsSyncData, 1);
-	sync_data->eflag = e_flag_new ();
-
-	e_ews_connection_get_attachments_start	(cnc,pri,uid,ids,cache,include_mime,
-						 ews_sync_reply_cb,
-						 progress_fn, progress_data,
-						 cancellable,
-						 (gpointer) sync_data);
-
-	e_flag_wait (sync_data->eflag);
-
-	attachments_ids = e_ews_connection_get_attachments_finish(cnc,
-						    sync_data->res,
-						    items,
-						    error);
-
-	e_flag_free (sync_data->eflag);
-	g_object_unref (sync_data->res);
-	g_free (sync_data);
+	g_return_val_if_fail (cnc != NULL, NULL);
 
-	return attachments_ids;
-}
-
-static void
-get_attachments_response_cb (ESoapParameter *param, EwsNode *enode)
-{
-	ESoapParameter *subparam, *attspara;
-	EwsAsyncData *async_data;
-	gchar *uri = NULL, *attach_id = NULL;
-	EEwsItem *item;
-	const gchar *name;
+	closure = e_async_closure_new ();
 
-	async_data = g_simple_async_result_get_op_res_gpointer (enode->simple);
+	e_ews_connection_get_attachments (
+		cnc, pri, uid, ids, cache, include_mime,
+		progress_fn, progress_data, cancellable,
+		e_async_closure_callback, closure);
 
-	attspara = e_soap_parameter_get_first_child_by_name (param, "Attachments");
+	result = e_async_closure_wait (closure);
 
-	for (subparam = e_soap_parameter_get_first_child (attspara); subparam != NULL; subparam = e_soap_parameter_get_next_child (subparam)) {
-		name = e_soap_parameter_get_name(subparam);
+	attachments_ids = e_ews_connection_get_attachments_finish (
+		cnc, result, items, error);
 
-		if (!g_ascii_strcasecmp (name, "ItemAttachment")) {
-			item = e_ews_item_new_from_soap_parameter(subparam);
-			attach_id = g_strdup (e_ews_item_get_attachment_id (item)->id);
-			uri = e_ews_item_dump_mime_content(item, async_data->directory);
+	e_async_closure_free (closure);
 
-		}
-		else if (!g_ascii_strcasecmp (name, "FileAttachment")) {
-			uri = e_ews_dump_file_attachment_from_soap_parameter(subparam, async_data->directory, async_data->sync_state, &attach_id);
-		}
-		if (uri && attach_id) {
-			async_data->items = g_slist_append (async_data->items, uri);
-			async_data->items_created = g_slist_append (async_data->items_created, attach_id);
-			uri = NULL;
-			attach_id = NULL;
-		}
-	}
+	return attachments_ids;
 }
 
 static void
-get_free_busy_response_cb (ESoapParameter *param, EwsNode *enode)
+ews_handle_free_busy_view (ESoapParameter *param,
+                           EwsAsyncData *async_data)
 {
        /*parse the response to create a free_busy data
-        http://msdn.microsoft.com/en-us/library/aa564001%28v=EXCHG.140%29.aspx*/
+	http://msdn.microsoft.com / en - us / library / aa564001 % 28v = EXCHG.140 % 29.aspx */
 	icalcomponent *vfb;
 	icalproperty *icalprop = NULL;
 	struct icalperiodtype ipt;
 	ESoapParameter *viewparam, *eventarray, *event_param, *subparam;
 	GTimeVal t_val;
 	const gchar *name;
-	gchar *value;
-	EwsAsyncData *async_data = g_simple_async_result_get_op_res_gpointer (enode->simple);
+	gchar *value, *new_val = NULL, *summary = NULL, *location = NULL;
 
 	viewparam = e_soap_parameter_get_first_child_by_name (param, "FreeBusyView");
 	if (!viewparam) return;
@@ -3947,17 +5892,41 @@ get_free_busy_response_cb (ESoapParamete
 
 			if (!g_ascii_strcasecmp (name, "StartTime")) {
 				value = e_soap_parameter_get_string_value (subparam);
-				g_time_val_from_iso8601 (value, &t_val);
-				g_free (value);
+				/*We are sending UTC timezone and expect server to return in same*/
+
+				/*Remove leading and trailing whitespace*/
+				g_strstrip (value);
 
-				ipt.start = icaltime_from_timet (t_val.tv_sec, 0);
+				if (g_utf8_strlen (value, -1) == 19) {
+					/*If server returns time without zone add Z to treat it in UTC*/
+					new_val = g_strdup_printf ("%sZ", value);
+					g_free (value);
+				} else
+					new_val = value;
+
+				g_time_val_from_iso8601 (new_val, &t_val);
+				g_free (new_val);
+
+				ipt.start = icaltime_from_timet_with_zone (t_val.tv_sec, 0, NULL);
 
 			} else if (!g_ascii_strcasecmp (name, "EndTime")) {
 				value = e_soap_parameter_get_string_value (subparam);
-				g_time_val_from_iso8601 (value, &t_val);
-				g_free (value);
+				/*We are sending UTC timezone and expect server to return in same*/
+
+				/*Remove leading and trailing whitespace*/
+				g_strstrip (value);
 
-				ipt.end = icaltime_from_timet (t_val.tv_sec, 0);
+				if (g_utf8_strlen (value, -1) == 19) {
+					/*If server returns time without zone add Z to treat it in UTC*/
+					new_val = g_strdup_printf ("%sZ", value);
+					g_free (value);
+				} else
+					new_val = value;
+
+				g_time_val_from_iso8601 (new_val, &t_val);
+				g_free (new_val);
+
+				ipt.end = icaltime_from_timet_with_zone (t_val.tv_sec, 0, NULL);
 
 				icalprop = icalproperty_new_freebusy (ipt);
 			} else if (!g_ascii_strcasecmp (name, "BusyType")) {
@@ -3971,60 +5940,131 @@ get_free_busy_response_cb (ESoapParamete
 				else if (!strcmp (value, "Free"))
 					icalproperty_set_parameter_from_string (icalprop, "FBTYPE", "FREE");
 				g_free (value);
+			} else if (!g_ascii_strcasecmp (name, "CalendarEventDetails")) {
+				ESoapParameter *dparam;
+
+				dparam = e_soap_parameter_get_first_child_by_name (subparam, "Subject");
+				if (dparam)
+					summary = e_soap_parameter_get_string_value (dparam);
+
+				dparam = e_soap_parameter_get_first_child_by_name (subparam, "Location");
+				if (dparam)
+					location = e_soap_parameter_get_string_value (dparam);
 			}
 		}
-		if (icalprop != NULL) icalcomponent_add_property(vfb, icalprop);
+		if (icalprop != NULL) {
+			if (summary)
+				icalproperty_set_parameter_from_string (icalprop, "X-SUMMARY", summary);
+			if (location)
+				icalproperty_set_parameter_from_string (icalprop, "X-LOCATION", location);
+			icalcomponent_add_property (vfb, icalprop);
+		}
+
+		g_free (summary);
+		g_free (location);
+		summary = NULL;
+		location = NULL;
 	}
 
 	async_data->items = g_slist_append (async_data->items, vfb);
 }
 
+static void
+get_free_busy_response_cb (ESoapResponse *response,
+                           GSimpleAsyncResult *simple)
+{
+	EwsAsyncData *async_data;
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	GError *error = NULL;
+
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "FreeBusyResponseArray", &error);
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	subparam = e_soap_parameter_get_first_child (param);
+
+	while (subparam != NULL) {
+		ESoapParameter *subsubparam;
+
+		subsubparam = e_soap_parameter_get_first_child_by_name (
+			subparam, "ResponseMessage");
+
+		if (subsubparam) {
+			if (!ews_get_response_status (subsubparam, &error)) {
+				g_simple_async_result_take_error (simple, error);
+				return;
+			}
+
+			ews_handle_free_busy_view (subparam, async_data);
+		}
+
+		subparam = e_soap_parameter_get_next_child (subparam);
+	}
+}
+
 void
-e_ews_connection_get_free_busy_start (EEwsConnection *cnc,
-				      gint pri,
-				      EEwsRequestCreationCallback free_busy_cb,
-				      gpointer free_busy_user_data,
-				      GAsyncReadyCallback cb,
-				      GCancellable *cancellable,
-				      gpointer user_data)
+e_ews_connection_get_free_busy (EEwsConnection *cnc,
+                                gint pri,
+                                EEwsRequestCreationCallback free_busy_cb,
+                                gpointer free_busy_user_data,
+                                GCancellable *cancellable,
+                                GAsyncReadyCallback callback,
+                                gpointer user_data)
 {
 	ESoapMessage *msg;
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 
-	msg = e_ews_message_new_with_header (cnc->priv->uri, "GetUserAvailabilityRequest",
-					     NULL, NULL, EWS_EXCHANGE_2007_SP1);
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "GetUserAvailabilityRequest",
+		NULL, NULL, EWS_EXCHANGE_2007_SP1);
 
 	free_busy_cb (msg, free_busy_user_data);
 
 	e_ews_message_write_footer (msg); /*GetUserAvailabilityRequest  */
 
-	simple = g_simple_async_result_new (G_OBJECT (cnc),
-					    cb,
-					    user_data,
-					    e_ews_connection_get_free_busy_start);
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_get_free_busy);
 
 	async_data = g_new0 (EwsAsyncData, 1);
 	g_simple_async_result_set_op_res_gpointer (
-						   simple, async_data, (GDestroyNotify) async_data_free);
+		simple, async_data, (GDestroyNotify) async_data_free);
 
-	ews_connection_queue_request (cnc, msg, get_free_busy_response_cb, pri,
-				      cancellable, simple, cb == ews_sync_reply_cb);
+	e_ews_connection_queue_request (
+		cnc, msg, get_free_busy_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
 }
 
 gboolean
 e_ews_connection_get_free_busy_finish (EEwsConnection *cnc,
-				       GAsyncResult *result,
-				       GSList **free_busy,
-				       GError **error)
+                                       GAsyncResult *result,
+                                       GSList **free_busy,
+                                       GError **error)
 {
 	GSimpleAsyncResult *simple;
 	EwsAsyncData *async_data;
 
+	g_return_val_if_fail (cnc != NULL, FALSE);
 	g_return_val_if_fail (
-			      g_simple_async_result_is_valid (
-							      result, G_OBJECT (cnc), e_ews_connection_get_free_busy_start),
-			      FALSE);
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (cnc), e_ews_connection_get_free_busy),
+		FALSE);
 
 	simple = G_SIMPLE_ASYNC_RESULT (result);
 	async_data = g_simple_async_result_get_op_res_gpointer (simple);
@@ -4037,33 +6077,1589 @@ e_ews_connection_get_free_busy_finish (E
 }
 
 gboolean
-e_ews_connection_get_free_busy (EEwsConnection *cnc,
-				gint pri,
-				EEwsRequestCreationCallback free_busy_cb,
-				gpointer free_busy_user_data,
-				GSList **free_busy,
-				GCancellable *cancellable,
-				GError **error)
+e_ews_connection_get_free_busy_sync (EEwsConnection *cnc,
+                                     gint pri,
+                                     EEwsRequestCreationCallback free_busy_cb,
+                                     gpointer free_busy_user_data,
+                                     GSList **free_busy,
+                                     GCancellable *cancellable,
+                                     GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_get_free_busy (
+		cnc, pri, free_busy_cb,
+		free_busy_user_data, cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_connection_get_free_busy_finish (
+		cnc, result, free_busy, error);
+
+	e_async_closure_free (closure);
+
+	return success;
+}
+
+static EwsPermissionLevel
+get_permission_from_string (const gchar *permission)
+{
+	g_return_val_if_fail (permission != NULL, EwsPermissionLevel_Unknown);
+
+	if (!g_ascii_strcasecmp (permission, "Editor"))
+		return EwsPermissionLevel_Editor;
+	else if (!g_ascii_strcasecmp (permission, "Author"))
+		return EwsPermissionLevel_Author;
+	else if (!g_ascii_strcasecmp (permission, "Reviewer"))
+		return EwsPermissionLevel_Reviewer;
+	else if (!g_ascii_strcasecmp (permission, "Custom"))
+		return EwsPermissionLevel_Custom;
+	else
+		return EwsPermissionLevel_None;
+
+}
+
+static void
+ews_handle_delegate_user_param (ESoapParameter *param,
+                                EwsAsyncData *async_data)
+{
+	ESoapParameter *subparam, *node, *child;
+	EwsDelegateInfo *data;
+	gchar *value;
+
+	node = e_soap_parameter_get_first_child_by_name (param, "DelegateUser");
+	if (!node)
+		return;
+
+	subparam = e_soap_parameter_get_first_child_by_name (node, "UserId");
+	if (!subparam)
+		return;
+
+	data = g_new0 (EwsDelegateInfo, 1);
+	data->user_id = g_new0 (EwsUserId, 1);
+
+	/*Parse User Id*/
+
+	child = e_soap_parameter_get_first_child_by_name (subparam, "SID");
+	data->user_id->sid = e_soap_parameter_get_string_value (child);
+
+	child = e_soap_parameter_get_first_child_by_name (subparam, "PrimarySmtpAddress");
+	data->user_id->primary_smtp = e_soap_parameter_get_string_value (child);
+
+	child = e_soap_parameter_get_first_child_by_name (subparam, "DisplayName");
+	data->user_id->display_name = e_soap_parameter_get_string_value (child);
+
+	subparam = e_soap_parameter_get_first_child_by_name (node, "DelegatePermissions");
+
+	/*Parse Delegate Permissions*/
+	child = e_soap_parameter_get_first_child_by_name (subparam, "CalendarFolderPermissionLevel");
+	if (child) {
+		value = e_soap_parameter_get_string_value (child);
+		data->calendar = get_permission_from_string (value);
+		g_free (value);
+	}
+
+	child = e_soap_parameter_get_first_child_by_name (subparam, "ContactsFolderPermissionLevel");
+	if (child) {
+		value = e_soap_parameter_get_string_value (child);
+		data->contacts = get_permission_from_string (value);
+		g_free (value);
+	}
+
+	child = e_soap_parameter_get_first_child_by_name (subparam, "InboxFolderPermissionLevel");
+	if (child) {
+		value = e_soap_parameter_get_string_value (child);
+		data->inbox = get_permission_from_string (value);
+		g_free (value);
+	}
+
+	child = e_soap_parameter_get_first_child_by_name (subparam, "TasksFolderPermissionLevel");
+	if (child) {
+		value = e_soap_parameter_get_string_value (child);
+		data->tasks = get_permission_from_string (value);
+		g_free (value);
+	}
+
+	child = e_soap_parameter_get_first_child_by_name (subparam, "NotesFolderPermissionLevel");
+	if (child) {
+		value = e_soap_parameter_get_string_value (child);
+		data->notes = get_permission_from_string (value);
+		g_free (value);
+	}
+
+	child = e_soap_parameter_get_first_child_by_name (subparam, "JournalFolderPermissionLevel");
+	if (child) {
+		value = e_soap_parameter_get_string_value (child);
+		data->journal = get_permission_from_string (value);
+		g_free (value);
+	}
+
+	subparam = e_soap_parameter_get_first_child_by_name (node, "ReceiveCopiesOfMeetingMessages");
+	if (subparam) {
+		value = e_soap_parameter_get_string_value (subparam);
+		data->meetingcopies = g_strcmp0 (value, "true") == 0;
+		g_free (value);
+	}
+
+	subparam = e_soap_parameter_get_first_child_by_name (node, "ViewPrivateItems");
+	if (subparam) {
+		value = e_soap_parameter_get_string_value (subparam);
+		data->view_priv_items = g_strcmp0 (value, "true") == 0;
+		g_free (value);
+	}
+
+	async_data->items = g_slist_append (async_data->items, data);
+}
+
+static void
+get_delegate_response_cb (ESoapResponse *response,
+                          GSimpleAsyncResult *simple)
+{
+	EwsAsyncData *async_data;
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	gchar *value;
+	GError *error = NULL;
+
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	if (ews_get_response_status (e_soap_response_get_parameter (response), &error))
+		param = e_soap_response_get_first_parameter_by_name (
+			response, "DeliverMeetingRequests", &error);
+	else
+		param = NULL;
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	value = e_soap_parameter_get_string_value (param);
+	if (g_strcmp0 (value, "DelegatesOnly") == 0)
+		async_data->deliver_to = EwsDelegateDeliver_DelegatesOnly;
+	else if (g_strcmp0 (value, "DelegatesAndMe") == 0)
+		async_data->deliver_to = EwsDelegateDeliver_DelegatesAndMe;
+	else if (g_strcmp0 (value, "DelegatesAndSendInformationToMe") == 0)
+		async_data->deliver_to = EwsDelegateDeliver_DelegatesAndSendInformationToMe;
+	else {
+		g_message ("%s: Unknown deliver-to value '%s'", G_STRFUNC, value ? value : "[null]");
+		async_data->deliver_to = EwsDelegateDeliver_DelegatesAndSendInformationToMe;
+	}
+	g_free (value);
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessages", NULL);
+	/* it's OK to not have set any delegate */
+	if (!param)
+		return;
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	subparam = e_soap_parameter_get_first_child (param);
+
+	while (subparam != NULL) {
+		const gchar *name = (const gchar *) subparam->name;
+
+		if (!ews_get_response_status (subparam, &error)) {
+			g_simple_async_result_take_error (simple, error);
+			return;
+		}
+
+		if (CHECK_ELEMENT (name, "DelegateUserResponseMessageType"))
+			ews_handle_delegate_user_param (subparam, async_data);
+
+		subparam = e_soap_parameter_get_next_child (subparam);
+	}
+}
+
+void
+e_ews_connection_get_delegate (EEwsConnection *cnc,
+                               gint pri,
+                               const gchar *mail_id,
+                               gboolean include_permissions,
+                               GCancellable *cancellable,
+                               GAsyncReadyCallback callback,
+                               gpointer user_data)
 {
-	EwsSyncData *sync_data;
-	gboolean result;
+	ESoapMessage *msg;
+	GSimpleAsyncResult *simple;
+	EwsAsyncData *async_data;
+
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "GetDelegate", "IncludePermissions", include_permissions ? "true" : "false", EWS_EXCHANGE_2007_SP1);
+
+	e_soap_message_start_element (msg, "Mailbox", "messages", NULL);
+
+	e_ews_message_write_string_parameter (msg, "EmailAddress", NULL, mail_id ? mail_id : cnc->priv->email);
+
+	e_soap_message_end_element (msg);
+
+	e_ews_message_write_footer (msg);
+
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_get_delegate);
+
+	async_data = g_new0 (EwsAsyncData, 1);
+	g_simple_async_result_set_op_res_gpointer (
+		simple, async_data, (GDestroyNotify) async_data_free);
+
+	e_ews_connection_queue_request (
+		cnc, msg, get_delegate_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
+}
+
+gboolean
+e_ews_connection_get_delegate_finish (EEwsConnection *cnc,
+                                      GAsyncResult *result,
+                                      EwsDelegateDeliver *deliver_to,
+                                      GSList **delegates, /* EwsDelegateInfo * */
+                                      GError **error)
+{
+	GSimpleAsyncResult *simple;
+	EwsAsyncData *async_data;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+	g_return_val_if_fail (delegates != NULL, FALSE);
+	g_return_val_if_fail (deliver_to != NULL, FALSE);
+	g_return_val_if_fail (
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (cnc), e_ews_connection_get_delegate),
+		FALSE);
+
+	simple = G_SIMPLE_ASYNC_RESULT (result);
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	if (g_simple_async_result_propagate_error (simple, error))
+		return FALSE;
+
+	*deliver_to = async_data->deliver_to;
+	*delegates = async_data->items;
+	async_data->items = NULL;
+
+	return TRUE;
+}
+
+gboolean
+e_ews_connection_get_delegate_sync (EEwsConnection *cnc,
+                                    gint pri,
+                                    const gchar *mail_id,
+                                    gboolean include_permissions,
+                                    EwsDelegateDeliver *deliver_to,
+                                    GSList **delegates, /* EwsDelegateInfo * */
+                                    GCancellable *cancellable,
+                                    GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (E_IS_EWS_CONNECTION (cnc), FALSE);
+	g_return_val_if_fail (deliver_to != NULL, FALSE);
+	g_return_val_if_fail (delegates != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_get_delegate (
+		cnc, pri, mail_id,
+		include_permissions, cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_connection_get_delegate_finish (
+		cnc, result, deliver_to, delegates, error);
+
+	e_async_closure_free (closure);
+
+	return success;
+}
+
+static void
+update_delegate_response_cb (ESoapResponse *response,
+                             GSimpleAsyncResult *simple)
+{
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	GError *error = NULL;
+
+	if (ews_get_response_status (e_soap_response_get_parameter (response), &error)) {
+		param = e_soap_response_get_first_parameter_by_name (
+			response, "ResponseMessages", NULL);
+		/* that's OK to not receive any ResponseMessages here */
+		if (!param)
+			return;
+	} else
+		param = NULL;
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	subparam = e_soap_parameter_get_first_child (param);
+
+	while (subparam != NULL) {
+		if (!ews_get_response_status (subparam, &error)) {
+			g_simple_async_result_take_error (simple, error);
+			return;
+		}
+
+		subparam = e_soap_parameter_get_next_child (param);
+	}
+}
+
+static void
+set_delegate_permission (ESoapMessage *msg,
+                         const gchar *elem_name,
+                         EwsPermissionLevel perm_level)
+{
+	const gchar *level_name = NULL;
+
+	if (perm_level == EwsPermissionLevel_None)
+		level_name = "None";
+	else if (perm_level == EwsPermissionLevel_Reviewer)
+		level_name = "Reviewer";
+	else if (perm_level == EwsPermissionLevel_Author)
+		level_name = "Author";
+	else if (perm_level == EwsPermissionLevel_Editor)
+		level_name = "Editor";
+
+	if (!level_name)
+		return;
+
+	e_ews_message_write_string_parameter (msg, elem_name, NULL, level_name);
+}
+
+void
+e_ews_connection_add_delegate (EEwsConnection *cnc,
+                               gint pri,
+                               const gchar *mail_id,
+                               const GSList *delegates, /* EwsDelegateInfo * */
+                               GCancellable *cancellable,
+                               GAsyncReadyCallback callback,
+                               gpointer user_data)
+{
+	ESoapMessage *msg;
+	GSimpleAsyncResult *simple;
+	EwsAsyncData *async_data;
+	const GSList *iter;
+
+	g_return_if_fail (cnc != NULL);
+	g_return_if_fail (delegates != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "AddDelegate", NULL, NULL, EWS_EXCHANGE_2007_SP1);
+
+	e_soap_message_start_element (msg, "Mailbox", "messages", NULL);
+	e_ews_message_write_string_parameter (msg, "EmailAddress", NULL, mail_id ? mail_id : cnc->priv->email);
+	e_soap_message_end_element (msg);
+
+	e_soap_message_start_element (msg, "DelegateUsers", "messages", NULL);
+	for (iter = delegates; iter; iter = iter->next) {
+		const EwsDelegateInfo *di = iter->data;
+
+		if (!di)
+			continue;
+
+		e_soap_message_start_element (msg, "DelegateUser", NULL, NULL);
+
+		e_soap_message_start_element (msg, "UserId", NULL, NULL);
+		e_ews_message_write_string_parameter (msg, "PrimarySmtpAddress", NULL, di->user_id->primary_smtp);
+		e_soap_message_end_element (msg); /* UserId */
+
+		e_soap_message_start_element (msg, "DelegatePermissions", NULL, NULL);
+		set_delegate_permission (msg, "CalendarFolderPermissionLevel", di->calendar);
+		set_delegate_permission (msg, "TasksFolderPermissionLevel", di->tasks);
+		set_delegate_permission (msg, "InboxFolderPermissionLevel", di->inbox);
+		set_delegate_permission (msg, "ContactsFolderPermissionLevel", di->contacts);
+		set_delegate_permission (msg, "NotesFolderPermissionLevel", di->notes);
+		set_delegate_permission (msg, "JournalFolderPermissionLevel", di->journal);
+		e_soap_message_end_element (msg); /* DelegatePermissions */
+
+		e_ews_message_write_string_parameter (
+			msg, "ReceiveCopiesOfMeetingMessages", NULL,
+			di->meetingcopies ? "true" : "false");
+		e_ews_message_write_string_parameter (
+			msg, "ViewPrivateItems", NULL,
+			di->view_priv_items ? "true" : "false");
+
+		e_soap_message_end_element (msg); /* DelegateUser */
+	}
+
+	e_soap_message_end_element (msg); /* DelegateUsers */
+
+	e_ews_message_write_footer (msg);
+
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_add_delegate);
+
+	async_data = g_new0 (EwsAsyncData, 1);
+	g_simple_async_result_set_op_res_gpointer (
+		simple, async_data, (GDestroyNotify) async_data_free);
+
+	e_ews_connection_queue_request (
+		cnc, msg, update_delegate_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
+}
+
+gboolean
+e_ews_connection_add_delegate_finish (EEwsConnection *cnc,
+                                      GAsyncResult *result,
+                                      GError **error)
+{
+	GSimpleAsyncResult *simple;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+	g_return_val_if_fail (
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (cnc), e_ews_connection_add_delegate),
+		FALSE);
+
+	simple = G_SIMPLE_ASYNC_RESULT (result);
+
+	return !g_simple_async_result_propagate_error (simple, error);
+}
+
+gboolean
+e_ews_connection_add_delegate_sync (EEwsConnection *cnc,
+                                    gint pri,
+                                    const gchar *mail_id,
+                                    const GSList *delegates, /* EwsDelegateInfo * */
+                                    GCancellable *cancellable,
+                                    GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (E_IS_EWS_CONNECTION (cnc), FALSE);
+	g_return_val_if_fail (delegates != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_add_delegate (
+		cnc, pri, mail_id, delegates, cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_connection_add_delegate_finish (cnc, result, error);
+
+	e_async_closure_free (closure);
+
+	return success;
+}
+
+void
+e_ews_connection_remove_delegate (EEwsConnection *cnc,
+                                  gint pri,
+                                  const gchar *mail_id,
+                                  const GSList *delegate_ids, /* EwsUserId * */
+                                  GCancellable *cancellable,
+                                  GAsyncReadyCallback callback,
+                                  gpointer user_data)
+{
+	ESoapMessage *msg;
+	GSimpleAsyncResult *simple;
+	EwsAsyncData *async_data;
+	const GSList *iter;
+
+	g_return_if_fail (cnc != NULL);
+	g_return_if_fail (delegate_ids != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "RemoveDelegate", NULL, NULL, EWS_EXCHANGE_2007_SP1);
+
+	e_soap_message_start_element (msg, "Mailbox", "messages", NULL);
+	e_ews_message_write_string_parameter (msg, "EmailAddress", NULL, mail_id ? mail_id : cnc->priv->email);
+	e_soap_message_end_element (msg);
+
+	e_soap_message_start_element (msg, "UserIds", "messages", NULL);
+	for (iter = delegate_ids; iter; iter = iter->next) {
+		const EwsUserId *user_id = iter->data;
+
+		if (!user_id)
+			continue;
+
+		e_soap_message_start_element (msg, "UserId", NULL, NULL);
+		e_ews_message_write_string_parameter (msg, "PrimarySmtpAddress", NULL, user_id->primary_smtp);
+		e_soap_message_end_element (msg); /* UserId */
+	}
+
+	e_soap_message_end_element (msg); /* UserIds */
+
+	e_ews_message_write_footer (msg);
+
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_remove_delegate);
+
+	async_data = g_new0 (EwsAsyncData, 1);
+	g_simple_async_result_set_op_res_gpointer (
+		simple, async_data, (GDestroyNotify) async_data_free);
+
+	e_ews_connection_queue_request (
+		cnc, msg, update_delegate_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
+}
+
+gboolean
+e_ews_connection_remove_delegate_finish (EEwsConnection *cnc,
+                                         GAsyncResult *result,
+                                         GError **error)
+{
+	GSimpleAsyncResult *simple;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+	g_return_val_if_fail (
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (cnc), e_ews_connection_remove_delegate),
+		FALSE);
+
+	simple = G_SIMPLE_ASYNC_RESULT (result);
+
+	return !g_simple_async_result_propagate_error (simple, error);
+}
+
+gboolean
+e_ews_connection_remove_delegate_sync (EEwsConnection *cnc,
+                                       gint pri,
+                                       const gchar *mail_id,
+                                       const GSList *delegate_ids, /* EwsUserId * */
+                                       GCancellable *cancellable,
+                                       GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (E_IS_EWS_CONNECTION (cnc), FALSE);
+	g_return_val_if_fail (delegate_ids != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_remove_delegate (
+		cnc, pri, mail_id, delegate_ids, cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_connection_remove_delegate_finish (cnc, result, error);
+
+	e_async_closure_free (closure);
+
+	return success;
+}
+
+void
+e_ews_connection_update_delegate (EEwsConnection *cnc,
+                                  gint pri,
+                                  const gchar *mail_id,
+                                  EwsDelegateDeliver deliver_to,
+                                  const GSList *delegates, /* EwsDelegateInfo * */
+                                  GCancellable *cancellable,
+                                  GAsyncReadyCallback callback,
+                                  gpointer user_data)
+{
+	ESoapMessage *msg;
+	GSimpleAsyncResult *simple;
+	EwsAsyncData *async_data;
+	const GSList *iter;
+
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "UpdateDelegate", NULL, NULL, EWS_EXCHANGE_2007_SP1);
+
+	e_soap_message_start_element (msg, "Mailbox", "messages", NULL);
+	e_ews_message_write_string_parameter (msg, "EmailAddress", NULL, mail_id ? mail_id : cnc->priv->email);
+	e_soap_message_end_element (msg);
+
+	if (delegates) {
+		e_soap_message_start_element (msg, "DelegateUsers", "messages", NULL);
+		for (iter = delegates; iter; iter = iter->next) {
+			const EwsDelegateInfo *di = iter->data;
+
+			if (!di)
+				continue;
+
+			e_soap_message_start_element (msg, "DelegateUser", NULL, NULL);
+
+			e_soap_message_start_element (msg, "UserId", NULL, NULL);
+			e_ews_message_write_string_parameter (msg, "PrimarySmtpAddress", NULL, di->user_id->primary_smtp);
+			e_soap_message_end_element (msg); /* UserId */
+
+			e_soap_message_start_element (msg, "DelegatePermissions", NULL, NULL);
+			set_delegate_permission (msg, "CalendarFolderPermissionLevel", di->calendar);
+			set_delegate_permission (msg, "TasksFolderPermissionLevel", di->tasks);
+			set_delegate_permission (msg, "InboxFolderPermissionLevel", di->inbox);
+			set_delegate_permission (msg, "ContactsFolderPermissionLevel", di->contacts);
+			set_delegate_permission (msg, "NotesFolderPermissionLevel", di->notes);
+			set_delegate_permission (msg, "JournalFolderPermissionLevel", di->journal);
+			e_soap_message_end_element (msg); /* DelegatePermissions */
+
+			e_ews_message_write_string_parameter (
+				msg, "ReceiveCopiesOfMeetingMessages", NULL,
+				di->meetingcopies ? "true" : "false");
+			e_ews_message_write_string_parameter (
+				msg, "ViewPrivateItems", NULL,
+				di->view_priv_items ? "true" : "false");
+
+			e_soap_message_end_element (msg); /* DelegateUser */
+		}
+
+		e_soap_message_end_element (msg); /* DelegateUsers */
+	}
+
+	e_ews_message_write_string_parameter (
+		msg, "DeliverMeetingRequests", "messages",
+		deliver_to == EwsDelegateDeliver_DelegatesOnly ? "DelegatesOnly" :
+		deliver_to == EwsDelegateDeliver_DelegatesAndMe ? "DelegatesAndMe" :
+		"DelegatesAndSendInformationToMe");
+
+	e_ews_message_write_footer (msg);
+
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_update_delegate);
+
+	async_data = g_new0 (EwsAsyncData, 1);
+	g_simple_async_result_set_op_res_gpointer (
+		simple, async_data, (GDestroyNotify) async_data_free);
+
+	e_ews_connection_queue_request (
+		cnc, msg, update_delegate_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
+}
+
+gboolean
+e_ews_connection_update_delegate_finish (EEwsConnection *cnc,
+                                         GAsyncResult *result,
+                                         GError **error)
+{
+	GSimpleAsyncResult *simple;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+	g_return_val_if_fail (
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (cnc), e_ews_connection_update_delegate),
+		FALSE);
+
+	simple = G_SIMPLE_ASYNC_RESULT (result);
+
+	return !g_simple_async_result_propagate_error (simple, error);
+}
+
+gboolean
+e_ews_connection_update_delegate_sync (EEwsConnection *cnc,
+                                       gint pri,
+                                       const gchar *mail_id,
+                                       EwsDelegateDeliver deliver_to,
+                                       const GSList *delegates, /* EwsDelegateInfo * */
+                                       GCancellable *cancellable,
+                                       GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (E_IS_EWS_CONNECTION (cnc), FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_update_delegate (
+		cnc, pri, mail_id, deliver_to, delegates, cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_connection_update_delegate_finish (cnc, result, error);
+
+	e_async_closure_free (closure);
+
+	return success;
+}
+
+static void
+get_folder_permissions_response_cb (ESoapResponse *response,
+                                    GSimpleAsyncResult *simple)
+{
+	EwsAsyncData *async_data;
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	GError *error = NULL;
+
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessages", &error);
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	subparam = e_soap_parameter_get_first_child (param);
+
+	while (subparam != NULL) {
+		const gchar *name = (const gchar *) subparam->name;
+
+		if (!ews_get_response_status (subparam, &error)) {
+			g_simple_async_result_take_error (simple, error);
+			return;
+		}
+
+		if (CHECK_ELEMENT (name, "GetFolderResponseMessage")) {
+			ESoapParameter *node;
+
+			node = e_soap_parameter_get_first_child_by_name (subparam, "Folders");
+			if (node) {
+				subparam = node;
+
+				node = e_soap_parameter_get_first_child (subparam);
+				if (node && node->name && g_str_has_suffix ((const gchar *) node->name, "Folder")) {
+					node = e_soap_parameter_get_first_child_by_name (node, "PermissionSet");
+					if (node) {
+						async_data->items = e_ews_permissions_from_soap_param (node);
+					}
+				}
+			}
+
+			break;
+		}
+
+		subparam = e_soap_parameter_get_next_child (subparam);
+	}
+}
+
+void
+e_ews_connection_get_folder_permissions (EEwsConnection *cnc,
+                                         gint pri,
+                                         EwsFolderId *folder_id,
+                                         GCancellable *cancellable,
+                                         GAsyncReadyCallback callback,
+                                         gpointer user_data)
+{
+	ESoapMessage *msg;
+	GSimpleAsyncResult *simple;
+	EwsAsyncData *async_data;
+
+	g_return_if_fail (cnc != NULL);
+	g_return_if_fail (folder_id != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "GetFolder", NULL, NULL, EWS_EXCHANGE_2007_SP1);
+
+	e_soap_message_start_element (msg, "FolderShape", "messages", NULL);
+	e_ews_message_write_string_parameter (msg, "BaseShape", NULL, "IdOnly");
+	e_soap_message_start_element (msg, "AdditionalProperties", NULL, NULL);
+	e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL, "FieldURI", "folder:PermissionSet");
+	e_soap_message_end_element (msg); /* AdditionalProperties */
+	e_soap_message_end_element (msg); /* FolderShape */
+
+	e_soap_message_start_element (msg, "FolderIds", "messages", NULL);
+	ews_append_folder_id_to_msg (msg, cnc->priv->email, folder_id);
+	e_soap_message_end_element (msg);
+
+	e_ews_message_write_footer (msg);
+
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_get_folder_permissions);
+
+	async_data = g_new0 (EwsAsyncData, 1);
+	g_simple_async_result_set_op_res_gpointer (
+		simple, async_data, (GDestroyNotify) async_data_free);
+
+	e_ews_connection_queue_request (
+		cnc, msg, get_folder_permissions_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
+}
+
+/* free permissions with e_ews_permissions_free() */
+gboolean
+e_ews_connection_get_folder_permissions_finish (EEwsConnection *cnc,
+                                                GAsyncResult *result,
+                                                GSList **permissions,
+                                                GError **error)
+{
+	GSimpleAsyncResult *simple;
+	EwsAsyncData *async_data;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+	g_return_val_if_fail (permissions != NULL, FALSE);
+	g_return_val_if_fail (
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (cnc), e_ews_connection_get_folder_permissions),
+		FALSE);
+
+	simple = G_SIMPLE_ASYNC_RESULT (result);
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	if (g_simple_async_result_propagate_error (simple, error))
+		return FALSE;
+
+	*permissions = async_data->items;
+
+	return TRUE;
+}
+
+/* free permissions with e_ews_permissions_free() */
+gboolean
+e_ews_connection_get_folder_permissions_sync (EEwsConnection *cnc,
+                                              gint pri,
+                                              EwsFolderId *folder_id,
+                                              GSList **permissions,
+                                              GCancellable *cancellable,
+                                              GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (E_IS_EWS_CONNECTION (cnc), FALSE);
+	g_return_val_if_fail (folder_id != NULL, FALSE);
+	g_return_val_if_fail (permissions != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_get_folder_permissions (
+		cnc, pri, folder_id, cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_connection_get_folder_permissions_finish (
+		cnc, result, permissions, error);
+
+	e_async_closure_free (closure);
+
+	return success;
+}
+
+void
+e_ews_connection_set_folder_permissions (EEwsConnection *cnc,
+                                         gint pri,
+                                         EwsFolderId *folder_id,
+                                         EEwsFolderType folder_type,
+                                         const GSList *permissions,
+                                         GCancellable *cancellable,
+                                         GAsyncReadyCallback callback,
+                                         gpointer user_data)
+{
+	ESoapMessage *msg;
+	GSimpleAsyncResult *simple;
+	EwsAsyncData *async_data;
+	const GSList *iter;
+
+	g_return_if_fail (cnc != NULL);
+	g_return_if_fail (folder_id != NULL);
+	g_return_if_fail (permissions != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "UpdateFolder", NULL, NULL, EWS_EXCHANGE_2007_SP1);
+
+	e_soap_message_start_element (msg, "FolderChanges", "messages", NULL);
+	e_ews_message_start_item_change (
+		msg, E_EWS_ITEMCHANGE_TYPE_FOLDER,
+		folder_id->id, folder_id->change_key, 0);
+
+	e_soap_message_start_element (msg, "SetFolderField", NULL, NULL);
+	e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL, "FieldURI", "folder:PermissionSet");
+
+	switch (folder_type) {
+	default:
+	case E_EWS_FOLDER_TYPE_MAILBOX:
+		e_soap_message_start_element (msg, "Folder", NULL, NULL);
+		break;
+	case E_EWS_FOLDER_TYPE_CALENDAR:
+		e_soap_message_start_element (msg, "CalendarFolder", NULL, NULL);
+		break;
+	case E_EWS_FOLDER_TYPE_CONTACTS:
+		e_soap_message_start_element (msg, "ContactsFolder", NULL, NULL);
+		break;
+	case E_EWS_FOLDER_TYPE_SEARCH:
+		e_soap_message_start_element (msg, "SearchFolder", NULL, NULL);
+		break;
+	case E_EWS_FOLDER_TYPE_TASKS:
+		e_soap_message_start_element (msg, "TasksFolder", NULL, NULL);
+		break;
+	}
+
+	e_soap_message_start_element (msg, "PermissionSet", NULL, NULL);
+	if (folder_type == E_EWS_FOLDER_TYPE_CALENDAR)
+		e_soap_message_start_element (msg, "CalendarPermissions", NULL, NULL);
+	else
+		e_soap_message_start_element (msg, "Permissions", NULL, NULL);
+
+	for (iter = permissions; iter; iter = iter->next) {
+		EEwsPermission *perm = iter->data;
+		const gchar *perm_level_name;
+
+		if (!perm)
+			continue;
+
+		if (folder_type == E_EWS_FOLDER_TYPE_CALENDAR)
+			e_soap_message_start_element (msg, "CalendarPermission", NULL, NULL);
+		else
+			e_soap_message_start_element (msg, "Permission", NULL, NULL);
+
+		e_soap_message_start_element (msg, "UserId", NULL, NULL);
+
+		switch (perm->user_type) {
+		case E_EWS_PERMISSION_USER_TYPE_NONE:
+			g_return_if_reached ();
+			break;
+		case E_EWS_PERMISSION_USER_TYPE_ANONYMOUS:
+			e_ews_message_write_string_parameter (msg, "DistinguishedUser", NULL, "Anonymous");
+			break;
+		case E_EWS_PERMISSION_USER_TYPE_DEFAULT:
+			e_ews_message_write_string_parameter (msg, "DistinguishedUser", NULL, "Default");
+			break;
+		case E_EWS_PERMISSION_USER_TYPE_REGULAR:
+			e_ews_message_write_string_parameter (msg, "PrimarySmtpAddress", NULL, perm->primary_smtp);
+			break;
+		}
+
+		e_soap_message_end_element (msg); /* UserId */
+
+		e_ews_permission_rights_to_level_name (perm->rights);
+
+		perm_level_name = e_ews_permission_rights_to_level_name (perm->rights);
+
+		if (g_strcmp0 (perm_level_name, "Custom") == 0) {
+			e_ews_message_write_string_parameter (
+				msg, "CanCreateItems", NULL,
+				(perm->rights & E_EWS_PERMISSION_BIT_CREATE) != 0 ? "true" : "false");
+			e_ews_message_write_string_parameter (
+				msg, "CanCreateSubFolders", NULL,
+				(perm->rights & E_EWS_PERMISSION_BIT_CREATE_SUBFOLDER) != 0 ? "true" : "false");
+			e_ews_message_write_string_parameter (
+				msg, "IsFolderOwner", NULL,
+				(perm->rights & E_EWS_PERMISSION_BIT_FOLDER_OWNER) != 0 ? "true" : "false");
+			e_ews_message_write_string_parameter (
+				msg, "IsFolderVisible", NULL,
+				(perm->rights & E_EWS_PERMISSION_BIT_FOLDER_VISIBLE) != 0 ? "true" : "false");
+			e_ews_message_write_string_parameter (
+				msg, "IsFolderContact", NULL,
+				(perm->rights & E_EWS_PERMISSION_BIT_FOLDER_CONTACT) != 0 ? "true" : "false");
+			e_ews_message_write_string_parameter (
+				msg, "EditItems", NULL,
+				(perm->rights & E_EWS_PERMISSION_BIT_EDIT_ANY) != 0 ? "All" :
+				(perm->rights & E_EWS_PERMISSION_BIT_EDIT_OWNED) != 0 ? "Owned" : "None");
+			e_ews_message_write_string_parameter (
+				msg, "DeleteItems", NULL,
+				(perm->rights & E_EWS_PERMISSION_BIT_DELETE_ANY) != 0 ? "All" :
+				(perm->rights & E_EWS_PERMISSION_BIT_DELETE_OWNED) != 0 ? "Owned" : "None");
+			if (folder_type == E_EWS_FOLDER_TYPE_CALENDAR)
+				e_ews_message_write_string_parameter (
+					msg, "ReadItems", NULL,
+					(perm->rights & E_EWS_PERMISSION_BIT_READ_ANY) != 0 ? "FullDetails" :
+					(perm->rights & E_EWS_PERMISSION_BIT_FREE_BUSY_DETAILED) != 0 ? "TimeAndSubjectAndLocation" :
+					(perm->rights & E_EWS_PERMISSION_BIT_FREE_BUSY_SIMPLE) != 0 ? "TimeOnly" : "None");
+			else
+				e_ews_message_write_string_parameter (
+					msg, "ReadItems", NULL,
+					(perm->rights & E_EWS_PERMISSION_BIT_READ_ANY) != 0 ? "FullDetails" : "None");
+		}
+
+		e_ews_message_write_string_parameter (
+			msg,
+			folder_type == E_EWS_FOLDER_TYPE_CALENDAR ? "CalendarPermissionLevel" : "PermissionLevel", NULL,
+			perm_level_name);
+
+		e_soap_message_end_element (msg); /* Permission/CalendarPermission */
+	}
+
+	e_soap_message_end_element (msg); /* Permissions */
+	e_soap_message_end_element (msg); /* PermissionSet */
+	e_soap_message_end_element (msg); /* Folder/CalendarFolder/... */
+	e_soap_message_end_element (msg); /* SetFolderField */
+
+	e_ews_message_end_item_change (msg);
+
+	e_ews_message_write_footer (msg);
+
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_set_folder_permissions);
+
+	async_data = g_new0 (EwsAsyncData, 1);
+	g_simple_async_result_set_op_res_gpointer (
+		simple, async_data, (GDestroyNotify) async_data_free);
+
+	e_ews_connection_queue_request (
+		cnc, msg, update_folder_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
+}
+
+gboolean
+e_ews_connection_set_folder_permissions_finish (EEwsConnection *cnc,
+                                                GAsyncResult *result,
+                                                GError **error)
+{
+	GSimpleAsyncResult *simple;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+	g_return_val_if_fail (
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (cnc), e_ews_connection_set_folder_permissions),
+		FALSE);
+
+	simple = G_SIMPLE_ASYNC_RESULT (result);
+
+	return !g_simple_async_result_propagate_error (simple, error);
+}
+
+gboolean
+e_ews_connection_set_folder_permissions_sync (EEwsConnection *cnc,
+                                              gint pri,
+                                              EwsFolderId *folder_id,
+                                              EEwsFolderType folder_type,
+                                              const GSList *permissions,
+                                              GCancellable *cancellable,
+                                              GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (E_IS_EWS_CONNECTION (cnc), FALSE);
+	g_return_val_if_fail (folder_id != NULL, FALSE);
+	g_return_val_if_fail (permissions != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_set_folder_permissions (
+		cnc, pri, folder_id, folder_type, permissions, cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_connection_set_folder_permissions_finish (
+		cnc, result, error);
+
+	e_async_closure_free (closure);
+
+	return success;
+}
+
+static void
+get_password_expiration_response_cb (ESoapResponse *response,
+                                     GSimpleAsyncResult *simple)
+{
+	EwsAsyncData *async_data;
+	ESoapParameter *param;
+	gchar *exp_date;
+	GError *error = NULL;
+
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "PasswordExpirationDate", &error);
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	exp_date = e_soap_parameter_get_string_value (param);
+
+	async_data->items = g_slist_append (async_data->items, exp_date);
+}
+
+/**
+ * e_ews_connection_get_password_expiration
+ * @cnc:
+ * @pri:
+ * @mail_id: mail is for which password expiration is requested
+ * @cb:
+ * @cancellable:
+ * @user_data:
+ **/
+void
+e_ews_connection_get_password_expiration (EEwsConnection *cnc,
+                                          gint pri,
+                                          const gchar *mail_id,
+                                          GCancellable *cancellable,
+                                          GAsyncReadyCallback callback,
+                                          gpointer user_data)
+{
+	ESoapMessage *msg;
+	GSimpleAsyncResult *simple;
+	EwsAsyncData *async_data;
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "GetPasswordExpirationDate", NULL, NULL, EWS_EXCHANGE_2010_SP2);
+	e_ews_message_write_string_parameter (msg, "MailboxSmtpAddress", NULL, mail_id ? mail_id : cnc->priv->email);
+	e_ews_message_write_footer (msg);
+
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_get_password_expiration);
+
+	async_data = g_new0 (EwsAsyncData, 1);
+	g_simple_async_result_set_op_res_gpointer (
+		simple, async_data, (GDestroyNotify) async_data_free);
+
+	e_ews_connection_queue_request (
+		cnc, msg, get_password_expiration_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
+}
+
+gboolean
+e_ews_connection_get_password_expiration_finish (EEwsConnection *cnc,
+                                                 GAsyncResult *result,
+                                                 gchar **exp_date,
+                                                 GError **error)
+{
+	GSimpleAsyncResult *simple;
+	EwsAsyncData *async_data;
+
+	g_return_val_if_fail (exp_date != NULL, FALSE);
+	g_return_val_if_fail (
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (cnc), e_ews_connection_get_password_expiration),
+		FALSE);
+
+	simple = G_SIMPLE_ASYNC_RESULT (result);
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	if (g_simple_async_result_propagate_error (simple, error))
+		return FALSE;
+
+	g_return_val_if_fail (async_data->items != NULL, FALSE);
+
+	*exp_date = async_data->items->data;
+	g_slist_free (async_data->items);
+
+	return TRUE;
+}
+
+/**
+ * e_ews_connection_get_password_expiration_sync
+ * @cnc:
+ * @pri:
+ * @mail_id: mail id for which password expiration is requested
+ * @cancellable:
+ * @error:
+ **/
+gboolean
+e_ews_connection_get_password_expiration_sync (EEwsConnection *cnc,
+                                               gint pri,
+                                               const gchar *mail_id,
+                                               gchar **exp_date,
+                                               GCancellable *cancellable,
+                                               GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (E_IS_EWS_CONNECTION (cnc), FALSE);
+	g_return_val_if_fail (exp_date != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_get_password_expiration (
+		cnc, pri, mail_id, cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_connection_get_password_expiration_finish (
+		cnc, result, exp_date, error);
+
+	e_async_closure_free (closure);
+
+	return success;
+}
+
+static void
+get_folder_info_response_cb (ESoapResponse *response,
+                             GSimpleAsyncResult *simple)
+{
+	EwsAsyncData *async_data;
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	GError *error = NULL;
+
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessages", &error);
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	subparam = e_soap_parameter_get_first_child (param);
+
+	while (subparam != NULL) {
+		const gchar *name = (const gchar *) subparam->name;
+
+		if (!ews_get_response_status (subparam, &error)) {
+			g_simple_async_result_take_error (simple, error);
+			return;
+		}
+
+		if (CHECK_ELEMENT (name, "GetFolderResponseMessage")) {
+			ESoapParameter *node;
+
+			node = e_soap_parameter_get_first_child_by_name (subparam, "Folders");
+			if (node) {
+				EEwsFolder *folder = e_ews_folder_new_from_soap_parameter (node);
+
+				if (folder)
+					async_data->items = g_slist_prepend (NULL, folder);
+			}
+
+			break;
+		}
+
+		subparam = e_soap_parameter_get_next_child (subparam);
+	}
+}
+
+void
+e_ews_connection_get_folder_info (EEwsConnection *cnc,
+                                  gint pri,
+                                  const gchar *mail_id,
+                                  const EwsFolderId *folder_id,
+                                  GCancellable *cancellable,
+                                  GAsyncReadyCallback callback,
+                                  gpointer user_data)
+{
+	ESoapMessage *msg;
+	GSimpleAsyncResult *simple;
+	EwsAsyncData *async_data;
+
+	g_return_if_fail (cnc != NULL);
+	g_return_if_fail (folder_id != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "GetFolder", NULL, NULL, EWS_EXCHANGE_2007_SP1);
+
+	e_soap_message_start_element (msg, "FolderShape", "messages", NULL);
+	e_ews_message_write_string_parameter (msg, "BaseShape", NULL, "Default");
+	e_soap_message_start_element (msg, "AdditionalProperties", NULL, NULL);
+	e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL, "FieldURI", "folder:FolderClass");
+	e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL, "FieldURI", "folder:ParentFolderId");
+	e_soap_message_end_element (msg); /* AdditionalProperties */
+	e_soap_message_end_element (msg); /* FolderShape */
+
+	e_soap_message_start_element (msg, "FolderIds", "messages", NULL);
+	ews_append_folder_id_to_msg (msg, mail_id, folder_id);
+	e_soap_message_end_element (msg);
+
+	e_ews_message_write_footer (msg);
+
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_get_folder_info);
+
+	async_data = g_new0 (EwsAsyncData, 1);
+	g_simple_async_result_set_op_res_gpointer (
+		simple, async_data, (GDestroyNotify) async_data_free);
+
+	e_ews_connection_queue_request (
+		cnc, msg, get_folder_info_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
+}
+
+gboolean
+e_ews_connection_get_folder_info_finish (EEwsConnection *cnc,
+                                         GAsyncResult *result,
+                                         EEwsFolder **folder,
+                                         GError **error)
+{
+	GSimpleAsyncResult *simple;
+	EwsAsyncData *async_data;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+	g_return_val_if_fail (folder != NULL, FALSE);
+	g_return_val_if_fail (
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (cnc), e_ews_connection_get_folder_info),
+		FALSE);
+
+	simple = G_SIMPLE_ASYNC_RESULT (result);
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	if (g_simple_async_result_propagate_error (simple, error))
+		return FALSE;
+
+	if (!async_data->items)
+		return FALSE;
+
+	*folder = async_data->items ? async_data->items->data : NULL;
+
+	g_slist_free (async_data->items);
+	async_data->items = NULL;
+
+	return TRUE;
+}
+
+gboolean
+e_ews_connection_get_folder_info_sync (EEwsConnection *cnc,
+                                       gint pri,
+                                       const gchar *mail_id,
+                                       const EwsFolderId *folder_id,
+                                       EEwsFolder **folder,
+                                       GCancellable *cancellable,
+                                       GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (E_IS_EWS_CONNECTION (cnc), FALSE);
+	g_return_val_if_fail (folder_id != NULL, FALSE);
+	g_return_val_if_fail (folder != NULL, FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_connection_get_folder_info (
+		cnc, pri, mail_id, folder_id, cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_connection_get_folder_info_finish (
+		cnc, result, folder, error);
+
+	e_async_closure_free (closure);
+
+	return success;
+}
+
+static void
+ews_handle_root_folder_param_folders (ESoapParameter *subparam,
+				      EwsAsyncData *async_data)
+{
+	ESoapParameter *node, *subparam1;
+	gchar *last, *total;
+	gint total_items;
+	EEwsFolder *folder;
+	gboolean includes_last_item = FALSE;
+
+	node = e_soap_parameter_get_first_child_by_name (subparam, "RootFolder");
+	total = e_soap_parameter_get_property (node, "TotalItemsInView");
+	total_items = atoi (total);
+	g_free (total);
+	last = e_soap_parameter_get_property (node, "IncludesLastItemInRange");
+	if (!strcmp (last, "true"))
+		includes_last_item = TRUE;
+	g_free (last);
+
+	node = e_soap_parameter_get_first_child_by_name (node, "Folders");
+	for (subparam1 = e_soap_parameter_get_first_child (node);
+	     subparam1; subparam1 = e_soap_parameter_get_next_child (subparam1)) {
+		folder = e_ews_folder_new_from_soap_parameter (subparam1);
+		if (!folder) continue;
+		async_data->items = g_slist_append (async_data->items, folder);
+	}
+	async_data->total_items = total_items;
+	async_data->includes_last_item = includes_last_item;
+}
+
+static void
+find_folder_response_cb (ESoapResponse *response,
+			 GSimpleAsyncResult *simple)
+{
+	EwsAsyncData *async_data;
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	GError *error = NULL;
+
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessages", &error);
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	subparam = e_soap_parameter_get_first_child (param);
+
+	while (subparam != NULL) {
+		const gchar *name = (const gchar *) subparam->name;
+
+		if (!ews_get_response_status (subparam, &error)) {
+			g_simple_async_result_take_error (simple, error);
+			return;
+		}
+
+		if (CHECK_ELEMENT (name, "FindFolderResponseMessage"))
+			ews_handle_root_folder_param_folders (subparam, async_data);
+
+		subparam = e_soap_parameter_get_next_child (subparam);
+	}
+}
+
+void
+e_ews_connection_find_folder (EEwsConnection *cnc,
+			      gint pri,
+			      const EwsFolderId *fid,
+			      GCancellable *cancellable,
+			      GAsyncReadyCallback callback,
+			      gpointer user_data)
+{
+	ESoapMessage *msg;
+	GSimpleAsyncResult *simple;
+	EwsAsyncData *async_data;
+
+	g_return_if_fail (cnc != NULL);
+
+	msg = e_ews_message_new_with_header (cnc->priv->uri, cnc->priv->impersonate_user, "FindFolder", "Traversal", "Shallow", EWS_EXCHANGE_2007_SP1);
+	e_soap_message_start_element (msg, "FolderShape", "messages", NULL);
+	e_ews_message_write_string_parameter (msg, "BaseShape", NULL, "Default");
+	e_soap_message_start_element (msg, "AdditionalProperties", NULL, NULL);
+	e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL, "FieldURI", "folder:FolderClass");
+	e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL, "FieldURI", "folder:ChildFolderCount");
+	e_soap_message_end_element (msg); /* AdditionalProperties */
+	e_soap_message_end_element (msg);
+
+	e_soap_message_start_element (msg, "ParentFolderIds", "messages", NULL);
+
+	if (fid->is_distinguished_id)
+		e_ews_message_write_string_parameter_with_attribute (msg, "DistinguishedFolderId", NULL, NULL, "Id", fid->id);
+	else
+		e_ews_message_write_string_parameter_with_attribute (msg, "FolderId", NULL, NULL, "Id", fid->id);
+
+	e_soap_message_end_element (msg);
+
+	/* Complete the footer and print the request */
+	e_ews_message_write_footer (msg);
+
+	simple = g_simple_async_result_new (
+		G_OBJECT (cnc), callback, user_data,
+		e_ews_connection_find_folder);
+
+	async_data = g_new0 (EwsAsyncData, 1);
+	g_simple_async_result_set_op_res_gpointer (
+		simple, async_data, (GDestroyNotify) async_data_free);
+
+	e_ews_connection_queue_request (
+		cnc, msg, find_folder_response_cb,
+		pri, cancellable, simple);
+
+	g_object_unref (simple);
+}
+
+gboolean
+e_ews_connection_find_folder_finish (EEwsConnection *cnc,
+				     GAsyncResult *result,
+				     gboolean *includes_last_item,
+				     GSList **folders,
+				     GError **error)
+{
+	GSimpleAsyncResult *simple;
+	EwsAsyncData *async_data;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
+	g_return_val_if_fail (
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (cnc), e_ews_connection_find_folder),
+		FALSE);
+
+	simple = G_SIMPLE_ASYNC_RESULT (result);
+	async_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	if (g_simple_async_result_propagate_error (simple, error))
+		return FALSE;
+
+	*includes_last_item = async_data->includes_last_item;
+	*folders = async_data->items;
+
+	return TRUE;
+}
+
+gboolean
+e_ews_connection_find_folder_sync (EEwsConnection *cnc,
+				   gint pri,
+				   const EwsFolderId *fid,
+				   gboolean *includes_last_item,
+				   GSList **folders,
+				   GCancellable *cancellable,
+				   GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (cnc != NULL, FALSE);
 
-	sync_data = g_new0 (EwsSyncData, 1);
-	sync_data->eflag = e_flag_new ();
+	closure = e_async_closure_new ();
 
-	e_ews_connection_get_free_busy_start (cnc, pri,
-					      free_busy_cb, free_busy_user_data,
-					      ews_sync_reply_cb, cancellable,
-					      (gpointer) sync_data);
+	e_ews_connection_find_folder (cnc, pri, fid, cancellable, e_async_closure_callback, closure);
 
-	e_flag_wait (sync_data->eflag);
+	result = e_async_closure_wait (closure);
 
-	result = e_ews_connection_get_free_busy_finish (cnc, sync_data->res,
-							free_busy, error);
+	success = e_ews_connection_find_folder_finish (
+		cnc, result, includes_last_item, folders, error);
 
-	e_flag_free (sync_data->eflag);
-	g_object_unref (sync_data->res);
-	g_free (sync_data);
+	e_async_closure_free (closure);
 
-	return result;
+	return success;
 }
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-ews-connection.h evolution-ews.sync-with-3.8.2/src/server/e-ews-connection.h
--- evolution-ews.git-gnome-3-0/src/server/e-ews-connection.h	2013-05-17 14:36:16.355671150 +0200
+++ evolution-ews.sync-with-3.8.2/src/server/e-ews-connection.h	2013-05-28 08:59:53.431713406 +0200
@@ -61,9 +61,12 @@ enum {
 	EWS_PRIORITY_HIGH
 };
 
-typedef void (*EEwsRequestCreationCallback) (ESoapMessage *msg,
-					     gpointer user_data);
-typedef void (*EwsProgressFn) (gpointer object, gint percent);
+typedef void	(*EEwsRequestCreationCallback)	(ESoapMessage *msg,
+						 gpointer user_data);
+typedef void	(*EwsProgressFn)		(gpointer object,
+						 gint percent);
+typedef void	(*EEwsResponseCallback)		(ESoapResponse *response,
+						 GSimpleAsyncResult *simple);
 
 typedef enum {
 	EWS_SEARCH_AD,
@@ -90,6 +93,13 @@ typedef enum {
 	EWS_SPECIFIED_OCCURRENCE_ONLY
 } EwsAffectedTaskOccurrencesType;
 
+typedef enum {
+	E_EWS_BODY_TYPE_ANY,
+	E_EWS_BODY_TYPE_BEST,
+	E_EWS_BODY_TYPE_HTML,
+	E_EWS_BODY_TYPE_TEXT
+} EEwsBodyType;
+
 typedef struct {
 	gchar *as_url;
 	gchar *oab_url;
@@ -115,13 +125,91 @@ typedef struct {
 	gchar *filename;
 } EwsOALDetails;
 
+typedef struct {
+	gchar *sid;
+	gchar *primary_smtp;
+	gchar *display_name;
+	gchar *distinguished_user;
+	gchar *external_user;
+} EwsUserId;
+
+typedef enum {
+	EwsPermissionLevel_Unknown = 0,
+	EwsPermissionLevel_None,
+	EwsPermissionLevel_Reviewer,
+	EwsPermissionLevel_Author,
+	EwsPermissionLevel_Editor,
+	EwsPermissionLevel_Custom
+} EwsPermissionLevel;
+
+typedef struct {
+	EwsUserId *user_id;
+	EwsPermissionLevel calendar, tasks, inbox, contacts, notes, journal;
+	gboolean meetingcopies;
+	gboolean view_priv_items;
+} EwsDelegateInfo;
+
+typedef enum {
+	EwsDelegateDeliver_DelegatesOnly,
+	EwsDelegateDeliver_DelegatesAndMe,
+	EwsDelegateDeliver_DelegatesAndSendInformationToMe
+} EwsDelegateDeliver;
+
+typedef enum {
+	NORMAL_FIELD_URI,
+	INDEXED_FIELD_URI,
+	EXTENDED_FIELD_URI
+} EwsFieldURIType;
+
+typedef struct {
+	gchar *distinguished_prop_set_id;
+	gchar *prop_set_id;
+	gchar *prop_tag;
+	gchar *prop_name;
+	gchar *prop_id;
+	gchar *prop_type;
+} EwsExtendedFieldURI;
+
+typedef struct {
+	gchar *field_uri;
+	gchar *field_index;
+} EwsIndexedFieldURI;
+
+typedef struct {
+	gchar *field_uri;
+	GSList *extended_furis;
+	GSList *indexed_furis;
+} EwsAdditionalProps;
+
+typedef struct {
+	gchar *order;
+	gint uri_type;
+	gpointer field_uri;
+} EwsSortOrder;
+
+void		ews_oal_free			(EwsOAL *oal);
+void		ews_oal_details_free		(EwsOALDetails *details);
+
 GType		e_ews_connection_get_type	(void);
 EEwsConnection *e_ews_connection_new		(const gchar *uri,
 						 const gchar *username,
 						 const gchar *password,
+						 const gchar *default_email,
+						 const gchar *impersonate_user,
+						 gint timeout,
+						 gboolean use_ntlm,
 						 GCallback authenticate_cb,
 						 gpointer authenticate_ctx,
 						 GError **error);
+const gchar *	e_ews_connection_get_uri	(EEwsConnection *cnc);
+const gchar *	e_ews_connection_get_password	(EEwsConnection *cnc);
+gchar *		e_ews_connection_dup_password	(EEwsConnection *cnc);
+void		e_ews_connection_set_password	(EEwsConnection *cnc,
+						 const gchar *password);
+const gchar *	e_ews_connection_get_impersonate_user
+						(EEwsConnection *cnc);
+SoupSession *	e_ews_connection_ref_soup_session
+						(EEwsConnection *cnc);
 EEwsConnection *e_ews_connection_find		(const gchar *uri,
 						 const gchar *username);
 void		e_ews_connection_authenticate	(EEwsConnection *cnc,
@@ -130,43 +218,76 @@ void		e_ews_connection_authenticate	(EEw
 						 const gchar *passwd,
 						 GError *error);
 
-typedef void (*EEwsAutoDiscoverCallback) (EwsUrls *urls, gpointer user_data, GError *error);
-void		e_ews_autodiscover_ws_url	(EEwsAutoDiscoverCallback cb,
-						 gpointer cbdata,
-						 const gchar *email,
-						 const gchar *password);
+void		e_ews_connection_queue_request	(EEwsConnection *cnc,
+						 ESoapMessage *msg,
+						 EEwsResponseCallback cb,
+						 gint pri,
+						 GCancellable *cancellable,
+						 GSimpleAsyncResult *simple);
+
+gboolean	e_ews_autodiscover_ws_url_sync	(GObject *on_object,
+						 const gchar *uri,
+						 const gchar *username,
+						 const gchar *email_address,
+						 const gchar *password,
+						 gint timeout,
+						 gboolean use_ntlm,
+						 gchar **as_url,
+						 gchar **oab_url,
+						 GCancellable *cancellable,
+						 GError **error);
+void		e_ews_autodiscover_ws_url	(GObject *on_object,
+						 const gchar *uri,
+						 const gchar *username,
+						 const gchar *email_address,
+						 const gchar *password,
+						 gint timeout,
+						 gboolean use_ntlm,
+						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
+						 gpointer user_data);
+gboolean	e_ews_autodiscover_ws_url_finish
+						(GObject *on_object,
+						 GAsyncResult *result,
+						 gchar **as_url,
+						 gchar **oab_url,
+						 GError **error);
+const gchar *	e_ews_connection_get_mailbox	(EEwsConnection *cnc);
 void		e_ews_connection_set_mailbox	(EEwsConnection *cnc,
 						 const gchar *email);
-/* Sync folder items */
-void		e_ews_connection_sync_folder_items_start
+
+void		ews_user_id_free		(EwsUserId *id);
+void		ews_delegate_info_free		(EwsDelegateInfo *info);
+
+void		e_ews_connection_sync_folder_items
 						(EEwsConnection *cnc,
 						 gint pri,
-						 const gchar *sync_state,
+						 const gchar *old_sync_state,
 						 const gchar *fid,
-						 const gchar *props,
+						 const gchar *default_props,
 						 const gchar *additional_props,
 						 guint max_entries,
-						 GAsyncReadyCallback cb,
 						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
 						 gpointer user_data);
-
 gboolean	e_ews_connection_sync_folder_items_finish
 						(EEwsConnection *cnc,
 						 GAsyncResult *result,
-					 	 gchar **sync_state,
+						 gchar **new_sync_state,
 						 gboolean *includes_last_item,
 						 GSList **items_created,
 						 GSList **items_updated,
 						 GSList **items_deleted,
 						 GError **error);
-gboolean	e_ews_connection_sync_folder_items
+gboolean	e_ews_connection_sync_folder_items_sync
 						(EEwsConnection *cnc,
 						 gint pri,
-						 gchar **sync_state,
+						 const gchar *old_sync_state,
 						 const gchar *fid,
 						 const gchar *default_props,
 						 const gchar *additional_props,
 						 guint max_entries,
+						 gchar **new_sync_state,
 						 gboolean *includes_last_item,
 						 GSList **items_created,
 						 GSList **items_updated,
@@ -174,67 +295,91 @@ gboolean	e_ews_connection_sync_folder_it
 						 GCancellable *cancellable,
 						 GError **error);
 
-/* Get folder items */
-void		e_ews_connection_get_items_start
+typedef void	(*EwsConvertQueryCallback)	(ESoapMessage *msg,
+						 const gchar *query,
+						 EEwsFolderType type);
+
+void		e_ews_connection_find_folder_items
 						(EEwsConnection *cnc,
 						 gint pri,
+						 EwsFolderId *fid,
+						 const gchar *props,
+						 EwsAdditionalProps *add_props,
+						 EwsSortOrder *sort_order,
+						 const gchar *query,
+						 EEwsFolderType type,
+						 EwsConvertQueryCallback convert_query_cb,
+						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
+						 gpointer user_data);
+gboolean	e_ews_connection_find_folder_items_finish
+						(EEwsConnection *cnc,
+						 GAsyncResult *result,
+						 gboolean *includes_last_item,
+						 GSList **items,
+						 GError **error);
+gboolean	e_ews_connection_find_folder_items_sync
+						(EEwsConnection *cnc,
+						 gint pri,
+						 EwsFolderId *fid,
+						 const gchar *default_props,
+						 EwsAdditionalProps *add_props,
+						 EwsSortOrder *sort_order,
+						 const gchar *query,
+						 EEwsFolderType type,
+						 gboolean *includes_last_item,
+						 GSList **items,
+						 EwsConvertQueryCallback convert_query_cb,
+						 GCancellable *cancellable,
+						 GError **error);
+
+void		e_ews_connection_get_items	(EEwsConnection *cnc,
+						 gint pri,
 						 const GSList *ids,
 						 const gchar *default_props,
 						 const gchar *additional_props,
 						 gboolean include_mime,
 						 const gchar *mime_directory,
-						 GAsyncReadyCallback cb,
+						 EEwsBodyType body_type,
 						 ESoapProgressFn progress_fn,
 						 gpointer progress_data,
 						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
 						 gpointer user_data);
-
 gboolean	e_ews_connection_get_items_finish
 						(EEwsConnection *cnc,
 						 GAsyncResult *result,
 						 GSList **items,
 						 GError **error);
-
-gboolean	e_ews_connection_get_items	(EEwsConnection *cnc,
+gboolean	e_ews_connection_get_items_sync	(EEwsConnection *cnc,
 						 gint pri,
 						 const GSList *ids,
 						 const gchar *default_props,
 						 const gchar *additional_props,
 						 gboolean include_mime,
 						 const gchar *mime_directory,
+						 EEwsBodyType body_type,
 						 GSList **items,
 						 ESoapProgressFn progress_fn,
 						 gpointer progress_data,
 						 GCancellable *cancellable,
 						 GError **error);
-/* Delete folder items */
-void		e_ews_connection_delete_items_start	(EEwsConnection *cnc,
-					 gint pri,
-					 GSList *ids,
-					 EwsDeleteType delete_type,
-					 EwsSendMeetingCancellationsType send_cancels,
-					 EwsAffectedTaskOccurrencesType affected_tasks,
-					 GAsyncReadyCallback cb,
-					 GCancellable *cancellable,
-					 gpointer user_data);
-
-void		e_ews_connection_delete_item_start	(EEwsConnection *cnc,
-					 gint pri,
-					 EwsId *id,
-					 guint index,
-					 EwsDeleteType delete_type,
-					 EwsSendMeetingCancellationsType send_cancels,
-					 EwsAffectedTaskOccurrencesType affected_tasks,
-					 GAsyncReadyCallback cb,
-					 GCancellable *cancellable,
-					 gpointer user_data);
 
+void		e_ews_connection_delete_items	(EEwsConnection *cnc,
+						 gint pri,
+						 GSList *ids,
+						 EwsDeleteType delete_type,
+						 EwsSendMeetingCancellationsType send_cancels,
+						 EwsAffectedTaskOccurrencesType affected_tasks,
+						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
+						 gpointer user_data);
 gboolean	e_ews_connection_delete_items_finish
 						(EEwsConnection *cnc,
 						 GAsyncResult *result,
 						 GError **error);
-
-gboolean	e_ews_connection_delete_items	(EEwsConnection *cnc,
+gboolean	e_ews_connection_delete_items_sync
+						(EEwsConnection *cnc,
 						 gint pri,
 						 GSList *ids,
 						 EwsDeleteType delete_type,
@@ -243,38 +388,45 @@ gboolean	e_ews_connection_delete_items	(
 						 GCancellable *cancellable,
 						 GError **error);
 
-gboolean
-e_ews_connection_delete_item	(EEwsConnection *cnc,
-				 gint pri,
-				 EwsId *id,
-				 guint index,
-				 EwsDeleteType delete_type,
-				 EwsSendMeetingCancellationsType send_cancels,
-				 EwsAffectedTaskOccurrencesType affected_tasks,
-				 GCancellable *cancellable,
-				 GError **error);
-
-/* Update folder items */
-void		e_ews_connection_update_items_start
+void		e_ews_connection_delete_item	(EEwsConnection *cnc,
+						 gint pri,
+						 EwsId *id,
+						 guint index,
+						 EwsDeleteType delete_type,
+						 EwsSendMeetingCancellationsType send_cancels,
+						 EwsAffectedTaskOccurrencesType affected_tasks,
+						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
+						 gpointer user_data);
+gboolean	e_ews_connection_delete_item_sync
 						(EEwsConnection *cnc,
 						 gint pri,
+						 EwsId *id,
+						 guint index,
+						 EwsDeleteType delete_type,
+						 EwsSendMeetingCancellationsType send_cancels,
+						 EwsAffectedTaskOccurrencesType affected_tasks,
+						 GCancellable *cancellable,
+						 GError **error);
+
+void		e_ews_connection_update_items	(EEwsConnection *cnc,
+						 gint pri,
 						 const gchar *conflict_res,
 						 const gchar *msg_disposition,
 						 const gchar *send_invites,
 						 const gchar *folder_id,
 						 EEwsRequestCreationCallback create_cb,
 						 gpointer create_user_data,
-						 GAsyncReadyCallback cb,
 						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
 						 gpointer user_data);
-
 gboolean	e_ews_connection_update_items_finish
 						(EEwsConnection *cnc,
 						 GAsyncResult *result,
 						 GSList **ids,
 						 GError **error);
-
-gboolean	e_ews_connection_update_items	(EEwsConnection *cnc,
+gboolean	e_ews_connection_update_items_sync
+						(EEwsConnection *cnc,
 						 gint pri,
 						 const gchar *conflict_res,
 						 const gchar *msg_disposition,
@@ -285,53 +437,40 @@ gboolean	e_ews_connection_update_items	(
 						 GSList **ids,
 						 GCancellable *cancellable,
 						 GError **error);
-/* Create folder items */
-void		e_ews_connection_create_items_start
-						(EEwsConnection *cnc,
+
+void		e_ews_connection_create_items	(EEwsConnection *cnc,
 						 gint pri,
 						 const gchar *msg_disposition,
 						 const gchar *send_invites,
-						 const gchar *folder_id,
+						 const EwsFolderId *fid,
 						 EEwsRequestCreationCallback create_cb,
 						 gpointer create_user_data,
-						 GAsyncReadyCallback cb,
 						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
 						 gpointer user_data);
-
 gboolean	e_ews_connection_create_items_finish
 						(EEwsConnection *cnc,
 						 GAsyncResult *result,
 						 GSList **ids,
 						 GError **error);
-
-gboolean	e_ews_connection_create_items	(EEwsConnection *cnc,
+gboolean	e_ews_connection_create_items_sync
+						(EEwsConnection *cnc,
 						 gint pri,
 						 const gchar *msg_disposition,
 						 const gchar *send_invites,
-						 const gchar *folder_id,
+						 const EwsFolderId *fid,
 						 EEwsRequestCreationCallback create_cb,
 						 gpointer create_user_data,
 						 GSList **ids,
 						 GCancellable *cancellable,
 						 GError **error);
 
-/* Sync folder hierarchy */
-gboolean	e_ews_connection_sync_folder_hierarchy
-						(EEwsConnection *cnc,
-						 gint pri,
-						 gchar **sync_state,
-						 gboolean *includes_last_folder,
-						 GSList **folders_created,
-						 GSList **folders_updated,
-						 GSList **folders_deleted,
-						 GCancellable *cancellable,
-						 GError **error);
-void		e_ews_connection_sync_folder_hierarchy_start
+void		e_ews_connection_sync_folder_hierarchy
 						(EEwsConnection *cnc,
 						 gint pri,
 						 const gchar *sync_state,
-						 GAsyncReadyCallback cb,
 						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
 						 gpointer user_data);
 gboolean	e_ews_connection_sync_folder_hierarchy_finish
 						(EEwsConnection *cnc,
@@ -342,16 +481,26 @@ gboolean	e_ews_connection_sync_folder_hi
 						 GSList **folders_updated,
 						 GSList **folders_deleted,
 						 GError **error);
-/* Resolve names */
-void		e_ews_connection_resolve_names_start
+gboolean	e_ews_connection_sync_folder_hierarchy_sync
 						(EEwsConnection *cnc,
 						 gint pri,
+						 const gchar *old_sync_state,
+						 gchar **new_sync_state,
+						 gboolean *includes_last_folder,
+						 GSList **folders_created,
+						 GSList **folders_updated,
+						 GSList **folders_deleted,
+						 GCancellable *cancellable,
+						 GError **error);
+
+void		e_ews_connection_resolve_names	(EEwsConnection *cnc,
+						 gint pri,
 						 const gchar *resolve_name,
 						 EwsContactsSearchScope scope,
 						 GSList *parent_folder_ids,
 						 gboolean fetch_contact_data,
-						 GAsyncReadyCallback cb,
 						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
 						 gpointer user_data);
 gboolean	e_ews_connection_resolve_names_finish
 						(EEwsConnection *cnc,
@@ -360,7 +509,8 @@ gboolean	e_ews_connection_resolve_names_
 						 GSList **contact_items,
 						 gboolean *includes_last_item,
 						 GError **error);
-gboolean	e_ews_connection_resolve_names	(EEwsConnection *cnc,
+gboolean	e_ews_connection_resolve_names_sync
+						(EEwsConnection *cnc,
 						 gint pri,
 						 const gchar *resolve_name,
 						 EwsContactsSearchScope scope,
@@ -371,13 +521,12 @@ gboolean	e_ews_connection_resolve_names	
 						 gboolean *includes_last_item,
 						 GCancellable *cancellable,
 						 GError **error);
-/* Expand distribution lists */
-void		e_ews_connection_expand_dl_start
-						(EEwsConnection *cnc,
+
+void		e_ews_connection_expand_dl	(EEwsConnection *cnc,
 						 gint pri,
 						 const EwsMailbox *mb,
-						 GAsyncReadyCallback cb,
 						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
 						 gpointer user_data);
 gboolean	e_ews_connection_expand_dl_finish
 						(EEwsConnection *cnc,
@@ -385,7 +534,7 @@ gboolean	e_ews_connection_expand_dl_fini
 						 GSList **mailboxes,
 						 gboolean *includes_last_item,
 						 GError **error);
-gboolean	e_ews_connection_expand_dl	(EEwsConnection *cnc,
+gboolean	e_ews_connection_expand_dl_sync	(EEwsConnection *cnc,
 						 gint pri,
 						 const EwsMailbox *mb,
 						 GSList **mailboxes,
@@ -393,49 +542,54 @@ gboolean	e_ews_connection_expand_dl	(EEw
 						 GCancellable *cancellable,
 						 GError **error);
 
-/*Create Folder*/
-
-void		e_ews_connection_create_folder_start
+gboolean	e_ews_connection_ex_to_smtp_sync
 						(EEwsConnection *cnc,
 						 gint pri,
+						 const gchar *name,
+						 const gchar *ex_address,
+						 gchar **smtp_address,
+						 GCancellable *cancellable,
+						 GError **error);
+
+void		e_ews_connection_create_folder	(EEwsConnection *cnc,
+						 gint pri,
 						 const gchar *parent_folder_id,
 						 gboolean is_distinguished_id,
 						 const gchar *folder_name,
-						 GAsyncReadyCallback cb,
+						 EEwsFolderType folder_type,
 						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
 						 gpointer user_data);
 gboolean	e_ews_connection_create_folder_finish
 						(EEwsConnection *cnc,
 						 GAsyncResult *result,
 						 EwsFolderId **folder_id,
 						 GError **error);
-gboolean	e_ews_connection_create_folder	(EEwsConnection *cnc,
+gboolean	e_ews_connection_create_folder_sync
+						(EEwsConnection *cnc,
 						 gint pri,
 						 const gchar *parent_folder_id,
 						 gboolean is_distinguished_id,
 						 const gchar *folder_name,
+						 EEwsFolderType folder_type,
 						 EwsFolderId **folder_id,
 						 GCancellable *cancellable,
 						 GError **error);
 
-/*Delete Folder*/
-
-void		e_ews_connection_delete_folder_start
-						(EEwsConnection *cnc,
+void		e_ews_connection_delete_folder	(EEwsConnection *cnc,
 						 gint pri,
 						 const gchar *folder_id,
 						 gboolean is_distinguished_id,
 						 const gchar *delete_type,
-						 GAsyncReadyCallback cb,
 						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
 						 gpointer user_data);
-
 gboolean	e_ews_connection_delete_folder_finish
 						(EEwsConnection *cnc,
 						 GAsyncResult *result,
 						 GError **error);
-
-gboolean	e_ews_connection_delete_folder	(EEwsConnection *cnc,
+gboolean	e_ews_connection_delete_folder_sync
+						(EEwsConnection *cnc,
 						 gint pri,
 						 const gchar *folder_id,
 						 gboolean is_distinguished_id,
@@ -443,68 +597,82 @@ gboolean	e_ews_connection_delete_folder	
 						 GCancellable *cancellable,
 						 GError **error);
 
-/* Update (e.g. rename) folder */
-void		e_ews_connection_update_folder_start
-						(EEwsConnection *cnc,
+void		e_ews_connection_update_folder	(EEwsConnection *cnc,
 						 gint pri,
 						 EEwsRequestCreationCallback create_cb,
 						 gpointer create_user_data,
-						 GAsyncReadyCallback cb,
 						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
 						 gpointer user_data);
-
 gboolean	e_ews_connection_update_folder_finish
 						(EEwsConnection *cnc,
 						 GAsyncResult *result,
 						 GError **error);
-
-gboolean	e_ews_connection_update_folder	(EEwsConnection *cnc,
+gboolean	e_ews_connection_update_folder_sync
+						(EEwsConnection *cnc,
 						 gint pri,
 						 EEwsRequestCreationCallback create_cb,
 						 gpointer create_user_data,
 						 GCancellable *cancellable,
 						 GError **error);
 
-/* Move folder (to new parent; for rename we need update_folder) */
-void		e_ews_connection_move_folder_start
-						(EEwsConnection *cnc,
+void		e_ews_connection_move_folder	(EEwsConnection *cnc,
 						 gint pri,
 						 const gchar *to_folder,
 						 const gchar *folder,
-						 GAsyncReadyCallback cb,
 						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
 						 gpointer user_data);
-
 gboolean	e_ews_connection_move_folder_finish
 						(EEwsConnection *cnc,
 						 GAsyncResult *result,
 						 GError **error);
-
-gboolean	e_ews_connection_move_folder	(EEwsConnection *cnc,
+gboolean	e_ews_connection_move_folder_sync
+						(EEwsConnection *cnc,
 						 gint pri,
 						 const gchar *to_folder,
 						 const gchar *folder,
 						 GCancellable *cancellable,
 						 GError **error);
 
-/* Copy and Move item */
-void		e_ews_connection_move_items_start
+void		e_ews_connection_get_folder	(EEwsConnection *cnc,
+						 gint pri,
+						 const gchar *folder_shape,
+						 EwsAdditionalProps *add_props,
+						 GSList *folder_ids,
+						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
+						 gpointer user_data);
+gboolean	e_ews_connection_get_folder_finish
+						(EEwsConnection *cnc,
+						 GAsyncResult *result,
+						 GSList **folders,
+						 GError **error);
+gboolean	e_ews_connection_get_folder_sync
 						(EEwsConnection *cnc,
 						 gint pri,
+						 const gchar *folder_shape,
+						 EwsAdditionalProps *add_props,
+						 GSList *folder_ids,
+						 GSList **folders,
+						 GCancellable *cancellable,
+						 GError **error);
+
+void		e_ews_connection_move_items	(EEwsConnection *cnc,
+						 gint pri,
 						 const gchar *folder_id,
 						 gboolean docopy,
 						 GSList *ids,
-						 GAsyncReadyCallback cb,
 						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
 						 gpointer user_data);
-
 gboolean	e_ews_connection_move_items_finish
 						(EEwsConnection *cnc,
 						 GAsyncResult *result,
 						 GSList **items,
 						 GError **error);
-
-gboolean	e_ews_connection_move_items	(EEwsConnection *cnc,
+gboolean	e_ews_connection_move_items_sync
+						(EEwsConnection *cnc,
 						 gint pri,
 						 const gchar *folder_id,
 						 gboolean docopy,
@@ -513,23 +681,20 @@ gboolean	e_ews_connection_move_items	(EE
 						 GCancellable *cancellable,
 						 GError **error);
 
-/* Create attachemnts and associate them with an item */
-void		e_ews_connection_create_attachments_start
+void		e_ews_connection_create_attachments
 						(EEwsConnection *cnc,
 						 gint pri,
 						 const EwsId *parent,
 						 const GSList *files,
-						 GAsyncReadyCallback cb,
 						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
 						 gpointer user_data);
-
 GSList *	e_ews_connection_create_attachments_finish
 						(EEwsConnection *cnc,
 						 gchar **change_key,
 						 GAsyncResult *result,
 						 GError **error);
-
-GSList *	e_ews_connection_create_attachments
+GSList *	e_ews_connection_create_attachments_sync
 						(EEwsConnection *cnc,
 						 gint pri,
 						 const EwsId *parent,
@@ -538,52 +703,46 @@ GSList *	e_ews_connection_create_attachm
 						 GCancellable *cancellable,
 						 GError **error);
 
-/* Delete attachemnts */
-void		e_ews_connection_delete_attachments_start
+void		e_ews_connection_delete_attachments
 						(EEwsConnection *cnc,
 						 gint pri,
 						 const GSList *ids,
-						 GAsyncReadyCallback cb,
 						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
 						 gpointer user_data);
-
 GSList *	e_ews_connection_delete_attachments_finish
 						(EEwsConnection *cnc,
 						 GAsyncResult *result,
 						 GError **error);
-
-GSList *	e_ews_connection_delete_attachments
+GSList *	e_ews_connection_delete_attachments_sync
 						(EEwsConnection *cnc,
 						 gint pri,
 						 const GSList *ids,
 						 GCancellable *cancellable,
 						 GError **error);
 
-/* Get attachments items */
-void		e_ews_connection_get_attachments_start
+void		e_ews_connection_get_attachments
 						(EEwsConnection *cnc,
 						 gint pri,
 						 const gchar *comp_uid,
 						 const GSList *ids,
 						 const gchar *cache,
 						 gboolean include_mime,
-						 GAsyncReadyCallback cb,
 						 ESoapProgressFn progress_fn,
 						 gpointer progress_data,
 						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
 						 gpointer user_data);
-
 GSList *	e_ews_connection_get_attachments_finish
 						(EEwsConnection *cnc,
 						 GAsyncResult *result,
 						 GSList **items,
 						 GError **error);
-
-GSList *	e_ews_connection_get_attachments
+GSList *	e_ews_connection_get_attachments_sync
 						(EEwsConnection *cnc,
 						 gint pri,
 						 const gchar *comp_uid,
-						 GSList *ids,
+						 const GSList *ids,
 						 const gchar *cache,
 						 gboolean include_mime,
 						 GSList **items,
@@ -592,51 +751,52 @@ GSList *	e_ews_connection_get_attachment
 						 GCancellable *cancellable,
 						 GError **error);
 
-void		e_ews_connection_get_oal_list_start
+gboolean	e_ews_connection_get_oal_list_sync
 						(EEwsConnection *cnc,
-						 GAsyncReadyCallback cb,
+						 GSList **oals,
+						 GCancellable *cancellable,
+						 GError **error);
+void		e_ews_connection_get_oal_list	(EEwsConnection *cnc,
 						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
 						 gpointer user_data);
 gboolean	e_ews_connection_get_oal_list_finish
 						(EEwsConnection *cnc,
 						 GAsyncResult *result,
 						 GSList **oals,
 						 GError **error);
-void		e_ews_connection_get_oal_detail_start
+gboolean	e_ews_connection_get_oal_detail_sync
 						(EEwsConnection *cnc,
 						 const gchar *oal_id,
 						 const gchar *oal_element,
-						 GAsyncReadyCallback cb,
+						 GSList **elements,
 						 GCancellable *cancellable,
+						 GError **error);
+void		e_ews_connection_get_oal_detail	(EEwsConnection *cnc,
+						 const gchar *oal_id,
+						 const gchar *oal_element,
+						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
 						 gpointer user_data);
 gboolean	e_ews_connection_get_oal_detail_finish
 						(EEwsConnection *cnc,
 						 GAsyncResult *result,
 						 GSList **elements,
 						 GError **error);
-gboolean	e_ews_connection_get_oal_detail 
-						(EEwsConnection *cnc,
-						 const gchar *oal_id,
-						 const gchar *oal_element,
-						 GSList **elements,
-						 GCancellable *cancellable,
-						 GError **error);
 
-/* Get free-busy status */
-void		e_ews_connection_get_free_busy_start
-						(EEwsConnection *cnc,
+void		e_ews_connection_get_free_busy	(EEwsConnection *cnc,
 						 gint pri,
 						 EEwsRequestCreationCallback free_busy_cb,
 						 gpointer free_busy_user_data,
-						 GAsyncReadyCallback cb,
 						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
 						 gpointer user_data);
 gboolean	e_ews_connection_get_free_busy_finish
 						(EEwsConnection *cnc,
 						 GAsyncResult *result,
 						 GSList **free_busy,
 						 GError **error);
-gboolean	e_ews_connection_get_free_busy
+gboolean	e_ews_connection_get_free_busy_sync
 						(EEwsConnection *cnc,
 						 gint pri,
 						 EEwsRequestCreationCallback free_busy_cb,
@@ -644,24 +804,208 @@ gboolean	e_ews_connection_get_free_busy
 						 GSList **free_busy,
 						 GCancellable *cancellable,
 						 GError **error);
-void		e_ews_connection_download_oal_file_start
+gboolean	e_ews_connection_download_oal_file_sync
+						(EEwsConnection *cnc,
+						 const gchar *cache_filename,
+						 EwsProgressFn progress_fn,
+						 gpointer progress_data,
+						 GCancellable *cancellable,
+						 GError **error);
+void		e_ews_connection_download_oal_file
 						(EEwsConnection *cnc,
 						 const gchar *cache_filename,
-						 GAsyncReadyCallback cb,
 						 EwsProgressFn progress_fn,
 						 gpointer progress_data,
 						 GCancellable *cancellable,
+						 GAsyncReadyCallback cb,
 						 gpointer user_data);
-
 gboolean	e_ews_connection_download_oal_file_finish
 						(EEwsConnection *cnc,
 						 GAsyncResult *result,
 						 GError **error);
-gboolean	e_ews_connection_download_oal_file	
+
+void		e_ews_connection_get_delegate	(EEwsConnection *cnc,
+						 gint pri,
+						 const gchar *mail_id,
+						 gboolean include_permissions,
+						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
+						 gpointer user_data);
+gboolean	e_ews_connection_get_delegate_finish
 						(EEwsConnection *cnc,
-						 const gchar *cache_filename,
-						 EwsProgressFn progress_fn,
-						 gpointer progress_data,
+						 GAsyncResult *result,
+						 EwsDelegateDeliver *deliver_to,
+						 GSList **delegates, /* EwsDelegateInfo * */
+						 GError **error);
+gboolean	e_ews_connection_get_delegate_sync
+						(EEwsConnection *cnc,
+						 gint pri,
+						 const gchar *mail_id,
+						 gboolean include_permissions,
+						 EwsDelegateDeliver *deliver_to,
+						 GSList **delegates, /* EwsDelegateInfo * */
+						 GCancellable *cancellable,
+						 GError **error);
+void		e_ews_connection_add_delegate	(EEwsConnection *cnc,
+						 gint pri,
+						 const gchar *mail_id,
+						 const GSList *delegates, /* EwsDelegateInfo * */
+						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
+						 gpointer user_data);
+gboolean	e_ews_connection_add_delegate_finish
+						(EEwsConnection *cnc,
+						 GAsyncResult *result,
+						 GError **error);
+gboolean	e_ews_connection_add_delegate_sync
+						(EEwsConnection *cnc,
+						 gint pri,
+						 const gchar *mail_id,
+						 const GSList *delegates, /* EwsDelegateInfo * */
+						 GCancellable *cancellable,
+						 GError **error);
+void		e_ews_connection_remove_delegate
+						(EEwsConnection *cnc,
+						 gint pri,
+						 const gchar *mail_id,
+						 const GSList *delegate_ids, /* EwsUserId * */
+						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
+						 gpointer user_data);
+gboolean	e_ews_connection_remove_delegate_finish
+						(EEwsConnection *cnc,
+						 GAsyncResult *result,
+						 GError **error);
+gboolean	e_ews_connection_remove_delegate_sync
+						(EEwsConnection *cnc,
+						 gint pri,
+						 const gchar *mail_id,
+						 const GSList *delegate_ids, /* EwsUserId * */
+						 GCancellable *cancellable,
+						 GError **error);
+void		e_ews_connection_update_delegate
+						(EEwsConnection *cnc,
+						 gint pri,
+						 const gchar *mail_id,
+						 EwsDelegateDeliver deliver_to,
+						 const GSList *delegates, /* EwsDelegateInfo * */
+						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
+						 gpointer user_data);
+gboolean	e_ews_connection_update_delegate_finish
+						(EEwsConnection *cnc,
+						 GAsyncResult *result,
+						 GError **error);
+gboolean	e_ews_connection_update_delegate_sync
+						(EEwsConnection *cnc,
+						 gint pri,
+						 const gchar *mail_id,
+						 EwsDelegateDeliver deliver_to,
+						 const GSList *delegates, /* EwsDelegateInfo * */
+						 GCancellable *cancellable,
+						 GError **error);
+void		e_ews_connection_get_folder_permissions
+						(EEwsConnection *cnc,
+						 gint pri,
+						 EwsFolderId *folder_id,
+						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
+						 gpointer user_data);
+gboolean	e_ews_connection_get_folder_permissions_finish
+						(EEwsConnection *cnc,
+						 GAsyncResult *result,
+						 GSList **permissions,
+						 GError **error);
+gboolean	e_ews_connection_get_folder_permissions_sync
+						(EEwsConnection *cnc,
+						 gint pri,
+						 EwsFolderId *folder_id,
+						 GSList **permissions,
+						 GCancellable *cancellable,
+						 GError **error);
+void		e_ews_connection_set_folder_permissions
+						(EEwsConnection *cnc,
+						 gint pri,
+						 EwsFolderId *folder_id,
+						 EEwsFolderType folder_type,
+						 const GSList *permissions,
+						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
+						 gpointer user_data);
+gboolean	e_ews_connection_set_folder_permissions_finish
+						(EEwsConnection *cnc,
+						 GAsyncResult *result,
+						 GError **error);
+gboolean	e_ews_connection_set_folder_permissions_sync
+						(EEwsConnection *cnc,
+						 gint pri,
+						 EwsFolderId *folder_id,
+						 EEwsFolderType folder_type,
+						 const GSList *permissions,
+						 GCancellable *cancellable,
+						 GError **error);
+
+void		e_ews_connection_get_password_expiration
+						(EEwsConnection *cnc,
+						 gint pri,
+						 const gchar *mail_id,
+						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
+						 gpointer user_data);
+
+gboolean	e_ews_connection_get_password_expiration_finish
+						(EEwsConnection *cnc,
+						 GAsyncResult *result,
+						 gchar **exp_date,
+						 GError **error);
+
+gboolean	e_ews_connection_get_password_expiration_sync
+						(EEwsConnection *cnc,
+						 gint pri,
+						 const gchar *mail_id,
+						 gchar **exp_date,
+						 GCancellable *cancellable,
+						 GError **error);
+
+void		e_ews_connection_get_folder_info
+						(EEwsConnection *cnc,
+						 gint pri,
+						 const gchar *mail_id,
+						 const EwsFolderId *folder_id,
+						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
+						 gpointer user_data);
+gboolean	e_ews_connection_get_folder_info_finish
+						(EEwsConnection *cnc,
+						 GAsyncResult *result,
+						 EEwsFolder **folder,
+						 GError **error);
+gboolean	e_ews_connection_get_folder_info_sync
+						(EEwsConnection *cnc,
+						 gint pri,
+						 const gchar *mail_id,
+						 const EwsFolderId *folder_id,
+						 EEwsFolder **folder,
+						 GCancellable *cancellable,
+						 GError **error);
+void		e_ews_connection_find_folder	(EEwsConnection *cnc,
+						 gint pri,
+						 const EwsFolderId *fid,
+						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
+						 gpointer user_data);
+gboolean	e_ews_connection_find_folder_finish
+						(EEwsConnection *cnc,
+						 GAsyncResult *result,
+						 gboolean *includes_last_item,
+						 GSList **folders,
+						 GError **error);
+gboolean	e_ews_connection_find_folder_sync
+						(EEwsConnection *cnc,
+						 gint pri,
+						 const EwsFolderId *fid,
+						 gboolean *includes_last_item,
+						 GSList **folders,
 						 GCancellable *cancellable,
 						 GError **error);
 
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-ews-enums.h evolution-ews.sync-with-3.8.2/src/server/e-ews-enums.h
--- evolution-ews.git-gnome-3-0/src/server/e-ews-enums.h	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/server/e-ews-enums.h	2013-05-28 08:59:53.426713239 +0200
@@ -0,0 +1,51 @@
+/*
+ * e-ews-enums.h
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) version 3.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the program; if not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef E_EWS_ENUMS_H
+#define E_EWS_ENUMS_H
+
+#include <glib.h>
+
+G_BEGIN_DECLS
+
+typedef enum {
+	E_EWS_EXTERNAL_AUDIENCE_NONE,
+	E_EWS_EXTERNAL_AUDIENCE_KNOWN,
+	E_EWS_EXTERNAL_AUDIENCE_ALL
+} EEwsExternalAudience;
+
+typedef enum {
+	E_EWS_FOLDER_TYPE_UNKNOWN,
+	E_EWS_FOLDER_TYPE_MAILBOX,
+	E_EWS_FOLDER_TYPE_CALENDAR,
+	E_EWS_FOLDER_TYPE_CONTACTS,
+	E_EWS_FOLDER_TYPE_SEARCH,
+	E_EWS_FOLDER_TYPE_TASKS,
+	E_EWS_FOLDER_TYPE_MEMOS
+} EEwsFolderType;
+
+typedef enum {
+	E_EWS_OOF_STATE_DISABLED,
+	E_EWS_OOF_STATE_ENABLED,
+	E_EWS_OOF_STATE_SCHEDULED
+} EEwsOofState;
+
+G_END_DECLS
+
+#endif /* E_EWS_ENUMS_H */
+
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-ews-enumtypes.c evolution-ews.sync-with-3.8.2/src/server/e-ews-enumtypes.c
--- evolution-ews.git-gnome-3-0/src/server/e-ews-enumtypes.c	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/server/e-ews-enumtypes.c	2013-05-28 08:59:53.425713426 +0200
@@ -0,0 +1,100 @@
+
+/* Generated data (by glib-mkenums) */
+
+#include "e-ews-enumtypes.h"
+/* enumerations from "./e-ews-enums.h" */
+#include "./e-ews-enums.h"
+
+GType
+e_ews_external_audience_get_type (void)
+{
+	static volatile gsize the_type__volatile = 0;
+
+	if (g_once_init_enter (&the_type__volatile)) {
+		static const GEnumValue values[] = {
+			{ E_EWS_EXTERNAL_AUDIENCE_NONE,
+			  "E_EWS_EXTERNAL_AUDIENCE_NONE",
+			  "none" },
+			{ E_EWS_EXTERNAL_AUDIENCE_KNOWN,
+			  "E_EWS_EXTERNAL_AUDIENCE_KNOWN",
+			  "known" },
+			{ E_EWS_EXTERNAL_AUDIENCE_ALL,
+			  "E_EWS_EXTERNAL_AUDIENCE_ALL",
+			  "all" },
+			{ 0, NULL, NULL }
+		};
+		GType the_type = g_enum_register_static (
+			g_intern_static_string ("EEwsExternalAudience"),
+			values);
+		g_once_init_leave (&the_type__volatile, the_type);
+	}
+	return the_type__volatile;
+}
+
+GType
+e_ews_folder_type_get_type (void)
+{
+	static volatile gsize the_type__volatile = 0;
+
+	if (g_once_init_enter (&the_type__volatile)) {
+		static const GEnumValue values[] = {
+			{ E_EWS_FOLDER_TYPE_UNKNOWN,
+			  "E_EWS_FOLDER_TYPE_UNKNOWN",
+			  "unknown" },
+			{ E_EWS_FOLDER_TYPE_MAILBOX,
+			  "E_EWS_FOLDER_TYPE_MAILBOX",
+			  "mailbox" },
+			{ E_EWS_FOLDER_TYPE_CALENDAR,
+			  "E_EWS_FOLDER_TYPE_CALENDAR",
+			  "calendar" },
+			{ E_EWS_FOLDER_TYPE_CONTACTS,
+			  "E_EWS_FOLDER_TYPE_CONTACTS",
+			  "contacts" },
+			{ E_EWS_FOLDER_TYPE_SEARCH,
+			  "E_EWS_FOLDER_TYPE_SEARCH",
+			  "search" },
+			{ E_EWS_FOLDER_TYPE_TASKS,
+			  "E_EWS_FOLDER_TYPE_TASKS",
+			  "tasks" },
+			{ E_EWS_FOLDER_TYPE_MEMOS,
+			  "E_EWS_FOLDER_TYPE_MEMOS",
+			  "memos" },
+			{ 0, NULL, NULL }
+		};
+		GType the_type = g_enum_register_static (
+			g_intern_static_string ("EEwsFolderType"),
+			values);
+		g_once_init_leave (&the_type__volatile, the_type);
+	}
+	return the_type__volatile;
+}
+
+GType
+e_ews_oof_state_get_type (void)
+{
+	static volatile gsize the_type__volatile = 0;
+
+	if (g_once_init_enter (&the_type__volatile)) {
+		static const GEnumValue values[] = {
+			{ E_EWS_OOF_STATE_DISABLED,
+			  "E_EWS_OOF_STATE_DISABLED",
+			  "disabled" },
+			{ E_EWS_OOF_STATE_ENABLED,
+			  "E_EWS_OOF_STATE_ENABLED",
+			  "enabled" },
+			{ E_EWS_OOF_STATE_SCHEDULED,
+			  "E_EWS_OOF_STATE_SCHEDULED",
+			  "scheduled" },
+			{ 0, NULL, NULL }
+		};
+		GType the_type = g_enum_register_static (
+			g_intern_static_string ("EEwsOofState"),
+			values);
+		g_once_init_leave (&the_type__volatile, the_type);
+	}
+	return the_type__volatile;
+}
+
+
+/* Generated data ends here */
+
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-ews-enumtypes.h evolution-ews.sync-with-3.8.2/src/server/e-ews-enumtypes.h
--- evolution-ews.git-gnome-3-0/src/server/e-ews-enumtypes.h	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/server/e-ews-enumtypes.h	2013-05-28 08:59:53.427713238 +0200
@@ -0,0 +1,27 @@
+
+/* Generated data (by glib-mkenums) */
+
+#ifndef E_EWS_ENUMTYPES_H
+#define E_EWS_ENUMTYPES_H
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+/* Enumerations from "./e-ews-enums.h" */
+
+#define E_TYPE_EWS_EXTERNAL_AUDIENCE	(e_ews_external_audience_get_type())
+GType e_ews_external_audience_get_type	(void) G_GNUC_CONST;
+
+#define E_TYPE_EWS_FOLDER_TYPE	(e_ews_folder_type_get_type())
+GType e_ews_folder_type_get_type	(void) G_GNUC_CONST;
+
+#define E_TYPE_EWS_OOF_STATE	(e_ews_oof_state_get_type())
+GType e_ews_oof_state_get_type	(void) G_GNUC_CONST;
+
+G_END_DECLS
+
+#endif /* E_EWS_ENUMTYPES_H */
+
+/* Generated data ends here */
+
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-ews-folder.c evolution-ews.sync-with-3.8.2/src/server/e-ews-folder.c
--- evolution-ews.git-gnome-3-0/src/server/e-ews-folder.c	2013-05-17 14:36:16.356671234 +0200
+++ evolution-ews.sync-with-3.8.2/src/server/e-ews-folder.c	2013-05-28 08:59:53.432713431 +0200
@@ -22,21 +22,33 @@
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
+
 #include <string.h>
+#include <glib/gi18n-lib.h>
+
+#include <libedataserver/e-source-group.h>
+#include <libedataserver/e-source.h>
+#include <libedataserver/e-source-list.h>
+
 #include "e-ews-folder.h"
 #include "e-ews-message.h"
+#include "e-ews-enumtypes.h"
+#include "ews-errors.h"
+
+#include "e-ews-gnome-3-8-compat.h"
 
 G_DEFINE_TYPE (EEwsFolder, e_ews_folder, G_TYPE_OBJECT)
 
 struct _EEwsFolderPrivate {
+	GError *error;
 	gchar *name;
 	EwsFolderId *fid;
 	EwsFolderId *parent_fid;
-	gchar *folder_class;
-	EwsFolderType folder_type;
+	EEwsFolderType folder_type;
 	guint32 unread;
 	guint32 total;
 	guint32 child_count;
+	gboolean foreign;
 };
 
 static GObjectClass *parent_class = NULL;
@@ -62,6 +74,8 @@ e_ews_folder_finalize (GObject *object)
 
 	priv = folder->priv;
 
+	g_clear_error (&priv->error);
+
 	if (priv->name) {
 		g_free (priv->name);
 		priv->name = NULL;
@@ -108,48 +122,68 @@ e_ews_folder_init (EEwsFolder *folder)
 	priv = g_new0 (EEwsFolderPrivate, 1);
 	folder->priv = priv;
 
-	priv->folder_type = EWS_FOLDER_TYPE_MAILBOX;
+	priv->error = NULL;
+	priv->folder_type = E_EWS_FOLDER_TYPE_UNKNOWN;
+	priv->foreign = FALSE;
 }
 
-/* FIXME pick it from folder_type and make it set folder_type */
-static void
-e_ews_folder_set_folder_class (EEwsFolder *folder, const gchar *folder_class)
-{
-	EEwsFolderPrivate *priv;
-
-	g_return_if_fail (E_IS_EWS_FOLDER (folder));
-	g_return_if_fail (folder_class != NULL);
-
-	priv = folder->priv;
-
-	if (priv->folder_class)
-		g_free (priv->folder_class);
-	priv->folder_class = g_strdup (folder_class);
-}
-
-
 static gboolean
-e_ews_folder_set_from_soap_parameter (EEwsFolder *folder, ESoapParameter *param)
+e_ews_folder_set_from_soap_parameter (EEwsFolder *folder,
+                                      ESoapParameter *param)
 {
 	EEwsFolderPrivate *priv = folder->priv;
-	gchar *value;
 	ESoapParameter *subparam, *node;
 
 	g_return_val_if_fail (param != NULL, FALSE);
 
-	if ((node = e_soap_parameter_get_first_child_by_name (param, "Folder")))
-		priv->folder_type = EWS_FOLDER_TYPE_MAILBOX;
+	if (g_strcmp0 (e_soap_parameter_get_name (param), "Folder") == 0) {
+		node = param;
+		priv->folder_type = E_EWS_FOLDER_TYPE_MAILBOX;
+	} else if (g_strcmp0 (e_soap_parameter_get_name (param), "CalendarFolder") == 0) {
+		node = param;
+		priv->folder_type = E_EWS_FOLDER_TYPE_CALENDAR;
+	} else if (g_strcmp0 (e_soap_parameter_get_name (param), "ContactsFolder") == 0) {
+		node = param;
+		priv->folder_type = E_EWS_FOLDER_TYPE_CONTACTS;
+	} else if (g_strcmp0 (e_soap_parameter_get_name (param), "TasksFolder") == 0) {
+		node = param;
+		priv->folder_type = E_EWS_FOLDER_TYPE_TASKS;
+	} else if ((node = e_soap_parameter_get_first_child_by_name (param, "Folder")))
+		priv->folder_type = E_EWS_FOLDER_TYPE_MAILBOX;
 	else if ((node = e_soap_parameter_get_first_child_by_name (param, "CalendarFolder")))
-		priv->folder_type = EWS_FOLDER_TYPE_CALENDAR;
+		priv->folder_type = E_EWS_FOLDER_TYPE_CALENDAR;
 	else if ((node = e_soap_parameter_get_first_child_by_name (param, "ContactsFolder")))
-		priv->folder_type = EWS_FOLDER_TYPE_CONTACTS;
+		priv->folder_type = E_EWS_FOLDER_TYPE_CONTACTS;
 	else if ((node = e_soap_parameter_get_first_child_by_name (param, "TasksFolder")))
-		priv->folder_type = EWS_FOLDER_TYPE_TASKS;
+		priv->folder_type = E_EWS_FOLDER_TYPE_TASKS;
 	else {
 		g_warning ("Unable to find the Folder node \n");
 		return FALSE;
 	}
 
+	if (priv->folder_type == E_EWS_FOLDER_TYPE_MAILBOX) {
+		subparam = e_soap_parameter_get_first_child_by_name (node, "FolderClass");
+		if (subparam) {
+			gchar *folder_class = e_soap_parameter_get_string_value (subparam);
+
+			priv->folder_type = E_EWS_FOLDER_TYPE_UNKNOWN;
+
+			if (g_strcmp0 (folder_class, "IPF.Note") == 0 || (folder_class && g_str_has_prefix (folder_class, "IPF.Note."))) {
+				priv->folder_type = E_EWS_FOLDER_TYPE_MAILBOX;
+			} else if (g_strcmp0 (folder_class, "IPF.Contact") == 0) {
+				priv->folder_type = E_EWS_FOLDER_TYPE_CONTACTS;
+			} else if (g_strcmp0 (folder_class, "IPF.Appointment") == 0) {
+				priv->folder_type = E_EWS_FOLDER_TYPE_CALENDAR;
+			} else if (g_strcmp0 (folder_class, "IPF.Task") == 0) {
+				priv->folder_type = E_EWS_FOLDER_TYPE_TASKS;
+			} else if (g_strcmp0 (folder_class, "IPF.StickyNote") == 0) {
+				priv->folder_type = E_EWS_FOLDER_TYPE_MEMOS;
+			}
+
+			g_free (folder_class);
+		}
+	}
+
 	subparam = e_soap_parameter_get_first_child_by_name (node, "FolderId");
 	if (subparam) {
 		priv->fid = g_new0 (EwsFolderId, 1);
@@ -164,13 +198,6 @@ e_ews_folder_set_from_soap_parameter (EE
 		priv->parent_fid->change_key = e_soap_parameter_get_property (subparam, "ChangeKey");
 	}
 
-	subparam = e_soap_parameter_get_first_child_by_name (node, "FolderClass");
-	if (subparam) {
-		value = e_soap_parameter_get_string_value (subparam);
-		e_ews_folder_set_folder_class (folder, (const gchar *) value);
-		g_free (value);
-	}
-
 	subparam = e_soap_parameter_get_first_child_by_name (node, "DisplayName");
 	if (subparam)
 		priv->name = e_soap_parameter_get_string_value (subparam);
@@ -190,6 +217,54 @@ e_ews_folder_set_from_soap_parameter (EE
 	return TRUE;
 }
 
+const gchar *
+e_ews_folder_type_to_nick (EEwsFolderType folder_type)
+{
+	GEnumClass *enum_class;
+	GEnumValue *enum_value;
+	const gchar *folder_type_nick;
+
+	enum_class = g_type_class_ref (E_TYPE_EWS_FOLDER_TYPE);
+	enum_value = g_enum_get_value (enum_class, folder_type);
+
+	if (enum_value == NULL) {
+		folder_type = E_EWS_FOLDER_TYPE_UNKNOWN;
+		enum_value = g_enum_get_value (enum_class, folder_type);
+	}
+
+	g_return_val_if_fail (enum_value != NULL, NULL);
+
+	folder_type_nick = g_intern_string (enum_value->value_nick);
+
+	g_type_class_unref (enum_class);
+
+	return folder_type_nick;
+}
+
+EEwsFolderType
+e_ews_folder_type_from_nick (const gchar *folder_type_nick)
+{
+	GEnumClass *enum_class;
+	GEnumValue *enum_value;
+	EEwsFolderType folder_type;
+
+	g_return_val_if_fail (
+		folder_type_nick != NULL,
+		E_EWS_FOLDER_TYPE_UNKNOWN);
+
+	enum_class = g_type_class_ref (E_TYPE_EWS_FOLDER_TYPE);
+	enum_value = g_enum_get_value_by_nick (enum_class, folder_type_nick);
+
+	if (enum_value != NULL)
+		folder_type = enum_value->value;
+	else
+		folder_type = E_EWS_FOLDER_TYPE_UNKNOWN;
+
+	g_type_class_unref (enum_class);
+
+	return folder_type;
+}
+
 EEwsFolder *
 e_ews_folder_new_from_soap_parameter (ESoapParameter *param)
 {
@@ -206,8 +281,52 @@ e_ews_folder_new_from_soap_parameter (ES
 	return folder;
 }
 
+EEwsFolder *
+e_ews_folder_new_from_error (const GError *error)
+{
+	EEwsFolder *folder;
+
+	g_return_val_if_fail (error != NULL, NULL);
+
+	folder = g_object_new (E_TYPE_EWS_FOLDER, NULL);
+	folder->priv->error = g_error_copy (error);
+
+	return folder;
+}
+
+gboolean
+e_ews_folder_is_error (EEwsFolder *folder)
+{
+	g_return_val_if_fail (E_IS_EWS_FOLDER (folder), TRUE);
+
+	return folder->priv->error != NULL;
+}
+
+const GError *
+e_ews_folder_get_error (EEwsFolder *folder)
+{
+	g_return_val_if_fail (E_IS_EWS_FOLDER (folder), NULL);
+
+	return folder->priv->error;
+}
+
+EwsFolderId *
+e_ews_folder_id_new (const gchar *id,
+                     const gchar *change_key,
+                     gboolean is_distinguished_id)
+{
+	EwsFolderId *fid;
+
+	fid = g_new0 (EwsFolderId, 1);
+	fid->id = g_strdup (id);
+	fid->change_key = g_strdup (change_key);
+	fid->is_distinguished_id = is_distinguished_id;
+
+	return fid;
+}
+
 void
-e_ews_folder_free_fid (EwsFolderId *fid)
+e_ews_folder_id_free (EwsFolderId *fid)
 {
 	if (fid) {
 		g_free (fid->id);
@@ -225,7 +344,8 @@ e_ews_folder_get_name (EEwsFolder *folde
 }
 
 void
-e_ews_folder_set_name (EEwsFolder *folder, const gchar *new_name)
+e_ews_folder_set_name (EEwsFolder *folder,
+                       const gchar *new_name)
 {
 	EEwsFolderPrivate *priv;
 
@@ -239,7 +359,6 @@ e_ews_folder_set_name (EEwsFolder *folde
 	priv->name = g_strdup (new_name);
 }
 
-
 const EwsFolderId *
 e_ews_folder_get_id (EEwsFolder *folder)
 {
@@ -257,7 +376,8 @@ e_ews_folder_get_parent_id (EEwsFolder *
 }
 
 void
-e_ews_folder_set_parent_id (EEwsFolder *folder, EwsFolderId *parent_fid)
+e_ews_folder_set_parent_id (EEwsFolder *folder,
+                            EwsFolderId *parent_fid)
 {
 	EEwsFolderPrivate *priv;
 
@@ -275,7 +395,7 @@ e_ews_folder_set_parent_id (EEwsFolder *
 	priv->parent_fid = parent_fid;
 }
 
-EwsFolderType
+EEwsFolderType
 e_ews_folder_get_folder_type (EEwsFolder *folder)
 {
 	g_return_val_if_fail (E_IS_EWS_FOLDER (folder), -1);
@@ -284,7 +404,8 @@ e_ews_folder_get_folder_type (EEwsFolder
 }
 
 void
-e_ews_folder_set_folder_type (EEwsFolder *folder, EwsFolderType folder_type)
+e_ews_folder_set_folder_type (EEwsFolder *folder,
+                              EEwsFolderType folder_type)
 {
 	g_return_if_fail (E_IS_EWS_FOLDER (folder));
 
@@ -305,7 +426,6 @@ e_ews_folder_get_unread_count (EEwsFolde
 	g_return_val_if_fail (E_IS_EWS_FOLDER (folder), -1);
 
 	return folder->priv->unread;
-
 }
 
 guint32
@@ -314,6 +434,542 @@ e_ews_folder_get_child_count (EEwsFolder
 	g_return_val_if_fail (E_IS_EWS_FOLDER (folder), -1);
 
 	return folder->priv->child_count;
+}
+
+gboolean
+e_ews_folder_get_foreign (EEwsFolder *folder)
+{
+	g_return_val_if_fail (E_IS_EWS_FOLDER (folder), FALSE);
+
+	return folder->priv->foreign;
+}
+
+void
+e_ews_folder_set_foreign (EEwsFolder *folder,
+                          gboolean is_foreign)
+{
+	g_return_if_fail (E_IS_EWS_FOLDER (folder));
+
+	folder->priv->foreign = is_foreign;
+}
+
+gchar *
+e_ews_folder_utils_pick_color_spec (gint move_by,
+                                    gboolean around_middle)
+{
+	static gint color_mover = 0;
+	static gint color_indexer = -1;
+	const guint32 colors[] = {
+		0x1464ae, /* dark blue */
+		0x14ae64, /* dark green */
+		0xae1464, /* dark red */
+		0
+	};
+	guint32 color;
+
+	if (move_by <= 0)
+		move_by = 1;
+
+	while (move_by > 0) {
+		move_by--;
+
+		color_indexer++;
+		if (colors[color_indexer] == 0) {
+			color_mover += 1;
+			color_indexer = 0;
+		}
+	}
+
+	color = colors[color_indexer];
+	color = (color & ~(0xFF << (color_indexer * 8))) |
+		(((((color >> (color_indexer * 8)) & 0xFF) + (0x33 * color_mover)) % 0xFF) << (color_indexer * 8));
+
+	if (around_middle) {
+		gint rr, gg, bb, diff;
+
+		rr = (0xFF0000 & color) >> 16;
+		gg = (0x00FF00 & color) >>  8;
+		bb = (0x0000FF & color);
+
+		diff = 0x80 - rr;
+		if (diff < 0x80 - gg)
+			diff = 0x80 - gg;
+		if (diff < 0x80 - bb)
+			diff = 0x80 - bb;
+
+		rr = rr + diff < 0 ? 0 : rr + diff > 0xCC ? 0xCC : rr + diff;
+		gg = gg + diff < 0 ? 0 : gg + diff > 0xCC ? 0xCC : gg + diff;
+		bb = bb + diff < 0 ? 0 : bb + diff > 0xCC ? 0xCC : bb + diff;
+
+		color = (rr << 16) + (gg << 8) + bb;
+	}
+
+	return g_strdup_printf ("#%06x", color);
+}
+
+#define EWS_BASE_URI "ews://"
+/* do not unref set ESourceList-s */
+void
+e_ews_folder_utils_manage_source_lists (ESourceList **pcontacts,
+					ESourceList **pevents,
+					ESourceList **pmemos,
+					ESourceList **ptasks,
+					gboolean save_them)
+{
+	static GStaticRecMutex lock = G_STATIC_REC_MUTEX_INIT;
+	static ESourceList *contacts = NULL, *events = NULL, *memos = NULL, *tasks = NULL;
+
+	g_static_rec_mutex_lock (&lock);
+	if (!contacts)
+		contacts = e_source_list_new_for_gconf_default ("/apps/evolution/addressbook/sources");
+	if (!events)
+		events = e_source_list_new_for_gconf_default ("/apps/evolution/calendar/sources");
+	if (!memos)
+		memos = e_source_list_new_for_gconf_default ("/apps/evolution/memos/sources");
+	if (!tasks)
+		tasks = e_source_list_new_for_gconf_default ("/apps/evolution/tasks/sources");
+
+	if (pcontacts)
+		*pcontacts = contacts;
+	if (pevents)
+		*pevents = events;
+	if (pmemos)
+		*pmemos = memos;
+	if (ptasks)
+		*ptasks = tasks;
+
+	if (save_them) {
+		if (contacts)
+			e_source_list_sync (contacts, NULL);
+		if (events)
+			e_source_list_sync (events, NULL);
+		if (memos)
+			e_source_list_sync (memos, NULL);
+		if (tasks)
+			e_source_list_sync (tasks, NULL);
+	}
+
+	g_static_rec_mutex_unlock (&lock);
+}
 
+static gboolean
+e_ews_folder_save_source_lists_cb (gpointer user_data)
+{
+	guint *pscheduled = user_data;
+
+	g_return_val_if_fail (pscheduled != NULL, FALSE);
+
+	*pscheduled = 0;
+
+	e_ews_folder_utils_manage_source_lists (NULL, NULL, NULL, NULL, TRUE);
+
+	return FALSE;
+}
+
+static void
+e_ews_folder_schedule_save_source_lists (void)
+{
+	static guint scheduled = 0;
+
+	if (scheduled)
+		g_source_remove (scheduled);
+
+	scheduled = g_timeout_add_seconds (5, e_ews_folder_save_source_lists_cb, &scheduled);
 }
 
+static gboolean
+e_ews_folder_source_uid_select_cb (gpointer user_data)
+{
+	gchar *source_uid = user_data;
+	const gchar *selected_key = NULL;
+	ESourceList *events = NULL, *memos = NULL, *tasks = NULL;
+
+	g_return_val_if_fail (source_uid != NULL, FALSE);
+
+	e_ews_folder_utils_manage_source_lists (NULL, &events, &memos, &tasks, FALSE);
+	if (events && e_source_list_peek_source_by_uid (events, source_uid))
+		selected_key = "/apps/evolution/calendar/display/selected_calendars";
+	else if (memos && e_source_list_peek_source_by_uid (memos, source_uid))
+		selected_key = "/apps/evolution/calendar/memos/selected_memos";
+	else if (tasks && e_source_list_peek_source_by_uid (tasks, source_uid))
+		selected_key = "/apps/evolution/calendar/tasks/selected_tasks";
+
+	if (selected_key) {
+		GConfClient *gconf_client = gconf_client_get_default ();
+		GSList *ids;
+
+		ids = gconf_client_get_list (gconf_client, selected_key , GCONF_VALUE_STRING, NULL);
+		ids = g_slist_append (ids, g_strdup (source_uid));
+		gconf_client_set_list (gconf_client,  selected_key, GCONF_VALUE_STRING, ids, NULL);
+
+		g_slist_free_full (ids, g_free);
+		g_object_unref (gconf_client);
+	}
+
+	g_free (source_uid);
+
+	return FALSE;
+}
+
+static void
+e_ews_folder_schedule_source_uid_select (const gchar *source_uid)
+{
+	g_idle_add (e_ews_folder_source_uid_select_cb, g_strdup (source_uid));
+}
+
+gboolean
+e_ews_folder_utils_populate_esource (ESource *source,
+                                     const GList *sources,
+                                     CamelURL *setup_url,
+                                     EEwsFolder *folder,
+				     EEwsESourceFlags flags,
+                                     gint color_seed,
+                                     GCancellable *cancellable,
+                                     GError **perror)
+{
+	EEwsFolderType folder_type;
+	const EwsFolderId *folder_id = e_ews_folder_get_id (folder);
+
+	g_return_val_if_fail (setup_url != NULL, FALSE);
+	g_return_val_if_fail (folder_id != NULL, FALSE);
+
+	folder_type = e_ews_folder_get_folder_type (folder);
+
+	switch (folder_type) {
+		case E_EWS_FOLDER_TYPE_CALENDAR:
+		case E_EWS_FOLDER_TYPE_MEMOS:
+		case E_EWS_FOLDER_TYPE_TASKS:
+		case E_EWS_FOLDER_TYPE_CONTACTS:
+			break;
+		default:
+			g_propagate_error (
+				perror, g_error_new_literal (EWS_CONNECTION_ERROR,
+				EWS_CONNECTION_ERROR_NORESPONSE, _("Cannot add folder, unsupported folder type")));
+			return FALSE;
+	}
+
+	e_source_set_name (source, e_ews_folder_get_name (folder));
+
+	e_source_set_property (source, "delete", "no");
+	e_source_set_property (source, "username", setup_url->user);
+	e_source_set_property (source, "auth-domain", "Exchange Web Services");
+	e_source_set_property (source, "email", camel_url_get_param (setup_url, "email"));
+	e_source_set_property (source, "hosturl", camel_url_get_param (setup_url, "hosturl"));
+	e_source_set_property (source, "impersonate_user", camel_url_get_param (setup_url, "impersonate_user"));
+	e_source_set_property (source, "timeout", camel_url_get_param (setup_url, "timeout"));
+
+	e_source_set_property (source, "folder-id", folder_id->id);
+	e_source_set_property (source, "change-key", NULL);
+	e_source_set_property (source, "foreign", e_ews_folder_get_foreign (folder) ? "1" : NULL);
+	e_source_set_property (source, "foreign_subfolders", (flags & E_EWS_ESOURCE_FLAG_INCLUDE_SUBFOLDERS) != 0 ? "1" : NULL);
+	e_source_set_property (source, "public", (flags & E_EWS_ESOURCE_FLAG_PUBLIC_FOLDER) != 0 ? "1" : NULL);
+	e_source_set_property (source, "offline_sync", (flags & E_EWS_ESOURCE_FLAG_OFFLINE_SYNC) != 0 ? "1" : NULL);
+
+	if (folder_type == E_EWS_FOLDER_TYPE_CONTACTS) {
+		e_source_set_property (source, "auth", "plain/password");
+		e_source_set_property (source, "completion", "true");
+	} else {
+		gchar *color_str;
+		gchar *today;
+		GTimeVal today_tv;
+		GDate dt;
+
+		color_str = e_ews_folder_utils_pick_color_spec (
+			1 + g_list_length ((GList *) sources),
+			folder_type != E_EWS_FOLDER_TYPE_CALENDAR);
+		e_source_set_color_spec (source, color_str);
+		g_free (color_str);
+
+		g_date_clear (&dt, 1);
+		g_get_current_time (&today_tv);
+		g_date_set_time_val (&dt, &today_tv);
+
+		/* midnight UTC */
+		today = g_strdup_printf ("%04d-%02d-%02dT00:00:00Z", g_date_get_year (&dt), g_date_get_month (&dt), g_date_get_day (&dt));
+
+		e_source_set_property (source, "auth", "1");
+		e_source_set_property (source, "alarm", "true");
+		e_source_set_property (source, "last-notified", today);
+
+		g_free (today);
+	}
+
+	return TRUE;
+}
+
+gboolean
+e_ews_folder_utils_add_as_esource (CamelURL *setup_url,
+				   const gchar *account_name,
+                                   EEwsFolder *folder,
+				   EEwsESourceFlags flags,
+                                   gint color_seed,
+                                   GCancellable *cancellable,
+                                   GError **perror)
+{
+	GList *sources;
+	ESource *source, *old_source;
+	const EwsFolderId *fid;
+	gboolean res = FALSE;
+
+	g_return_val_if_fail (setup_url != NULL, FALSE);
+	g_return_val_if_fail (account_name != NULL, FALSE);
+
+	fid = e_ews_folder_get_id (folder);
+	sources = e_ews_folder_utils_get_esources (camel_url_get_param (setup_url, "hosturl"), setup_url->user, cancellable, perror);
+
+	old_source = e_ews_folder_utils_get_source_for_folder (sources, camel_url_get_param (setup_url, "hosturl"), setup_url->user, fid->id);
+	if (old_source) {
+		res = FALSE;
+
+		g_propagate_error (
+			perror,
+			g_error_new (EWS_CONNECTION_ERROR, EWS_CONNECTION_ERROR_FOLDEREXISTS,
+			_("Cannot add folder, folder already exists as '%s'"), e_source_peek_name (old_source)));
+	} else {
+		ESourceList *source_list = NULL;
+		ESourceGroup *group = NULL;
+		gchar *relative_uri;
+		gchar *source_uri;
+		GSList *giter;
+
+		switch (e_ews_folder_get_folder_type (folder)) {
+			case E_EWS_FOLDER_TYPE_CALENDAR:
+				e_ews_folder_utils_manage_source_lists (NULL, &source_list, NULL, NULL, FALSE);
+				break;
+			case E_EWS_FOLDER_TYPE_MEMOS:
+				e_ews_folder_utils_manage_source_lists (NULL, NULL, &source_list, NULL, FALSE);
+				break;
+			case E_EWS_FOLDER_TYPE_TASKS:
+				e_ews_folder_utils_manage_source_lists (NULL, NULL, NULL, &source_list, FALSE);
+				break;
+			case E_EWS_FOLDER_TYPE_CONTACTS:
+				e_ews_folder_utils_manage_source_lists (&source_list, NULL, NULL, NULL, FALSE);
+				break;
+			default:
+				source_list = NULL;
+				break;
+		}
+
+		if (!source_list) {
+			g_propagate_error (
+				perror, g_error_new_literal (EWS_CONNECTION_ERROR,
+				EWS_CONNECTION_ERROR_NORESPONSE, _("Cannot add folder, unsupported folder type")));
+			return FALSE;
+		}
+
+		for (giter = e_source_list_peek_groups (source_list); giter; giter = giter->next) {
+			group = giter->data;
+
+			if (group && e_source_group_peek_base_uri (group) &&
+			    g_ascii_strcasecmp (e_source_group_peek_base_uri (group), EWS_BASE_URI) == 0 &&
+			    e_source_group_peek_name (group) &&
+			    g_str_equal (e_source_group_peek_name (group), account_name)) {
+				g_object_ref (group);
+				break;
+			}
+
+			group = NULL;
+		}
+
+		if (!group) {
+			group = e_source_group_new (account_name, EWS_BASE_URI);
+			e_source_group_set_property (group, "create_source", "no");
+
+			e_source_list_add_group (source_list, group, -1);
+		}
+
+		relative_uri = camel_url_to_string (setup_url, CAMEL_URL_HIDE_ALL);
+		g_return_val_if_fail (relative_uri != NULL, FALSE);
+		g_return_val_if_fail (g_ascii_strncasecmp (relative_uri, EWS_BASE_URI, strlen (EWS_BASE_URI)) == 0, FALSE);
+
+		source_uri = g_strdup_printf ("%s;folderid=%s", relative_uri, fid->id);
+		g_free (relative_uri);
+		relative_uri = source_uri;
+
+		source = e_source_new (e_ews_folder_get_name (folder), relative_uri + strlen (EWS_BASE_URI));
+		g_free (relative_uri);
+
+		if (e_ews_folder_utils_populate_esource (
+			source,
+			sources,
+			setup_url,
+			folder,
+			flags,
+			color_seed,
+			cancellable,
+			perror)) {
+			e_source_group_add_source (group, source, -1);
+			e_ews_folder_schedule_save_source_lists ();
+			e_ews_folder_schedule_source_uid_select (e_source_peek_uid (source));
+			res = TRUE;
+		}
+
+		g_object_unref (source);
+		g_object_unref (group);
+	}
+
+	g_list_free_full (sources, g_object_unref);
+
+	return res;
+}
+
+gboolean
+e_ews_folder_utils_remove_as_esource (const gchar *master_hosturl,
+                                      const gchar *master_username,
+                                      const gchar *folder_id,
+                                      GCancellable *cancellable,
+                                      GError **perror)
+{
+	ESource *source;
+	GList *sources;
+	gboolean res = TRUE;
+
+	sources = e_ews_folder_utils_get_esources (master_hosturl, master_username, cancellable, perror);
+	source = e_ews_folder_utils_get_source_for_folder (sources, master_hosturl, master_username, folder_id);
+
+	if (source) {
+		ESourceGroup *group = e_source_peek_group (source);
+
+		if (group && e_source_group_remove_source (group, source)) {
+			if (!e_source_group_peek_sources (group)) {
+				ESourceList *contacts = NULL, *events = NULL, *memos = NULL, *tasks = NULL;
+
+				e_ews_folder_utils_manage_source_lists (&contacts, &events, &memos, &tasks, FALSE);
+				if (!e_source_list_remove_group (contacts, group))
+					if (!e_source_list_remove_group (events, group))
+						if (!e_source_list_remove_group (memos, group))
+							e_source_list_remove_group (tasks, group);
+			}
+
+			e_ews_folder_schedule_save_source_lists ();
+		}
+	}
+
+	g_list_free_full (sources, g_object_unref);
+
+	return res;
+}
+
+gboolean
+e_ews_folder_utils_source_is_for_account (ESource *source,
+					  const gchar *master_hosturl,
+					  const gchar *master_username)
+{
+	ESourceGroup *group;
+	const gchar *prop;
+
+	group = e_source_peek_group (source);
+	if (!group || !e_source_group_peek_base_uri (group) ||
+	    g_ascii_strcasecmp (e_source_group_peek_base_uri (group), EWS_BASE_URI) != 0)
+		return FALSE;
+
+	if (!master_hosturl && !master_username)
+		return TRUE;
+
+	prop = e_source_get_property (source, "hosturl");
+	if (master_hosturl && (!prop || g_ascii_strcasecmp (master_hosturl, prop) != 0))
+		return FALSE;
+
+	prop = e_source_get_property (source, "username");
+	if (master_username && (!prop || g_ascii_strcasecmp (master_username, prop) != 0))
+		return FALSE;
+
+	return TRUE;
+}
+
+static void
+gather_ews_sources (ESourceList *source_list,
+		    const gchar *master_hosturl,
+		    const gchar *master_username,
+		    GList **esources)
+{
+	GSList *giter, *siter;
+
+	g_return_if_fail (source_list != NULL);
+	g_return_if_fail (esources != NULL);
+
+	for (giter = e_source_list_peek_groups (source_list); giter; giter = giter->next) {
+		ESourceGroup *group = giter->data;
+
+		if (group && e_source_group_peek_base_uri (group) &&
+		    g_ascii_strcasecmp (e_source_group_peek_base_uri (group), EWS_BASE_URI) == 0) {
+			for (siter = e_source_group_peek_sources (group); siter; siter = siter->next) {
+				ESource *source = siter->data;
+
+				if (source && e_ews_folder_utils_source_is_for_account (source, master_hosturl, master_username))
+					*esources = g_list_prepend (*esources, g_object_ref (source));
+			}
+		}
+	}
+}
+
+GList *
+e_ews_folder_utils_get_esources (const gchar *master_hosturl,
+				 const gchar *master_username,
+				 GCancellable *cancellable,
+				 GError **perror)
+{
+	ESourceList *contacts = NULL, *events = NULL, *memos = NULL, *tasks = NULL;
+	GList *esources = NULL;
+
+	e_ews_folder_utils_manage_source_lists (&contacts, &events, &memos, &tasks, FALSE);
+
+	gather_ews_sources (contacts, master_hosturl, master_username, &esources);
+	gather_ews_sources (events, master_hosturl, master_username, &esources);
+	gather_ews_sources (memos, master_hosturl, master_username, &esources);
+	gather_ews_sources (tasks, master_hosturl, master_username, &esources);
+
+	return g_list_reverse (esources);
+}
+
+gboolean
+e_ews_folder_utils_is_subscribed_as_esource (const GList *esources,
+                                             const gchar *master_hosturl,
+                                             const gchar *master_username,
+                                             const gchar *folder_id)
+{
+	return e_ews_folder_utils_get_source_for_folder (esources, master_hosturl, master_username, folder_id) != NULL;
+}
+
+/* filters @esources thus the resulting list will contain ESource-s only for @profile;
+ * free returned list with g_list_free_full (list, g_object_unref); */
+GList *
+e_ews_folder_utils_filter_sources_for_account (const GList *esources,
+                                               const gchar *master_hosturl,
+                                               const gchar *master_username)
+{
+	GList *found = NULL;
+	const GList *iter;
+
+	for (iter = esources; iter; iter = iter->next) {
+		ESource *source = iter->data;
+
+		if (e_ews_folder_utils_source_is_for_account (source, master_hosturl, master_username))
+			found = g_list_prepend (found, g_object_ref (source));
+	}
+
+	return g_list_reverse (found);
+}
+
+/* returns (not-reffed) member of @esources, which is for @profile and @folder_id */
+ESource *
+e_ews_folder_utils_get_source_for_folder (const GList *esources,
+                                          const gchar *master_hosturl,
+                                          const gchar *master_username,
+                                          const gchar *folder_id)
+{
+	const GList *iter;
+
+	for (iter = esources; iter; iter = iter->next) {
+		ESource *source = iter->data;
+
+		if (e_ews_folder_utils_source_is_for_account (source, master_hosturl, master_username)) {
+			const gchar *source_folder_id = e_source_get_property (source, "folder-id");
+
+			if (source_folder_id && g_str_equal (source_folder_id, folder_id))
+				return source;
+		}
+	}
+
+	return NULL;
+}
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-ews-folder.h evolution-ews.sync-with-3.8.2/src/server/e-ews-folder.h
--- evolution-ews.git-gnome-3-0/src/server/e-ews-folder.h	2013-05-17 14:36:16.356671234 +0200
+++ evolution-ews.sync-with-3.8.2/src/server/e-ews-folder.h	2013-05-28 08:59:53.421724250 +0200
@@ -22,6 +22,12 @@
 #ifndef E_EWS_FOLDER_H
 #define E_EWS_FOLDER_H
 
+#include <gio/gio.h>
+#include <libedataserver/e-source.h>
+#include <libedataserver/e-source-list.h>
+#include <camel/camel.h>
+
+#include "e-ews-enums.h"
 #include "e-soap-message.h"
 
 G_BEGIN_DECLS
@@ -45,14 +51,6 @@ struct _EEwsFolderClass {
 	GObjectClass parent_class;
 };
 
-typedef enum {
-	EWS_FOLDER_TYPE_MAILBOX,
-	EWS_FOLDER_TYPE_CALENDAR,
-	EWS_FOLDER_TYPE_CONTACTS,
-	EWS_FOLDER_TYPE_QUERY,
-	EWS_FOLDER_TYPE_TASKS
-} EwsFolderType;
-
 typedef struct {
 	gchar *id;
 	gchar *change_key;
@@ -60,7 +58,12 @@ typedef struct {
 } EwsFolderId;
 
 GType		e_ews_folder_get_type (void);
+const gchar *	e_ews_folder_type_to_nick (EEwsFolderType folder_type);
+EEwsFolderType	e_ews_folder_type_from_nick (const gchar *folder_type_nick);
 EEwsFolder *	e_ews_folder_new_from_soap_parameter (ESoapParameter *param);
+EEwsFolder *	e_ews_folder_new_from_error (const GError *error);
+gboolean	e_ews_folder_is_error (EEwsFolder *folder);
+const GError *	e_ews_folder_get_error (EEwsFolder *folder);
 const gchar *	e_ews_folder_get_name (EEwsFolder *folder);
 void		e_ews_folder_set_name (EEwsFolder *folder, const gchar *new_name);
 void		e_ews_folder_set_parent_id (EEwsFolder *folder, EwsFolderId *fid);
@@ -73,10 +76,68 @@ guint32		e_ews_folder_get_unread_count (
 guint32		e_ews_folder_get_child_count (EEwsFolder *folder);
 gboolean	e_ews_folder_get_is_writable (EEwsFolder *folder);
 void		e_ews_folder_set_is_writable (EEwsFolder *folder, gboolean writable);
-EwsFolderType	e_ews_folder_get_folder_type (EEwsFolder *folder);
-void 		e_ews_folder_set_folder_type (EEwsFolder *folder, EwsFolderType folder_type);
+EEwsFolderType	e_ews_folder_get_folder_type (EEwsFolder *folder);
+void		e_ews_folder_set_folder_type (EEwsFolder *folder, EEwsFolderType folder_type);
+gboolean	e_ews_folder_get_foreign (EEwsFolder *folder);
+void		e_ews_folder_set_foreign (EEwsFolder *folder, gboolean is_foreign);
+
+EwsFolderId *	e_ews_folder_id_new (const gchar *id,
+				     const gchar *change_key,
+				     gboolean is_distinguished_id);
+void		e_ews_folder_id_free (EwsFolderId *fid);
 
-void		e_ews_folder_free_fid (EwsFolderId *fid);
+typedef enum {
+	E_EWS_ESOURCE_FLAG_NONE			= 0,
+	E_EWS_ESOURCE_FLAG_INCLUDE_SUBFOLDERS	= 1 << 0,
+	E_EWS_ESOURCE_FLAG_OFFLINE_SYNC		= 1 << 1,
+	E_EWS_ESOURCE_FLAG_PUBLIC_FOLDER	= 1 << 2
+} EEwsESourceFlags;
+
+gchar *		e_ews_folder_utils_pick_color_spec		(gint move_by,
+								 gboolean around_middle);
+gboolean	e_ews_folder_utils_populate_esource		(ESource *source,
+								 const GList *sources,
+								 CamelURL *setup_url,
+								 EEwsFolder *folder,
+								 EEwsESourceFlags flags,
+								 gint color_seed,
+								 GCancellable *cancellable,
+								 GError **perror);
+gboolean	e_ews_folder_utils_add_as_esource		(CamelURL *setup_url,
+								 const gchar *account_name,
+								 EEwsFolder *folder,
+								 EEwsESourceFlags flags,
+								 gint color_seed,
+								 GCancellable *cancellable,
+								 GError **perror);
+gboolean	e_ews_folder_utils_remove_as_esource		(const gchar *master_hosturl,
+								 const gchar *master_username,
+								 const gchar *folder_id,
+								 GCancellable *cancellable,
+								 GError **perror);
+GList *		e_ews_folder_utils_get_esources			(const gchar *master_hosturl,
+								 const gchar *master_username,
+								 GCancellable *cancellable,
+								 GError **perror);
+gboolean	e_ews_folder_utils_is_subscribed_as_esource	(const GList *esources,
+								 const gchar *master_hosturl,
+								 const gchar *master_username,
+								 const gchar *folder_id);
+GList *		e_ews_folder_utils_filter_sources_for_account	(const GList *esources,
+								 const gchar *master_hosturl,
+								 const gchar *master_username);
+ESource *	e_ews_folder_utils_get_source_for_folder	(const GList *esources,
+								 const gchar *master_hosturl,
+								 const gchar *master_username,
+								 const gchar *folder_id);
+void		e_ews_folder_utils_manage_source_lists		(ESourceList **pcontacts,
+								 ESourceList **pevents,
+								 ESourceList **pmemos,
+								 ESourceList **ptasks,
+								 gboolean save_them);
+gboolean	e_ews_folder_utils_source_is_for_account	(ESource *source,
+								 const gchar *master_hosturl,
+								 const gchar *master_username);
 
 G_END_DECLS
 
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-ews-gnome-3-8-compat.c evolution-ews.sync-with-3.8.2/src/server/e-ews-gnome-3-8-compat.c
--- evolution-ews.git-gnome-3-0/src/server/e-ews-gnome-3-8-compat.c	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/server/e-ews-gnome-3-8-compat.c	2013-05-28 08:59:53.426713239 +0200
@@ -0,0 +1,488 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/*
+ * Authors :
+ *  Milan Crha <mcrha@redhat.com>
+ *
+ * Copyright © 2013 Red Hat, inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU Lesser General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
+ * USA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <libedataserver/e-data-server-util.h>
+#include <errno.h>
+
+#include "e-ews-gnome-3-8-compat.h"
+
+void
+g_simple_async_result_take_error (GSimpleAsyncResult *result,
+				  GError *error)
+{
+	if (error) {
+		g_simple_async_result_set_from_error (result, error);
+		g_clear_error (&error);
+	}
+}
+
+void
+g_simple_async_result_set_check_cancellable (GSimpleAsyncResult *simple,
+					     GCancellable *check_cancellable)
+{
+	/* no way to mimic this */
+}
+
+const gchar *
+soup_uri_get_host (SoupURI *suri)
+{
+	g_return_val_if_fail (suri != NULL, NULL);
+
+	return suri->host;
+}
+
+const gchar *
+soup_uri_get_scheme (SoupURI *suri)
+{
+	g_return_val_if_fail (suri != NULL, NULL);
+
+	return suri->scheme;
+}
+
+void
+g_mutex_init (GMutex **mutex)
+{
+	g_return_if_fail (mutex != NULL);
+
+	*mutex = g_mutex_new ();
+}
+
+void
+g_mutex_clear (GMutex **mutex)
+{
+	g_return_if_fail (mutex != NULL);
+
+	if (*mutex) {
+		g_mutex_free (*mutex);
+		*mutex = NULL;
+	}
+}
+
+gchar *
+e_util_strdup_strip (const gchar *string)
+{
+	gchar *duplicate;
+
+	duplicate = g_strdup (string);
+	if (duplicate != NULL) {
+		g_strstrip (duplicate);
+		if (*duplicate == '\0') {
+			g_free (duplicate);
+			duplicate = NULL;
+		}
+	}
+
+	return duplicate;
+}
+
+struct _EAsyncClosure {
+	GMainLoop *loop;
+	GMainContext *context;
+	GAsyncResult *result;
+};
+
+EAsyncClosure *
+e_async_closure_new (void)
+{
+	EAsyncClosure *closure;
+
+	closure = g_slice_new0 (EAsyncClosure);
+	closure->context = g_main_context_new ();
+	closure->loop = g_main_loop_new (closure->context, FALSE);
+
+	g_main_context_push_thread_default (closure->context);
+
+	return closure;
+}
+
+GAsyncResult *
+e_async_closure_wait (EAsyncClosure *closure)
+{
+	g_return_val_if_fail (closure != NULL, NULL);
+
+	g_main_loop_run (closure->loop);
+
+	return closure->result;
+}
+
+void
+e_async_closure_free (EAsyncClosure *closure)
+{
+	g_return_if_fail (closure != NULL);
+
+	g_main_context_pop_thread_default (closure->context);
+
+	g_main_loop_unref (closure->loop);
+	g_main_context_unref (closure->context);
+
+	if (closure->result != NULL)
+		g_object_unref (closure->result);
+
+	g_slice_free (EAsyncClosure, closure);
+}
+
+void
+e_async_closure_callback (GObject *object,
+                          GAsyncResult *result,
+                          gpointer closure)
+{
+	EAsyncClosure *real_closure;
+
+	g_return_if_fail (G_IS_ASYNC_RESULT (result));
+	g_return_if_fail (closure != NULL);
+
+	real_closure = closure;
+
+	/* Replace any previous result. */
+	if (real_closure->result != NULL)
+		g_object_unref (real_closure->result);
+	real_closure->result = g_object_ref (result);
+
+	g_main_loop_quit (real_closure->loop);
+}
+
+void
+g_slist_free_full (GSList *slist,
+		   GDestroyNotify destroy_func)
+{
+	g_slist_foreach (slist, (GFunc) destroy_func, NULL);
+	g_slist_free (slist);
+}
+
+void
+g_list_free_full (GList *list,
+		  GDestroyNotify destroy_func)
+{
+	g_list_foreach (list, (GFunc) destroy_func, NULL);
+	g_list_free (list);
+}
+
+static GStaticRecMutex service_dir_lock = G_STATIC_REC_MUTEX_INIT;
+
+const gchar *
+camel_service_get_user_data_dir (CamelService *service)
+{
+	gchar *value;
+	gchar *service_path;
+
+	g_return_val_if_fail (CAMEL_IS_SERVICE (service), NULL);
+
+	g_static_rec_mutex_lock (&service_dir_lock);
+
+	value = g_object_get_data (G_OBJECT (service), "camel::user-data-dir");
+	if (value) {
+		g_static_rec_mutex_unlock (&service_dir_lock);
+		return value;
+	}
+
+	service_path = camel_service_get_path (service);
+	value = g_build_filename (
+		e_get_user_data_dir (), "mail", service_path, NULL);
+	g_free (service_path);
+
+	g_object_set_data_full (G_OBJECT (service), "camel::user-data-dir", value, g_free);
+	g_static_rec_mutex_unlock (&service_dir_lock);
+
+	if (g_mkdir_with_parents (value, S_IRWXU) == -1) {
+		g_warning (
+			"Could not create directory %s:\n%s",
+			value, g_strerror (errno));
+	}
+
+	return value;
+}
+
+const gchar *
+camel_service_get_user_cache_dir (CamelService *service)
+{
+	gchar *value;
+	gchar *service_path;
+
+	g_return_val_if_fail (CAMEL_IS_SERVICE (service), NULL);
+
+	g_static_rec_mutex_lock (&service_dir_lock);
+
+	value = g_object_get_data (G_OBJECT (service), "camel::user-cache-dir");
+	if (value) {
+		g_static_rec_mutex_unlock (&service_dir_lock);
+		return value;
+	}
+
+	service_path = camel_service_get_path (service);
+	value = g_build_filename (
+		e_get_user_cache_dir (), "mail", service_path, NULL);
+	g_free (service_path);
+
+	g_object_set_data_full (G_OBJECT (service), "camel::user-cache-dir", value, g_free);
+	g_static_rec_mutex_unlock (&service_dir_lock);
+
+	if (g_mkdir_with_parents (value, S_IRWXU) == -1) {
+		g_warning (
+			"Could not create directory %s:\n%s",
+			value, g_strerror (errno));
+	}
+
+	return value;
+}
+
+int
+g_access (const gchar *filename,
+	  int          mode)
+{
+#ifdef G_OS_WIN32
+  wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
+  int retval;
+  int save_errno;
+    
+  if (wfilename == NULL)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+
+#ifndef X_OK
+#define X_OK 1
+#endif
+
+  retval = _waccess (wfilename, mode & ~X_OK);
+  save_errno = errno;
+
+  g_free (wfilename);
+
+  errno = save_errno;
+  return retval;
+#else
+  return access (filename, mode);
+#endif
+}
+
+gboolean
+g_hash_table_contains (GHashTable *table,
+		       gconstpointer key)
+{
+	gpointer orig_key, orig_value;
+
+	g_return_val_if_fail (table != NULL, FALSE);
+
+	return g_hash_table_lookup_extended (table, key, &orig_key, &orig_value);
+}
+
+guint
+camel_folder_summary_get_deleted_count (CamelFolderSummary *summary)
+{
+	if (!summary)
+		return 0;
+	return summary->deleted_count;
+}
+
+guint
+camel_folder_summary_get_junk_count (CamelFolderSummary *summary)
+{
+	if (!summary)
+		return 0;
+	return summary->junk_count;
+}
+
+guint
+camel_folder_summary_get_unread_count (CamelFolderSummary *summary)
+{
+	if (!summary)
+		return 0;
+	return summary->unread_count;
+}
+
+void
+camel_folder_summary_free_array (GPtrArray *array)
+{
+	if (!array)
+		return;
+
+	g_ptr_array_foreach (array, (GFunc) camel_pstring_free, NULL);
+	g_ptr_array_free (array, TRUE);
+}
+
+void
+camel_operation_push_message (GCancellable *cancellable,
+			      const gchar *text)
+{
+	camel_operation_start_transient (NULL, "%s", text);
+}
+
+void
+camel_operation_pop_message (GCancellable *cancellable)
+{
+	camel_operation_end (NULL);
+}
+
+CamelSession *
+camel_service_ref_session (CamelService *service)
+{
+	CamelSession *session;
+
+	g_return_val_if_fail (CAMEL_IS_SERVICE (service), NULL);
+
+	session = camel_service_get_session (service);
+	if (session)
+		g_object_ref (session);
+
+	return session;
+}
+
+/* Prioritize ahead of GTK+ redraws. */
+#define JOB_PRIORITY G_PRIORITY_HIGH_IDLE
+
+typedef struct _JobData JobData;
+struct _JobData {
+	CamelSession *session;
+	GCancellable *cancellable;
+	CamelSessionCallback callback;
+	gpointer user_data;
+	GDestroyNotify notify;
+};
+
+static void
+job_data_free (JobData *job_data)
+{
+	g_object_unref (job_data->session);
+	g_object_unref (job_data->cancellable);
+
+	if (job_data->notify != NULL)
+		job_data->notify (job_data->user_data);
+
+	g_slice_free (JobData, job_data);
+}
+
+static void
+session_finish_job_cb (CamelSession *session,
+                       GSimpleAsyncResult *simple)
+{
+	JobData *job_data;
+	GError *error = NULL;
+
+	g_simple_async_result_propagate_error (simple, &error);
+	job_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	g_clear_error (&error);
+}
+
+static void
+session_do_job_cb (GSimpleAsyncResult *simple,
+                   CamelSession *session,
+                   GCancellable *cancellable)
+{
+	JobData *job_data;
+	GError *error = NULL;
+
+	job_data = g_simple_async_result_get_op_res_gpointer (simple);
+
+	job_data->callback (
+		session, cancellable,
+		job_data->user_data, &error);
+
+	if (error != NULL)
+		g_simple_async_result_take_error (simple, error);
+}
+
+static gboolean
+session_start_job_cb (gpointer user_data)
+{
+	JobData *job_data = user_data;
+	GSimpleAsyncResult *simple;
+
+	simple = g_simple_async_result_new (
+		G_OBJECT (job_data->session),
+		(GAsyncReadyCallback) session_finish_job_cb,
+		NULL, camel_session_submit_job);
+
+	g_simple_async_result_set_check_cancellable (
+		simple, job_data->cancellable);
+
+	g_simple_async_result_set_op_res_gpointer (
+		simple, job_data, (GDestroyNotify) job_data_free);
+
+	g_simple_async_result_run_in_thread (
+		simple, (GSimpleAsyncThreadFunc)
+		session_do_job_cb, JOB_PRIORITY,
+		job_data->cancellable);
+
+	g_object_unref (simple);
+
+	return FALSE;
+}
+
+static guint
+camel_session_idle_add (CamelSession *session,
+                        gint priority,
+                        GSourceFunc function,
+                        gpointer data,
+                        GDestroyNotify notify)
+{
+	GMainContext *main_context;
+	GSource *source;
+	guint source_id;
+
+	g_return_val_if_fail (CAMEL_IS_SESSION (session), 0);
+	g_return_val_if_fail (function != NULL, 0);
+
+	main_context = g_main_context_default ();
+
+	source = g_idle_source_new ();
+
+	if (priority != G_PRIORITY_DEFAULT_IDLE)
+		g_source_set_priority (source, priority);
+
+	g_source_set_callback (source, function, data, notify);
+
+	source_id = g_source_attach (source, main_context);
+
+	g_source_unref (source);
+
+	return source_id;
+}
+
+void
+camel_session_submit_job (CamelSession *session,
+			  CamelSessionCallback callback,
+			  gpointer user_data,
+			  GDestroyNotify notify)
+{
+	JobData *job_data;
+
+	g_return_if_fail (CAMEL_IS_SESSION (session));
+	g_return_if_fail (callback != NULL);
+
+	job_data = g_slice_new0 (JobData);
+	job_data->session = g_object_ref (session);
+	job_data->cancellable = g_cancellable_new ();
+	job_data->callback = callback;
+	job_data->user_data = user_data;
+	job_data->notify = notify;
+
+	camel_session_idle_add (
+		session, JOB_PRIORITY,
+		session_start_job_cb,
+		job_data, (GDestroyNotify) NULL);
+}
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-ews-gnome-3-8-compat.h evolution-ews.sync-with-3.8.2/src/server/e-ews-gnome-3-8-compat.h
--- evolution-ews.git-gnome-3-0/src/server/e-ews-gnome-3-8-compat.h	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/server/e-ews-gnome-3-8-compat.h	2013-05-28 08:59:53.429713328 +0200
@@ -0,0 +1,107 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/*
+ * Authors :
+ *  Milan Crha <mcrha@redhat.com>
+ *
+ * Copyright © 2013 Red Hat, inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU Lesser General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
+ * USA
+ */
+
+#ifndef E_EWS_GNOME_3_8_COMPAT_H
+#define E_EWS_GNOME_3_8_COMPAT_H
+
+#include <libsoup/soup.h>
+#include <gio/gio.h>
+#include <camel/camel.h>
+
+void		g_simple_async_result_take_error(GSimpleAsyncResult *result,
+						 GError *error);
+void		g_simple_async_result_set_check_cancellable
+						(GSimpleAsyncResult *simple,
+						 GCancellable *check_cancellable);
+
+const gchar *	soup_uri_get_host		(SoupURI *suri);
+const gchar *	soup_uri_get_scheme		(SoupURI *suri);
+
+void		g_mutex_init			(GMutex **mutex);
+void		g_mutex_clear			(GMutex **mutex);
+
+#define GRecMutex GStaticRecMutex
+#define g_rec_mutex_init g_static_rec_mutex_init
+#define g_rec_mutex_clear g_static_rec_mutex_free
+#define g_rec_mutex_lock g_static_rec_mutex_lock
+#define g_rec_mutex_unlock g_static_rec_mutex_unlock
+
+gchar *		e_util_strdup_strip		(const gchar *string);
+
+typedef struct _EAsyncClosure EAsyncClosure;
+
+EAsyncClosure *	e_async_closure_new		(void);
+GAsyncResult *	e_async_closure_wait		(EAsyncClosure *closure);
+void		e_async_closure_free		(EAsyncClosure *closure);
+void		e_async_closure_callback	(GObject *object,
+						 GAsyncResult *result,
+						 gpointer closure);
+
+void		g_slist_free_full		(GSList *slist,
+						 GDestroyNotify destroy_func);
+void		g_list_free_full		(GList *list,
+						 GDestroyNotify destroy_func);
+
+const gchar *	camel_service_get_user_data_dir	(CamelService *service);
+const gchar *	camel_service_get_user_cache_dir(CamelService *service);
+
+int		g_access			(const gchar *filename,
+						 int mode);
+gboolean	g_hash_table_contains		(GHashTable *table,
+						 gconstpointer key);
+
+guint		camel_folder_summary_get_deleted_count
+						(CamelFolderSummary *summary);
+guint		camel_folder_summary_get_junk_count
+						(CamelFolderSummary *summary);
+guint		camel_folder_summary_get_unread_count
+						(CamelFolderSummary *summary);
+#define camel_folder_summary_get_array camel_folder_summary_array
+#define camel_folder_summary_get camel_folder_summary_uid
+void		camel_folder_summary_free_array	(GPtrArray *array);
+
+#define CamelSubscribable CamelStore
+#define CAMEL_SUBSCRIBABLE CAMEL_STORE
+#define camel_subscribable_folder_subscribed camel_store_folder_subscribed
+#define camel_subscribable_folder_unsubscribed camel_store_folder_unsubscribed
+
+#define CAMEL_FOLDER_TYPE_CONTACTS (0)
+#define CAMEL_FOLDER_TYPE_EVENTS   (0)
+#define CAMEL_FOLDER_TYPE_MEMOS    (0)
+#define CAMEL_FOLDER_TYPE_TASKS    (0)
+
+void		camel_operation_push_message	(GCancellable *cancellable,
+						 const gchar *text);
+void		camel_operation_pop_message	(GCancellable *cancellable);
+CamelSession *	camel_service_ref_session	(CamelService *service);
+
+typedef void	(*CamelSessionCallback)		(CamelSession *session,
+						 GCancellable *cancellable,
+						 gpointer user_data,
+						 GError **error);
+
+void		camel_session_submit_job	(CamelSession *session,
+						 CamelSessionCallback callback,
+						 gpointer user_data,
+						 GDestroyNotify notify);
+
+#endif /* E_EWS_GNOME_3_8_COMPAT_H */
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-ews-item.c evolution-ews.sync-with-3.8.2/src/server/e-ews-item.c
--- evolution-ews.git-gnome-3-0/src/server/e-ews-item.c	2013-05-17 14:36:16.357671048 +0200
+++ evolution-ews.sync-with-3.8.2/src/server/e-ews-item.c	2013-05-28 08:59:53.427713238 +0200
@@ -21,6 +21,7 @@
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
+
 #include <string.h>
 #include <errno.h>
 #include <sys/types.h>
@@ -34,18 +35,21 @@
 #include "e-ews-connection.h"
 #include "e-ews-message.h"
 
+#include "e-ews-gnome-3-8-compat.h"
+
 #ifdef G_OS_WIN32
 
 static gchar *
-g_mkdtemp (gchar *tmpl, int mode)
+g_mkdtemp (gchar *tmpl,
+           gint mode)
 {
-	static const char letters[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
-	static const int NLETTERS = sizeof (letters) - 1;
-	static int counter = 0;
-	char *XXXXXX;
+	static const gchar letters[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
+	static const gint NLETTERS = sizeof (letters) - 1;
+	static gint counter = 0;
+	gchar *XXXXXX;
 	GTimeVal tv;
 	glong value;
-	int count;
+	gint count;
 
 	/* find the last occurrence of "XXXXXX" */
 	XXXXXX = g_strrstr (tmpl, "XXXXXX");
@@ -100,7 +104,7 @@ G_DEFINE_TYPE (EEwsItem, e_ews_item, G_T
 struct _EEwsContactFields {
 	gchar *fileas;
 	EwsCompleteName *complete_name;
-	
+
 	GHashTable *email_addresses;
 	GHashTable *physical_addresses;
 	GHashTable *phone_numbers;
@@ -112,16 +116,17 @@ struct _EEwsContactFields {
 	gchar *assistant_name;
 	gchar *manager;
 	gchar *office_location;
-	
+
 	gchar *business_homepage;
-	
+
 	time_t birthday;
 	time_t wedding_anniversary;
-	
+
 	gchar *profession;
 	gchar *spouse_name;
 	gchar *culture;
 	gchar *surname;
+	gchar *notes;
 };
 
 struct _EEwsTaskFields {
@@ -142,15 +147,16 @@ struct _EEwsTaskFields {
 struct _EEwsItemPrivate {
 	EwsId *attachment_id;
 	EEwsItemType item_type;
+	GError *error;
 
 	/* MAPI properties */
 	/* The Exchange server is so fundamentally misdesigned that it doesn't expose
-	   certain information in a coherent way; the \Answered, and \Deleted message
-	   flags don't even seem to work properly. It looks like the only way to work
-	   it out is from the PidTagIconIndex field. Quite what the hell an *icon*
-	   selector is doing in the database, I have absolutely no fucking idea; a
-	   database is supposed to represent the *data*, not do bizarre things that
-	   live in the client. But that's typical Exchange brain damage for you... */
+	 * certain information in a coherent way; the \Answered, and \Deleted message
+	 * flags don't even seem to work properly. It looks like the only way to work
+	 * it out is from the PidTagIconIndex field. Quite what the hell an *icon*
+	 * selector is doing in the database, I have absolutely no fucking idea; a
+	 * database is supposed to represent the *data*, not do bizarre things that
+	 * live in the client. But that's typical Exchange brain damage for you... */
 	guint32 mapi_icon_index;		/* http://msdn.microsoft.com/en-us/library/cc815472.aspx */
 	guint32 mapi_last_verb_executed;	/* http://msdn.microsoft.com/en-us/library/cc841968.aspx */
 	guint32 mapi_message_status;		/* http://msdn.microsoft.com/en-us/library/cc839915.aspx */
@@ -200,7 +206,6 @@ struct _EEwsItemPrivate {
 };
 
 static GObjectClass *parent_class = NULL;
-static void	ews_item_free_mailbox (EwsMailbox *mb);
 static void	ews_item_free_attendee (EwsAttendee *attendee);
 static void	ews_free_contact_fields (struct _EEwsContactFields *con_fields);
 
@@ -216,6 +221,8 @@ e_ews_item_dispose (GObject *object)
 
 	priv = item->priv;
 
+	g_clear_error (&priv->error);
+
 	if (priv->item_id) {
 		g_free (priv->item_id->id);
 		g_free (priv->item_id->change_key);
@@ -251,19 +258,19 @@ e_ews_item_dispose (GObject *object)
 	priv->timezone = NULL;
 
 	if (priv->to_recipients) {
-		g_slist_foreach (priv->to_recipients, (GFunc) ews_item_free_mailbox, NULL);
+		g_slist_foreach (priv->to_recipients, (GFunc) e_ews_mailbox_free, NULL);
 		g_slist_free (priv->to_recipients);
 		priv->to_recipients = NULL;
 	}
 
 	if (priv->cc_recipients) {
-		g_slist_foreach (priv->cc_recipients, (GFunc) ews_item_free_mailbox, NULL);
+		g_slist_foreach (priv->cc_recipients, (GFunc) e_ews_mailbox_free, NULL);
 		g_slist_free (priv->cc_recipients);
 		priv->cc_recipients = NULL;
 	}
 
 	if (priv->bcc_recipients) {
-		g_slist_foreach (priv->bcc_recipients, (GFunc) ews_item_free_mailbox, NULL);
+		g_slist_foreach (priv->bcc_recipients, (GFunc) e_ews_mailbox_free, NULL);
 		g_slist_free (priv->bcc_recipients);
 		priv->bcc_recipients = NULL;
 	}
@@ -294,8 +301,8 @@ e_ews_item_dispose (GObject *object)
 		priv->calendar_item_accept_id = NULL;
 	}
 
-	ews_item_free_mailbox (priv->sender);
-	ews_item_free_mailbox (priv->from);
+	e_ews_mailbox_free (priv->sender);
+	e_ews_mailbox_free (priv->from);
 
 	if (priv->item_type == E_EWS_ITEM_TYPE_CONTACT)
 		ews_free_contact_fields (priv->contact_fields);
@@ -365,7 +372,7 @@ ews_free_contact_fields (struct _EEwsCon
 	if (con_fields) {
 		if (con_fields->complete_name) {
 			EwsCompleteName *cn = con_fields->complete_name;
-			
+
 			g_free (cn->title);
 			g_free (cn->first_name);
 			g_free (cn->middle_name);
@@ -380,16 +387,16 @@ ews_free_contact_fields (struct _EEwsCon
 
 		if (con_fields->email_addresses)
 			g_hash_table_destroy (con_fields->email_addresses);
-		
+
 		if (con_fields->physical_addresses)
 			g_hash_table_destroy (con_fields->physical_addresses);
-		
+
 		if (con_fields->phone_numbers)
 			g_hash_table_destroy (con_fields->phone_numbers);
-		
+
 		if (con_fields->im_addresses)
 			g_hash_table_destroy (con_fields->im_addresses);
-		
+
 		g_free (con_fields->fileas);
 		g_free (con_fields->company_name);
 		g_free (con_fields->department);
@@ -402,17 +409,8 @@ ews_free_contact_fields (struct _EEwsCon
 		g_free (con_fields->spouse_name);
 		g_free (con_fields->culture);
 		g_free (con_fields->surname);
+		g_free (con_fields->notes);
 		g_free (con_fields);
-	}	
-}
-
-static void
-ews_item_free_mailbox (EwsMailbox *mb)
-{
-	if (mb) {
-		g_free (mb->name);
-		g_free (mb->email);
-		g_free (mb);
 	}
 }
 
@@ -420,7 +418,7 @@ static void
 ews_item_free_attendee (EwsAttendee *attendee)
 {
 	if (attendee) {
-		ews_item_free_mailbox (attendee->mailbox);
+		e_ews_mailbox_free (attendee->mailbox);
 		g_free (attendee->responsetype);
 		g_free (attendee);
 	}
@@ -466,7 +464,9 @@ ews_item_parse_date (const gchar *dtstri
 	return t;
 }
 
-static void parse_extended_property (EEwsItemPrivate *priv, ESoapParameter *param)
+static void
+parse_extended_property (EEwsItemPrivate *priv,
+                         ESoapParameter *param)
 {
 	ESoapParameter *subparam;
 	gchar *str;
@@ -523,12 +523,15 @@ static void parse_extended_property (EEw
 		break;
 
 	default:
-		g_print ("Fetched unrecognised MAPI property 0x%x, value %d\n",
-			 tag, value);
+		g_print (
+			"Fetched unrecognised MAPI property 0x%x, value %d\n",
+			tag, value);
 	}
 }
 
-static void parse_categories (EEwsItemPrivate *priv, ESoapParameter *param)
+static void
+parse_categories (EEwsItemPrivate *priv,
+                  ESoapParameter *param)
 {
 	gchar *value;
 	ESoapParameter *subparam;
@@ -541,12 +544,12 @@ static void parse_categories (EEwsItemPr
 	}
 
 	/* categories are an array of <string> */
-	for (subparam = e_soap_parameter_get_first_child(param);
+	for (subparam = e_soap_parameter_get_first_child (param);
 	     subparam != NULL;
-	     subparam = e_soap_parameter_get_next_child(subparam)) {
+	     subparam = e_soap_parameter_get_next_child (subparam)) {
 		value = e_soap_parameter_get_string_value (subparam);
 
-		priv->categories = g_slist_append(priv->categories, value);
+		priv->categories = g_slist_append (priv->categories, value);
 	}
 
 }
@@ -568,22 +571,27 @@ parse_importance (ESoapParameter *param)
 	return importance;
 }
 
-static void process_modified_occurrences(EEwsItemPrivate *priv, ESoapParameter *param) {
+static void
+process_modified_occurrences (EEwsItemPrivate *priv,
+                              ESoapParameter *param)
+{
 	ESoapParameter *subparam, *subparam1;
 	gchar *modified_occurrence_id;
 
-	for (subparam = e_soap_parameter_get_first_child(param); subparam != NULL; subparam = e_soap_parameter_get_next_child(subparam)) {
+	for (subparam = e_soap_parameter_get_first_child (param); subparam != NULL; subparam = e_soap_parameter_get_next_child (subparam)) {
 
-		subparam1 = e_soap_parameter_get_first_child_by_name(subparam, "ItemId");
-		modified_occurrence_id = e_soap_parameter_get_property(subparam1, "Id");
-		priv->modified_occurrences = g_slist_append(priv->modified_occurrences, modified_occurrence_id);
+		subparam1 = e_soap_parameter_get_first_child_by_name (subparam, "ItemId");
+		modified_occurrence_id = e_soap_parameter_get_property (subparam1, "Id");
+		priv->modified_occurrences = g_slist_append (priv->modified_occurrences, modified_occurrence_id);
 	}
 
 	return;
 }
 
-static void process_attachments_list(EEwsItemPrivate *priv, ESoapParameter *param) {
-
+static void
+process_attachments_list (EEwsItemPrivate *priv,
+                          ESoapParameter *param)
+{
 	ESoapParameter *subparam, *subparam1;
 
 	GSList *list = NULL;
@@ -599,17 +607,21 @@ static void process_attachments_list(EEw
 	return;
 }
 
-static void process_attendees(EEwsItemPrivate *priv, ESoapParameter *param, const gchar *type) {
+static void
+process_attendees (EEwsItemPrivate *priv,
+                   ESoapParameter *param,
+                   const gchar *type)
+{
 	ESoapParameter *subparam, *subparam1;
 	EwsAttendee *attendee;
 
-	for (subparam = e_soap_parameter_get_first_child(param); subparam != NULL; subparam = e_soap_parameter_get_next_child(subparam)) {
+	for (subparam = e_soap_parameter_get_first_child (param); subparam != NULL; subparam = e_soap_parameter_get_next_child (subparam)) {
 		EwsMailbox *mailbox = NULL;
 
 		subparam1 = e_soap_parameter_get_first_child_by_name (subparam, "Mailbox");
 		mailbox = e_ews_item_mailbox_from_soap_param (subparam1);
 		/* Ignore attendee if mailbox is not valid,
-		   for instance, ppl that does not exists any more */
+		 * for instance, ppl that does not exists any more */
 		if (!mailbox)
 			continue;
 
@@ -620,7 +632,7 @@ static void process_attendees(EEwsItemPr
 		subparam1 = e_soap_parameter_get_first_child_by_name (subparam, "ResponseType");
 		attendee->responsetype = e_soap_parameter_get_string_value (subparam1);
 
-		attendee->attendeetype = (gchar *)type;
+		attendee->attendeetype = (gchar *) type;
 
 		priv->attendees = g_slist_append (priv->attendees, attendee);
 	}
@@ -629,7 +641,8 @@ static void process_attendees(EEwsItemPr
 }
 
 static void
-parse_complete_name (struct _EEwsContactFields *con_fields, ESoapParameter *param)
+parse_complete_name (struct _EEwsContactFields *con_fields,
+                     ESoapParameter *param)
 {
 	ESoapParameter *subparam;
 	EwsCompleteName *cn;
@@ -637,34 +650,34 @@ parse_complete_name (struct _EEwsContact
 	cn = g_new0 (EwsCompleteName, 1);
 
 	subparam = e_soap_parameter_get_first_child_by_name (param, "Title");
-	if (subparam)	
+	if (subparam)
 		cn->title = e_soap_parameter_get_string_value (subparam);
 	subparam = e_soap_parameter_get_first_child_by_name (param, "FirstName");
-	if (subparam)	
+	if (subparam)
 		cn->first_name = e_soap_parameter_get_string_value (subparam);
 	subparam = e_soap_parameter_get_first_child_by_name (param, "MiddleName");
-	if (subparam)	
+	if (subparam)
 		cn->middle_name = e_soap_parameter_get_string_value (subparam);
 	subparam = e_soap_parameter_get_first_child_by_name (param, "LastName");
-	if (subparam)	
+	if (subparam)
 		cn->last_name = e_soap_parameter_get_string_value (subparam);
 	subparam = e_soap_parameter_get_first_child_by_name (param, "Suffix");
-	if (subparam)	
+	if (subparam)
 		cn->suffix = e_soap_parameter_get_string_value (subparam);
 	subparam = e_soap_parameter_get_first_child_by_name (param, "Initials");
-	if (subparam)	
+	if (subparam)
 		cn->initials = e_soap_parameter_get_string_value (subparam);
 	subparam = e_soap_parameter_get_first_child_by_name (param, "FullName");
-	if (subparam)	
+	if (subparam)
 		cn->full_name = e_soap_parameter_get_string_value (subparam);
 	subparam = e_soap_parameter_get_first_child_by_name (param, "Nickname");
-	if (subparam)	
+	if (subparam)
 		cn->nick_name = e_soap_parameter_get_string_value (subparam);
 	subparam = e_soap_parameter_get_first_child_by_name (param, "YomiFirstName");
-	if (subparam)	
+	if (subparam)
 		cn->yomi_first_name = e_soap_parameter_get_string_value (subparam);
 	subparam = e_soap_parameter_get_first_child_by_name (param, "YomiLastName");
-	if (subparam)	
+	if (subparam)
 		cn->yomi_last_name = e_soap_parameter_get_string_value (subparam);
 
 	con_fields->complete_name = cn;
@@ -679,42 +692,44 @@ ews_get_physical_address (ESoapParameter
 	address = g_new0 (EwsAddress, 1);
 
 	subparam = e_soap_parameter_get_first_child_by_name (param, "Street");
-	if (subparam)	
+	if (subparam)
 		address->street = e_soap_parameter_get_string_value (subparam);
 
 	subparam = e_soap_parameter_get_first_child_by_name (param, "City");
-	if (subparam)	
+	if (subparam)
 		address->city = e_soap_parameter_get_string_value (subparam);
 
 	subparam = e_soap_parameter_get_first_child_by_name (param, "State");
-	if (subparam)	
+	if (subparam)
 		address->state = e_soap_parameter_get_string_value (subparam);
 
 	subparam = e_soap_parameter_get_first_child_by_name (param, "Country");
-	if (subparam)	
+	if (subparam)
 		address->country = e_soap_parameter_get_string_value (subparam);
 
 	subparam = e_soap_parameter_get_first_child_by_name (param, "PostalCode");
-	if (subparam)	
+	if (subparam)
 		address->postal_code = e_soap_parameter_get_string_value (subparam);
 
 	return address;
 }
 
 static void
-parse_entries (GHashTable *hash_table, ESoapParameter *param, EwsGetValFunc get_val_func)
+parse_entries (GHashTable *hash_table,
+               ESoapParameter *param,
+               EwsGetValFunc get_val_func)
 {
 	ESoapParameter *subparam;
 
 	for (subparam = e_soap_parameter_get_first_child_by_name (param, "Entry");
-			subparam != NULL;
-			subparam = e_soap_parameter_get_next_child_by_name (subparam, "Entry")) {
+		subparam != NULL;
+		subparam = e_soap_parameter_get_next_child_by_name (subparam, "Entry")) {
 		gchar *key;
 		gpointer value;
-			
+
 		key = e_soap_parameter_get_property (subparam, "Key");
 		value = get_val_func (subparam);
-	
+
 		if (value)
 			g_hash_table_insert (hash_table, key, value);
 		else
@@ -738,11 +753,13 @@ ews_free_physical_address (gpointer valu
 }
 
 static void
-parse_contact_field (EEwsItem *item, const gchar *name, ESoapParameter *subparam)
+parse_contact_field (EEwsItem *item,
+                     const gchar *name,
+                     ESoapParameter *subparam)
 {
 	EEwsItemPrivate *priv = item->priv;
 	gchar *value = NULL;
-	
+
 	if (!g_ascii_strcasecmp (name, "Culture")) {
 		priv->contact_fields->culture = e_soap_parameter_get_string_value (subparam);
 	} else if (!g_ascii_strcasecmp (name, "FileAs")) {
@@ -763,9 +780,9 @@ parse_contact_field (EEwsItem *item, con
 	} else if (!g_ascii_strcasecmp (name, "AssistantName")) {
 		priv->contact_fields->assistant_name = e_soap_parameter_get_string_value (subparam);
 	} else if (!g_ascii_strcasecmp (name, "Birthday")) {
-			value = e_soap_parameter_get_string_value (subparam);
-			priv->contact_fields->birthday = ews_item_parse_date (value);
-			g_free (value);
+		value = e_soap_parameter_get_string_value (subparam);
+		priv->contact_fields->birthday = ews_item_parse_date (value);
+		g_free (value);
 	} else if (!g_ascii_strcasecmp (name, "BusinessHomePage")) {
 		priv->contact_fields->business_homepage = e_soap_parameter_get_string_value (subparam);
 	} else if (!g_ascii_strcasecmp (name, "Department")) {
@@ -786,9 +803,16 @@ parse_contact_field (EEwsItem *item, con
 	} else if (!g_ascii_strcasecmp (name, "Surname")) {
 		priv->contact_fields->surname = e_soap_parameter_get_string_value (subparam);
 	} else if (!g_ascii_strcasecmp (name, "WeddingAnniversary")) {
-			value = e_soap_parameter_get_string_value (subparam);
-			priv->contact_fields->wedding_anniversary = ews_item_parse_date (value);
-			g_free (value);
+		value = e_soap_parameter_get_string_value (subparam);
+		priv->contact_fields->wedding_anniversary = ews_item_parse_date (value);
+		g_free (value);
+	} else if (!g_ascii_strcasecmp (name, "Body")) {
+		/*
+		 * For Exchange versions >= 2010_SP2 Notes property can be get
+		 * directly from contacts:Notes. But for backward compatibility
+		 * with old servers (< 2010_SP2) we prefer use item:Body.
+		 */
+		priv->contact_fields->notes = e_soap_parameter_get_string_value (subparam);
 	}
 }
 
@@ -797,14 +821,46 @@ strip_html_tags (const gchar *html_text)
 {
 	gssize haystack_len = strlen (html_text);
 	gchar *plain_text = g_malloc (haystack_len);
-	gchar *start = g_strstr_len (html_text, haystack_len, "<body>"),
-		*end = g_strstr_len (html_text, haystack_len, "</body>"),
+	gchar *start = g_strstr_len (html_text, haystack_len, "<body"),
+		*end = g_strstr_len (html_text, haystack_len, "</body"),
 		*i, *j;
 
-	for (j = plain_text, i = start + 6; i < end; i++) {
-		if (*i == '&') i = i + 6;
-		if (*i == '<') while (*i != '>') i++;
-		else { *j = *i; j++; }
+	if (!start || !end) {
+		g_free (plain_text);
+		return g_strdup (html_text);
+	}
+
+	i = start;
+	while (i < end && *i != '>') {
+		i++;
+	}
+
+	for (j = plain_text; i < end; i++) {
+		if (*i == '&') {
+			gchar *from = i;
+
+			while (i < end && *i != ';' && *i != '<' && *i != '>')
+				i++;
+
+			if (i >= end)
+				break;
+
+			if (*i != ';')
+				i = from;
+			else
+				continue;
+		}
+
+		if (*i == '<') {
+			while (i < end && *i != '>')
+				i++;
+
+			if (i >= end)
+				break;
+		} else {
+			*j = *i;
+			j++;
+		}
 	}
 
 	*j = '\0';
@@ -813,7 +869,9 @@ strip_html_tags (const gchar *html_text)
 }
 
 static void
-parse_task_field (EEwsItem *item, const gchar *name, ESoapParameter *subparam)
+parse_task_field (EEwsItem *item,
+                  const gchar *name,
+                  ESoapParameter *subparam)
 {
 	EEwsItemPrivate *priv = item->priv;
 	gchar *value = NULL;
@@ -859,62 +917,102 @@ parse_task_field (EEwsItem *item, const 
 }
 
 static gboolean
-e_ews_item_set_from_soap_parameter (EEwsItem *item, ESoapParameter *param)
+e_ews_item_set_from_soap_parameter (EEwsItem *item,
+                                    ESoapParameter *param)
 {
 	EEwsItemPrivate *priv = item->priv;
-	ESoapParameter *subparam, *node;
-	gboolean contact = FALSE, task = FALSE;
+	ESoapParameter *subparam, *node = NULL, *attach_id;
+	const gchar *name;
 
 	g_return_val_if_fail (param != NULL, FALSE);
 
-	if ((node = e_soap_parameter_get_first_child_by_name (param, "AttachmentId"))) {
-		priv->attachment_id = g_new0 (EwsId, 1);
-		priv->attachment_id->id = e_soap_parameter_get_property (node, "Id");
-		priv->attachment_id->change_key = e_soap_parameter_get_property (node, "ChangeKey");
-	} else if ((node = e_soap_parameter_get_first_child_by_name (param, "ItemId"))) {
-		/*Spesial case when we are facing  <ReadFlagChange> during sync folders*/
-		priv->item_id = g_new0 (EwsId, 1);
-		priv->item_id->id = e_soap_parameter_get_property (node, "Id");
-		priv->item_id->change_key = e_soap_parameter_get_property (node, "ChangeKey");
-		return TRUE;
-	} else if ((node = e_soap_parameter_get_first_child_by_name (param, "Message")))
+	name = e_soap_parameter_get_name (param);
+
+	/*We get two types of response for items from server like below from two apis
+	 *  Syncfolderitems			and  		Finditem
+	 * <m:Changes>							<t:Items>
+ *          <t:Create>							  <t:Contact>
+ *            <t:Contact>						    <t:ItemId Id="AS4AUn=" ChangeKey="fsVU4==" />
+ *              <t:ItemId Id="AAA=" ChangeKey="NAgws"/>			  </t:Contact>
+ *            </t:Contact>						  <t:Contact>
+ *          </t:Create>							    <t:ItemId Id="AS4BS=" ChangeKey="fjidU4==" />
+	 *    <t:Contact>						  </t:Contact>
+ *              <t:ItemId Id="ABB=" ChangeKey="GCDab"/>			  ...
+ *            </t:Contact>						</t:Items>
+	 *  </t:Create>
+	 *  ...
+	 * </m:Changes> 
+	 * So check param is the node we want to use, by comparing name or is it child of the param */
+
+	if (!g_ascii_strcasecmp (name, "Message") || (node = e_soap_parameter_get_first_child_by_name (param, "Message"))) {
 		priv->item_type = E_EWS_ITEM_TYPE_MESSAGE;
-	else if ((node = e_soap_parameter_get_first_child_by_name (param, "PostItem")))
+		subparam = e_soap_parameter_get_first_child_by_name (node ? node : param, "ItemClass");
+		if (subparam) {
+			gchar *folder_class = e_soap_parameter_get_string_value (subparam);
+
+			if (g_strcmp0 (folder_class, "IPM.StickyNote") == 0) {
+				priv->item_type = E_EWS_ITEM_TYPE_MEMO;
+				priv->task_fields = g_new0 (struct _EEwsTaskFields, 1);
+				priv->task_fields->has_due_date = FALSE;
+				priv->task_fields->has_start_date = FALSE;
+				priv->task_fields->has_complete_date = FALSE;
+			}
+
+			g_free (folder_class);
+		}
+	} else if (!g_ascii_strcasecmp (name, "PostItem") || (node = e_soap_parameter_get_first_child_by_name (param, "PostItem")))
 		priv->item_type = E_EWS_ITEM_TYPE_POST_ITEM;
-	else if ((node = e_soap_parameter_get_first_child_by_name (param, "CalendarItem")))
-		priv->item_type = E_EWS_ITEM_TYPE_CALENDAR_ITEM;
-	else if ((node = e_soap_parameter_get_first_child_by_name (param, "Contact"))) {
-		contact = TRUE;	
+	else if (!g_ascii_strcasecmp (name, "CalendarItem") || (node = e_soap_parameter_get_first_child_by_name (param, "CalendarItem")))
+		priv->item_type = E_EWS_ITEM_TYPE_EVENT;
+	else if (!g_ascii_strcasecmp (name, "Contact") || (node = e_soap_parameter_get_first_child_by_name (param, "Contact"))) {
 		priv->item_type = E_EWS_ITEM_TYPE_CONTACT;
 		priv->contact_fields = g_new0 (struct _EEwsContactFields, 1);
-	} else if ((node = e_soap_parameter_get_first_child_by_name (param, "DistributionList")))
+	} else if (!g_ascii_strcasecmp (name, "DistributionList") || (node = e_soap_parameter_get_first_child_by_name (param, "DistributionList")))
 		priv->item_type = E_EWS_ITEM_TYPE_GROUP;
-	else if ((node = e_soap_parameter_get_first_child_by_name (param, "MeetingMessage")))
+	else if (!g_ascii_strcasecmp (name, "MeetingMessage") || (node = e_soap_parameter_get_first_child_by_name (param, "MeetingMessage")))
 		priv->item_type = E_EWS_ITEM_TYPE_MEETING_MESSAGE;
-	else if ((node = e_soap_parameter_get_first_child_by_name (param, "MeetingRequest")))
+	else if (!g_ascii_strcasecmp (name, "MeetingRequest") || (node = e_soap_parameter_get_first_child_by_name (param, "MeetingRequest")))
 		priv->item_type = E_EWS_ITEM_TYPE_MEETING_REQUEST;
-	else if ((node = e_soap_parameter_get_first_child_by_name (param, "MeetingResponse")))
+	else if (!g_ascii_strcasecmp (name, "MeetingResponse") || (node = e_soap_parameter_get_first_child_by_name (param, "MeetingResponse")))
 		priv->item_type = E_EWS_ITEM_TYPE_MEETING_RESPONSE;
-	else if ((node = e_soap_parameter_get_first_child_by_name (param, "MeetingCancellation")))
+	else if (!g_ascii_strcasecmp (name, "MeetingCancellation") || (node = e_soap_parameter_get_first_child_by_name (param, "MeetingCancellation")))
 		priv->item_type = E_EWS_ITEM_TYPE_MEETING_CANCELLATION;
-	else if ((node = e_soap_parameter_get_first_child_by_name (param, "Task"))) {
-		task = TRUE;
+	else if (!g_ascii_strcasecmp (name, "Task") || (node = e_soap_parameter_get_first_child_by_name (param, "Task"))) {
 		priv->item_type = E_EWS_ITEM_TYPE_TASK;
 		priv->task_fields = g_new0 (struct _EEwsTaskFields, 1);
 		priv->task_fields->has_due_date = FALSE;
 		priv->task_fields->has_start_date = FALSE;
 		priv->task_fields->has_complete_date = FALSE;
-	}
-	else if ((node = e_soap_parameter_get_first_child_by_name (param, "Item")))
+	} else if (!g_ascii_strcasecmp (name, "Item") || (node = e_soap_parameter_get_first_child_by_name (param, "Item")))
 		priv->item_type = E_EWS_ITEM_TYPE_GENERIC_ITEM;
-	else {
+	else if ((node = e_soap_parameter_get_first_child_by_name (param, "AttachmentId"))) {
+		priv->attachment_id = g_new0 (EwsId, 1);
+		priv->attachment_id->id = e_soap_parameter_get_property (node, "Id");
+		priv->attachment_id->change_key = e_soap_parameter_get_property (node, "ChangeKey");
+	} else if ((node = e_soap_parameter_get_first_child_by_name (param, "ItemId"))) {
+		/*Spesial case when we are facing  <ReadFlagChange> during sync folders*/
+		priv->item_id = g_new0 (EwsId, 1);
+		priv->item_id->id = e_soap_parameter_get_property (node, "Id");
+		priv->item_id->change_key = e_soap_parameter_get_property (node, "ChangeKey");
+		return TRUE;
+	} else {
 		g_warning ("Unable to find the Item type \n");
 		return FALSE;
 	}
 
+	attach_id = e_soap_parameter_get_first_child_by_name (param, "AttachmentId");
+	if (attach_id) {
+		priv->attachment_id = g_new0 (EwsId, 1);
+		priv->attachment_id->id = e_soap_parameter_get_property (attach_id, "Id");
+		priv->attachment_id->change_key = e_soap_parameter_get_property (attach_id, "ChangeKey");
+	}
+
+	if (!node)
+		node = param;
+
 	for (subparam = e_soap_parameter_get_first_child (node);
-			subparam != NULL;
-			subparam = e_soap_parameter_get_next_child (subparam)) {
+		subparam != NULL;
+		subparam = e_soap_parameter_get_next_child (subparam)) {
 		ESoapParameter *subparam1;
 		const gchar *name;
 		gchar *value = NULL;
@@ -967,8 +1065,8 @@ e_ews_item_set_from_soap_parameter (EEws
 			priv->has_attachments = (!g_ascii_strcasecmp (value, "true"));
 			g_free (value);
 		} else if (!g_ascii_strcasecmp (name, "Attachments")) {
-			process_attachments_list(priv, subparam);
-		} else if (contact)
+			process_attachments_list (priv, subparam);
+		} else if (priv->item_type == E_EWS_ITEM_TYPE_CONTACT)
 			parse_contact_field (item, name, subparam);
 			/* fields below are not relevant for contacts, so skip them */	
 		else if (!g_ascii_strcasecmp (name, "Sender")) {
@@ -1014,7 +1112,7 @@ e_ews_item_set_from_soap_parameter (EEws
 			g_free (value);
 		} else if (!g_ascii_strcasecmp (name, "TimeZone")) {
 			priv->timezone = e_soap_parameter_get_string_value (subparam);
-		} else if (task) {
+		} else if (priv->item_type == E_EWS_ITEM_TYPE_TASK || priv->item_type == E_EWS_ITEM_TYPE_MEMO) {
 			parse_task_field (item, name, subparam);
 			/* fields below are not relevant for task, so skip them */
 		} else if (!g_ascii_strcasecmp (name, "References")) {
@@ -1022,7 +1120,7 @@ e_ews_item_set_from_soap_parameter (EEws
 		} else if (!g_ascii_strcasecmp (name, "ExtendedProperty")) {
 			parse_extended_property (priv, subparam);
 		} else if (!g_ascii_strcasecmp (name, "ModifiedOccurrences")) {
-			process_modified_occurrences(priv, subparam);
+			process_modified_occurrences (priv, subparam);
 		} else if (!g_ascii_strcasecmp (name, "RequiredAttendees")) {
 			process_attendees (priv, subparam, "Required");
 		} else if (!g_ascii_strcasecmp (name, "OptionalAttendees")) {
@@ -1055,6 +1153,19 @@ e_ews_item_new_from_soap_parameter (ESoa
 	return item;
 }
 
+EEwsItem *
+e_ews_item_new_from_error (const GError *error)
+{
+	EEwsItem *item;
+
+	g_return_val_if_fail (error != NULL, NULL);
+
+	item = g_object_new (E_TYPE_EWS_ITEM, NULL);
+	e_ews_item_set_error (item, error);
+
+	return item;
+}
+
 EEwsItemType
 e_ews_item_get_item_type (EEwsItem *item)
 {
@@ -1064,11 +1175,42 @@ e_ews_item_get_item_type (EEwsItem *item
 }
 
 void
-e_ews_item_set_item_type (EEwsItem *item, EEwsItemType new_type)
+e_ews_item_set_item_type (EEwsItem *item,
+                          EEwsItemType new_type)
 {
 	g_return_if_fail (E_IS_EWS_ITEM (item));
 
-	item->priv->item_type = new_type;
+	/* once the type is set to error type it stays as error type */
+	if (item->priv->item_type != E_EWS_ITEM_TYPE_ERROR)
+		item->priv->item_type = new_type;
+}
+
+const GError *
+e_ews_item_get_error (EEwsItem *item)
+{
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
+
+	return item->priv->error;
+}
+
+void
+e_ews_item_set_error (EEwsItem *item,
+                      const GError *error)
+{
+	GError *new_error;
+
+	g_return_if_fail (E_IS_EWS_ITEM (item));
+
+	if (error)
+		new_error = g_error_copy (error);
+	else
+		new_error = NULL;
+
+	g_clear_error (&item->priv->error);
+	item->priv->error = new_error;
+
+	if (item->priv->error)
+		e_ews_item_set_item_type (item, E_EWS_ITEM_TYPE_ERROR);
 }
 
 const gchar *
@@ -1080,7 +1222,8 @@ e_ews_item_get_subject (EEwsItem *item)
 }
 
 void
-e_ews_item_set_subject (EEwsItem *item, const gchar *new_subject)
+e_ews_item_set_subject (EEwsItem *item,
+                        const gchar *new_subject)
 {
 	g_return_if_fail (E_IS_EWS_ITEM (item));
 
@@ -1098,7 +1241,8 @@ e_ews_item_get_mime_content (EEwsItem *i
 }
 
 void
-e_ews_item_set_mime_content (EEwsItem *item, const gchar *new_mime_content)
+e_ews_item_set_mime_content (EEwsItem *item,
+                             const gchar *new_mime_content)
 {
 	g_return_if_fail (E_IS_EWS_ITEM (item));
 
@@ -1108,7 +1252,7 @@ e_ews_item_set_mime_content (EEwsItem *i
 }
 
 const EwsId *
-e_ews_item_get_id	(EEwsItem *item)
+e_ews_item_get_id (EEwsItem *item)
 {
 	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 
@@ -1116,7 +1260,7 @@ e_ews_item_get_id	(EEwsItem *item)
 }
 
 const EwsId *
-e_ews_item_get_attachment_id	(EEwsItem *item)
+e_ews_item_get_attachment_id (EEwsItem *item)
 {
 	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 
@@ -1124,7 +1268,7 @@ e_ews_item_get_attachment_id	(EEwsItem *
 }
 
 gsize
-e_ews_item_get_size	(EEwsItem *item)
+e_ews_item_get_size (EEwsItem *item)
 {
 	g_return_val_if_fail (E_IS_EWS_ITEM (item), -1);
 
@@ -1132,7 +1276,7 @@ e_ews_item_get_size	(EEwsItem *item)
 }
 
 const gchar *
-e_ews_item_get_msg_id	(EEwsItem *item)
+e_ews_item_get_msg_id (EEwsItem *item)
 {
 	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 
@@ -1140,7 +1284,7 @@ e_ews_item_get_msg_id	(EEwsItem *item)
 }
 
 const gchar *
-e_ews_item_get_uid	(EEwsItem *item)
+e_ews_item_get_uid (EEwsItem *item)
 {
 	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 
@@ -1163,7 +1307,7 @@ e_ews_item_get_references (EEwsItem *ite
 }
 
 time_t
-e_ews_item_get_date_received	(EEwsItem *item)
+e_ews_item_get_date_received (EEwsItem *item)
 {
 	g_return_val_if_fail (E_IS_EWS_ITEM (item), -1);
 
@@ -1171,7 +1315,7 @@ e_ews_item_get_date_received	(EEwsItem *
 }
 
 time_t
-e_ews_item_get_date_sent	(EEwsItem *item)
+e_ews_item_get_date_sent (EEwsItem *item)
 {
 	g_return_val_if_fail (E_IS_EWS_ITEM (item), -1);
 
@@ -1179,7 +1323,7 @@ e_ews_item_get_date_sent	(EEwsItem *item
 }
 
 time_t
-e_ews_item_get_date_created	(EEwsItem *item)
+e_ews_item_get_date_created (EEwsItem *item)
 {
 	g_return_val_if_fail (E_IS_EWS_ITEM (item), -1);
 
@@ -1187,7 +1331,8 @@ e_ews_item_get_date_created	(EEwsItem *i
 }
 
 gboolean
-e_ews_item_has_attachments	(EEwsItem *item, gboolean *has_attachments)
+e_ews_item_has_attachments (EEwsItem *item,
+                            gboolean *has_attachments)
 {
 	g_return_val_if_fail (E_IS_EWS_ITEM (item), FALSE);
 
@@ -1197,7 +1342,8 @@ e_ews_item_has_attachments	(EEwsItem *it
 }
 
 gboolean
-e_ews_item_is_read		(EEwsItem *item, gboolean *read)
+e_ews_item_is_read (EEwsItem *item,
+                    gboolean *read)
 {
 	g_return_val_if_fail (E_IS_EWS_ITEM (item), FALSE);
 
@@ -1207,7 +1353,8 @@ e_ews_item_is_read		(EEwsItem *item, gbo
 }
 
 gboolean
-e_ews_item_is_forwarded		(EEwsItem *item, gboolean *forwarded)
+e_ews_item_is_forwarded (EEwsItem *item,
+                         gboolean *forwarded)
 {
 	g_return_val_if_fail (E_IS_EWS_ITEM (item), FALSE);
 
@@ -1217,7 +1364,8 @@ e_ews_item_is_forwarded		(EEwsItem *item
 }
 
 gboolean
-e_ews_item_is_answered		(EEwsItem *item, gboolean *answered)
+e_ews_item_is_answered (EEwsItem *item,
+                        gboolean *answered)
 {
 	g_return_val_if_fail (E_IS_EWS_ITEM (item), FALSE);
 
@@ -1226,9 +1374,8 @@ e_ews_item_is_answered		(EEwsItem *item,
 	return TRUE;
 }
 
-
 const GSList *
-e_ews_item_get_to_recipients	(EEwsItem *item)
+e_ews_item_get_to_recipients (EEwsItem *item)
 {
 	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 
@@ -1236,7 +1383,7 @@ e_ews_item_get_to_recipients	(EEwsItem *
 }
 
 const GSList *
-e_ews_item_get_cc_recipients	(EEwsItem *item)
+e_ews_item_get_cc_recipients (EEwsItem *item)
 {
 	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 
@@ -1244,7 +1391,7 @@ e_ews_item_get_cc_recipients	(EEwsItem *
 }
 
 const GSList *
-e_ews_item_get_bcc_recipients	(EEwsItem *item)
+e_ews_item_get_bcc_recipients (EEwsItem *item)
 {
 	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 
@@ -1252,7 +1399,7 @@ e_ews_item_get_bcc_recipients	(EEwsItem 
 }
 
 const EwsMailbox *
-e_ews_item_get_sender		(EEwsItem *item)
+e_ews_item_get_sender (EEwsItem *item)
 {
 	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 
@@ -1260,7 +1407,7 @@ e_ews_item_get_sender		(EEwsItem *item)
 }
 
 const EwsMailbox *
-e_ews_item_get_from		(EEwsItem *item)
+e_ews_item_get_from (EEwsItem *item)
 {
 	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 
@@ -1268,7 +1415,7 @@ e_ews_item_get_from		(EEwsItem *item)
 }
 
 const GSList *
-e_ews_item_get_categories	(EEwsItem *item)
+e_ews_item_get_categories (EEwsItem *item)
 {
 	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 
@@ -1276,7 +1423,7 @@ e_ews_item_get_categories	(EEwsItem *ite
 }
 
 EwsImportance
-e_ews_item_get_importance	(EEwsItem *item)
+e_ews_item_get_importance (EEwsItem *item)
 {
 	g_return_val_if_fail (E_IS_EWS_ITEM (item), EWS_ITEM_LOW);
 
@@ -1289,19 +1436,6 @@ e_ews_item_mailbox_from_soap_param (ESoa
 	EwsMailbox *mb;
 	ESoapParameter *subparam;
 
-	/* Return NULL if RoutingType of Mailbox is not SMTP
-		   For instance, people who don't exist any more	*/
-	subparam = e_soap_parameter_get_first_child_by_name (param, "RoutingType");
-	if (subparam) {
-		gchar *routingtype;
-		routingtype = e_soap_parameter_get_string_value (subparam);
-		if (g_ascii_strcasecmp (routingtype, "SMTP")) {
-			g_free (routingtype);
-			return NULL;
-		}
-		g_free (routingtype);
-	}
-
 	mb = g_new0 (EwsMailbox, 1);
 
 	subparam = e_soap_parameter_get_first_child_by_name (param, "Name");
@@ -1312,52 +1446,89 @@ e_ews_item_mailbox_from_soap_param (ESoa
 	if (subparam)
 		mb->email = e_soap_parameter_get_string_value (subparam);
 
+	subparam = e_soap_parameter_get_first_child_by_name (param, "RoutingType");
+	if (subparam)
+		mb->routing_type = e_soap_parameter_get_string_value (subparam);
+
+	subparam = e_soap_parameter_get_first_child_by_name (param, "MailboxType");
+	if (subparam)
+		mb->mailbox_type = e_soap_parameter_get_string_value (subparam);
+
+	if (!mb->email && !mb->name) {
+		e_ews_mailbox_free (mb);
+		mb = NULL;
+	}
+
 	return mb;
 }
 
+void
+e_ews_mailbox_free (EwsMailbox *mailbox)
+{
+	if (!mailbox)
+		return;
+
+	g_free (mailbox->name);
+	g_free (mailbox->email);
+	g_free (mailbox->routing_type);
+	g_free (mailbox->mailbox_type);
+
+	if (mailbox->item_id) {
+		g_free (mailbox->item_id->id);
+		g_free (mailbox->item_id->change_key);
+		g_free (mailbox->item_id);
+	}
+
+	g_free (mailbox);
+}
+
 const GSList *
-e_ews_item_get_modified_occurrences(EEwsItem *item)
+e_ews_item_get_modified_occurrences (EEwsItem *item)
 {
-	g_return_val_if_fail(E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 
 	return item->priv->modified_occurrences;
 }
 
 GSList *
-e_ews_item_get_attachments_ids(EEwsItem *item)
+e_ews_item_get_attachments_ids (EEwsItem *item)
 {
-	g_return_val_if_fail(E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 
 	return item->priv->attachments_list;
 }
 
 gchar *
-e_ews_embed_attachment_id_in_uri (const gchar *olduri, const char *attach_id)
+e_ews_embed_attachment_id_in_uri (const gchar *olduri,
+                                  const gchar *attach_id)
 {
 	gchar *tmpdir, *tmpfilename, filename[350], dirname[350], *name;
 
 	tmpfilename = g_filename_from_uri (olduri, NULL, NULL);
 
-	name = g_strrstr (tmpfilename, "/")+1;
-	tmpdir = g_strndup(tmpfilename, g_strrstr (tmpfilename, "/") - tmpfilename);
+	name = g_strrstr (tmpfilename, "/") + 1;
+	tmpdir = g_strndup (tmpfilename, g_strrstr (tmpfilename, "/") - tmpfilename);
 
 	snprintf (dirname, 350, "%s/%s", tmpdir, attach_id);
 	if (g_mkdir (dirname, 0775) == -1) {
-		g_warning("Failed create directory to place file in [%s]: %s\n", dirname, strerror (errno));
+		g_warning ("Failed create directory to place file in [%s]: %s\n", dirname, strerror (errno));
 	}
 
-	snprintf(filename, 350, "%s/%s", dirname, name);
+	snprintf (filename, 350, "%s/%s", dirname, name);
 	if (g_rename (tmpfilename, filename) != 0) {
-		g_warning("Failed to move attachment cache file [%s -> %s]: %s\n", tmpfilename, filename, strerror (errno));
+		g_warning ("Failed to move attachment cache file [%s -> %s]: %s\n", tmpfilename, filename, strerror (errno));
 	}
 
-	g_free(tmpdir);
+	g_free (tmpdir);
 
-	return g_filename_to_uri(filename, NULL, NULL);
+	return g_filename_to_uri (filename, NULL, NULL);
 }
 
 gchar *
-e_ews_dump_file_attachment_from_soap_parameter (ESoapParameter *param, const gchar *cache, const gchar *comp_uid, gchar **attach_id)
+e_ews_dump_file_attachment_from_soap_parameter (ESoapParameter *param,
+                                                const gchar *cache,
+                                                const gchar *comp_uid,
+                                                gchar **attach_id)
 {
 	ESoapParameter *subparam;
 	const gchar *param_name;
@@ -1370,89 +1541,91 @@ e_ews_dump_file_attachment_from_soap_par
 
 	/* Parse element, look for filename and content */
 	*attach_id = NULL;
-	for (subparam = e_soap_parameter_get_first_child(param); subparam != NULL; subparam = e_soap_parameter_get_next_child(subparam)) {
-		param_name = e_soap_parameter_get_name(subparam);
+	for (subparam = e_soap_parameter_get_first_child (param); subparam != NULL; subparam = e_soap_parameter_get_next_child (subparam)) {
+		param_name = e_soap_parameter_get_name (subparam);
 
-		if (g_ascii_strcasecmp(param_name, "Name") == 0) {
-			value = e_soap_parameter_get_string_value(subparam);
-			name = g_uri_escape_string(value, "", TRUE);
+		if (g_ascii_strcasecmp (param_name, "Name") == 0) {
+			value = e_soap_parameter_get_string_value (subparam);
+			name = g_uri_escape_string (value, "", TRUE);
 			g_free (value);
-		} else if (g_ascii_strcasecmp(param_name, "Content") == 0) {
+		} else if (g_ascii_strcasecmp (param_name, "Content") == 0) {
 			value = e_soap_parameter_get_string_value (subparam);
 			content = g_base64_decode (value, &data_len);
 			g_free (value);
-		} else if (g_ascii_strcasecmp(param_name, "AttachmentId") == 0) {
+		} else if (g_ascii_strcasecmp (param_name, "AttachmentId") == 0) {
 			*attach_id = e_soap_parameter_get_property (subparam, "Id");
 		}
 	}
 
 	/* Make sure we have needed data */
 	if (!content || !name || !*attach_id) {
-		g_free(name);
-		g_free(content);
-		g_free(*attach_id);
+		g_free (name);
+		g_free (content);
+		g_free (*attach_id);
 		return NULL;
 	}
 
 	tmpfilename = (gchar *) content;
-	tmpdir = g_strndup(tmpfilename, g_strrstr (tmpfilename, "/") - tmpfilename);
+	tmpdir = g_strndup (tmpfilename, g_strrstr (tmpfilename, "/") - tmpfilename);
 
 	dirname = g_build_filename (tmpdir, comp_uid, NULL);
 	if (g_mkdir_with_parents (dirname, 0775) == -1) {
-		g_warning("Failed create directory to place file in [%s]: %s\n", dirname, strerror (errno));
+		g_warning ("Failed create directory to place file in [%s]: %s\n", dirname, strerror (errno));
 	}
 
 	filename = g_build_filename (dirname, name, NULL);
 	if (g_rename (tmpfilename, filename) != 0) {
-		g_warning("Failed to move attachment cache file [%s -> %s]: %s\n", tmpfilename, filename, strerror (errno));
+		g_warning ("Failed to move attachment cache file [%s -> %s]: %s\n", tmpfilename, filename, strerror (errno));
 	}
 
 	g_free (dirname);
-	g_free(tmpdir);
-	g_free(name);
-	g_free(content);
+	g_free (tmpdir);
+	g_free (name);
+	g_free (content);
 
 	/* Return URI to saved file */
-	name = g_filename_to_uri(filename, NULL, NULL);
+	name = g_filename_to_uri (filename, NULL, NULL);
 	g_free (filename);
 	return name;
 }
 
 gchar *
-e_ews_item_dump_mime_content(EEwsItem *item, const gchar *cache) {
+e_ews_item_dump_mime_content (EEwsItem *item,
+                              const gchar *cache)
+{
 	gchar *filename, *surename, *dirname;
 	gchar *tmpdir, *tmpfilename;
 
 	g_return_val_if_fail (item->priv->mime_content != NULL, NULL);
 
 	tmpfilename = (gchar *) item->priv->mime_content;
-	tmpdir = g_strndup(tmpfilename, g_strrstr (tmpfilename, "/") - tmpfilename);
+	tmpdir = g_strndup (tmpfilename, g_strrstr (tmpfilename, "/") - tmpfilename);
 
 	dirname = g_build_filename (tmpdir, "XXXXXX", NULL);
-	if (!mkdtemp(dirname))
+	if (!mkdtemp (dirname))
 		g_warning ("Failed to create directory for attachment cache");
 
-	surename = g_uri_escape_string(item->priv->subject, "", TRUE);
+	surename = g_uri_escape_string (item->priv->subject, "", TRUE);
 	filename = g_build_filename (dirname, surename, NULL);
 
-	if (g_rename ((const gchar *)item->priv->mime_content, filename) != 0) {
-		g_warning("Failed to move attachment cache file");
+	if (g_rename ((const gchar *) item->priv->mime_content, filename) != 0) {
+		g_warning ("Failed to move attachment cache file");
 	}
 
 	g_free (filename);
 	g_free (dirname);
-	g_free(tmpdir);
-	g_free(tmpfilename);
-	g_free(surename);
+	g_free (tmpdir);
+	g_free (tmpfilename);
+	g_free (surename);
 
 	/* Return URI to saved file */
-	return g_filename_to_uri(filename, NULL, NULL);
+	return g_filename_to_uri (filename, NULL, NULL);
 }
 
 const GSList *
 e_ews_item_get_attendees (EEwsItem *item)
 {
-	g_return_val_if_fail(E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 
 	return item->priv->attendees;
 }
@@ -1460,24 +1633,24 @@ e_ews_item_get_attendees (EEwsItem *item
 const EwsId *
 e_ews_item_get_calendar_item_accept_id (EEwsItem *item)
 {
-	g_return_val_if_fail(E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 
-	return (const EwsId*) item->priv->calendar_item_accept_id;
+	return (const EwsId *) item->priv->calendar_item_accept_id;
 }
 
 const gchar *
 e_ews_item_get_fileas (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->contact_fields != NULL, NULL);
 
-	return (const gchar*) item->priv->contact_fields->fileas;
+	return (const gchar *) item->priv->contact_fields->fileas;
 }
 
 const EwsCompleteName *
 e_ews_item_get_complete_name (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->contact_fields != NULL, NULL);
 
 	return (const EwsCompleteName *) item->priv->contact_fields->complete_name;
@@ -1492,11 +1665,12 @@ e_ews_item_get_complete_name (EEwsItem *
  * Returns: 
  **/
 const gchar *
-e_ews_item_get_email_address (EEwsItem *item, const gchar *field)
+e_ews_item_get_email_address (EEwsItem *item,
+                              const gchar *field)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->contact_fields != NULL, NULL);
-	
+
 	if (item->priv->contact_fields->email_addresses)
 		return g_hash_table_lookup (item->priv->contact_fields->email_addresses, field);
 
@@ -1512,11 +1686,12 @@ e_ews_item_get_email_address (EEwsItem *
  * Returns: 
  **/
 const EwsAddress *
-e_ews_item_get_physical_address (EEwsItem *item, const gchar *field)
+e_ews_item_get_physical_address (EEwsItem *item,
+                                 const gchar *field)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->contact_fields != NULL, NULL);
-	
+
 	if (item->priv->contact_fields->physical_addresses)
 		return g_hash_table_lookup (item->priv->contact_fields->physical_addresses, field);
 
@@ -1534,11 +1709,12 @@ e_ews_item_get_physical_address (EEwsIte
  * Returns: 
  **/
 const gchar *
-e_ews_item_get_phone_number (EEwsItem *item, const gchar *field)
+e_ews_item_get_phone_number (EEwsItem *item,
+                             const gchar *field)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->contact_fields != NULL, NULL);
-	
+
 	if (item->priv->contact_fields->phone_numbers)
 		return g_hash_table_lookup (item->priv->contact_fields->phone_numbers, field);
 
@@ -1554,11 +1730,12 @@ e_ews_item_get_phone_number (EEwsItem *i
  * Returns: 
  **/
 const gchar *
-e_ews_item_get_im_address (EEwsItem *item, const gchar *field)
+e_ews_item_get_im_address (EEwsItem *item,
+                           const gchar *field)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->contact_fields != NULL, NULL);
-	
+
 	if (item->priv->contact_fields->im_addresses)
 		return g_hash_table_lookup (item->priv->contact_fields->im_addresses, field);
 
@@ -1568,97 +1745,106 @@ e_ews_item_get_im_address (EEwsItem *ite
 const gchar *
 e_ews_item_get_company_name (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->contact_fields != NULL, NULL);
 
-	return (const gchar*) item->priv->contact_fields->company_name;
+	return (const gchar *) item->priv->contact_fields->company_name;
 }
 
 const gchar *
 e_ews_item_get_department (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->contact_fields != NULL, NULL);
 
-	return (const gchar*) item->priv->contact_fields->department;
+	return (const gchar *) item->priv->contact_fields->department;
 }
 
 const gchar *
 e_ews_item_get_job_title (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->contact_fields != NULL, NULL);
 
-	return (const gchar*) item->priv->contact_fields->job_title;
+	return (const gchar *) item->priv->contact_fields->job_title;
 }
 
 const gchar *
 e_ews_item_get_assistant_name (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->contact_fields != NULL, NULL);
 
-	return (const gchar*) item->priv->contact_fields->assistant_name;
+	return (const gchar *) item->priv->contact_fields->assistant_name;
 }
 
 const gchar *
 e_ews_item_get_manager (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->contact_fields != NULL, NULL);
 
-	return (const gchar*) item->priv->contact_fields->manager;
+	return (const gchar *) item->priv->contact_fields->manager;
 }
 
 const gchar *
 e_ews_item_get_office_location (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->contact_fields != NULL, NULL);
 
-	return (const gchar*) item->priv->contact_fields->office_location;
+	return (const gchar *) item->priv->contact_fields->office_location;
 }
 
 const gchar *
 e_ews_item_get_business_homepage (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->contact_fields != NULL, NULL);
 
-	return (const gchar*) item->priv->contact_fields->business_homepage;
+	return (const gchar *) item->priv->contact_fields->business_homepage;
 }
 
 const gchar *
 e_ews_item_get_profession (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->contact_fields != NULL, NULL);
 
-	return (const gchar*) item->priv->contact_fields->profession;
+	return (const gchar *) item->priv->contact_fields->profession;
 }
 
 const gchar *
 e_ews_item_get_spouse_name (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->contact_fields != NULL, NULL);
 
-	return (const gchar*) item->priv->contact_fields->spouse_name;
+	return (const gchar *) item->priv->contact_fields->spouse_name;
 }
 
 const gchar *
 e_ews_item_get_surname (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
+	g_return_val_if_fail (item->priv->contact_fields != NULL, NULL);
+
+	return (const gchar *) item->priv->contact_fields->surname;
+}
+
+const gchar *
+e_ews_item_get_notes (EEwsItem *item)
+{
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->contact_fields != NULL, NULL);
 
-	return (const gchar*) item->priv->contact_fields->surname;
+	return item->priv->contact_fields->notes;
 }
-	
+
 time_t
 e_ews_item_get_birthday (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), -1);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), -1);
 	g_return_val_if_fail (item->priv->contact_fields != NULL, -1);
 
 	return item->priv->contact_fields->birthday;
@@ -1667,7 +1853,7 @@ e_ews_item_get_birthday (EEwsItem *item)
 time_t
 e_ews_item_get_wedding_anniversary (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), -1);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), -1);
 	g_return_val_if_fail (item->priv->contact_fields != NULL, -1);
 
 	return item->priv->contact_fields->wedding_anniversary;
@@ -1676,7 +1862,7 @@ e_ews_item_get_wedding_anniversary (EEws
 const gchar *
 e_ews_item_get_status (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->task_fields != NULL, NULL);
 
 	return item->priv->task_fields->status;
@@ -1684,7 +1870,7 @@ e_ews_item_get_status (EEwsItem *item)
 
 const gchar *	e_ews_item_get_percent_complete (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->task_fields != NULL, NULL);
 
 	return item->priv->task_fields->percent_complete;
@@ -1693,7 +1879,7 @@ const gchar *	e_ews_item_get_percent_com
 time_t
 e_ews_item_get_due_date (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), -1);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), -1);
 	g_return_val_if_fail (item->priv->task_fields != NULL, -1);
 
 	return item->priv->task_fields->due_date;
@@ -1702,7 +1888,7 @@ e_ews_item_get_due_date (EEwsItem *item)
 time_t
 e_ews_item_get_start_date (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), -1);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), -1);
 	g_return_val_if_fail (item->priv->task_fields != NULL, -1);
 
 	return item->priv->task_fields->start_date;
@@ -1711,7 +1897,7 @@ e_ews_item_get_start_date (EEwsItem *ite
 time_t
 e_ews_item_get_complete_date (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), -1);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), -1);
 	g_return_val_if_fail (item->priv->task_fields != NULL, -1);
 
 	return item->priv->task_fields->complete_date;
@@ -1720,7 +1906,7 @@ e_ews_item_get_complete_date (EEwsItem *
 const gchar *
 e_ews_item_get_sensitivity (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->task_fields != NULL, NULL);
 
 	return item->priv->task_fields->sensitivity;
@@ -1729,7 +1915,7 @@ e_ews_item_get_sensitivity (EEwsItem *it
 const gchar *
 e_ews_item_get_body (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->task_fields != NULL, NULL);
 
 	return item->priv->task_fields->body;
@@ -1738,7 +1924,7 @@ e_ews_item_get_body (EEwsItem *item)
 const gchar *
 e_ews_item_get_owner (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->task_fields != NULL, NULL);
 
 	return item->priv->task_fields->owner;
@@ -1747,16 +1933,17 @@ e_ews_item_get_owner (EEwsItem *item)
 const gchar *
 e_ews_item_get_delegator (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->task_fields != NULL, NULL);
 
 	return item->priv->task_fields->delegator;
 }
 
 gboolean
-e_ews_item_task_has_start_date (EEwsItem *item, gboolean *has_date)
+e_ews_item_task_has_start_date (EEwsItem *item,
+                                gboolean *has_date)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), FALSE);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), FALSE);
 	g_return_val_if_fail (item->priv->task_fields != NULL, FALSE);
 
 	*has_date =  item->priv->task_fields->has_start_date;
@@ -1765,9 +1952,10 @@ e_ews_item_task_has_start_date (EEwsItem
 }
 
 gboolean
-e_ews_item_task_has_due_date (EEwsItem *item,  gboolean *has_date)
+e_ews_item_task_has_due_date (EEwsItem *item,
+                              gboolean *has_date)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), FALSE);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), FALSE);
 	g_return_val_if_fail (item->priv->task_fields != NULL, FALSE);
 
 	*has_date =  item->priv->task_fields->has_due_date;
@@ -1776,9 +1964,10 @@ e_ews_item_task_has_due_date (EEwsItem *
 }
 
 gboolean
-e_ews_item_task_has_complete_date (EEwsItem *item,  gboolean *has_date)
+e_ews_item_task_has_complete_date (EEwsItem *item,
+                                   gboolean *has_date)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), FALSE);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), FALSE);
 	g_return_val_if_fail (item->priv->task_fields != NULL, FALSE);
 
 	*has_date =  item->priv->task_fields->has_complete_date;
@@ -1789,10 +1978,403 @@ e_ews_item_task_has_complete_date (EEwsI
 const gchar *
 e_ews_item_get_tzid (EEwsItem *item)
 {
-	g_return_val_if_fail (E_IS_EWS_ITEM(item), NULL);
+	g_return_val_if_fail (E_IS_EWS_ITEM (item), NULL);
 	g_return_val_if_fail (item->priv->timezone != NULL, NULL);
 
 	return item->priv->timezone;
 }
 
+EwsResolveContact *
+e_ews_item_resolve_contact_from_soap_param (ESoapParameter *param)
+{
+	ESoapParameter *subparam;
+	EwsResolveContact *rc;
+
+	if (!param)
+		return NULL;
+
+	rc = g_new0 (EwsResolveContact, 1);
+	rc->email_addresses = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
+
+	subparam = e_soap_parameter_get_first_child_by_name (param, "DisplayName");
+	if (subparam)
+		rc->display_name = e_soap_parameter_get_string_value (subparam);
+
+	subparam = e_soap_parameter_get_first_child_by_name (param, "EmailAddresses");
+	if (subparam)
+		parse_entries (rc->email_addresses, subparam, (EwsGetValFunc) e_soap_parameter_get_string_value);
+
+	return rc;
+}
+
+void
+e_ews_free_resolve_contact (gpointer rc)
+{
+	EwsResolveContact *resc = rc;
+
+	if (!resc)
+		return;
+
+	g_free (resc->display_name);
+	g_hash_table_unref (resc->email_addresses);
+	g_free (resc);
+}
+
+/* free returned pointer with e_ews_permission_free() */
+EEwsPermission *
+e_ews_permission_new (EEwsPermissionUserType user_type,
+                      const gchar *display_name,
+                      const gchar *primary_smtp,
+                      const gchar *sid,
+                      guint32 rights)
+{
+	EEwsPermission *perm;
+
+	perm = g_new0 (EEwsPermission, 1);
+	perm->user_type = user_type;
+	perm->display_name = g_strdup (display_name);
+	perm->primary_smtp = g_strdup (primary_smtp);
+	perm->sid = g_strdup (sid);
+	perm->rights = rights;
+
+	return perm;
+}
+
+void
+e_ews_permission_free (EEwsPermission *perm)
+{
+	if (!perm)
+		return;
+
+	g_free (perm->display_name);
+	g_free (perm->primary_smtp);
+	g_free (perm->sid);
+	g_free (perm);
+}
+
+static void
+ews_level_rights_converter (const gchar **plevel_name,
+                            guint32 *prights,
+                            gboolean level_to_rights)
+{
+	struct _known {
+		const gchar *level_name;
+		guint32 rights;
+	} known[] = {
+		{ "None", 0 },
+		{ "Owner",	E_EWS_PERMISSION_BIT_READ_ANY |
+			E_EWS_PERMISSION_BIT_CREATE |
+			E_EWS_PERMISSION_BIT_CREATE_SUBFOLDER |
+			E_EWS_PERMISSION_BIT_EDIT_OWNED |
+			E_EWS_PERMISSION_BIT_EDIT_ANY |
+			E_EWS_PERMISSION_BIT_DELETE_OWNED |
+			E_EWS_PERMISSION_BIT_DELETE_ANY |
+			E_EWS_PERMISSION_BIT_FOLDER_OWNER |
+			E_EWS_PERMISSION_BIT_FOLDER_CONTACT |
+			E_EWS_PERMISSION_BIT_FOLDER_VISIBLE },
+		{ "PublishingEditor",
+			E_EWS_PERMISSION_BIT_READ_ANY |
+			E_EWS_PERMISSION_BIT_CREATE |
+			E_EWS_PERMISSION_BIT_CREATE_SUBFOLDER |
+			E_EWS_PERMISSION_BIT_EDIT_OWNED |
+			E_EWS_PERMISSION_BIT_EDIT_ANY |
+			E_EWS_PERMISSION_BIT_DELETE_OWNED |
+			E_EWS_PERMISSION_BIT_DELETE_ANY |
+			E_EWS_PERMISSION_BIT_FOLDER_VISIBLE },
+		{ "Editor",
+			E_EWS_PERMISSION_BIT_READ_ANY |
+			E_EWS_PERMISSION_BIT_CREATE |
+			E_EWS_PERMISSION_BIT_EDIT_OWNED |
+			E_EWS_PERMISSION_BIT_EDIT_ANY |
+			E_EWS_PERMISSION_BIT_DELETE_OWNED |
+			E_EWS_PERMISSION_BIT_DELETE_ANY |
+			E_EWS_PERMISSION_BIT_FOLDER_VISIBLE },
+		{ "PublishingAuthor",
+			E_EWS_PERMISSION_BIT_READ_ANY |
+			E_EWS_PERMISSION_BIT_CREATE |
+			E_EWS_PERMISSION_BIT_CREATE_SUBFOLDER |
+			E_EWS_PERMISSION_BIT_EDIT_OWNED |
+			E_EWS_PERMISSION_BIT_DELETE_OWNED |
+			E_EWS_PERMISSION_BIT_FOLDER_VISIBLE },
+		{ "Author",
+			E_EWS_PERMISSION_BIT_READ_ANY |
+			E_EWS_PERMISSION_BIT_CREATE |
+			E_EWS_PERMISSION_BIT_EDIT_OWNED |
+			E_EWS_PERMISSION_BIT_DELETE_OWNED |
+			E_EWS_PERMISSION_BIT_FOLDER_VISIBLE },
+		{ "NoneditingAuthor",
+			E_EWS_PERMISSION_BIT_READ_ANY |
+			E_EWS_PERMISSION_BIT_CREATE |
+			E_EWS_PERMISSION_BIT_DELETE_OWNED |
+			E_EWS_PERMISSION_BIT_FOLDER_VISIBLE },
+		{ "Reviewer",
+			E_EWS_PERMISSION_BIT_READ_ANY |
+			E_EWS_PERMISSION_BIT_FOLDER_VISIBLE },
+		{ "Contributor",
+			E_EWS_PERMISSION_BIT_CREATE |
+			E_EWS_PERMISSION_BIT_FOLDER_VISIBLE },
+		{ "FreeBusyTimeOnly",
+			E_EWS_PERMISSION_BIT_FREE_BUSY_SIMPLE },
+		{ "FreeBusyTimeAndSubjectAndLocation",
+			E_EWS_PERMISSION_BIT_FREE_BUSY_DETAILED }
+
+	};
+	gint ii;
+	guint32 rights;
+
+	g_return_if_fail (plevel_name != NULL);
+	g_return_if_fail (prights != NULL);
+
+	rights = (*prights) & ~(E_EWS_PERMISSION_BIT_FREE_BUSY_SIMPLE | E_EWS_PERMISSION_BIT_FREE_BUSY_DETAILED);
+
+	for (ii = 0; ii < G_N_ELEMENTS (known); ii++) {
+		if (level_to_rights) {
+			if (g_strcmp0 (*plevel_name, known[ii].level_name) == 0) {
+				*prights = known[ii].rights;
+				return;
+			}
+		} else {
+			if (*prights == known[ii].rights || (rights && rights == known[ii].rights)) {
+				*plevel_name = known[ii].level_name;
+				return;
+			}
+		}
+	}
+
+	/* here lefts only "Custom" */
+	if (level_to_rights)
+		*prights = 0;
+	else
+		*plevel_name = "Custom";
+}
+
+/* converts user rights to level name suitable for PermissionLevel/CalendarPermissionLevel */
+const gchar *
+e_ews_permission_rights_to_level_name (guint32 rights)
+{
+	const gchar *level_name = NULL;
+
+	ews_level_rights_converter (&level_name, &rights, FALSE);
+
+	return level_name;
+}
+
+/* converts PermissionLevel/CalendarPermissionLevel name to user rights */
+guint32
+e_ews_permission_level_name_to_rights (const gchar *level_name)
+{
+	guint32 rights = 0;
+
+	ews_level_rights_converter (&level_name, &rights, TRUE);
+
+	return rights;
+}
+
+static EEwsPermission *
+ews_permissions_parse (ESoapParameter *param)
+{
+	EEwsPermission *res;
+	ESoapParameter *node, *subnode;
+	EEwsPermissionUserType user_type;
+	gchar *value, *display_name = NULL, *primary_smtp = NULL, *sid = NULL;
+	guint32 rights = 0;
+
+	g_return_val_if_fail (param != NULL, NULL);
+
+	node = e_soap_parameter_get_first_child_by_name (param, "UserId");
+	if (!node)
+		return NULL;
+
+	subnode = e_soap_parameter_get_first_child_by_name (node, "DistinguishedUser");
+	if (subnode) {
+		value = e_soap_parameter_get_string_value (subnode);
+		if (g_strcmp0 (value, "Anonymous") == 0) {
+			user_type = E_EWS_PERMISSION_USER_TYPE_ANONYMOUS;
+		} else if (g_strcmp0 (value, "Default") == 0) {
+			user_type = E_EWS_PERMISSION_USER_TYPE_DEFAULT;
+		} else {
+			g_free (value);
+			return NULL;
+		}
+
+		g_free (value);
+	} else {
+		user_type = E_EWS_PERMISSION_USER_TYPE_REGULAR;
+	}
+
+	subnode = e_soap_parameter_get_first_child_by_name (node, "SID");
+	if (subnode)
+		sid = e_soap_parameter_get_string_value (subnode);
+
+	subnode = e_soap_parameter_get_first_child_by_name (node, "PrimarySmtpAddress");
+	if (subnode)
+		primary_smtp = e_soap_parameter_get_string_value (subnode);
+
+	subnode = e_soap_parameter_get_first_child_by_name (node, "DisplayName");
+	if (subnode)
+		display_name = e_soap_parameter_get_string_value (subnode);
+
+	node = e_soap_parameter_get_first_child_by_name (param, "PermissionLevel");
+	if (!node)
+		node = e_soap_parameter_get_first_child_by_name (param, "CalendarPermissionLevel");
+
+	if (node) {
+		value = e_soap_parameter_get_string_value (node);
+		rights = e_ews_permission_level_name_to_rights (value);
+		g_free (value);
+	}
+
+	node = e_soap_parameter_get_first_child_by_name (param, "CanCreateItems");
+	if (node) {
+		value = e_soap_parameter_get_string_value (node);
+		if (g_strcmp0 (value, "true") == 0)
+			rights |= E_EWS_PERMISSION_BIT_CREATE;
+		g_free (value);
+	}
+
+	node = e_soap_parameter_get_first_child_by_name (param, "CanCreateSubFolders");
+	if (node) {
+		value = e_soap_parameter_get_string_value (node);
+		if (g_strcmp0 (value, "true") == 0)
+			rights |= E_EWS_PERMISSION_BIT_CREATE_SUBFOLDER;
+		g_free (value);
+	}
+
+	node = e_soap_parameter_get_first_child_by_name (param, "IsFolderOwner");
+	if (node) {
+		value = e_soap_parameter_get_string_value (node);
+		if (g_strcmp0 (value, "true") == 0)
+			rights |= E_EWS_PERMISSION_BIT_FOLDER_OWNER;
+		g_free (value);
+	}
+
+	node = e_soap_parameter_get_first_child_by_name (param, "IsFolderVisible");
+	if (node) {
+		value = e_soap_parameter_get_string_value (node);
+		if (g_strcmp0 (value, "true") == 0)
+			rights |= E_EWS_PERMISSION_BIT_FOLDER_VISIBLE;
+		g_free (value);
+	}
+
+	node = e_soap_parameter_get_first_child_by_name (param, "IsFolderContact");
+	if (node) {
+		value = e_soap_parameter_get_string_value (node);
+		if (g_strcmp0 (value, "true") == 0)
+			rights |= E_EWS_PERMISSION_BIT_FOLDER_CONTACT;
+		g_free (value);
+	}
+
+	node = e_soap_parameter_get_first_child_by_name (param, "EditItems");
+	if (node) {
+		value = e_soap_parameter_get_string_value (node);
+		if (g_strcmp0 (value, "None") == 0)
+			rights |= 0;
+		else if (g_strcmp0 (value, "Owned") == 0)
+			rights |= E_EWS_PERMISSION_BIT_EDIT_OWNED;
+		else if (g_strcmp0 (value, "All") == 0)
+			rights |= E_EWS_PERMISSION_BIT_EDIT_ANY;
+		g_free (value);
+	}
+
+	node = e_soap_parameter_get_first_child_by_name (param, "DeleteItems");
+	if (node) {
+		value = e_soap_parameter_get_string_value (node);
+		if (g_strcmp0 (value, "None") == 0)
+			rights |= 0;
+		else if (g_strcmp0 (value, "Owned") == 0)
+			rights |= E_EWS_PERMISSION_BIT_DELETE_OWNED;
+		else if (g_strcmp0 (value, "All") == 0)
+			rights |= E_EWS_PERMISSION_BIT_DELETE_ANY;
+		g_free (value);
+	}
+
+	node = e_soap_parameter_get_first_child_by_name (param, "ReadItems");
+	if (node) {
+		value = e_soap_parameter_get_string_value (node);
+		if (g_strcmp0 (value, "None") == 0)
+			rights |= 0;
+		else if (g_strcmp0 (value, "TimeOnly") == 0)
+			rights |= E_EWS_PERMISSION_BIT_FREE_BUSY_SIMPLE;
+		else if (g_strcmp0 (value, "TimeAndSubjectAndLocation") == 0)
+			rights |= E_EWS_PERMISSION_BIT_FREE_BUSY_DETAILED;
+		else if (g_strcmp0 (value, "FullDetails") == 0)
+			rights |= E_EWS_PERMISSION_BIT_READ_ANY;
+		g_free (value);
+	}
+
+	res = e_ews_permission_new (user_type, display_name, primary_smtp, sid, rights);
+
+	g_free (display_name);
+	g_free (primary_smtp);
+	g_free (sid);
+
+	return res;
+}
+
+/* Returns GSList of EEwsPermission * objects, as read from @param.
+ * Returned GSList should be freed with e_ews_permissions_free()
+ * when done with it. Returns NULL when no permissions recognized
+ * from @param.
+*/
+GSList *
+e_ews_permissions_from_soap_param (ESoapParameter *param)
+{
+	GSList *perms = NULL;
+	ESoapParameter *node;
+	const gchar *name;
+
+	g_return_val_if_fail (param != NULL, NULL);
+
+	name = e_soap_parameter_get_name (param);
+	if (g_ascii_strcasecmp (name, "Permissions") == 0 ||
+	    g_ascii_strcasecmp (name, "CalendarPermissions") == 0) {
+		node = param;
+	} else {
+		node = e_soap_parameter_get_first_child_by_name (param, "Permissions");
+		if (!node)
+			node = e_soap_parameter_get_first_child_by_name (param, "CalendarPermissions");
+		if (!node)
+			return NULL;
+	}
+
+	for (node = e_soap_parameter_get_first_child (node);
+	     node;
+	     node = e_soap_parameter_get_next_child (node)) {
+		name = e_soap_parameter_get_name (node);
+		if (g_ascii_strcasecmp (name, "Permission") == 0 ||
+		    g_ascii_strcasecmp (name, "CalendarPermission") == 0) {
+			EEwsPermission *perm;
+
+			perm = ews_permissions_parse (node);
+			if (perm) {
+				perms = g_slist_prepend (perms, perm);
+			}
+		}
+	}
+
+	return perms ? g_slist_reverse (perms) : NULL;
+}
+
+void
+e_ews_permissions_free (GSList *permissions)
+{
+	g_slist_free_full (permissions, (GDestroyNotify) e_ews_permission_free);
+}
+
+/* strips ex_address by its LDAP-like part, returning position in ex_address where
+   common name begins; returns whole ex_address, if not found */
+const gchar *
+e_ews_item_util_strip_ex_address (const gchar *ex_address)
+{
+	const gchar *ptr;
 
+	if (!ex_address)
+		return ex_address;
+
+	ptr = strrchr (ex_address, '/');
+	if (ptr && g_ascii_strncasecmp (ptr, "/cn=", 4) == 0) {
+		return ptr + 4;
+	}
+
+	return ex_address;
+}
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-ews-item-change.c evolution-ews.sync-with-3.8.2/src/server/e-ews-item-change.c
--- evolution-ews.git-gnome-3-0/src/server/e-ews-item-change.c	2013-05-17 14:36:16.356671234 +0200
+++ evolution-ews.sync-with-3.8.2/src/server/e-ews-item-change.c	2013-05-28 08:59:53.423144208 +0200
@@ -19,58 +19,74 @@
  * USA
  */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include "e-soap-message.h"
 #include "e-soap-response.h"
 #include "e-ews-message.h"
 #include "e-ews-item-change.h"
 
 void
-e_ews_message_start_item_change(ESoapMessage *msg, EEwsItemChangeType type,
-				const gchar *itemid, const gchar *changekey,
-				gint instance_index)
+e_ews_message_start_item_change (ESoapMessage *msg,
+                                 EEwsItemChangeType type,
+                                 const gchar *itemid,
+                                 const gchar *changekey,
+                                 gint instance_index)
 {
 	gchar *instance;
 
 	switch (type) {
 	case E_EWS_ITEMCHANGE_TYPE_FOLDER:
 		e_soap_message_start_element (msg, "FolderChange", NULL, NULL);
-		e_soap_message_start_element (msg, "FolderId",
-					      NULL, NULL);
-		e_soap_message_add_attribute (msg, "Id",
-					      itemid, NULL, NULL);
+		e_soap_message_start_element (
+			msg, "FolderId",
+			NULL, NULL);
+		e_soap_message_add_attribute (
+			msg, "Id",
+			itemid, NULL, NULL);
 		break;
 
 	case E_EWS_ITEMCHANGE_TYPE_ITEM:
 		e_soap_message_start_element (msg, "ItemChange", NULL, NULL);
-		e_soap_message_start_element (msg, "ItemId",
-					      NULL, NULL);
-		e_soap_message_add_attribute (msg, "Id",
-					      itemid, NULL, NULL);
+		e_soap_message_start_element (
+			msg, "ItemId",
+			NULL, NULL);
+		e_soap_message_add_attribute (
+			msg, "Id",
+			itemid, NULL, NULL);
 		break;
 
 	case E_EWS_ITEMCHANGE_TYPE_OCCURRENCEITEM:
 		e_soap_message_start_element (msg, "ItemChange", NULL, NULL);
-		e_soap_message_start_element (msg, "OccurrenceItemId",
-					      NULL, NULL);
-		e_soap_message_add_attribute (msg, "RecurringMasterId",
-					      itemid, NULL, NULL);
-		instance = g_strdup_printf("%d", instance_index);
-		e_soap_message_add_attribute (msg, "InstanceIndex", instance,
-					      NULL, NULL);
-		g_free(instance);
+		e_soap_message_start_element (
+			msg, "OccurrenceItemId",
+			NULL, NULL);
+		e_soap_message_add_attribute (
+			msg, "RecurringMasterId",
+			itemid, NULL, NULL);
+		instance = g_strdup_printf ("%d", instance_index);
+		e_soap_message_add_attribute (
+			msg, "InstanceIndex", instance,
+			NULL, NULL);
+		g_free (instance);
 		break;
 
 	case E_EWS_ITEMCHANGE_TYPE_RECURRINGMASTER:
 		e_soap_message_start_element (msg, "ItemChange", NULL, NULL);
-		e_soap_message_start_element (msg, "RecurringMasterItemId",
-					      NULL, NULL);
-		e_soap_message_add_attribute (msg, "OccurrenceId",
-					      itemid, NULL, NULL);
+		e_soap_message_start_element (
+			msg, "RecurringMasterItemId",
+			NULL, NULL);
+		e_soap_message_add_attribute (
+			msg, "OccurrenceId",
+			itemid, NULL, NULL);
 		break;
 	}
 	if (changekey)
-		e_soap_message_add_attribute (msg, "ChangeKey",
-					      changekey, NULL, NULL);
+		e_soap_message_add_attribute (
+			msg, "ChangeKey",
+			changekey, NULL, NULL);
 	e_soap_message_end_element (msg);
 
 	e_soap_message_start_element (msg, "Updates", NULL, NULL);
@@ -84,25 +100,34 @@ e_ews_message_end_item_change (ESoapMess
 }
 
 void
-e_ews_message_start_set_item_field (ESoapMessage *msg, const gchar *name, const gchar * fielduri_prefix, const char *field_kind)
+e_ews_message_start_set_item_field (ESoapMessage *msg,
+                                    const gchar *name,
+                                    const gchar *fielduri_prefix,
+                                    const gchar *field_kind)
 {
 	gchar * fielduri = NULL;
 	fielduri = g_strconcat (fielduri_prefix, ":", name, NULL);
 
 	e_soap_message_start_element (msg, "SetItemField", NULL, NULL);
-	e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL, "FieldURI", fielduri);
+	e_ews_message_write_string_parameter_with_attribute (
+		msg, "FieldURI", NULL, NULL, "FieldURI", fielduri);
 	e_soap_message_start_element (msg, field_kind, NULL, NULL);
 
 	g_free (fielduri);
 }
 
 void
-e_ews_message_start_set_indexed_item_field (ESoapMessage *msg, const gchar *name, const gchar * fielduri_prefix, const char *field_kind, const char *field_index, gboolean delete_field)
+e_ews_message_start_set_indexed_item_field (ESoapMessage *msg,
+                                            const gchar *name,
+                                            const gchar *fielduri_prefix,
+                                            const gchar *field_kind,
+                                            const gchar *field_index,
+                                            gboolean delete_field)
 {
 	gchar * fielduri = NULL;
 	fielduri = g_strconcat (fielduri_prefix, ":", name, NULL);
 
-	if(delete_field)
+	if (delete_field)
 		e_soap_message_start_element (msg, "DeleteItemField", NULL, NULL);
 	else
 		e_soap_message_start_element (msg, "SetItemField", NULL, NULL);
@@ -112,16 +137,17 @@ e_ews_message_start_set_indexed_item_fie
 	e_soap_message_add_attribute (msg, "FieldIndex", field_index, NULL, NULL);
 	e_soap_message_end_element (msg);
 
-	if(!delete_field)
+	if (!delete_field)
 		e_soap_message_start_element (msg, field_kind, NULL, NULL);
 
 	g_free (fielduri);
 }
 
 void
-e_ews_message_end_set_indexed_item_field (ESoapMessage *msg, gboolean delete_field)
+e_ews_message_end_set_indexed_item_field (ESoapMessage *msg,
+                                          gboolean delete_field)
 {
-	if(!delete_field)
+	if (!delete_field)
 		e_soap_message_end_element (msg); /* CalendarItem */
 	e_soap_message_end_element (msg); /* SetItemField */
 }
@@ -132,3 +158,40 @@ e_ews_message_end_set_item_field (ESoapM
 	e_soap_message_end_element (msg); /* CalendarItem */
 	e_soap_message_end_element (msg); /* SetItemField */
 }
+
+void
+e_ews_message_add_delete_item_field (ESoapMessage *msg,
+                                     const gchar *name,
+                                     const gchar *fielduri_prefix)
+{
+	gchar *fielduri;
+
+	fielduri = g_strconcat (fielduri_prefix, ":", name, NULL);
+
+	e_soap_message_start_element (msg, "DeleteItemField", NULL, NULL);
+	e_ews_message_write_string_parameter_with_attribute (
+		msg, "FieldURI", NULL, NULL, "FieldURI", fielduri);
+	e_soap_message_end_element (msg); /* DeleteItemField */
+
+	g_free (fielduri);
+}
+
+void
+e_ews_message_add_delete_item_field_indexed (ESoapMessage *msg,
+                                             const gchar *name,
+                                             const gchar *fielduri_prefix,
+                                             const gchar *field_index)
+{
+	gchar *fielduri;
+
+	fielduri = g_strconcat (fielduri_prefix, ":", name, NULL);
+
+	e_soap_message_start_element (msg, "DeleteItemField", NULL, NULL);
+	e_soap_message_start_element (msg, "IndexedFieldURI", NULL, NULL);
+	e_soap_message_add_attribute (msg, "FieldURI", fielduri, NULL, NULL);
+	e_soap_message_add_attribute (msg, "FieldIndex", field_index, NULL, NULL);
+	e_soap_message_end_element (msg); /* IndexedFieldURI */
+	e_soap_message_end_element (msg); /* DeleteItemField */
+
+	g_free (fielduri);
+}
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-ews-item-change.h evolution-ews.sync-with-3.8.2/src/server/e-ews-item-change.h
--- evolution-ews.git-gnome-3-0/src/server/e-ews-item-change.h	2013-05-17 14:36:16.356671234 +0200
+++ evolution-ews.sync-with-3.8.2/src/server/e-ews-item-change.h	2013-05-28 08:59:53.423733891 +0200
@@ -34,19 +34,23 @@ typedef enum {
 	E_EWS_ITEMCHANGE_TYPE_RECURRINGMASTER,
 } EEwsItemChangeType;
 
-void e_ews_message_start_item_change(ESoapMessage *msg, EEwsItemChangeType type,
+void e_ews_message_start_item_change (ESoapMessage *msg, EEwsItemChangeType type,
 				     const gchar *itemid, const gchar *changekey,
 				     gint instance_index);
 void e_ews_message_end_item_change (ESoapMessage *msg);
 
-void e_ews_message_start_set_item_field (ESoapMessage *msg, const gchar *name, const gchar * fielduri_prefix, const char *field_kind);
+void e_ews_message_start_set_item_field (ESoapMessage *msg, const gchar *name, const gchar * fielduri_prefix, const gchar *field_kind);
 
-void e_ews_message_start_set_indexed_item_field (ESoapMessage *msg, const gchar *name, const gchar * fielduri_prefix, const char *field_kind, const char *field_index, gboolean delete_field);
+void e_ews_message_start_set_indexed_item_field (ESoapMessage *msg, const gchar *name, const gchar * fielduri_prefix, const gchar *field_kind, const gchar *field_index, gboolean delete_field);
 
 void e_ews_message_end_set_indexed_item_field (ESoapMessage *msg, gboolean delete_field);
 
 void e_ews_message_end_set_item_field (ESoapMessage *msg);
 
+void e_ews_message_add_delete_item_field (ESoapMessage *msg, const gchar *name, const gchar *fielduri_prefix);
+
+void e_ews_message_add_delete_item_field_indexed (ESoapMessage *msg, const gchar *name, const gchar *fielduri_prefix, const gchar *field_index);
+
 G_END_DECLS
 
 #endif
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-ews-item.h evolution-ews.sync-with-3.8.2/src/server/e-ews-item.h
--- evolution-ews.git-gnome-3-0/src/server/e-ews-item.h	2013-05-17 14:36:16.357671048 +0200
+++ evolution-ews.sync-with-3.8.2/src/server/e-ews-item.h	2013-05-28 08:59:53.430713464 +0200
@@ -41,7 +41,7 @@ typedef enum {
 	E_EWS_ITEM_TYPE_UNKNOWN,
 	E_EWS_ITEM_TYPE_MESSAGE,
 	E_EWS_ITEM_TYPE_POST_ITEM,
-	E_EWS_ITEM_TYPE_CALENDAR_ITEM,
+	E_EWS_ITEM_TYPE_EVENT,
 	E_EWS_ITEM_TYPE_CONTACT,
 	E_EWS_ITEM_TYPE_GROUP,
 	E_EWS_ITEM_TYPE_MEETING_MESSAGE,
@@ -49,7 +49,9 @@ typedef enum {
 	E_EWS_ITEM_TYPE_MEETING_RESPONSE,
 	E_EWS_ITEM_TYPE_MEETING_CANCELLATION,
 	E_EWS_ITEM_TYPE_TASK,
-	E_EWS_ITEM_TYPE_GENERIC_ITEM
+	E_EWS_ITEM_TYPE_MEMO,
+	E_EWS_ITEM_TYPE_GENERIC_ITEM,
+	E_EWS_ITEM_TYPE_ERROR
 } EEwsItemType;
 
 typedef enum {
@@ -75,11 +77,17 @@ typedef struct {
 typedef struct {
 	gchar *name;
 	gchar *email;
-	gchar *mb_type;
+	gchar *routing_type;
+	gchar *mailbox_type;
 	EwsId *item_id;
 } EwsMailbox;
 
 typedef struct {
+	gchar *display_name;
+	GHashTable *email_addresses;
+} EwsResolveContact;
+
+typedef struct {
 	EwsMailbox *mailbox;
 	gchar *attendeetype;
 	gchar *responsetype;
@@ -106,13 +114,47 @@ typedef struct {
 	gchar *postal_code;
 } EwsAddress;
 
-GType       	e_ews_item_get_type (void);
+typedef enum {
+	E_EWS_PERMISSION_BIT_FREE_BUSY_DETAILED	= 0x00001000,
+	E_EWS_PERMISSION_BIT_FREE_BUSY_SIMPLE	= 0x00000800,
+	E_EWS_PERMISSION_BIT_FOLDER_VISIBLE	= 0x00000400,
+	E_EWS_PERMISSION_BIT_FOLDER_CONTACT	= 0x00000200,
+	E_EWS_PERMISSION_BIT_FOLDER_OWNER	= 0x00000100,
+	E_EWS_PERMISSION_BIT_CREATE_SUBFOLDER	= 0x00000080,
+	E_EWS_PERMISSION_BIT_DELETE_ANY		= 0x00000040,
+	E_EWS_PERMISSION_BIT_EDIT_ANY		= 0x00000020,
+	E_EWS_PERMISSION_BIT_DELETE_OWNED	= 0x00000010,
+	E_EWS_PERMISSION_BIT_EDIT_OWNED		= 0x00000008,
+	E_EWS_PERMISSION_BIT_CREATE		= 0x00000002,
+	E_EWS_PERMISSION_BIT_READ_ANY		= 0x00000001
+} EEwsPermissionBits;
+
+typedef enum {
+	E_EWS_PERMISSION_USER_TYPE_NONE		= 0,
+	E_EWS_PERMISSION_USER_TYPE_ANONYMOUS	= 1 << 1, /* anonymous user */
+	E_EWS_PERMISSION_USER_TYPE_DEFAULT	= 1 << 2, /* default rights for any users */
+	E_EWS_PERMISSION_USER_TYPE_REGULAR	= 1 << 3  /* regular user, the EEwsPermission::user_smtp member is valid */
+} EEwsPermissionUserType;
+
+typedef struct {
+	EEwsPermissionUserType user_type;	/* whether is distinguished name, if 'true' */
+	gchar *display_name;			/* display name for a user */
+	gchar *primary_smtp;			/* valid only for E_EWS_PERMISSION_USER_TYPE_REGULAR */
+	gchar *sid;				/* security identifier (SID), if any */
+	guint32 rights;				/* EEwsPermissionBits for the user */
+} EEwsPermission;
+
+GType		e_ews_item_get_type (void);
 EEwsItem *	e_ews_item_new_from_soap_parameter
 						(ESoapParameter *param);
+EEwsItem *	e_ews_item_new_from_error	(const GError *error);
 
-EEwsItemType 	e_ews_item_get_item_type	(EEwsItem *item);
+EEwsItemType	e_ews_item_get_item_type	(EEwsItem *item);
 void		e_ews_item_set_item_type	(EEwsItem *item,
 						 EEwsItemType new_type);
+const GError *	e_ews_item_get_error		(EEwsItem *item);
+void		e_ews_item_set_error		(EEwsItem *item,
+						 const GError *error);
 const gchar *	e_ews_item_get_subject		(EEwsItem *item);
 void		e_ews_item_set_subject		(EEwsItem *item,
 						 const gchar *new_subject);
@@ -120,7 +162,7 @@ const gchar *	e_ews_item_get_mime_conten
 void		e_ews_item_set_mime_content	(EEwsItem *item,
 						 const gchar *new_mime_content);
 const EwsId *	e_ews_item_get_id		(EEwsItem *item);
-const EwsId *	e_ews_item_get_attachment_id		(EEwsItem *item);
+const EwsId *	e_ews_item_get_attachment_id	(EEwsItem *item);
 gsize		e_ews_item_get_size		(EEwsItem *item);
 const gchar *	e_ews_item_get_msg_id		(EEwsItem *item);
 const gchar *	e_ews_item_get_uid		(EEwsItem *item);
@@ -151,20 +193,24 @@ const GSList *
 EwsMailbox *
 		e_ews_item_mailbox_from_soap_param
 						(ESoapParameter *param);
+void		e_ews_mailbox_free		(EwsMailbox *mailbox);
+EwsResolveContact *
+		e_ews_item_resolve_contact_from_soap_param (ESoapParameter *param);
+void		e_ews_free_resolve_contact	(/*EwsResolveContact * */ gpointer rc);
 
 const GSList *	e_ews_item_get_modified_occurrences
 						(EEwsItem *item);
-gchar *		e_ews_embed_attachment_id_in_uri (const gchar *olduri, const char *attach_id);
+gchar *		e_ews_embed_attachment_id_in_uri (const gchar *olduri, const gchar *attach_id);
 GSList *	e_ews_item_get_attachments_ids
 						(EEwsItem *item);
 gchar *
 e_ews_dump_file_attachment_from_soap_parameter (ESoapParameter *param, const gchar *cache, const gchar *comp_uid, gchar **attach_id);
 
 gchar *
-e_ews_item_ical_dump(EEwsItem *item);
+e_ews_item_ical_dump (EEwsItem *item);
 
 gchar *
-e_ews_item_dump_mime_content(EEwsItem *item, const gchar *cache);
+e_ews_item_dump_mime_content (EEwsItem *item, const gchar *cache);
 
 const GSList *	e_ews_item_get_attendees	(EEwsItem *item);
 
@@ -173,10 +219,10 @@ const EwsId *	e_ews_item_get_calendar_it
 
 /* Contact fields */
 const gchar *	e_ews_item_get_fileas		(EEwsItem *item);
-const EwsCompleteName *	
+const EwsCompleteName *
 		e_ews_item_get_complete_name	(EEwsItem *item);
 const gchar *	e_ews_item_get_email_address	(EEwsItem *item, const gchar *type);
-const EwsAddress *	
+const EwsAddress *
 		e_ews_item_get_physical_address	(EEwsItem *item, const gchar *type);
 const gchar *	e_ews_item_get_phone_number	(EEwsItem *item, const gchar *type);
 const gchar *	e_ews_item_get_im_address	(EEwsItem *item, const gchar *type);
@@ -196,6 +242,7 @@ const gchar *	e_ews_item_get_profession	
 const gchar *	e_ews_item_get_spouse_name	(EEwsItem *item);
 const gchar *	e_ews_item_get_culture		(EEwsItem *item);
 const gchar *	e_ews_item_get_surname		(EEwsItem *item);
+const gchar *	e_ews_item_get_notes		(EEwsItem *item);
 
 /*Task fields*/
 const gchar *	e_ews_item_get_status		(EEwsItem *item);
@@ -212,10 +259,31 @@ gboolean	e_ews_item_task_has_start_date	
 gboolean	e_ews_item_task_has_due_date	(EEwsItem *item,
 						 gboolean *has_date);
 gboolean	e_ews_item_task_has_complete_date
-						(EEwsItem* item,
-						 gboolean* has_date);
+						(EEwsItem * item,
+						 gboolean * has_date);
 const gchar *	e_ews_item_get_tzid		(EEwsItem *item);
 
+/* Folder Permissions */
+EEwsPermission *e_ews_permission_new		(EEwsPermissionUserType user_type,
+						 const gchar *display_name,
+						 const gchar *primary_smtp,
+						 const gchar *sid,
+						 guint32 rights);
+void		e_ews_permission_free		(EEwsPermission *perm);
+
+const gchar *	e_ews_permission_rights_to_level_name
+						(guint32 rights);
+guint32		e_ews_permission_level_name_to_rights
+						(const gchar *level_name);
+
+GSList *	e_ews_permissions_from_soap_param
+						(ESoapParameter *param);
+void		e_ews_permissions_free (GSList *permissions);
+
+/* Utility functions */
+const gchar *	e_ews_item_util_strip_ex_address
+						(const gchar *ex_address);
+
 G_END_DECLS
 
 #endif
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-ews-message.c evolution-ews.sync-with-3.8.2/src/server/e-ews-message.c
--- evolution-ews.git-gnome-3-0/src/server/e-ews-message.c	2013-05-17 14:36:16.357671048 +0200
+++ evolution-ews.sync-with-3.8.2/src/server/e-ews-message.c	2013-05-28 08:59:53.423733891 +0200
@@ -21,62 +21,104 @@
  * USA
  */
 
+#ifdef HAVE_CONFIG_H
 #include <config.h>
+#endif
+
 #include <string.h>
 #include <libsoup/soup-uri.h>
 #include "e-ews-message.h"
 
 ESoapMessage *
 e_ews_message_new_with_header (const gchar *uri,
-			      const gchar *method_name,
-			      const gchar *attribute_name,
-			      const gchar *attribute_value,
-			      EwsServerVersion server_info)
+			       const gchar *impersonate_user,
+                               const gchar *method_name,
+                               const gchar *attribute_name,
+                               const gchar *attribute_value,
+                               EwsServerVersion server_info)
 {
 	ESoapMessage *msg;
 	const gchar *server_ver;
 
-	msg = e_soap_message_new (SOUP_METHOD_POST, uri, FALSE, NULL, NULL, NULL);
-	if (!msg) {
+	msg = e_soap_message_new (
+		SOUP_METHOD_POST, uri, FALSE, NULL, NULL, NULL);
+	if (msg == NULL) {
 		g_warning (G_STRLOC ": Could not build SOAP message");
 		return NULL;
 	}
 
-	soup_message_headers_append (SOUP_MESSAGE (msg)->request_headers, "Content-Type", "text/xml");
-	soup_message_headers_append (SOUP_MESSAGE (msg)->request_headers, "User-Agent",
-				     "Evolution/" VERSION);
-	soup_message_headers_append (SOUP_MESSAGE (msg)->request_headers,"Connection",  "Keep-Alive");
+	soup_message_headers_append (
+		SOUP_MESSAGE (msg)->request_headers,
+		"Content-Type", "text/xml; charset=utf-8");
+	soup_message_headers_append (
+		SOUP_MESSAGE (msg)->request_headers,
+		"User-Agent", "Evolution/" VERSION);
+	soup_message_headers_append (
+		SOUP_MESSAGE (msg)->request_headers,
+		"Connection", "Keep-Alive");
 
 	e_soap_message_start_envelope (msg);
 
 	/* server info */
 	if (server_info == EWS_EXCHANGE_2007_SP1)
 		server_ver = "Exchange2007_SP1";
+	else if (server_info == EWS_EXCHANGE_2010)
+		server_ver = "Exchange2010";
+	else if (server_info == EWS_EXCHANGE_2010_SP1)
+		server_ver = "Exchange2010_SP1";
+	else if (server_info == EWS_EXCHANGE_2010_SP2)
+		server_ver = "Exchange2010_SP2";
 	else
 		server_ver = "Exchange2007";
 
 	e_soap_message_start_header (msg);
 
-	e_soap_message_start_element (msg, "RequestServerVersion", "types",
-					"http://schemas.microsoft.com/exchange/services/2006/types");
+	e_soap_message_start_element (
+		msg, "RequestServerVersion", "types",
+		"http://schemas.microsoft.com/exchange/services/2006/types");
 	e_soap_message_add_attribute (msg, "Version", server_ver, NULL, NULL);
 	e_soap_message_end_element (msg);
 
+	if (impersonate_user && *impersonate_user) {
+		e_soap_message_start_element (msg, "ExchangeImpersonation", "types",
+			"http://schemas.microsoft.com/exchange/services/2006/types");
+
+		e_soap_message_start_element (msg, "ConnectingSID", "types", NULL);
+
+		if (strchr (impersonate_user, '@') != 0)
+			e_soap_message_start_element (msg, "PrimarySmtpAddress", "types", NULL);
+		else
+			e_soap_message_start_element (msg, "PrincipalName", "types", NULL);
+		e_soap_message_write_string (msg, impersonate_user);
+		e_soap_message_end_element (msg); /* PrimarySmtpAddress or PrincipalName */
+
+		e_soap_message_end_element (msg); /* ConnectingSID */
+
+		e_soap_message_end_element (msg); /* ExchangeImpersonation */
+	}
+
 	e_soap_message_end_header (msg);
 
-	e_soap_message_start_body(msg);
-	e_soap_message_add_namespace(msg, "messages",
-				       "http://schemas.microsoft.com/exchange/services/2006/messages");
-	e_soap_message_start_element(msg, method_name, "messages", NULL);
-	e_soap_message_set_default_namespace(msg,
-						"http://schemas.microsoft.com/exchange/services/2006/types");
-	if (attribute_name)
-		e_soap_message_add_attribute (msg, attribute_name, attribute_value, NULL, NULL);
+	e_soap_message_start_body (msg);
+	e_soap_message_add_namespace (
+		msg, "messages",
+		"http://schemas.microsoft.com/exchange/services/2006/messages");
+	e_soap_message_start_element (msg, method_name, "messages", NULL);
+	e_soap_message_set_default_namespace (
+		msg,
+		"http://schemas.microsoft.com/exchange/services/2006/types");
+	if (attribute_name != NULL)
+		e_soap_message_add_attribute (
+			msg, attribute_name, attribute_value, NULL, NULL);
+
 	return msg;
 }
 
 void
-e_ews_message_write_string_parameter (ESoapMessage *msg, const gchar *name, const gchar *prefix, const gchar *value)
+e_ews_message_write_string_parameter (ESoapMessage *msg,
+                                      const gchar *name,
+                                      const gchar *prefix,
+                                      const gchar *value)
 {
 	e_soap_message_start_element (msg, name, prefix, NULL);
 	e_soap_message_write_string (msg, value);
@@ -85,20 +127,24 @@ e_ews_message_write_string_parameter (ES
 
 void
 e_ews_message_write_string_parameter_with_attribute (ESoapMessage *msg,
-						    const gchar *name,
-						    const gchar *prefix,
-						    const gchar *value,
-						    const gchar *attribute_name,
-						    const gchar *attribute_value)
+                                                     const gchar *name,
+                                                     const gchar *prefix,
+                                                     const gchar *value,
+                                                     const gchar *attribute_name,
+                                                     const gchar *attribute_value)
 {
 	e_soap_message_start_element (msg, name, prefix, NULL);
-	e_soap_message_add_attribute (msg, attribute_name, attribute_value, NULL, NULL);
+	e_soap_message_add_attribute (
+		msg, attribute_name, attribute_value, NULL, NULL);
 	e_soap_message_write_string (msg, value);
 	e_soap_message_end_element (msg);
 }
 
 void
-e_ews_message_write_base64_parameter (ESoapMessage *msg, const gchar *name, const gchar *prefix, const gchar *value)
+e_ews_message_write_base64_parameter (ESoapMessage *msg,
+                                      const gchar *name,
+                                      const gchar *prefix,
+                                      const gchar *value)
 {
 	e_soap_message_start_element (msg, name, prefix, NULL);
 	e_soap_message_write_base64 (msg, value, strlen (value));
@@ -106,7 +152,10 @@ e_ews_message_write_base64_parameter (ES
 }
 
 void
-e_ews_message_write_int_parameter (ESoapMessage *msg, const gchar *name, const gchar *prefix, glong value)
+e_ews_message_write_int_parameter (ESoapMessage *msg,
+                                   const gchar *name,
+                                   const gchar *prefix,
+                                   glong value)
 {
 	e_soap_message_start_element (msg, name, prefix, NULL);
 	e_soap_message_write_int (msg, value);
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-ews-message.h evolution-ews.sync-with-3.8.2/src/server/e-ews-message.h
--- evolution-ews.git-gnome-3-0/src/server/e-ews-message.h	2013-05-17 14:36:16.357671048 +0200
+++ evolution-ews.sync-with-3.8.2/src/server/e-ews-message.h	2013-05-28 08:59:53.425144879 +0200
@@ -30,17 +30,23 @@ G_BEGIN_DECLS
 
 typedef enum {
 	EWS_EXCHANGE_2007,
-	EWS_EXCHANGE_2007_SP1
+	EWS_EXCHANGE_2007_SP1,
+	EWS_EXCHANGE_2010,
+	EWS_EXCHANGE_2010_SP1,
+	EWS_EXCHANGE_2010_SP2
 } EwsServerVersion;
 
 ESoapMessage *	e_ews_message_new_with_header	(const gchar *uri,
+						 const gchar *impersonate_user,
 						 const gchar *method_name,
 						 const gchar *attribute_name,
 						 const gchar *attribute_value,
 						 EwsServerVersion version);
 void		e_ews_message_write_string_parameter
-						(ESoapMessage *msg, const gchar *name,
-						 const gchar *prefix, const gchar *value);
+						(ESoapMessage *msg,
+						 const gchar *name,
+						 const gchar *prefix,
+						 const gchar *value);
 void		e_ews_message_write_string_parameter_with_attribute
 						(ESoapMessage *msg,
 						 const gchar *name,
@@ -53,12 +59,11 @@ void		e_ews_message_write_base64_paramet
 						 const gchar *name,
 						 const gchar *prefix,
 						 const gchar *value);
-void 		e_ews_message_write_int_parameter
+void		e_ews_message_write_int_parameter
 						(ESoapMessage *msg,
 						 const gchar *name,
 						 const gchar *prefix,
 						 glong value);
-
 void		e_ews_message_write_footer	(ESoapMessage *msg);
 
 G_END_DECLS
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-ews-oof-settings.c evolution-ews.sync-with-3.8.2/src/server/e-ews-oof-settings.c
--- evolution-ews.git-gnome-3-0/src/server/e-ews-oof-settings.c	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/server/e-ews-oof-settings.c	2013-05-28 08:59:53.423144208 +0200
@@ -0,0 +1,1104 @@
+/*
+ * e-ews-oof-settings.c
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) version 3.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the program; if not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "e-ews-oof-settings.h"
+
+#include <glib/gi18n-lib.h>
+
+#include "e-ews-gnome-3-8-compat.h"
+
+#include "ews-errors.h"
+#include "e-ews-enumtypes.h"
+#include "e-ews-message.h"
+
+#define E_EWS_OOF_SETTINGS_GET_PRIVATE(obj) \
+	(G_TYPE_INSTANCE_GET_PRIVATE \
+	((obj), E_TYPE_EWS_OOF_SETTINGS, EEwsOofSettingsPrivate))
+
+/* Forward Declarations */
+static void	e_ews_oof_settings_initable_init
+					(GInitableIface *interface);
+static void	e_ews_oof_settings_async_initable_init
+					(GAsyncInitableIface *interface);
+
+struct _EEwsOofSettingsPrivate {
+	GMutex *property_lock;
+	EEwsConnection *connection;
+	EEwsOofState state;
+	EEwsExternalAudience external_audience;
+	GDateTime *start_time;
+	GDateTime *end_time;
+	gchar *internal_reply;
+	gchar *external_reply;
+};
+
+enum {
+	PROP_0,
+	PROP_CONNECTION,
+	PROP_END_TIME,
+	PROP_EXTERNAL_AUDIENCE,
+	PROP_EXTERNAL_REPLY,
+	PROP_INTERNAL_REPLY,
+	PROP_START_TIME,
+	PROP_STATE
+};
+
+G_DEFINE_TYPE_WITH_CODE (
+	EEwsOofSettings,
+	e_ews_oof_settings,
+	G_TYPE_OBJECT,
+	G_IMPLEMENT_INTERFACE (
+		G_TYPE_INITABLE,
+		e_ews_oof_settings_initable_init)
+	G_IMPLEMENT_INTERFACE (
+		G_TYPE_ASYNC_INITABLE,
+		e_ews_oof_settings_async_initable_init))
+
+static GDateTime *
+ews_oof_settings_string_to_date_time (const gchar *string)
+{
+	GTimeVal tv = { 0, 0 };
+	GDateTime *date_time = NULL;
+
+	if (g_time_val_from_iso8601 (string, &tv))
+		date_time = g_date_time_new_from_timeval_utc (&tv);
+
+	return date_time;
+}
+
+static gchar *
+ews_oof_settings_date_time_to_string (GDateTime *date_time)
+{
+	GTimeVal tv = { 0, 0 };
+	gchar *string = NULL;
+
+	if (g_date_time_to_timeval (date_time, &tv))
+		string = g_time_val_to_iso8601 (&tv);
+
+	return string;
+}
+
+static gchar *
+ews_oof_settings_text_from_html (gchar *html_text)
+{
+	gsize haystack_len;
+	gchar *plain_text;
+	gchar *start, *end;
+	gchar *ii, *jj;
+
+	/* Note, this consumes the input string. */
+
+	g_return_val_if_fail (html_text != NULL, NULL);
+
+	haystack_len = strlen (html_text);
+	start = g_strstr_len (html_text, haystack_len, "<body");
+	end = g_strstr_len (html_text, haystack_len, "</body>");
+
+	/* Parse the status set by Outlook Web Access. */
+	if (g_strrstr (html_text, "BodyFragment") != NULL && start == NULL) {
+		start = html_text;
+		end = html_text + haystack_len;
+	}
+
+	/* Strip HTML tags. */
+	plain_text = jj = g_malloc (end - start);
+	for (ii = start; ii < end; ii++) {
+		if (*ii == '<') {
+			while (*ii != '>')
+				ii++;
+		} else {
+			*jj++ = *ii;
+		}
+	}
+	*jj = '\0';
+
+	g_free (html_text);
+
+	return plain_text;
+}
+
+static void
+ews_oof_settings_get_response_cb (ESoapResponse *response,
+                                  GSimpleAsyncResult *simple)
+{
+	GAsyncResult *result;
+	GObject *source_object;
+	EEwsOofSettings *settings;
+	ESoapParameter *param;
+	ESoapParameter *subparam;
+	ESoapParameter *subsubparam;
+	GDateTime *date_time;
+	gchar *string;
+	GError *error = NULL;
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessage", &error);
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	if (!ews_get_response_status (param, &error)) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "OofSettings", &error);
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL) {
+		g_simple_async_result_take_error (simple, error);
+		return;
+	}
+
+	result = G_ASYNC_RESULT (simple);
+	source_object = g_async_result_get_source_object (result);
+	settings = E_EWS_OOF_SETTINGS (source_object);
+
+	subparam = e_soap_parameter_get_first_child_by_name (
+		param, "OofState");
+	string = e_soap_parameter_get_string_value (subparam);
+	if (g_strcmp0 (string, "Disabled") == 0)
+		e_ews_oof_settings_set_state (
+			settings, E_EWS_OOF_STATE_DISABLED);
+	else if (g_strcmp0 (string, "Enabled") == 0)
+		e_ews_oof_settings_set_state (
+			settings, E_EWS_OOF_STATE_ENABLED);
+	else if (g_strcmp0 (string, "Scheduled") == 0)
+		e_ews_oof_settings_set_state (
+			settings, E_EWS_OOF_STATE_SCHEDULED);
+	g_free (string);
+
+	subparam = e_soap_parameter_get_first_child_by_name (
+		param, "ExternalAudience");
+	string = e_soap_parameter_get_string_value (subparam);
+	if (g_strcmp0 (string, "None") == 0)
+		e_ews_oof_settings_set_external_audience (
+			settings, E_EWS_EXTERNAL_AUDIENCE_NONE);
+	else if (g_strcmp0 (string, "Known") == 0)
+		e_ews_oof_settings_set_external_audience (
+			settings, E_EWS_EXTERNAL_AUDIENCE_KNOWN);
+	else if (g_strcmp0 (string, "All") == 0)
+		e_ews_oof_settings_set_external_audience (
+			settings, E_EWS_EXTERNAL_AUDIENCE_ALL);
+	g_free (string);
+
+	subparam = e_soap_parameter_get_first_child_by_name (
+		param, "Duration");
+	subsubparam = e_soap_parameter_get_first_child_by_name (
+		subparam, "StartTime");
+	string = e_soap_parameter_get_string_value (subsubparam);
+	date_time = ews_oof_settings_string_to_date_time (string);
+	if (date_time != NULL) {
+		e_ews_oof_settings_set_start_time (settings, date_time);
+		g_date_time_unref (date_time);
+	}
+	g_free (string);
+	subsubparam = e_soap_parameter_get_first_child_by_name (
+		subparam, "EndTime");
+	string = e_soap_parameter_get_string_value (subsubparam);
+	date_time = ews_oof_settings_string_to_date_time (string);
+	if (date_time != NULL) {
+		e_ews_oof_settings_set_end_time (settings, date_time);
+		g_date_time_unref (date_time);
+	}
+	g_free (string);
+
+	subparam = e_soap_parameter_get_first_child_by_name (
+		param, "InternalReply");
+	subsubparam = e_soap_parameter_get_first_child_by_name (
+		subparam, "Message");
+	string = e_soap_parameter_get_string_value (subsubparam);
+	if (g_strrstr (string, "</body>") != NULL)
+		string = ews_oof_settings_text_from_html (string);
+	else if (g_strrstr (string, "BodyFragment") != NULL)
+		string = ews_oof_settings_text_from_html (string);
+	e_ews_oof_settings_set_internal_reply (settings, string);
+	g_free (string);
+
+	subparam = e_soap_parameter_get_first_child_by_name (
+		param, "ExternalReply");
+	subsubparam = e_soap_parameter_get_first_child_by_name (
+		subparam, "Message");
+	string = e_soap_parameter_get_string_value (subsubparam);
+	if (g_strrstr (string, "</body>") != NULL)
+		string = ews_oof_settings_text_from_html (string);
+	else if (g_strrstr (string, "BodyFragment") != NULL)
+		string = ews_oof_settings_text_from_html (string);
+	e_ews_oof_settings_set_external_reply (settings, string);
+	g_free (string);
+
+	g_object_unref (source_object);
+}
+
+static void
+ews_oof_settings_set_connection (EEwsOofSettings *settings,
+                                 EEwsConnection *connection)
+{
+	g_return_if_fail (E_IS_EWS_CONNECTION (connection));
+	g_return_if_fail (settings->priv->connection == NULL);
+
+	settings->priv->connection = g_object_ref (connection);
+}
+
+static void
+ews_oof_settings_set_property (GObject *object,
+                               guint property_id,
+                               const GValue *value,
+                               GParamSpec *pspec)
+{
+	switch (property_id) {
+		case PROP_CONNECTION:
+			ews_oof_settings_set_connection (
+				E_EWS_OOF_SETTINGS (object),
+				g_value_get_object (value));
+			return;
+
+		case PROP_END_TIME:
+			e_ews_oof_settings_set_end_time (
+				E_EWS_OOF_SETTINGS (object),
+				g_value_get_boxed (value));
+			return;
+
+		case PROP_EXTERNAL_AUDIENCE:
+			e_ews_oof_settings_set_external_audience (
+				E_EWS_OOF_SETTINGS (object),
+				g_value_get_enum (value));
+			return;
+
+		case PROP_EXTERNAL_REPLY:
+			e_ews_oof_settings_set_external_reply (
+				E_EWS_OOF_SETTINGS (object),
+				g_value_get_string (value));
+			return;
+
+		case PROP_INTERNAL_REPLY:
+			e_ews_oof_settings_set_internal_reply (
+				E_EWS_OOF_SETTINGS (object),
+				g_value_get_string (value));
+			return;
+
+		case PROP_START_TIME:
+			e_ews_oof_settings_set_start_time (
+				E_EWS_OOF_SETTINGS (object),
+				g_value_get_boxed (value));
+			return;
+
+		case PROP_STATE:
+			e_ews_oof_settings_set_state (
+				E_EWS_OOF_SETTINGS (object),
+				g_value_get_enum (value));
+			return;
+	}
+
+	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+}
+
+static void
+ews_oof_settings_get_property (GObject *object,
+                               guint property_id,
+                               GValue *value,
+                               GParamSpec *pspec)
+{
+	switch (property_id) {
+		case PROP_CONNECTION:
+			g_value_set_object (
+				value,
+				e_ews_oof_settings_get_connection (
+				E_EWS_OOF_SETTINGS (object)));
+			return;
+
+		case PROP_END_TIME:
+			g_value_take_boxed (
+				value,
+				e_ews_oof_settings_ref_end_time (
+				E_EWS_OOF_SETTINGS (object)));
+			return;
+
+		case PROP_EXTERNAL_AUDIENCE:
+			g_value_set_enum (
+				value,
+				e_ews_oof_settings_get_external_audience (
+				E_EWS_OOF_SETTINGS (object)));
+			return;
+
+		case PROP_EXTERNAL_REPLY:
+			g_value_take_string (
+				value,
+				e_ews_oof_settings_dup_external_reply (
+				E_EWS_OOF_SETTINGS (object)));
+			return;
+
+		case PROP_INTERNAL_REPLY:
+			g_value_take_string (
+				value,
+				e_ews_oof_settings_dup_internal_reply (
+				E_EWS_OOF_SETTINGS (object)));
+			return;
+
+		case PROP_START_TIME:
+			g_value_take_boxed (
+				value,
+				e_ews_oof_settings_ref_start_time (
+				E_EWS_OOF_SETTINGS (object)));
+			return;
+
+		case PROP_STATE:
+			g_value_set_enum (
+				value,
+				e_ews_oof_settings_get_state (
+				E_EWS_OOF_SETTINGS (object)));
+			return;
+	}
+
+	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+}
+
+static void
+ews_oof_settings_dispose (GObject *object)
+{
+	EEwsOofSettingsPrivate *priv;
+
+	priv = E_EWS_OOF_SETTINGS_GET_PRIVATE (object);
+
+	if (priv->connection != NULL) {
+		g_object_unref (priv->connection);
+		priv->connection = NULL;
+	}
+
+	/* Chain up to parent's dispose() method. */
+	G_OBJECT_CLASS (e_ews_oof_settings_parent_class)->dispose (object);
+}
+
+static void
+ews_oof_settings_finalize (GObject *object)
+{
+	EEwsOofSettingsPrivate *priv;
+
+	priv = E_EWS_OOF_SETTINGS_GET_PRIVATE (object);
+
+	g_mutex_free (priv->property_lock);
+
+	g_date_time_unref (priv->start_time);
+	g_date_time_unref (priv->end_time);
+
+	g_free (priv->internal_reply);
+	g_free (priv->external_reply);
+
+	/* Chain up to parent's finalize() method. */
+	G_OBJECT_CLASS (e_ews_oof_settings_parent_class)->finalize (object);
+}
+
+static gboolean
+ews_oof_settings_initable_init (GInitable *initable,
+                                GCancellable *cancellable,
+                                GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	closure = e_async_closure_new ();
+
+	g_async_initable_init_async (
+		G_ASYNC_INITABLE (initable),
+		G_PRIORITY_DEFAULT, cancellable,
+		e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = g_async_initable_init_finish (
+		G_ASYNC_INITABLE (initable), result, error);
+
+	e_async_closure_free (closure);
+
+	return success;
+}
+
+static void
+ews_oof_settings_initable_init_async (GAsyncInitable *initable,
+                                      gint io_priority,
+                                      GCancellable *cancellable,
+                                      GAsyncReadyCallback callback,
+                                      gpointer user_data)
+{
+	GSimpleAsyncResult *simple;
+	EEwsOofSettings *settings;
+	EEwsConnection *connection;
+	ESoapMessage *message;
+	const gchar *uri, *impersonate_user;
+	const gchar *mailbox;
+
+	settings = E_EWS_OOF_SETTINGS (initable);
+	connection = e_ews_oof_settings_get_connection (settings);
+
+	uri = e_ews_connection_get_uri (connection);
+	impersonate_user = e_ews_connection_get_impersonate_user (connection);
+	mailbox = e_ews_connection_get_mailbox (connection);
+
+	message = e_ews_message_new_with_header (
+		uri, impersonate_user, "GetUserOofSettingsRequest",
+		NULL, NULL, EWS_EXCHANGE_2007_SP1);
+
+	e_soap_message_start_element (message, "Mailbox", NULL, NULL);
+	e_ews_message_write_string_parameter (
+		message, "Address", NULL, mailbox);
+	e_soap_message_end_element (message);
+
+	e_ews_message_write_footer (message);
+
+	simple = g_simple_async_result_new (
+		G_OBJECT (initable), callback, user_data,
+		ews_oof_settings_initable_init_async);
+
+	g_simple_async_result_set_check_cancellable (simple, cancellable);
+
+	e_ews_connection_queue_request (
+		connection, message,
+		ews_oof_settings_get_response_cb,
+		EWS_PRIORITY_MEDIUM, cancellable, simple);
+
+	g_object_unref (simple);
+}
+
+static gboolean
+ews_oof_settings_initable_init_finish (GAsyncInitable *initable,
+                                       GAsyncResult *result,
+                                       GError **error)
+{
+	GSimpleAsyncResult *simple;
+
+	g_return_val_if_fail (
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (initable),
+		ews_oof_settings_initable_init_async), FALSE);
+
+	simple = G_SIMPLE_ASYNC_RESULT (result);
+
+	/* Assume success unless a GError is set. */
+	return !g_simple_async_result_propagate_error (simple, error);
+}
+
+static void
+e_ews_oof_settings_class_init (EEwsOofSettingsClass *class)
+{
+	GObjectClass *object_class;
+
+	g_type_class_add_private (class, sizeof (EEwsOofSettingsPrivate));
+
+	object_class = G_OBJECT_CLASS (class);
+	object_class->set_property = ews_oof_settings_set_property;
+	object_class->get_property = ews_oof_settings_get_property;
+	object_class->dispose = ews_oof_settings_dispose;
+	object_class->finalize = ews_oof_settings_finalize;
+
+	g_object_class_install_property (
+		object_class,
+		PROP_CONNECTION,
+		g_param_spec_object (
+			"connection",
+			"Connection",
+			"Exchange Web Services connection object",
+			E_TYPE_EWS_CONNECTION,
+			G_PARAM_READWRITE |
+			G_PARAM_CONSTRUCT_ONLY |
+			G_PARAM_STATIC_STRINGS));
+
+	g_object_class_install_property (
+		object_class,
+		PROP_END_TIME,
+		g_param_spec_boxed (
+			"end-time",
+			"End Time",
+			"The end of an Out of Office time span",
+			G_TYPE_DATE_TIME,
+			G_PARAM_READWRITE |
+			G_PARAM_STATIC_STRINGS));
+
+	g_object_class_install_property (
+		object_class,
+		PROP_EXTERNAL_AUDIENCE,
+		g_param_spec_enum (
+			"external-audience",
+			"External Audience",
+			"Determines to whom external "
+			"Out of Office messages are sent",
+			E_TYPE_EWS_EXTERNAL_AUDIENCE,
+			E_EWS_EXTERNAL_AUDIENCE_NONE,
+			G_PARAM_READWRITE |
+			G_PARAM_STATIC_STRINGS));
+
+	g_object_class_install_property (
+		object_class,
+		PROP_EXTERNAL_REPLY,
+		g_param_spec_string (
+			"external-reply",
+			"External Reply",
+			"Out of Office reply to external senders",
+			NULL,
+			G_PARAM_READWRITE |
+			G_PARAM_STATIC_STRINGS));
+
+	g_object_class_install_property (
+		object_class,
+		PROP_INTERNAL_REPLY,
+		g_param_spec_string (
+			"internal-reply",
+			"Internal Reply",
+			"Out of Office reply to internal senders",
+			NULL,
+			G_PARAM_READWRITE |
+			G_PARAM_STATIC_STRINGS));
+
+	g_object_class_install_property (
+		object_class,
+		PROP_START_TIME,
+		g_param_spec_boxed (
+			"start-time",
+			"Start Time",
+			"The start of an Out of Office time span",
+			G_TYPE_DATE_TIME,
+			G_PARAM_READWRITE |
+			G_PARAM_STATIC_STRINGS));
+
+	g_object_class_install_property (
+		object_class,
+		PROP_STATE,
+		g_param_spec_enum (
+			"state",
+			"State",
+			"Out of Office state",
+			E_TYPE_EWS_OOF_STATE,
+			E_EWS_OOF_STATE_DISABLED,
+			G_PARAM_READWRITE |
+			G_PARAM_STATIC_STRINGS));
+}
+
+static void
+e_ews_oof_settings_init (EEwsOofSettings *settings)
+{
+	settings->priv = E_EWS_OOF_SETTINGS_GET_PRIVATE (settings);
+
+	settings->priv->property_lock = g_mutex_new ();
+
+	/* This is just to make sure the values are never NULL.
+	 * They will be destroyed as soon as we get real values. */
+	settings->priv->start_time = g_date_time_new_now_local ();
+	settings->priv->end_time = g_date_time_new_now_local ();
+}
+
+static void
+e_ews_oof_settings_initable_init (GInitableIface *interface)
+{
+	interface->init = ews_oof_settings_initable_init;
+}
+
+static void
+e_ews_oof_settings_async_initable_init (GAsyncInitableIface *interface)
+{
+	interface->init_async = ews_oof_settings_initable_init_async;
+	interface->init_finish = ews_oof_settings_initable_init_finish;
+}
+
+EEwsOofSettings *
+e_ews_oof_settings_new_sync (EEwsConnection *connection,
+                             GCancellable *cancellable,
+                             GError **error)
+{
+	g_return_val_if_fail (E_IS_EWS_CONNECTION (connection), NULL);
+
+	return g_initable_new (
+		E_TYPE_EWS_OOF_SETTINGS, cancellable, error,
+		"connection", connection, NULL);
+}
+
+void
+e_ews_oof_settings_new (EEwsConnection *connection,
+                        gint io_priority,
+                        GCancellable *cancellable,
+                        GAsyncReadyCallback callback,
+                        gpointer user_data)
+{
+	g_return_if_fail (E_IS_EWS_CONNECTION (connection));
+
+	g_async_initable_new_async (
+		E_TYPE_EWS_OOF_SETTINGS, io_priority,
+		cancellable, callback, user_data,
+		"connection", connection, NULL);
+}
+
+EEwsOofSettings *
+e_ews_oof_settings_new_finish (GAsyncResult *result,
+                               GError **error)
+{
+	GObject *source_object;
+	GObject *object;
+
+	g_return_val_if_fail (G_IS_ASYNC_RESULT (result), NULL);
+
+	source_object = g_async_result_get_source_object (result);
+	g_return_val_if_fail (source_object != NULL, NULL);
+
+	object = g_async_initable_new_finish (
+		G_ASYNC_INITABLE (source_object), result, error);
+
+	g_object_unref (source_object);
+
+	return (object != NULL) ? E_EWS_OOF_SETTINGS (object) : NULL;
+}
+
+EEwsConnection *
+e_ews_oof_settings_get_connection (EEwsOofSettings *settings)
+{
+	g_return_val_if_fail (E_IS_EWS_OOF_SETTINGS (settings), NULL);
+
+	return settings->priv->connection;
+}
+
+EEwsOofState
+e_ews_oof_settings_get_state (EEwsOofSettings *settings)
+{
+	g_return_val_if_fail (
+		E_IS_EWS_OOF_SETTINGS (settings),
+		E_EWS_OOF_STATE_DISABLED);
+
+	return settings->priv->state;
+}
+
+void
+e_ews_oof_settings_set_state (EEwsOofSettings *settings,
+                              EEwsOofState state)
+{
+	g_return_if_fail (E_IS_EWS_OOF_SETTINGS (settings));
+
+	if (settings->priv->state == state)
+		return;
+
+	settings->priv->state = state;
+
+	g_object_notify (G_OBJECT (settings), "state");
+}
+
+EEwsExternalAudience
+e_ews_oof_settings_get_external_audience (EEwsOofSettings *settings)
+{
+	g_return_val_if_fail (
+		E_IS_EWS_OOF_SETTINGS (settings),
+		E_EWS_EXTERNAL_AUDIENCE_NONE);
+
+	return settings->priv->external_audience;
+}
+
+void
+e_ews_oof_settings_set_external_audience (EEwsOofSettings *settings,
+                                          EEwsExternalAudience external_audience)
+{
+	g_return_if_fail (E_IS_EWS_OOF_SETTINGS (settings));
+
+	if (settings->priv->external_audience == external_audience)
+		return;
+
+	settings->priv->external_audience = external_audience;
+
+	g_object_notify (G_OBJECT (settings), "external-audience");
+}
+
+GDateTime *
+e_ews_oof_settings_ref_start_time (EEwsOofSettings *settings)
+{
+	g_return_val_if_fail (E_IS_EWS_OOF_SETTINGS (settings), NULL);
+
+	return g_date_time_ref (settings->priv->start_time);
+}
+
+void
+e_ews_oof_settings_set_start_time (EEwsOofSettings *settings,
+                                   GDateTime *start_time)
+{
+	g_return_if_fail (E_IS_EWS_OOF_SETTINGS (settings));
+	g_return_if_fail (start_time != NULL);
+
+	g_mutex_lock (settings->priv->property_lock);
+
+	if (g_date_time_compare (settings->priv->start_time, start_time) == 0) {
+		g_mutex_unlock (settings->priv->property_lock);
+		return;
+	}
+
+	if (start_time != settings->priv->start_time) {
+		g_date_time_unref (settings->priv->start_time);
+		settings->priv->start_time = g_date_time_ref (start_time);
+	}
+
+	g_mutex_unlock (settings->priv->property_lock);
+
+	g_object_notify (G_OBJECT (settings), "start-time");
+}
+
+GDateTime *
+e_ews_oof_settings_ref_end_time (EEwsOofSettings *settings)
+{
+	g_return_val_if_fail (E_IS_EWS_OOF_SETTINGS (settings), NULL);
+
+	return g_date_time_ref (settings->priv->end_time);
+}
+
+void
+e_ews_oof_settings_set_end_time (EEwsOofSettings *settings,
+                                 GDateTime *end_time)
+{
+	g_return_if_fail (E_IS_EWS_OOF_SETTINGS (settings));
+	g_return_if_fail (end_time != NULL);
+
+	g_mutex_lock (settings->priv->property_lock);
+
+	if (g_date_time_compare (settings->priv->end_time, end_time) == 0) {
+		g_mutex_unlock (settings->priv->property_lock);
+		return;
+	}
+
+	if (end_time != settings->priv->end_time) {
+		g_date_time_unref (settings->priv->end_time);
+		settings->priv->end_time = g_date_time_ref (end_time);
+	}
+
+	g_mutex_unlock (settings->priv->property_lock);
+
+	g_object_notify (G_OBJECT (settings), "end-time");
+}
+
+const gchar *
+e_ews_oof_settings_get_internal_reply (EEwsOofSettings *settings)
+{
+	g_return_val_if_fail (E_IS_EWS_OOF_SETTINGS (settings), NULL);
+
+	return settings->priv->internal_reply;
+}
+
+gchar *
+e_ews_oof_settings_dup_internal_reply (EEwsOofSettings *settings)
+{
+	const gchar *protected;
+	gchar *duplicate;
+
+	g_return_val_if_fail (E_IS_EWS_OOF_SETTINGS (settings), NULL);
+
+	g_mutex_lock (settings->priv->property_lock);
+
+	protected = e_ews_oof_settings_get_internal_reply (settings);
+	duplicate = g_strdup (protected);
+
+	g_mutex_unlock (settings->priv->property_lock);
+
+	return duplicate;
+}
+
+void
+e_ews_oof_settings_set_internal_reply (EEwsOofSettings *settings,
+                                       const gchar *internal_reply)
+{
+	g_return_if_fail (E_IS_EWS_OOF_SETTINGS (settings));
+
+	g_mutex_lock (settings->priv->property_lock);
+
+	if (g_strcmp0 (internal_reply, settings->priv->internal_reply) == 0) {
+		g_mutex_unlock (settings->priv->property_lock);
+		return;
+	}
+
+	g_free (settings->priv->internal_reply);
+	settings->priv->internal_reply = g_strdup (internal_reply);
+
+	g_mutex_unlock (settings->priv->property_lock);
+
+	g_object_notify (G_OBJECT (settings), "internal-reply");
+}
+
+const gchar *
+e_ews_oof_settings_get_external_reply (EEwsOofSettings *settings)
+{
+	g_return_val_if_fail (E_IS_EWS_OOF_SETTINGS (settings), NULL);
+
+	return settings->priv->external_reply;
+}
+
+gchar *
+e_ews_oof_settings_dup_external_reply (EEwsOofSettings *settings)
+{
+	const gchar *protected;
+	gchar *duplicate;
+
+	g_return_val_if_fail (E_IS_EWS_OOF_SETTINGS (settings), NULL);
+
+	g_mutex_lock (settings->priv->property_lock);
+
+	protected = e_ews_oof_settings_get_external_reply (settings);
+	duplicate = g_strdup (protected);
+
+	g_mutex_unlock (settings->priv->property_lock);
+
+	return duplicate;
+}
+
+void
+e_ews_oof_settings_set_external_reply (EEwsOofSettings *settings,
+                                       const gchar *external_reply)
+{
+	g_return_if_fail (E_IS_EWS_OOF_SETTINGS (settings));
+
+	g_mutex_lock (settings->priv->property_lock);
+
+	if (g_strcmp0 (external_reply, settings->priv->external_reply) == 0) {
+		g_mutex_unlock (settings->priv->property_lock);
+		return;
+	}
+
+	g_free (settings->priv->external_reply);
+	settings->priv->external_reply = g_strdup (external_reply);
+
+	g_mutex_unlock (settings->priv->property_lock);
+
+	g_object_notify (G_OBJECT (settings), "external-reply");
+}
+
+gboolean
+e_ews_oof_settings_submit_sync (EEwsOofSettings *settings,
+                                GCancellable *cancellable,
+                                GError **error)
+{
+	EAsyncClosure *closure;
+	GAsyncResult *result;
+	gboolean success;
+
+	g_return_val_if_fail (E_IS_EWS_OOF_SETTINGS (settings), FALSE);
+
+	closure = e_async_closure_new ();
+
+	e_ews_oof_settings_submit (
+		settings, cancellable, e_async_closure_callback, closure);
+
+	result = e_async_closure_wait (closure);
+
+	success = e_ews_oof_settings_submit_finish (settings, result, error);
+
+	e_async_closure_free (closure);
+
+	return success;
+}
+
+static void
+ews_oof_settings_submit_response_cb (ESoapResponse *response,
+                                     GSimpleAsyncResult *simple)
+{
+	ESoapParameter *param;
+	GError *error = NULL;
+
+	param = e_soap_response_get_first_parameter_by_name (
+		response, "ResponseMessage", &error);
+
+	/* Sanity check */
+	g_return_if_fail (
+		(param != NULL && error == NULL) ||
+		(param == NULL && error != NULL));
+
+	if (error != NULL)
+		g_simple_async_result_take_error (simple, error);
+
+	else if (!ews_get_response_status (param, &error))
+		g_simple_async_result_take_error (simple, error);
+}
+
+void
+e_ews_oof_settings_submit (EEwsOofSettings *settings,
+                           GCancellable *cancellable,
+                           GAsyncReadyCallback callback,
+                           gpointer user_data)
+{
+	ESoapMessage *message;
+	EEwsConnection *connection;
+	GSimpleAsyncResult *simple;
+	GDateTime *date_time;
+	const gchar *mailbox;
+	const gchar *string;
+	const gchar *uri, *impersonate_user;
+	gchar *internal_reply;
+	gchar *external_reply;
+	gchar *start_time;
+	gchar *end_time;
+
+	g_return_if_fail (E_IS_EWS_OOF_SETTINGS (settings));
+
+	connection = e_ews_oof_settings_get_connection (settings);
+	mailbox = e_ews_connection_get_mailbox (connection);
+	uri = e_ews_connection_get_uri (connection);
+	impersonate_user = e_ews_connection_get_impersonate_user (connection);
+
+	internal_reply = e_ews_oof_settings_dup_internal_reply (settings);
+	external_reply = e_ews_oof_settings_dup_external_reply (settings);
+
+	date_time = e_ews_oof_settings_ref_start_time (settings);
+	start_time = ews_oof_settings_date_time_to_string (date_time);
+	g_date_time_unref (date_time);
+
+	date_time = e_ews_oof_settings_ref_end_time (settings);
+	end_time = ews_oof_settings_date_time_to_string (date_time);
+	g_date_time_unref (date_time);
+
+	message = e_ews_message_new_with_header (
+		uri, impersonate_user, "SetUserOofSettingsRequest",
+		NULL, NULL, EWS_EXCHANGE_2007_SP1);
+
+	/* <Mailbox> */
+
+	e_soap_message_start_element (
+		message, "Mailbox", NULL, NULL);
+	e_ews_message_write_string_parameter (
+		message, "Address", NULL, mailbox);
+	e_soap_message_end_element (message);
+
+	/* </Mailbox> */
+
+	/* <UserOofSettings> */
+
+	e_soap_message_start_element (
+		message, "UserOofSettings", NULL, NULL);
+
+	switch (e_ews_oof_settings_get_state (settings)) {
+		default:
+			g_warn_if_reached ();
+			/* fall through */
+		case E_EWS_OOF_STATE_DISABLED:
+			string = "Disabled";
+			break;
+		case E_EWS_OOF_STATE_ENABLED:
+			string = "Enabled";
+			break;
+		case E_EWS_OOF_STATE_SCHEDULED:
+			string = "Scheduled";
+			break;
+	}
+
+	e_ews_message_write_string_parameter (
+		message, "OofState", NULL, string);
+
+	switch (e_ews_oof_settings_get_external_audience (settings)) {
+		default:
+			g_warn_if_reached ();
+			/* fall through */
+		case E_EWS_EXTERNAL_AUDIENCE_NONE:
+			string = "None";
+			break;
+		case E_EWS_EXTERNAL_AUDIENCE_KNOWN:
+			string = "Known";
+			break;
+		case E_EWS_EXTERNAL_AUDIENCE_ALL:
+			string = "All";
+			break;
+	}
+
+	e_ews_message_write_string_parameter (
+		message, "ExternalAudience", NULL, string);
+
+	/* <Duration> */
+
+	e_soap_message_start_element (
+		message, "Duration", NULL, NULL);
+	e_ews_message_write_string_parameter (
+		message, "StartTime", NULL, start_time);
+	e_ews_message_write_string_parameter (
+		message, "EndTime", NULL, end_time);
+	e_soap_message_end_element (message);
+
+	/* </Duration> */
+
+	/* <InternalReply> */
+
+	e_soap_message_start_element (
+		message, "InternalReply", NULL, NULL);
+	e_ews_message_write_string_parameter (
+		message, "Message", NULL, internal_reply);
+	e_soap_message_end_element (message);
+
+	/* </InternalReply> */
+
+	/* <ExternalReply> */
+
+	e_soap_message_start_element (
+		message, "ExternalReply", NULL, NULL);
+	e_ews_message_write_string_parameter (
+		message, "Message", NULL, external_reply);
+	e_soap_message_end_element (message);
+
+	/* </ExternalReply> */
+
+	e_soap_message_end_element (message);
+
+	/* </UserOofSettings> */
+
+	e_ews_message_write_footer (message);
+
+	simple = g_simple_async_result_new (
+		G_OBJECT (settings), callback,
+		user_data, e_ews_oof_settings_submit);
+
+	e_ews_connection_queue_request (
+		connection, message,
+		ews_oof_settings_submit_response_cb,
+		EWS_PRIORITY_MEDIUM, cancellable, simple);
+
+	g_object_unref (simple);
+
+	g_free (internal_reply);
+	g_free (external_reply);
+	g_free (start_time);
+	g_free (end_time);
+}
+
+gboolean
+e_ews_oof_settings_submit_finish (EEwsOofSettings *settings,
+                                  GAsyncResult *result,
+                                  GError **error)
+{
+	GSimpleAsyncResult *simple;
+
+	g_return_val_if_fail (
+		g_simple_async_result_is_valid (
+		result, G_OBJECT (settings),
+		e_ews_oof_settings_submit), FALSE);
+
+	simple = G_SIMPLE_ASYNC_RESULT (result);
+
+	/* Assume success unless a GError is set. */
+	return !g_simple_async_result_propagate_error (simple, error);
+}
+
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-ews-oof-settings.h evolution-ews.sync-with-3.8.2/src/server/e-ews-oof-settings.h
--- evolution-ews.git-gnome-3-0/src/server/e-ews-oof-settings.h	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/server/e-ews-oof-settings.h	2013-05-28 08:59:53.423733891 +0200
@@ -0,0 +1,121 @@
+/*
+ * e-ews-oof-settings.h
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) version 3.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the program; if not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef E_EWS_OOF_SETTINGS_H
+#define E_EWS_OOF_SETTINGS_H
+
+#include <server/e-ews-connection.h>
+#include <server/e-ews-enums.h>
+
+/* Standard GObject macros */
+#define E_TYPE_EWS_OOF_SETTINGS \
+	(e_ews_oof_settings_get_type ())
+#define E_EWS_OOF_SETTINGS(obj) \
+	(G_TYPE_CHECK_INSTANCE_CAST \
+	((obj), E_TYPE_EWS_OOF_SETTINGS, EEwsOofSettings))
+#define E_EWS_OOF_SETTINGS_CLASS(cls) \
+	(G_TYPE_CHECK_CLASS_CAST \
+	((cls), E_TYPE_EWS_OOF_SETTINGS, EEwsOofSettingsClass))
+#define E_IS_EWS_OOF_SETTINGS(obj) \
+	(G_TYPE_CHECK_INSTANCE_TYPE \
+	((obj), E_TYPE_EWS_OOF_SETTINGS))
+#define E_IS_EWS_OOF_SETTINGS_CLASS(cls) \
+	(G_TYPE_CHECK_CLASS_TYPE \
+	((cls), E_TYPE_EWS_OOF_SETTINGS))
+#define E_EWS_OOF_SETTINGS_GET_CLASS(obj) \
+	(G_TYPE_INSTANCE_GET_CLASS \
+	((obj), E_TYPE_EWS_OOF_SETTINGS, EEwsOofSettingsClass))
+
+G_BEGIN_DECLS
+
+typedef struct _EEwsOofSettings EEwsOofSettings;
+typedef struct _EEwsOofSettingsClass EEwsOofSettingsClass;
+typedef struct _EEwsOofSettingsPrivate EEwsOofSettingsPrivate;
+
+struct _EEwsOofSettings {
+	GObject parent;
+	EEwsOofSettingsPrivate *priv;
+};
+
+struct _EEwsOofSettingsClass {
+	GObjectClass parent_class;
+};
+
+GType		e_ews_oof_settings_get_type	(void) G_GNUC_CONST;
+EEwsOofSettings *
+		e_ews_oof_settings_new_sync	(EEwsConnection *connection,
+						 GCancellable *cancellable,
+						 GError **error);
+void		e_ews_oof_settings_new		(EEwsConnection *connection,
+						 gint io_priority,
+						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
+						 gpointer user_data);
+EEwsOofSettings *
+		e_ews_oof_settings_new_finish	(GAsyncResult *result,
+						 GError **error);
+EEwsConnection *
+		e_ews_oof_settings_get_connection
+						(EEwsOofSettings *settings);
+EEwsOofState	e_ews_oof_settings_get_state	(EEwsOofSettings *settings);
+void		e_ews_oof_settings_set_state	(EEwsOofSettings *settings,
+						 EEwsOofState state);
+EEwsExternalAudience
+		e_ews_oof_settings_get_external_audience
+						(EEwsOofSettings *settings);
+void		e_ews_oof_settings_set_external_audience
+						(EEwsOofSettings *settings,
+						 EEwsExternalAudience external_audience);
+GDateTime *	e_ews_oof_settings_ref_start_time
+						(EEwsOofSettings *settings);
+void		e_ews_oof_settings_set_start_time
+						(EEwsOofSettings *settings,
+						 GDateTime *start_time);
+GDateTime *	e_ews_oof_settings_ref_end_time	(EEwsOofSettings *settings);
+void		e_ews_oof_settings_set_end_time	(EEwsOofSettings *settings,
+						 GDateTime *end_time);
+const gchar *	e_ews_oof_settings_get_internal_reply
+						(EEwsOofSettings *settings);
+gchar *		e_ews_oof_settings_dup_internal_reply
+						(EEwsOofSettings *settings);
+void		e_ews_oof_settings_set_internal_reply
+						(EEwsOofSettings *settings,
+						 const gchar *internal_reply);
+const gchar *	e_ews_oof_settings_get_external_reply
+						(EEwsOofSettings *settings);
+gchar *		e_ews_oof_settings_dup_external_reply
+						(EEwsOofSettings *settings);
+void		e_ews_oof_settings_set_external_reply
+						(EEwsOofSettings *settings,
+						 const gchar *external_reply);
+gboolean	e_ews_oof_settings_submit_sync	(EEwsOofSettings *settings,
+						 GCancellable *cancellable,
+						 GError **error);
+void		e_ews_oof_settings_submit	(EEwsOofSettings *settings,
+						 GCancellable *cancellable,
+						 GAsyncReadyCallback callback,
+						 gpointer user_data);
+gboolean	e_ews_oof_settings_submit_finish
+						(EEwsOofSettings *settings,
+						 GAsyncResult *result,
+						 GError **error);
+
+G_END_DECLS
+
+#endif /* E_EWS_OOF_SETTINGS_H */
+
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-soap-message.c evolution-ews.sync-with-3.8.2/src/server/e-soap-message.c
--- evolution-ews.git-gnome-3-0/src/server/e-soap-message.c	2013-05-17 14:36:16.357671048 +0200
+++ evolution-ews.sync-with-3.8.2/src/server/e-soap-message.c	2013-05-28 08:59:53.423733891 +0200
@@ -3,6 +3,10 @@
  * Copyright (C) 1999-2008 Novell, Inc. (www.novell.com)
  */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include <libedataserver/eds-version.h>
 
 #include <string.h>
@@ -13,9 +17,11 @@
 #endif
 #include "e-soap-message.h"
 
-G_DEFINE_TYPE (ESoapMessage, e_soap_message, SOUP_TYPE_MESSAGE)
+#define E_SOAP_MESSAGE_GET_PRIVATE(obj) \
+	(G_TYPE_INSTANCE_GET_PRIVATE \
+	((obj), E_TYPE_SOAP_MESSAGE, ESoapMessagePrivate))
 
-typedef struct {
+struct _ESoapMessagePrivate {
 	/* Serialization fields */
 	xmlParserCtxtPtr ctxt;
 	xmlDocPtr doc;
@@ -34,95 +40,124 @@ typedef struct {
 
 	gint steal_b64_state;
 	guint steal_b64_save;
-	int steal_fd;
+	gint steal_fd;
 
 	/* Progress callbacks */
 	gsize response_size;
 	gsize response_received;
 	ESoapProgressFn progress_fn;
 	gpointer progress_data;
+};
 
-} ESoapMessagePrivate;
-#define E_SOAP_MESSAGE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), E_TYPE_SOAP_MESSAGE, ESoapMessagePrivate))
+G_DEFINE_TYPE (ESoapMessage, e_soap_message, SOUP_TYPE_MESSAGE)
 
 static void
-finalize (GObject *object)
+soap_message_finalize (GObject *object)
 {
-	ESoapMessagePrivate *priv = E_SOAP_MESSAGE_GET_PRIVATE (object);
+	ESoapMessagePrivate *priv;
 
-	if (priv->ctxt) {
-		if (priv->ctxt->myDoc)
+	priv = E_SOAP_MESSAGE_GET_PRIVATE (object);
+
+	if (priv->ctxt != NULL) {
+		if (priv->ctxt->myDoc != NULL)
 			xmlFreeDoc (priv->ctxt->myDoc);
 		xmlFreeParserCtxt (priv->ctxt);
 	}
-	if (priv->doc)
+
+	if (priv->doc != NULL)
 		xmlFreeDoc (priv->doc);
-	if (priv->action)
+
+	if (priv->action != NULL)
 		g_free (priv->action);
-	if (priv->env_uri)
-                xmlFree (priv->env_uri);
-	if (priv->env_prefix)
-                xmlFree (priv->env_prefix);
+
+	if (priv->env_uri != NULL)
+		xmlFree (priv->env_uri);
+
+	if (priv->env_prefix != NULL)
+		xmlFree (priv->env_prefix);
 
 	g_free (priv->steal_node);
 	g_free (priv->steal_dir);
+
 	if (priv->steal_fd != -1)
 		close (priv->steal_fd);
+
+	/* Chain up to parent's finalize() method. */
 	G_OBJECT_CLASS (e_soap_message_parent_class)->finalize (object);
 }
 
 static void
-e_soap_message_class_init (ESoapMessageClass *e_soap_message_class)
+e_soap_message_class_init (ESoapMessageClass *class)
 {
-	GObjectClass *object_class = G_OBJECT_CLASS (e_soap_message_class);
+	GObjectClass *object_class;
 
-	g_type_class_add_private (e_soap_message_class, sizeof (ESoapMessagePrivate));
+	g_type_class_add_private (class, sizeof (ESoapMessagePrivate));
 
-	object_class->finalize = finalize;
+	object_class = G_OBJECT_CLASS (class);
+	object_class->finalize = soap_message_finalize;
 }
 
 static void
 e_soap_message_init (ESoapMessage *msg)
 {
-	ESoapMessagePrivate *priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
+	msg->priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 
 	/* initialize XML structures */
-	priv->doc = xmlNewDoc ((const xmlChar *)"1.0");
-	priv->doc->standalone = FALSE;
-	priv->doc->encoding = xmlCharStrdup ("UTF-8");
-	priv->steal_fd = -1;
+	msg->priv->doc = xmlNewDoc ((const xmlChar *) "1.0");
+	msg->priv->doc->standalone = FALSE;
+	msg->priv->doc->encoding = xmlCharStrdup ("UTF-8");
+	msg->priv->steal_fd = -1;
+
+#ifdef HAVE_SOUP_MESSAGE_IDEMPOTENT_FLAG
+	soup_message_set_flags (SOUP_MESSAGE (msg), SOUP_MESSAGE_IDEMPOTENT);
+#endif
 }
 
 static xmlNsPtr
-fetch_ns (ESoapMessage *msg, const gchar *prefix, const gchar *ns_uri)
+fetch_ns (ESoapMessage *msg,
+          const gchar *prefix,
+          const gchar *ns_uri)
 {
 	ESoapMessagePrivate *priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
-        xmlNsPtr ns = NULL;
+	xmlNsPtr ns = NULL;
 
-        if (prefix && ns_uri)
-                ns = xmlNewNs (priv->last_node, (const xmlChar *)ns_uri, (const xmlChar *)prefix);
-        else if (prefix && !ns_uri) {
-                ns = xmlSearchNs (priv->doc, priv->last_node, (const xmlChar *)prefix);
-                if (!ns)
-			ns = xmlNewNs (priv->last_node, (const xmlChar *)"", (const xmlChar *)prefix);
-        }
+	if (prefix && ns_uri)
+		ns = xmlNewNs (
+			priv->last_node,
+			(const xmlChar *) ns_uri,
+			(const xmlChar *) prefix);
+	else if (prefix && !ns_uri) {
+		ns = xmlSearchNs (
+			priv->doc, priv->last_node,
+			(const xmlChar *) prefix);
+		if (!ns)
+			ns = xmlNewNs (
+				priv->last_node,
+				(const xmlChar *) "",
+				(const xmlChar *) prefix);
+	}
 
-        return ns;
+	return ns;
 }
 
-static void soap_got_headers (SoupMessage *msg, gpointer data)
+static void
+soap_got_headers (SoupMessage *msg,
+                  gpointer data)
 {
 	ESoapMessagePrivate *priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
-	const char *size;
+	const gchar *size;
 
-	size = soup_message_headers_get_one (msg->response_headers,
-					     "Content-Length");
+	size = soup_message_headers_get_one (
+		msg->response_headers,
+		"Content-Length");
 
 	if (size)
-		priv->response_size = strtol(size, NULL, 10);
+		priv->response_size = strtol (size, NULL, 10);
 }
 
-static void soap_restarted (SoupMessage *msg, gpointer data)
+static void
+soap_restarted (SoupMessage *msg,
+                gpointer data)
 {
 	ESoapMessagePrivate *priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 
@@ -138,23 +173,25 @@ static void soap_restarted (SoupMessage 
 	}
 }
 
-static void soap_sax_startElementNs (void * _ctxt,
-				     const xmlChar *localname,
-				     const xmlChar *prefix,
-				     const xmlChar *uri,
-				     int nb_namespaces,
-				     const xmlChar **namespaces,
-				     int nb_attributes,
-				     int nb_defaulted,
-				     const xmlChar **attributes)
+static void
+soap_sax_startElementNs (gpointer _ctxt,
+                         const xmlChar *localname,
+                         const xmlChar *prefix,
+                         const xmlChar *uri,
+                         gint nb_namespaces,
+                         const xmlChar **namespaces,
+                         gint nb_attributes,
+                         gint nb_defaulted,
+                         const xmlChar **attributes)
 {
 	xmlParserCtxt *ctxt = _ctxt;
 	ESoapMessagePrivate *priv = ctxt->_private;
 	gchar *fname;
 
-	xmlSAX2StartElementNs (ctxt, localname, prefix, uri, nb_namespaces,
-			       namespaces, nb_attributes, nb_defaulted,
-			       attributes);
+	xmlSAX2StartElementNs (
+		ctxt, localname, prefix, uri, nb_namespaces,
+		namespaces, nb_attributes, nb_defaulted,
+		attributes);
 
 	/* steal_node can contain multiple node name separated by " " */
 	if (priv->steal_node && *priv->steal_node) {
@@ -163,7 +200,7 @@ static void soap_sax_startElementNs (voi
 		gboolean isnode = FALSE;
 
 		while (prop[i]) {
-			if (strcmp ((const char *)localname, prop [i]) == 0) {
+			if (strcmp ((const gchar *) localname, prop[i]) == 0) {
 				isnode = TRUE;
 				break;
 			}
@@ -179,19 +216,20 @@ static void soap_sax_startElementNs (voi
 	priv->steal_fd = g_mkstemp (fname);
 	if (priv->steal_fd != -1) {
 		if (priv->steal_base64) {
-			gchar *enc = g_base64_encode ((guchar *)fname, strlen(fname));
-			xmlSAX2Characters (ctxt, (xmlChar *)enc, strlen (enc));
+			gchar *enc = g_base64_encode ((guchar *) fname, strlen (fname));
+			xmlSAX2Characters (ctxt, (xmlChar *) enc, strlen (enc));
 			g_free (enc);
 		} else
-			xmlSAX2Characters (ctxt, (xmlChar *)fname, strlen (fname));
+			xmlSAX2Characters (ctxt, (xmlChar *) fname, strlen (fname));
 	}
 	g_free (fname);
 }
 
-static void soap_sax_endElementNs (void *_ctxt,
-				   const xmlChar *localname,
-				   const xmlChar *prefix,
-				   const xmlChar *uri)
+static void
+soap_sax_endElementNs (gpointer _ctxt,
+                       const xmlChar *localname,
+                       const xmlChar *prefix,
+                       const xmlChar *uri)
 {
 	xmlParserCtxt *ctxt = _ctxt;
 	ESoapMessagePrivate *priv = ctxt->_private;
@@ -207,7 +245,10 @@ static void soap_sax_endElementNs (void 
 	xmlSAX2EndElementNs (ctxt, localname, prefix, uri);
 }
 
-static void soap_sax_characters (void *_ctxt, const xmlChar *ch, int len)
+static void
+soap_sax_characters (gpointer _ctxt,
+                     const xmlChar *ch,
+                     gint len)
 {
 	xmlParserCtxt *ctxt = _ctxt;
 	ESoapMessagePrivate *priv = ctxt->_private;
@@ -215,7 +256,7 @@ static void soap_sax_characters (void *_
 	if (priv->steal_fd == -1)
 		xmlSAX2Characters (ctxt, ch, len);
 	else if (!priv->steal_base64) {
-		if (write (priv->steal_fd, (const gchar*)ch, len) != len) {
+		if (write (priv->steal_fd, (const gchar *) ch, len) != len) {
 		write_err:
 			/* Handle error better */
 			g_warning ("Failed to write streaming data to file");
@@ -224,33 +265,36 @@ static void soap_sax_characters (void *_
 		guchar *bdata = g_malloc (len);
 		gsize blen;
 
-		blen = g_base64_decode_step ((const gchar *)ch, len,
-					     bdata, &priv->steal_b64_state,
-					     &priv->steal_b64_save);
-		if (write (priv->steal_fd, (const gchar*)bdata, blen) != blen) {
+		blen = g_base64_decode_step (
+			(const gchar *) ch, len,
+			bdata, &priv->steal_b64_state,
+			&priv->steal_b64_save);
+		if (write (priv->steal_fd, (const gchar *) bdata, blen) != blen) {
 			g_free (bdata);
 			goto write_err;
 		}
 		g_free (bdata);
 	}
 }
-static void soap_got_chunk (SoupMessage *msg, SoupBuffer *chunk, gpointer data)
+
+static void
+soap_got_chunk (SoupMessage *msg,
+                SoupBuffer *chunk,
+                gpointer data)
 {
 	ESoapMessagePrivate *priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 
-	if (msg->status_code != 200)
-		return;
-
 	priv->response_received += chunk->length;
 
 	if (priv->response_size && priv->progress_fn) {
-		int pc = priv->response_received * 100 / priv->response_size;
+		gint pc = priv->response_received * 100 / priv->response_size;
 		priv->progress_fn (priv->progress_data, pc);
 	}
 
 	if (!priv->ctxt) {
-		priv->ctxt = xmlCreatePushParserCtxt (NULL, msg, chunk->data,
-						      chunk->length, NULL);
+		priv->ctxt = xmlCreatePushParserCtxt (
+			NULL, msg, chunk->data,
+			chunk->length, NULL);
 		priv->ctxt->_private = priv;
 		priv->ctxt->sax->startElementNs = soap_sax_startElementNs;
 		priv->ctxt->sax->endElementNs = soap_sax_endElementNs;
@@ -273,13 +317,14 @@ static void soap_got_chunk (SoupMessage 
  *
  * Returns: the new #ESoapMessage (or %NULL if @uri_string could not be
  * parsed).
- *
- * Since: 2.92
  */
 ESoapMessage *
-e_soap_message_new (const gchar *method, const gchar *uri_string,
-		       gboolean standalone, const gchar *xml_encoding,
-		       const gchar *env_prefix, const gchar *env_uri)
+e_soap_message_new (const gchar *method,
+                    const gchar *uri_string,
+                    gboolean standalone,
+                    const gchar *xml_encoding,
+                    const gchar *env_prefix,
+                    const gchar *env_uri)
 {
 	ESoapMessage *msg;
 	SoupURI *uri;
@@ -288,15 +333,17 @@ e_soap_message_new (const gchar *method,
 	if (!uri)
 		return NULL;
 
-	msg = e_soap_message_new_from_uri (method, uri, standalone,
-					   xml_encoding, env_prefix, env_uri);
+	msg = e_soap_message_new_from_uri (
+		method, uri, standalone,
+		xml_encoding, env_prefix, env_uri);
 
 	soup_uri_free (uri);
 
 	/* Don't accumulate body data into a huge buffer.
-	   Instead, parse it as it arrives. */
-	soup_message_body_set_accumulate (SOUP_MESSAGE (msg)->response_body,
-					  FALSE);
+	 * Instead, parse it as it arrives. */
+	soup_message_body_set_accumulate (
+		SOUP_MESSAGE (msg)->response_body,
+		FALSE);
 	g_signal_connect (msg, "got-headers", G_CALLBACK (soap_got_headers), NULL);
 	g_signal_connect (msg, "got-chunk", G_CALLBACK (soap_got_chunk), NULL);
 	g_signal_connect (msg, "restarted", G_CALLBACK (soap_restarted), NULL);
@@ -316,35 +363,33 @@ e_soap_message_new (const gchar *method,
  * Creates a new empty #ESoapMessage, which will connect to @uri
  *
  * Returns: the new #ESoapMessage
- *
- * Since: 2.92
  */
 ESoapMessage *
-e_soap_message_new_from_uri (const gchar *method, SoupURI *uri,
-				gboolean standalone, const gchar *xml_encoding,
-				const gchar *env_prefix, const gchar *env_uri)
+e_soap_message_new_from_uri (const gchar *method,
+                             SoupURI *uri,
+                             gboolean standalone,
+                             const gchar *xml_encoding,
+                             const gchar *env_prefix,
+                             const gchar *env_uri)
 {
 	ESoapMessage *msg;
-	ESoapMessagePrivate *priv;
-
-	msg = g_object_new (E_TYPE_SOAP_MESSAGE,
-			    SOUP_MESSAGE_METHOD, method,
-			    SOUP_MESSAGE_URI, uri,
-			    NULL);
 
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
+	msg = g_object_new (
+		E_TYPE_SOAP_MESSAGE,
+		SOUP_MESSAGE_METHOD, method,
+		SOUP_MESSAGE_URI, uri, NULL);
 
-	priv->doc->standalone = standalone;
+	msg->priv->doc->standalone = standalone;
 
 	if (xml_encoding) {
-		xmlFree ((xmlChar *)priv->doc->encoding);
-		priv->doc->encoding = xmlCharStrdup (xml_encoding);
+		xmlFree ((xmlChar *) msg->priv->doc->encoding);
+		msg->priv->doc->encoding = xmlCharStrdup (xml_encoding);
 	}
 
-	if (env_prefix)
-		priv->env_prefix = xmlCharStrdup (env_prefix);
-	if (env_uri)
-		priv->env_uri = xmlCharStrdup (env_uri);
+	if (env_prefix != NULL)
+		msg->priv->env_prefix = xmlCharStrdup (env_prefix);
+	if (env_uri != NULL)
+		msg->priv->env_uri = xmlCharStrdup (env_uri);
 
 	return msg;
 }
@@ -359,24 +404,19 @@ e_soap_message_new_from_uri (const gchar
  * This requests that character data for certain XML nodes should
  * be streamed directly to a disk file as it arrives, rather than
  * being stored in memory in the soup response buffer.
- *
- * Since: xxx
  */
 
 void
 e_soap_message_store_node_data (ESoapMessage *msg,
-				const gchar *nodename,
-				const gchar *directory,
-				gboolean base64)
+                                const gchar *nodename,
+                                const gchar *directory,
+                                gboolean base64)
 {
-	ESoapMessagePrivate *priv;
-
 	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 
-	priv->steal_node = g_strdup (nodename);
-	priv->steal_dir = g_strdup (directory);
-	priv->steal_base64 = base64;
+	msg->priv->steal_node = g_strdup (nodename);
+	msg->priv->steal_dir = g_strdup (directory);
+	msg->priv->steal_base64 = base64;
 }
 
 /**
@@ -386,20 +426,16 @@ e_soap_message_store_node_data (ESoapMes
  * @object: first argument to callback function
  *
  * Starts the top level SOAP Envelope element.
- *
- * Since: xxx
  */
-void		  e_soap_message_set_progress_fn (ESoapMessage *msg,
-						  ESoapProgressFn fn,
-						  gpointer object)
+void
+e_soap_message_set_progress_fn (ESoapMessage *msg,
+                                ESoapProgressFn fn,
+                                gpointer object)
 {
-	ESoapMessagePrivate *priv;
-
 	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 
-	priv->progress_fn = fn;
-	priv->progress_data = object;
+	msg->priv->progress_fn = fn;
+	msg->priv->progress_data = object;
 }
 
 /**
@@ -407,47 +443,54 @@ void		  e_soap_message_set_progress_fn (
  * @msg: the %ESoapMessage.
  *
  * Starts the top level SOAP Envelope element.
- *
- * Since: 2.92
  */
 void
 e_soap_message_start_envelope (ESoapMessage *msg)
 {
-	ESoapMessagePrivate *priv;
-
 	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
-
-	priv->last_node = priv->doc->xmlRootNode =
-		xmlNewDocNode (priv->doc, NULL, (const xmlChar *)"Envelope", NULL);
 
-	priv->soap_ns = xmlNewNs (priv->doc->xmlRootNode,
-				  priv->env_uri ? priv->env_uri :
-				  (const xmlChar *)"http://schemas.xmlsoap.org/soap/envelope/",
-				  priv->env_prefix ? priv->env_prefix : (const xmlChar *)"SOAP-ENV");
-	if (priv->env_uri) {
-		xmlFree (priv->env_uri);
-		priv->env_uri = NULL;
-	}
-	if (priv->env_prefix) {
-		xmlFree (priv->env_prefix);
-		priv->env_prefix = NULL;
+	msg->priv->doc->xmlRootNode = xmlNewDocNode (
+		msg->priv->doc, NULL,
+		(const xmlChar *) "Envelope",
+		(const xmlChar *) NULL);
+	msg->priv->last_node = msg->priv->doc->xmlRootNode;
+
+	msg->priv->soap_ns = xmlNewNs (
+		msg->priv->doc->xmlRootNode,
+		msg->priv->env_uri ? msg->priv->env_uri :
+		(const xmlChar *) "http://schemas.xmlsoap.org/soap/envelope/",
+		msg->priv->env_prefix ? msg->priv->env_prefix :
+		(const xmlChar *) "SOAP-ENV");
+
+	if (msg->priv->env_uri != NULL) {
+		xmlFree (msg->priv->env_uri);
+		msg->priv->env_uri = NULL;
 	}
 
-	xmlSetNs (priv->doc->xmlRootNode, priv->soap_ns);
+	if (msg->priv->env_prefix) {
+		xmlFree (msg->priv->env_prefix);
+		msg->priv->env_prefix = NULL;
+	}
 
-	xmlNewNs (priv->doc->xmlRootNode,
-		  (const xmlChar *)"http://schemas.xmlsoap.org/soap/encoding/",
-                  (const xmlChar *)"SOAP-ENC");
-	xmlNewNs (priv->doc->xmlRootNode,
-                  (const xmlChar *)"http://www.w3.org/1999/XMLSchema",
-                  (const xmlChar *)"xsd");
-	xmlNewNs (priv->doc->xmlRootNode,
-		  (const xmlChar *)"http://schemas.xmlsoap.org/soap/envelope/",
-		  (const xmlChar *)"SOAP-ENV");
-	priv->xsi_ns = xmlNewNs (priv->doc->xmlRootNode,
-				 (const xmlChar *)"http://www.w3.org/1999/XMLSchema-instance",
-				 (const xmlChar *)"xsi");
+	xmlSetNs (
+		msg->priv->doc->xmlRootNode,
+		msg->priv->soap_ns);
+	xmlNewNs (
+		msg->priv->doc->xmlRootNode,
+		(const xmlChar *) "http://schemas.xmlsoap.org/soap/encoding/",
+		(const xmlChar *) "SOAP-ENC");
+	xmlNewNs (
+		msg->priv->doc->xmlRootNode,
+		(const xmlChar *) "http://www.w3.org/2001/XMLSchema",
+		(const xmlChar *) "xsd");
+	xmlNewNs (
+		msg->priv->doc->xmlRootNode,
+		(const xmlChar *) "http://schemas.xmlsoap.org/soap/envelope/",
+		(const xmlChar *) "SOAP-ENV");
+	msg->priv->xsi_ns = xmlNewNs (
+		msg->priv->doc->xmlRootNode,
+		(const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance",
+		(const xmlChar *) "xsi");
 }
 
 /**
@@ -455,8 +498,6 @@ e_soap_message_start_envelope (ESoapMess
  * @msg: the %ESoapMessage.
  *
  * Closes the top level SOAP Envelope element.
- *
- * Since: 2.92
  */
 void
 e_soap_message_end_envelope (ESoapMessage *msg)
@@ -469,25 +510,21 @@ e_soap_message_end_envelope (ESoapMessag
  * @msg: the %ESoapMessage.
  *
  * Starts the SOAP Body element.
- *
- * Since: 2.92
  */
 void
 e_soap_message_start_body (ESoapMessage *msg)
 {
-	ESoapMessagePrivate *priv;
-
 	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 
-	if (priv->body_started)
+	if (msg->priv->body_started)
 		return;
 
-	priv->last_node = xmlNewChild (priv->last_node,
-				       priv->soap_ns,
-				       (const xmlChar *)"Body", NULL);
+	msg->priv->last_node = xmlNewChild (
+		msg->priv->last_node,
+		msg->priv->soap_ns,
+		(const xmlChar *) "Body", NULL);
 
-	priv->body_started = TRUE;
+	msg->priv->body_started = TRUE;
 }
 
 /**
@@ -495,8 +532,6 @@ e_soap_message_start_body (ESoapMessage 
  * @msg: the %ESoapMessage.
  *
  * Closes the SOAP Body element.
- *
- * Since: 2.92
  */
 void
 e_soap_message_end_body (ESoapMessage *msg)
@@ -524,27 +559,26 @@ e_soap_message_end_body (ESoapMessage *m
  *
  * Passing NULL for both @prefix and @ns_uri causes no prefix to be
  * used, and the element will be in the default namespace.
- *
- * Since: 2.92
  */
 void
 e_soap_message_start_element (ESoapMessage *msg,
-				 const gchar *name,
-				 const gchar *prefix,
-				 const gchar *ns_uri)
+                              const gchar *name,
+                              const gchar *prefix,
+                              const gchar *ns_uri)
 {
-	ESoapMessagePrivate *priv;
-
 	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 
-	priv->last_node = xmlNewChild (priv->last_node, NULL, (const xmlChar *)name, NULL);
+	msg->priv->last_node = xmlNewChild (
+		msg->priv->last_node, NULL,
+		(const xmlChar *) name, NULL);
+
+	xmlSetNs (msg->priv->last_node, fetch_ns (msg, prefix, ns_uri));
 
-	xmlSetNs (priv->last_node, fetch_ns (msg, prefix, ns_uri));
+	if (ns_uri == NULL)
+		ns_uri = "";
 
-	if (priv->body_started && !priv->action)
-		priv->action = g_strconcat (ns_uri ? ns_uri : "",
-					    "#", name, NULL);
+	if (msg->priv->body_started && msg->priv->action == NULL)
+		msg->priv->action = g_strconcat (ns_uri, "#", name, NULL);
 }
 
 /**
@@ -552,18 +586,13 @@ e_soap_message_start_element (ESoapMessa
  * @msg: the #ESoapMessage.
  *
  * Closes the current message element.
- *
- * Since: 2.92
  */
 void
 e_soap_message_end_element (ESoapMessage *msg)
 {
-	ESoapMessagePrivate *priv;
-
 	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 
-	priv->last_node = priv->last_node->parent;
+	msg->priv->last_node = msg->priv->last_node->parent;
 }
 
 /**
@@ -579,29 +608,36 @@ e_soap_message_end_element (ESoapMessage
  * If you wish to add the faultdetail element, use
  * e_soap_message_start_fault_detail(), and then
  * e_soap_message_start_element() to add arbitrary sub-elements.
- *
- * Since: 2.92
  */
 void
 e_soap_message_start_fault (ESoapMessage *msg,
-			       const gchar *faultcode,
-			       const gchar *faultstring,
-			       const gchar *faultfactor)
+                            const gchar *faultcode,
+                            const gchar *faultstring,
+                            const gchar *faultfactor)
 {
-	ESoapMessagePrivate *priv;
-
 	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 
-	priv->last_node = xmlNewChild (priv->last_node,
-				       priv->soap_ns,
-				       (const xmlChar *)"Fault", NULL);
-	xmlNewChild (priv->last_node, priv->soap_ns, (const xmlChar *)"faultcode", (const xmlChar *)faultcode);
-	xmlNewChild (priv->last_node, priv->soap_ns, (const xmlChar *)"faultstring", (const xmlChar *)faultstring);
-
-	priv->last_node = xmlNewChild (priv->last_node, priv->soap_ns,
-				       (const xmlChar *)"faultfactor", (const xmlChar *)faultfactor);
-	if (!faultfactor)
+	msg->priv->last_node = xmlNewChild (
+		msg->priv->last_node,
+		msg->priv->soap_ns,
+		(const xmlChar *) "Fault", NULL);
+	xmlNewChild (
+		msg->priv->last_node,
+		msg->priv->soap_ns,
+		(const xmlChar *) "faultcode",
+		(const xmlChar *) faultcode);
+	xmlNewChild (
+		msg->priv->last_node,
+		msg->priv->soap_ns,
+		(const xmlChar *) "faultstring",
+		(const xmlChar *) faultstring);
+
+	msg->priv->last_node = xmlNewChild (
+		msg->priv->last_node,
+		msg->priv->soap_ns,
+		(const xmlChar *) "faultfactor",
+		(const xmlChar *) faultfactor);
+	if (faultfactor == NULL)
 		e_soap_message_set_null (msg);
 
 	e_soap_message_end_element (msg);
@@ -612,13 +648,11 @@ e_soap_message_start_fault (ESoapMessage
  * @msg: the #ESoapMessage.
  *
  * Closes the current SOAP Fault element.
- *
- * Since: 2.92
  */
 void
 e_soap_message_end_fault (ESoapMessage *msg)
 {
-        e_soap_message_end_element (msg);
+	e_soap_message_end_element (msg);
 }
 
 /**
@@ -628,21 +662,18 @@ e_soap_message_end_fault (ESoapMessage *
  * Start the faultdetail child element of the current SOAP Fault
  * element. The faultdetail element allows arbitrary data to be sent
  * in a returned fault.
- *
- * Since: 2.92
  **/
 void
 e_soap_message_start_fault_detail (ESoapMessage *msg)
 {
-	ESoapMessagePrivate *priv;
 
-        g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
+	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
 
-        priv->last_node = xmlNewChild (priv->last_node,
-				       priv->soap_ns,
-				       (const xmlChar *)"detail",
-				       NULL);
+	msg->priv->last_node = xmlNewChild (
+		msg->priv->last_node,
+		msg->priv->soap_ns,
+		(const xmlChar *) "detail",
+		(const xmlChar *) NULL);
 }
 
 /**
@@ -650,8 +681,6 @@ e_soap_message_start_fault_detail (ESoap
  * @msg: the #ESoapMessage.
  *
  * Closes the current SOAP faultdetail element.
- *
- * Since: 2.92
  */
 void
 e_soap_message_end_fault_detail (ESoapMessage *msg)
@@ -670,19 +699,17 @@ e_soap_message_end_fault_detail (ESoapMe
  *
  * This should be called after e_soap_message_start_envelope() and
  * before e_soap_message_start_body().
- *
- * Since: 2.92
  */
 void
 e_soap_message_start_header (ESoapMessage *msg)
 {
-	ESoapMessagePrivate *priv;
-
 	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 
-	priv->last_node = xmlNewChild (priv->last_node, priv->soap_ns,
-				       (const xmlChar *)"Header", NULL);
+	msg->priv->last_node = xmlNewChild (
+		msg->priv->last_node,
+		msg->priv->soap_ns,
+		(const xmlChar *) "Header",
+		(const xmlChar *) NULL);
 }
 
 /**
@@ -690,8 +717,6 @@ e_soap_message_start_header (ESoapMessag
  * @msg: the #ESoapMessage.
  *
  * Closes the current SOAP Header element.
- *
- * Since: 2.92
  */
 void
 e_soap_message_end_header (ESoapMessage *msg)
@@ -710,27 +735,30 @@ e_soap_message_end_header (ESoapMessage 
  * @ns_uri: the namespace URI
  *
  * Starts a new SOAP arbitrary header element.
- *
- * Since: 2.92
  */
 void
 e_soap_message_start_header_element (ESoapMessage *msg,
-					const gchar *name,
-					gboolean must_understand,
-					const gchar *actor_uri,
-					const gchar *prefix,
-					const gchar *ns_uri)
+                                     const gchar *name,
+                                     gboolean must_understand,
+                                     const gchar *actor_uri,
+                                     const gchar *prefix,
+                                     const gchar *ns_uri)
 {
-	ESoapMessagePrivate *priv;
-
 	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 
 	e_soap_message_start_element (msg, name, prefix, ns_uri);
-	if (actor_uri)
-		xmlNewNsProp (priv->last_node, priv->soap_ns, (const xmlChar *)"actorUri", (const xmlChar *)actor_uri);
+	if (actor_uri != NULL)
+		xmlNewNsProp (
+			msg->priv->last_node,
+			msg->priv->soap_ns,
+			(const xmlChar *) "actorUri",
+			(const xmlChar *) actor_uri);
 	if (must_understand)
-		xmlNewNsProp (priv->last_node, priv->soap_ns, (const xmlChar *)"mustUnderstand", (const xmlChar *)"1");
+		xmlNewNsProp (
+			msg->priv->last_node,
+			msg->priv->soap_ns,
+			(const xmlChar *) "mustUnderstand",
+			(const xmlChar *) "1");
 }
 
 /**
@@ -738,8 +766,6 @@ e_soap_message_start_header_element (ESo
  * @msg: the #ESoapMessage.
  *
  * Closes the current SOAP header element.
- *
- * Since: 2.92
  */
 void
 e_soap_message_end_header_element (ESoapMessage *msg)
@@ -753,15 +779,18 @@ e_soap_message_end_header_element (ESoap
  * @i: the integer value to write.
  *
  * Writes the stringified value of @i as the current element's content.
- *
- * Since: 2.92
  */
 void
-e_soap_message_write_int (ESoapMessage *msg, glong i)
+e_soap_message_write_int (ESoapMessage *msg,
+                          glong i)
 {
-	gchar *str = g_strdup_printf ("%ld", i);
-	e_soap_message_write_string (msg, str);
-	g_free (str);
+	gchar *string;
+
+	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
+
+	string = g_strdup_printf ("%ld", i);
+	e_soap_message_write_string (msg, string);
+	g_free (string);
 }
 
 /**
@@ -770,15 +799,18 @@ e_soap_message_write_int (ESoapMessage *
  * @d: the double value to write.
  *
  * Writes the stringified value of @d as the current element's content.
- *
- * Since: 2.92
  */
 void
-e_soap_message_write_double (ESoapMessage *msg, gdouble d)
+e_soap_message_write_double (ESoapMessage *msg,
+                             gdouble d)
 {
-	gchar *str = g_strdup_printf ("%f", d);
-	e_soap_message_write_string (msg, str);
-	g_free (str);
+	gchar *string;
+
+	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
+
+	string = g_strdup_printf ("%f", d);
+	e_soap_message_write_string (msg, string);
+	g_free (string);
 }
 
 /**
@@ -789,15 +821,19 @@ e_soap_message_write_double (ESoapMessag
  *
  * Writes the Base-64 encoded value of @string as the current
  * element's content.
- *
- * Since: 2.92
  **/
 void
-e_soap_message_write_base64 (ESoapMessage *msg, const gchar *string, gint len)
+e_soap_message_write_base64 (ESoapMessage *msg,
+                             const gchar *string,
+                             gint len)
 {
-        gchar *str = g_base64_encode ((const guchar *)string, len);
-        e_soap_message_write_string (msg, str);
-        g_free (str);
+	gchar *encoded;
+
+	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
+
+	encoded = g_base64_encode ((const guchar *) string, len);
+	e_soap_message_write_string (msg, encoded);
+	g_free (encoded);
 }
 
 /**
@@ -807,14 +843,17 @@ e_soap_message_write_base64 (ESoapMessag
  *
  * Writes the stringified value of @timeval as the current element's
  * content.
- *
- * Since: 2.92
  **/
 void
-e_soap_message_write_time (ESoapMessage *msg, const time_t *timeval)
+e_soap_message_write_time (ESoapMessage *msg,
+                           const time_t *timeval)
 {
-        gchar *str = g_strchomp (ctime (timeval));
-        e_soap_message_write_string (msg, str);
+	gchar *string;
+
+	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
+
+	string = g_strchomp (ctime (timeval));
+	e_soap_message_write_string (msg, string);
 }
 
 /**
@@ -823,18 +862,16 @@ e_soap_message_write_time (ESoapMessage 
  * @string: string to write.
  *
  * Writes the @string as the current element's content.
- *
- * Since: 2.92
  */
 void
-e_soap_message_write_string (ESoapMessage *msg, const gchar *string)
+e_soap_message_write_string (ESoapMessage *msg,
+                             const gchar *string)
 {
-	ESoapMessagePrivate *priv;
-
 	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 
-	xmlNodeAddContent (priv->last_node, (const xmlChar *)string);
+	xmlNodeAddContent (
+		msg->priv->last_node,
+		(const xmlChar *) string);
 }
 
 /**
@@ -845,18 +882,17 @@ e_soap_message_write_string (ESoapMessag
  *
  * Writes the string buffer pointed to by @buffer as the current
  * element's content.
- *
- * Since: 2.92
  */
 void
-e_soap_message_write_buffer (ESoapMessage *msg, const gchar *buffer, gint len)
+e_soap_message_write_buffer (ESoapMessage *msg,
+                             const gchar *buffer,
+                             gint len)
 {
-	ESoapMessagePrivate *priv;
-
 	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 
-	xmlNodeAddContentLen (priv->last_node, (const xmlChar *)buffer, len);
+	xmlNodeAddContentLen (
+		msg->priv->last_node,
+		(const xmlChar *) buffer, len);
 }
 
 /**
@@ -866,18 +902,18 @@ e_soap_message_write_buffer (ESoapMessag
  *
  * Sets the current element's XML schema xsi:type attribute, which
  * specifies the element's type name.
- *
- * Since: 2.92
  */
 void
-e_soap_message_set_element_type (ESoapMessage *msg, const gchar *xsi_type)
+e_soap_message_set_element_type (ESoapMessage *msg,
+                                 const gchar *xsi_type)
 {
-	ESoapMessagePrivate *priv;
-
 	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 
-	xmlNewNsProp (priv->last_node, priv->xsi_ns, (const xmlChar *)"type", (const xmlChar *)xsi_type);
+	xmlNewNsProp (
+		msg->priv->last_node,
+		msg->priv->xsi_ns,
+		(const xmlChar *) "type",
+		(const xmlChar *) xsi_type);
 }
 
 /**
@@ -885,18 +921,17 @@ e_soap_message_set_element_type (ESoapMe
  * @msg: the #ESoapMessage.
  *
  * Sets the current element's XML Schema xsi:null attribute.
- *
- * Since: 2.92
  */
 void
 e_soap_message_set_null (ESoapMessage *msg)
 {
-	ESoapMessagePrivate *priv;
-
 	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 
-	xmlNewNsProp (priv->last_node, priv->xsi_ns, (const xmlChar *)"null", (const xmlChar *)"1");
+	xmlNewNsProp (
+		msg->priv->last_node,
+		msg->priv->xsi_ns,
+		(const xmlChar *) "null",
+		(const xmlChar *) "1");
 }
 
 /**
@@ -908,24 +943,21 @@ e_soap_message_set_null (ESoapMessage *m
  * @ns_uri: the namespace URI
  *
  * Adds an XML attribute to the current element.
- *
- * Since: 2.92
  */
 void
 e_soap_message_add_attribute (ESoapMessage *msg,
-				 const gchar *name,
-				 const gchar *value,
-				 const gchar *prefix,
-				 const gchar *ns_uri)
+                              const gchar *name,
+                              const gchar *value,
+                              const gchar *prefix,
+                              const gchar *ns_uri)
 {
-	ESoapMessagePrivate *priv;
-
 	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 
-	xmlNewNsProp (priv->last_node,
-		      fetch_ns (msg, prefix, ns_uri),
-		      (const xmlChar *)name, (const xmlChar *)value);
+	xmlNewNsProp (
+		msg->priv->last_node,
+		fetch_ns (msg, prefix, ns_uri),
+		(const xmlChar *) name,
+		(const xmlChar *) value);
 }
 
 /**
@@ -935,18 +967,21 @@ e_soap_message_add_attribute (ESoapMessa
  * @ns_uri: the namespace URI, or NULL for empty namespace
  *
  * Adds a new XML namespace to the current element.
- *
- * Since: 2.92
  */
 void
-e_soap_message_add_namespace (ESoapMessage *msg, const gchar *prefix, const gchar *ns_uri)
+e_soap_message_add_namespace (ESoapMessage *msg,
+                              const gchar *prefix,
+                              const gchar *ns_uri)
 {
-	ESoapMessagePrivate *priv;
-
 	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 
-	xmlNewNs (priv->last_node, (const xmlChar *)(ns_uri ? ns_uri : ""), (const xmlChar *)prefix);
+	if (ns_uri == NULL)
+		ns_uri = "";
+
+	xmlNewNs (
+		msg->priv->last_node,
+		(const xmlChar *) ns_uri,
+		(const xmlChar *) prefix);
 }
 
 /**
@@ -957,11 +992,10 @@ e_soap_message_add_namespace (ESoapMessa
  * Sets the default namespace to the URI specified in @ns_uri. The
  * default namespace becomes the namespace all non-explicitly
  * namespaced child elements fall into.
- *
- * Since: 2.92
  */
 void
-e_soap_message_set_default_namespace (ESoapMessage *msg, const gchar *ns_uri)
+e_soap_message_set_default_namespace (ESoapMessage *msg,
+                                      const gchar *ns_uri)
 {
 	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
 
@@ -975,18 +1009,18 @@ e_soap_message_set_default_namespace (ES
  *
  * Sets the encodingStyle attribute on the current element to the
  * value of @enc_style.
- *
- * Since: 2.92
  */
 void
-e_soap_message_set_encoding_style (ESoapMessage *msg, const gchar *enc_style)
+e_soap_message_set_encoding_style (ESoapMessage *msg,
+                                   const gchar *enc_style)
 {
-	ESoapMessagePrivate *priv;
-
 	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 
-	xmlNewNsProp (priv->last_node, priv->soap_ns, (const xmlChar *)"encodingStyle", (const xmlChar *)enc_style);
+	xmlNewNsProp (
+		msg->priv->last_node,
+		msg->priv->soap_ns,
+		(const xmlChar *) "encodingStyle",
+		(const xmlChar *) enc_style);
 }
 
 /**
@@ -994,32 +1028,29 @@ e_soap_message_set_encoding_style (ESoap
  * @msg: the #ESoapMessage.
  *
  * Resets the internal XML representation of the SOAP message.
- *
- * Since: 2.92
  */
 void
 e_soap_message_reset (ESoapMessage *msg)
 {
-	ESoapMessagePrivate *priv;
-
 	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
-
-	xmlFreeDoc (priv->doc);
-	priv->doc = xmlNewDoc ((const xmlChar *)"1.0");
-	priv->last_node = NULL;
-
-	g_free (priv->action);
-	priv->action = NULL;
-	priv->body_started = FALSE;
 
-	if (priv->env_uri)
-		xmlFree (priv->env_uri);
-	priv->env_uri = NULL;
+	xmlFreeDoc (msg->priv->doc);
+	msg->priv->doc = xmlNewDoc ((const xmlChar *) "1.0");
+	msg->priv->last_node = NULL;
+
+	g_free (msg->priv->action);
+	msg->priv->action = NULL;
+	msg->priv->body_started = FALSE;
+
+	if (msg->priv->env_uri != NULL) {
+		xmlFree (msg->priv->env_uri);
+		msg->priv->env_uri = NULL;
+	}
 
-	if (priv->env_prefix)
-		xmlFree (priv->env_prefix);
-	priv->env_prefix = NULL;
+	if (msg->priv->env_prefix != NULL) {
+		xmlFree (msg->priv->env_prefix);
+		msg->priv->env_prefix = NULL;
+	}
 }
 
 /**
@@ -1027,24 +1058,22 @@ e_soap_message_reset (ESoapMessage *msg)
  * @msg: the #ESoapMessage.
  *
  * Writes the serialized XML tree to the #SoupMessage's buffer.
- *
- * Since: 2.92
  */
 void
 e_soap_message_persist (ESoapMessage *msg)
 {
-	ESoapMessagePrivate *priv;
 	xmlChar *body;
 	gint len;
 
 	g_return_if_fail (E_IS_SOAP_MESSAGE (msg));
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 
-	xmlDocDumpMemory (priv->doc, &body, &len);
+	xmlDocDumpMemory (msg->priv->doc, &body, &len);
 
 	/* serialize to SoupMessage class */
-	soup_message_set_request (SOUP_MESSAGE (msg), "text/xml",
-				  SOUP_MEMORY_TAKE, (gchar *)body, len);
+	soup_message_set_request (
+		SOUP_MESSAGE (msg),
+		"text/xml; charset=utf-8",
+		SOUP_MEMORY_TAKE, (gchar *) body, len);
 }
 
 /**
@@ -1057,23 +1086,23 @@ e_soap_message_persist (ESoapMessage *ms
  *
  * Returns: The namespace prefix, or %NULL if no namespace exists
  * for the URI given.
- *
- * Since: 2.92
  */
 const gchar *
-e_soap_message_get_namespace_prefix (ESoapMessage *msg, const gchar *ns_uri)
+e_soap_message_get_namespace_prefix (ESoapMessage *msg,
+                                     const gchar *ns_uri)
 {
-	ESoapMessagePrivate *priv;
 	xmlNsPtr ns = NULL;
 
 	g_return_val_if_fail (E_IS_SOAP_MESSAGE (msg), NULL);
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 	g_return_val_if_fail (ns_uri != NULL, NULL);
 
-	ns = xmlSearchNsByHref (priv->doc, priv->last_node, (const xmlChar *)ns_uri);
-	if (ns) {
-		if (ns->prefix)
-			return (const gchar *)ns->prefix;
+	ns = xmlSearchNsByHref (
+		msg->priv->doc,
+		msg->priv->last_node,
+		(const xmlChar *) ns_uri);
+	if (ns != NULL) {
+		if (ns->prefix != NULL)
+			return (const gchar *) ns->prefix;
 		else
 			return "";
 	}
@@ -1089,18 +1118,13 @@ e_soap_message_get_namespace_prefix (ESo
  * #ESoapMessage pointed to by @msg.
  *
  * Returns: the #xmlDocPtr representing the SOAP message.
- *
- * Since: 2.92
  */
 xmlDocPtr
 e_soap_message_get_xml_doc (ESoapMessage *msg)
 {
-	ESoapMessagePrivate *priv;
-
 	g_return_val_if_fail (E_IS_SOAP_MESSAGE (msg), NULL);
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
 
-	return priv->doc;
+	return msg->priv->doc;
 }
 
 /**
@@ -1111,30 +1135,25 @@ e_soap_message_get_xml_doc (ESoapMessage
  *
  * Returns: a #ESoapResponse representing the response from
  * the server, or %NULL if there was an error.
- *
- * Since: 2.92
  */
 ESoapResponse *
 e_soap_message_parse_response (ESoapMessage *msg)
 {
-	ESoapMessagePrivate *priv;
 	xmlDocPtr xmldoc;
 
 	g_return_val_if_fail (E_IS_SOAP_MESSAGE (msg), NULL);
 
-	priv = E_SOAP_MESSAGE_GET_PRIVATE (msg);
-
-	if (!priv->ctxt)
+	if (msg->priv->ctxt == NULL)
 		return NULL;
 
-	xmlParseChunk (priv->ctxt, 0, 0, 1);
+	xmlParseChunk (msg->priv->ctxt, 0, 0, 1);
 
-	xmldoc = priv->ctxt->myDoc;
+	xmldoc = msg->priv->ctxt->myDoc;
 
-	xmlFreeParserCtxt (priv->ctxt);
-	priv->ctxt = NULL;
+	xmlFreeParserCtxt (msg->priv->ctxt);
+	msg->priv->ctxt = NULL;
 
-	if (!xmldoc)
+	if (xmldoc == NULL)
 		return NULL;
 
 	return e_soap_response_new_from_xmldoc (xmldoc);
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-soap-message.h evolution-ews.sync-with-3.8.2/src/server/e-soap-message.h
--- evolution-ews.git-gnome-3-0/src/server/e-soap-message.h	2013-05-17 14:36:16.358670992 +0200
+++ evolution-ews.sync-with-3.8.2/src/server/e-soap-message.h	2013-05-28 08:59:53.426713239 +0200
@@ -4,104 +4,138 @@
  */
 
 #ifndef EWS_SOAP_MESSAGE_H
-#define EWS_SOAP_MESSAGE_H 1
+#define EWS_SOAP_MESSAGE_H
 
 #include <time.h>
 #include <libxml/tree.h>
 #include <libsoup/soup-message.h>
 #include "e-soap-response.h"
 
+/* Standard GObject macros */
+#define E_TYPE_SOAP_MESSAGE \
+	(e_soap_message_get_type ())
+#define E_SOAP_MESSAGE(obj) \
+	(G_TYPE_CHECK_INSTANCE_CAST \
+	((obj), E_TYPE_SOAP_MESSAGE, ESoapMessage))
+#define E_SOAP_MESSAGE_CLASS(cls) \
+	(G_TYPE_CHECK_CLASS_CAST \
+	((cls), E_TYPE_SOAP_MESSAGE, ESoapMessageClass))
+#define E_IS_SOAP_MESSAGE(obj) \
+	(G_TYPE_CHECK_INSTANCE_TYPE \
+	((obj), E_TYPE_SOAP_MESSAGE))
+#define E_IS_SOAP_MESSAGE_CLASS(cls) \
+	(G_TYPE_CHECK_CLASS_TYPE \
+	((cls), E_TYPE_SOAP_MESSAGE))
+#define E_SOAP_MESSAGE_GET_CLASS(obj) \
+	(G_TYPE_INSTANCE_GET_CLASS \
+	((obj), E_TYPE_SOAP_MESSAGE, ESoapMessageClass))
+
 G_BEGIN_DECLS
 
-#define E_TYPE_SOAP_MESSAGE            (e_soap_message_get_type ())
-#define E_SOAP_MESSAGE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), E_TYPE_SOAP_MESSAGE, ESoapMessage))
-#define E_SOAP_MESSAGE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), E_TYPE_SOAP_MESSAGE, ESoapMessageClass))
-#define E_IS_SOAP_MESSAGE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), E_TYPE_SOAP_MESSAGE))
-#define E_IS_SOAP_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), E_TYPE_SOAP_MESSAGE))
-#define E_SOAP_MESSAGE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), E_TYPE_SOAP_MESSAGE, ESoapMessageClass))
+typedef struct _ESoapMessage ESoapMessage;
+typedef struct _ESoapMessageClass ESoapMessageClass;
+typedef struct _ESoapMessagePrivate ESoapMessagePrivate;
 
-typedef struct {
+struct _ESoapMessage {
 	SoupMessage parent;
+	ESoapMessagePrivate *priv;
+};
 
-} ESoapMessage;
-
-typedef struct {
+struct _ESoapMessageClass {
 	SoupMessageClass parent_class;
-} ESoapMessageClass;
-
-GType             e_soap_message_get_type (void);
+};
 
-ESoapMessage  *e_soap_message_new (const gchar *method, const gchar *uri_string,
-					 gboolean standalone, const gchar *xml_encoding,
-					 const gchar *env_prefix, const gchar *env_uri);
-ESoapMessage  *e_soap_message_new_from_uri (const gchar *method, SoupURI *uri,
-						  gboolean standalone, const gchar *xml_encoding,
-						  const gchar *env_prefix, const gchar *env_uri);
-
-void              e_soap_message_start_envelope (ESoapMessage *msg);
-void              e_soap_message_end_envelope (ESoapMessage *msg);
-void              e_soap_message_start_body (ESoapMessage *msg);
-void              e_soap_message_end_body (ESoapMessage *msg);
-void              e_soap_message_start_element (ESoapMessage *msg,
-						   const gchar *name,
-						   const gchar *prefix,
-						   const gchar *ns_uri);
-void              e_soap_message_end_element (ESoapMessage *msg);
-void              e_soap_message_start_fault (ESoapMessage *msg,
+GType		e_soap_message_get_type		(void) G_GNUC_CONST;
+ESoapMessage *	e_soap_message_new		(const gchar *method,
+						 const gchar *uri_string,
+						 gboolean standalone,
+						 const gchar *xml_encoding,
+						 const gchar *env_prefix,
+						 const gchar *env_uri);
+ESoapMessage *	e_soap_message_new_from_uri	(const gchar *method,
+						 SoupURI *uri,
+						 gboolean standalone,
+						 const gchar *xml_encoding,
+						 const gchar *env_prefix,
+						 const gchar *env_uri);
+void		e_soap_message_start_envelope	(ESoapMessage *msg);
+void		e_soap_message_end_envelope	(ESoapMessage *msg);
+void		e_soap_message_start_body	(ESoapMessage *msg);
+void		e_soap_message_end_body		(ESoapMessage *msg);
+void		e_soap_message_start_element	(ESoapMessage *msg,
+						 const gchar *name,
+						 const gchar *prefix,
+						 const gchar *ns_uri);
+void		e_soap_message_end_element	(ESoapMessage *msg);
+void		e_soap_message_start_fault	(ESoapMessage *msg,
 						 const gchar *faultcode,
 						 const gchar *faultstring,
 						 const gchar *faultfactor);
-void              e_soap_message_end_fault (ESoapMessage *msg);
-void              e_soap_message_start_fault_detail (ESoapMessage *msg);
-void              e_soap_message_end_fault_detail (ESoapMessage *msg);
-void              e_soap_message_start_header (ESoapMessage *msg);
-void              e_soap_message_end_header (ESoapMessage *msg);
-void              e_soap_message_start_header_element (ESoapMessage *msg,
-							  const gchar *name,
-							  gboolean must_understand,
-							  const gchar *actor_uri,
-							  const gchar *prefix,
-							  const gchar *ns_uri);
-void              e_soap_message_end_header_element (ESoapMessage *msg);
-void              e_soap_message_write_int (ESoapMessage *msg, glong i);
-void              e_soap_message_write_double (ESoapMessage *msg, gdouble d);
-void              e_soap_message_write_base64 (ESoapMessage *msg, const gchar *string, gint len);
-void              e_soap_message_write_time (ESoapMessage *msg, const time_t *timeval);
-void              e_soap_message_write_string (ESoapMessage *msg, const gchar *string);
-void              e_soap_message_write_buffer (ESoapMessage *msg, const gchar *buffer, gint len);
-void              e_soap_message_set_element_type (ESoapMessage *msg, const gchar *xsi_type);
-void              e_soap_message_set_null (ESoapMessage *msg);
-void              e_soap_message_add_attribute (ESoapMessage *msg,
-						   const gchar *name,
-						   const gchar *value,
-						   const gchar *prefix,
-						   const gchar *ns_uri);
-void              e_soap_message_add_namespace (ESoapMessage *msg,
-						   const gchar *prefix,
-						   const gchar *ns_uri);
-void              e_soap_message_set_default_namespace (ESoapMessage *msg,
-							   const gchar *ns_uri);
-void              e_soap_message_set_encoding_style (ESoapMessage *msg, const gchar *enc_style);
-void              e_soap_message_reset (ESoapMessage *msg);
-void              e_soap_message_persist (ESoapMessage *msg);
-
-const gchar       *e_soap_message_get_namespace_prefix (ESoapMessage *msg, const gchar *ns_uri);
-
-xmlDocPtr         e_soap_message_get_xml_doc (ESoapMessage *msg);
-
-void		  e_soap_message_store_node_data (ESoapMessage *msg,
-						  const gchar *nodename,
-						  const gchar *directory,
-						  gboolean base64);
-
-ESoapResponse *e_soap_message_parse_response (ESoapMessage *msg);
+void		e_soap_message_end_fault	(ESoapMessage *msg);
+void		e_soap_message_start_fault_detail
+						(ESoapMessage *msg);
+void		e_soap_message_end_fault_detail	(ESoapMessage *msg);
+void		e_soap_message_start_header	(ESoapMessage *msg);
+void		e_soap_message_end_header	(ESoapMessage *msg);
+void		e_soap_message_start_header_element
+						(ESoapMessage *msg,
+						 const gchar *name,
+						 gboolean must_understand,
+						 const gchar *actor_uri,
+						 const gchar *prefix,
+						 const gchar *ns_uri);
+void		e_soap_message_end_header_element
+						(ESoapMessage *msg);
+void		e_soap_message_write_int	(ESoapMessage *msg,
+						 glong i);
+void		e_soap_message_write_double	(ESoapMessage *msg,
+						 gdouble d);
+void		e_soap_message_write_base64	(ESoapMessage *msg,
+						 const gchar *string,
+						 gint len);
+void		e_soap_message_write_time	(ESoapMessage *msg,
+						 const time_t *timeval);
+void		e_soap_message_write_string	(ESoapMessage *msg,
+						 const gchar *string);
+void		e_soap_message_write_buffer	(ESoapMessage *msg,
+						 const gchar *buffer,
+						 gint len);
+void		e_soap_message_set_element_type	(ESoapMessage *msg,
+						 const gchar *xsi_type);
+void		e_soap_message_set_null		(ESoapMessage *msg);
+void		e_soap_message_add_attribute	(ESoapMessage *msg,
+						 const gchar *name,
+						 const gchar *value,
+						 const gchar *prefix,
+						 const gchar *ns_uri);
+void		e_soap_message_add_namespace	(ESoapMessage *msg,
+						 const gchar *prefix,
+						 const gchar *ns_uri);
+void		e_soap_message_set_default_namespace
+						(ESoapMessage *msg,
+						 const gchar *ns_uri);
+void		e_soap_message_set_encoding_style
+						(ESoapMessage *msg,
+						 const gchar *enc_style);
+void		e_soap_message_reset		(ESoapMessage *msg);
+void		e_soap_message_persist		(ESoapMessage *msg);
+const gchar *	e_soap_message_get_namespace_prefix
+						(ESoapMessage *msg,
+						 const gchar *ns_uri);
+xmlDocPtr	e_soap_message_get_xml_doc	(ESoapMessage *msg);
+void		e_soap_message_store_node_data	(ESoapMessage *msg,
+						 const gchar *nodename,
+						 const gchar *directory,
+						 gboolean base64);
+ESoapResponse *	e_soap_message_parse_response	(ESoapMessage *msg);
 
 /* By an amazing coincidence, this looks a lot like camel_progress() */
 typedef void (*ESoapProgressFn) (gpointer object, gint percent);
 
-void		  e_soap_message_set_progress_fn (ESoapMessage *msg,
-						  ESoapProgressFn fn,
-						  gpointer object);
+void		e_soap_message_set_progress_fn	(ESoapMessage *msg,
+						 ESoapProgressFn fn,
+						 gpointer object);
+
 G_END_DECLS
 
-#endif
+#endif /* E_SOAP_MESSAGE_H */
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-soap-response.c evolution-ews.sync-with-3.8.2/src/server/e-soap-response.c
--- evolution-ews.git-gnome-3-0/src/server/e-soap-response.c	2013-05-17 14:36:16.358670992 +0200
+++ evolution-ews.sync-with-3.8.2/src/server/e-soap-response.c	2013-05-28 08:59:53.430713464 +0200
@@ -3,6 +3,10 @@
  * Copyright (C) 1999-2008 Novell, Inc. (www.novell.com)
  */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include <libedataserver/eds-version.h>
 
 #include <stdlib.h>
@@ -11,9 +15,11 @@
 #include <libsoup/soup.h>
 #include "e-soap-response.h"
 
-G_DEFINE_TYPE (ESoapResponse, e_soap_response, G_TYPE_OBJECT)
+#define E_SOAP_RESPONSE_GET_PRIVATE(obj) \
+	(G_TYPE_INSTANCE_GET_PRIVATE \
+	((obj), E_TYPE_SOAP_RESPONSE, ESoapResponsePrivate))
 
-typedef struct {
+struct _ESoapResponsePrivate {
 	/* the XML document */
 	xmlDocPtr xmldoc;
 	xmlNodePtr xml_root;
@@ -21,40 +27,52 @@ typedef struct {
 	xmlNodePtr xml_method;
 	xmlNodePtr soap_fault;
 	GList *parameters;
-} ESoapResponsePrivate;
-#define E_SOAP_RESPONSE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), E_TYPE_SOAP_RESPONSE, ESoapResponsePrivate))
+};
 
-static xmlNode *soup_xml_real_node (xmlNode *node);
+G_DEFINE_TYPE (ESoapResponse, e_soap_response, G_TYPE_OBJECT)
+
+static xmlNode *
+soup_xml_real_node (xmlNode *node)
+{
+	while (node && (node->type == XML_COMMENT_NODE ||
+		xmlIsBlankNode (node)))
+		node = node->next;
+	return node;
+}
 
 static void
-finalize (GObject *object)
+soap_response_finalize (GObject *object)
 {
-	ESoapResponsePrivate *priv = E_SOAP_RESPONSE_GET_PRIVATE (object);
+	ESoapResponsePrivate *priv;
+
+	priv = E_SOAP_RESPONSE_GET_PRIVATE (object);
 
-	if (priv->xmldoc)
+	if (priv->xmldoc != NULL)
 		xmlFreeDoc (priv->xmldoc);
-	if (priv->parameters != NULL)
-		g_list_free (priv->parameters);
 
+	g_list_free (priv->parameters);
+
+	/* Chain up to parent's finalize() method. */
 	G_OBJECT_CLASS (e_soap_response_parent_class)->finalize (object);
 }
 
 static void
-e_soap_response_class_init (ESoapResponseClass *e_soap_response_class)
+e_soap_response_class_init (ESoapResponseClass *class)
 {
-	GObjectClass *object_class = G_OBJECT_CLASS (e_soap_response_class);
+	GObjectClass *object_class;
 
-	g_type_class_add_private (e_soap_response_class, sizeof (ESoapResponsePrivate));
+	g_type_class_add_private (class, sizeof (ESoapResponsePrivate));
 
-	object_class->finalize = finalize;
+	object_class = G_OBJECT_CLASS (class);
+	object_class->finalize = soap_response_finalize;
 }
 
 static void
 e_soap_response_init (ESoapResponse *response)
 {
-	ESoapResponsePrivate *priv = E_SOAP_RESPONSE_GET_PRIVATE (response);
+	response->priv = E_SOAP_RESPONSE_GET_PRIVATE (response);
 
-	priv->xmldoc = xmlNewDoc ((const xmlChar *)"1.0");
+	response->priv->xmldoc = xmlNewDoc ((const xmlChar *)"1.0");
 }
 
 /**
@@ -65,8 +83,6 @@ e_soap_response_init (ESoapResponse *res
  *
  * Returns: the new #ESoapResponse (or %NULL if there was an
  * error).
- *
- * Since: 2.92
  */
 ESoapResponse *
 e_soap_response_new (void)
@@ -86,8 +102,6 @@ e_soap_response_new (void)
  *
  * Returns: the new #ESoapResponse (or %NULL if there was an
  * error).
- *
- * Since: 2.92
  */
 ESoapResponse *
 e_soap_response_new_from_string (const gchar *xmlstr)
@@ -114,8 +128,6 @@ e_soap_response_new_from_string (const g
  *
  * Returns: the new #ESoapResponse (or %NULL if there was an
  * error).
- *
- * Since: xxx
  */
 ESoapResponse *
 e_soap_response_new_from_xmldoc (xmlDoc *xmldoc)
@@ -134,19 +146,21 @@ e_soap_response_new_from_xmldoc (xmlDoc 
 }
 
 static void
-parse_parameters (ESoapResponsePrivate *priv, xmlNodePtr xml_method)
+parse_parameters (ESoapResponse *response,
+                  xmlNodePtr xml_method)
 {
 	xmlNodePtr tmp;
 
 	for (tmp = soup_xml_real_node (xml_method->children);
 	     tmp != NULL;
 	     tmp = soup_xml_real_node (tmp->next)) {
-		if (!strcmp ((const gchar *)tmp->name, "Fault")) {
-			priv->soap_fault = tmp;
+		if (!strcmp ((const gchar *) tmp->name, "Fault")) {
+			response->priv->soap_fault = tmp;
 			continue;
 		} else {
 			/* regular parameters */
-			priv->parameters = g_list_append (priv->parameters, tmp);
+			response->priv->parameters = g_list_append (
+				response->priv->parameters, tmp);
 		}
 	}
 }
@@ -160,11 +174,10 @@ parse_parameters (ESoapResponsePrivate *
  * it in the @response object.
  *
  * Returns: %TRUE if successful, %FALSE otherwise.
- *
- * Since: 2.92
  */
 gboolean
-e_soap_response_from_string (ESoapResponse *response, const gchar *xmlstr)
+e_soap_response_from_string (ESoapResponse *response,
+                             const gchar *xmlstr)
 {
 	xmlDocPtr xmldoc;
 
@@ -179,7 +192,6 @@ e_soap_response_from_string (ESoapRespon
 	return e_soap_response_from_xmldoc (response, xmldoc);
 }
 
-
 /**
  * e_soap_response_from_xmldoc:
  * @response: the #ESoapResponse object.
@@ -188,16 +200,14 @@ e_soap_response_from_string (ESoapRespon
  * Sets all properties from the @xmldoc in the @response object.
  *
  * Returns: %TRUE if successful, %FALSE otherwise.
- *
- * Since: xxx
  */
-gboolean e_soap_response_from_xmldoc (ESoapResponse *response, xmlDoc *xmldoc)
+gboolean
+e_soap_response_from_xmldoc (ESoapResponse *response,
+                             xmlDoc *xmldoc)
 {
-	ESoapResponsePrivate *priv;
 	xmlNodePtr xml_root, xml_body, xml_method = NULL;
 
 	g_return_val_if_fail (E_IS_SOAP_RESPONSE (response), FALSE);
-	priv = E_SOAP_RESPONSE_GET_PRIVATE (response);
 	g_return_val_if_fail (xmldoc != NULL, FALSE);
 
 	xml_root = xmlDocGetRootElement (xmldoc);
@@ -206,16 +216,16 @@ gboolean e_soap_response_from_xmldoc (ES
 		return FALSE;
 	}
 
-	if (strcmp ((const gchar *)xml_root->name, "Envelope") != 0) {
+	if (strcmp ((const gchar *) xml_root->name, "Envelope") != 0) {
 		xmlFreeDoc (xmldoc);
 		return FALSE;
 	}
 
 	xml_body = soup_xml_real_node (xml_root->children);
 	if (xml_body != NULL) {
-		if (strcmp ((const gchar *)xml_body->name, "Header") == 0)
+		if (strcmp ((const gchar *) xml_body->name, "Header") == 0)
 			xml_body = soup_xml_real_node (xml_body->next);
-		if (strcmp ((const gchar *)xml_body->name, "Body") != 0) {
+		if (strcmp ((const gchar *) xml_body->name, "Body") != 0) {
 			xmlFreeDoc (xmldoc);
 			return FALSE;
 		}
@@ -224,15 +234,15 @@ gboolean e_soap_response_from_xmldoc (ES
 
 		/* read all parameters */
 		if (xml_method)
-			parse_parameters (priv, xml_method);
+			parse_parameters (response, xml_method);
 	}
 
-	xmlFreeDoc (priv->xmldoc);
-	priv->xmldoc = xmldoc;
+	xmlFreeDoc (response->priv->xmldoc);
+	response->priv->xmldoc = xmldoc;
 
-	priv->xml_root = xml_root;
-	priv->xml_body = xml_body;
-	priv->xml_method = xml_method;
+	response->priv->xml_root = xml_root;
+	response->priv->xml_body = xml_body;
+	response->priv->xml_method = xml_method;
 
 	return TRUE;
 }
@@ -244,19 +254,14 @@ gboolean e_soap_response_from_xmldoc (ES
  * Gets the method name from the SOAP response.
  *
  * Returns: the method name.
- *
- * Since: 2.92
  */
 const gchar *
 e_soap_response_get_method_name (ESoapResponse *response)
 {
-	ESoapResponsePrivate *priv;
-
 	g_return_val_if_fail (E_IS_SOAP_RESPONSE (response), NULL);
-	priv = E_SOAP_RESPONSE_GET_PRIVATE (response);
-	g_return_val_if_fail (priv->xml_method != NULL, NULL);
+	g_return_val_if_fail (response->priv->xml_method != NULL, NULL);
 
-	return (const gchar *) priv->xml_method->name;
+	return (const gchar *) response->priv->xml_method->name;
 }
 
 /**
@@ -265,20 +270,18 @@ e_soap_response_get_method_name (ESoapRe
  * @method_name: the method name to set.
  *
  * Sets the method name on the given #ESoapResponse.
- *
- * Since: 2.92
  */
 void
-e_soap_response_set_method_name (ESoapResponse *response, const gchar *method_name)
+e_soap_response_set_method_name (ESoapResponse *response,
+                                 const gchar *method_name)
 {
-	ESoapResponsePrivate *priv;
-
 	g_return_if_fail (E_IS_SOAP_RESPONSE (response));
-	priv = E_SOAP_RESPONSE_GET_PRIVATE (response);
-	g_return_if_fail (priv->xml_method != NULL);
+	g_return_if_fail (response->priv->xml_method != NULL);
 	g_return_if_fail (method_name != NULL);
 
-	xmlNodeSetName (priv->xml_method, (const xmlChar *)method_name);
+	xmlNodeSetName (
+		response->priv->xml_method,
+		(const xmlChar *) method_name);
 }
 
 /**
@@ -288,8 +291,6 @@ e_soap_response_set_method_name (ESoapRe
  * Returns the parameter name.
  *
  * Returns: the parameter name.
- *
- * Since: 2.92
  */
 const gchar *
 e_soap_parameter_get_name (ESoapParameter *param)
@@ -306,8 +307,6 @@ e_soap_parameter_get_name (ESoapParamete
  * Returns the parameter's (integer) value.
  *
  * Returns: the parameter value as an integer
- *
- * Since: 2.92
  */
 gint
 e_soap_parameter_get_int_value (ESoapParameter *param)
@@ -318,7 +317,7 @@ e_soap_parameter_get_int_value (ESoapPar
 
 	s = xmlNodeGetContent (param);
 	if (s) {
-		i = atoi ((gchar *)s);
+		i = atoi ((gchar *) s);
 		xmlFree (s);
 
 		return i;
@@ -335,8 +334,6 @@ e_soap_parameter_get_int_value (ESoapPar
  *
  * Returns: the parameter value as a string, which must be freed
  * by the caller.
- *
- * Since: 2.92
  */
 gchar *
 e_soap_parameter_get_string_value (ESoapParameter *param)
@@ -346,7 +343,7 @@ e_soap_parameter_get_string_value (ESoap
 	g_return_val_if_fail (param != NULL, NULL);
 
 	xml_s = xmlNodeGetContent (param);
-	s = g_strdup ((gchar *)xml_s);
+	s = g_strdup ((gchar *) xml_s);
 	xmlFree (xml_s);
 
 	return s;
@@ -361,8 +358,6 @@ e_soap_parameter_get_string_value (ESoap
  * themselves.
  *
  * Returns: the first child or %NULL if there are no children.
- *
- * Since: 2.92
  */
 ESoapParameter *
 e_soap_parameter_get_first_child (ESoapParameter *param)
@@ -382,11 +377,10 @@ e_soap_parameter_get_first_child (ESoapP
  *
  * Returns: the first child with the given name or %NULL if there
  * are no children.
- *
- * Since: 2.92
  */
 ESoapParameter *
-e_soap_parameter_get_first_child_by_name (ESoapParameter *param, const gchar *name)
+e_soap_parameter_get_first_child_by_name (ESoapParameter *param,
+                                          const gchar *name)
 {
 	ESoapParameter *tmp;
 
@@ -396,7 +390,7 @@ e_soap_parameter_get_first_child_by_name
 	for (tmp = e_soap_parameter_get_first_child (param);
 	     tmp != NULL;
 	     tmp = e_soap_parameter_get_next_child (tmp)) {
-		if (!strcmp (name, (const gchar *)tmp->name))
+		if (!strcmp (name, (const gchar *) tmp->name))
 			return tmp;
 	}
 
@@ -415,8 +409,6 @@ e_soap_parameter_get_first_child_by_name
  *
  * Returns: the next sibling, or %NULL if there are no more
  * siblings.
- *
- * Since: 2.92
  */
 ESoapParameter *
 e_soap_parameter_get_next_child (ESoapParameter *param)
@@ -437,12 +429,10 @@ e_soap_parameter_get_next_child (ESoapPa
  * FIXME: the name of this method is wrong
  *
  * Returns: the next sibling with the given name, or %NULL
- *
- * Since: 2.92
  */
 ESoapParameter *
 e_soap_parameter_get_next_child_by_name (ESoapParameter *param,
-					    const gchar *name)
+                                         const gchar *name)
 {
 	ESoapParameter *tmp;
 
@@ -452,7 +442,7 @@ e_soap_parameter_get_next_child_by_name 
 	for (tmp = e_soap_parameter_get_next_child (param);
 	     tmp != NULL;
 	     tmp = e_soap_parameter_get_next_child (tmp)) {
-		if (!strcmp (name, (const gchar *)tmp->name))
+		if (!strcmp (name, (const gchar *) tmp->name))
 			return tmp;
 	}
 
@@ -467,11 +457,10 @@ e_soap_parameter_get_next_child_by_name 
  * Returns the named property of @param.
  *
  * Returns: the property, which must be freed by the caller.
- *
- * Since: 2.92
  */
 gchar *
-e_soap_parameter_get_property (ESoapParameter *param, const gchar *prop_name)
+e_soap_parameter_get_property (ESoapParameter *param,
+                               const gchar *prop_name)
 {
 	xmlChar *xml_s;
 	gchar *s;
@@ -479,8 +468,8 @@ e_soap_parameter_get_property (ESoapPara
 	g_return_val_if_fail (param != NULL, NULL);
 	g_return_val_if_fail (prop_name != NULL, NULL);
 
-	xml_s = xmlGetProp (param, (const xmlChar *)prop_name);
-	s = g_strdup ((gchar *)xml_s);
+	xml_s = xmlGetProp (param, (const xmlChar *) prop_name);
+	s = g_strdup ((gchar *) xml_s);
 	xmlFree (xml_s);
 
 	return s;
@@ -493,18 +482,21 @@ e_soap_parameter_get_property (ESoapPara
  * Returns the list of parameters received in the SOAP response.
  *
  * Returns: a list of #ESoapParameter
- *
- * Since: 2.92
  */
 const GList *
 e_soap_response_get_parameters (ESoapResponse *response)
 {
-	ESoapResponsePrivate *priv;
+	g_return_val_if_fail (E_IS_SOAP_RESPONSE (response), NULL);
 
+	return (const GList *) response->priv->parameters;
+}
+
+ESoapParameter *
+e_soap_response_get_parameter (ESoapResponse *response)
+{
 	g_return_val_if_fail (E_IS_SOAP_RESPONSE (response), NULL);
-	priv = E_SOAP_RESPONSE_GET_PRIVATE (response);
 
-	return (const GList *) priv->parameters;
+	return response->priv->xml_method;
 }
 
 /**
@@ -515,51 +507,80 @@ e_soap_response_get_parameters (ESoapRes
  *
  * Returns: a #ESoapParameter representing the first
  * parameter, or %NULL if there are no parameters.
- *
- * Since: 2.92
  */
 ESoapParameter *
 e_soap_response_get_first_parameter (ESoapResponse *response)
 {
-	ESoapResponsePrivate *priv;
-
 	g_return_val_if_fail (E_IS_SOAP_RESPONSE (response), NULL);
-	priv = E_SOAP_RESPONSE_GET_PRIVATE (response);
 
-	return priv->parameters ? priv->parameters->data : NULL;
+	if (response->priv->parameters == NULL)
+		return NULL;
+
+	return response->priv->parameters->data;
 }
 
 /**
  * e_soap_response_get_first_parameter_by_name:
  * @response: the #ESoapResponse object.
  * @name: the name of the parameter to look for.
+ * @error: return location for a #GError, or %NULL
  *
  * Retrieves the first parameter contained in the SOAP response whose
- * name is @name.
+ * name is @name.  If no parameter is found, the function sets @error
+ * and returns %NULL.
+ *
+ * The function also checks for a SOAP "faultstring" parameter and,
+ * if found, uses it to set the #GError message.
  *
  * Returns: a #ESoapParameter representing the first parameter
  * with the given name, or %NULL.
- *
- * Since: 2.92
  */
 ESoapParameter *
 e_soap_response_get_first_parameter_by_name (ESoapResponse *response,
-						const gchar *name)
+                                             const gchar *name,
+                                             GError **error)
 {
-	ESoapResponsePrivate *priv;
 	GList *l;
 
 	g_return_val_if_fail (E_IS_SOAP_RESPONSE (response), NULL);
-	priv = E_SOAP_RESPONSE_GET_PRIVATE (response);
 	g_return_val_if_fail (name != NULL, NULL);
 
-	for (l = priv->parameters; l != NULL; l = l->next) {
+	for (l = response->priv->parameters; l != NULL; l = l->next) {
 		ESoapParameter *param = (ESoapParameter *) l->data;
 
-		if (!strcmp (name, (const gchar *)param->name))
+		if (strcmp (name, (const gchar *) param->name) == 0)
 			return param;
 	}
 
+	/* XXX These are probably not the best error codes, but
+	 *     wanted to avoid EWS_CONNECTION_ERROR codes since
+	 *     this class is potentially reusable. */
+
+	for (l = response->priv->parameters; l != NULL; l = l->next) {
+		ESoapParameter *param = (ESoapParameter *) l->data;
+
+		if (strcmp ("faultstring", (const gchar *) param->name) == 0) {
+			gchar *string;
+
+			string = e_soap_parameter_get_string_value (param);
+
+			g_set_error (
+				error,
+				SOUP_HTTP_ERROR, SOUP_STATUS_IO_ERROR,
+				"%s", (string != NULL) ? string :
+				"<faultstring> in SOAP response");
+
+			g_free (string);
+
+			return NULL;
+		}
+	}
+
+	g_set_error (
+		error,
+		SOUP_HTTP_ERROR, SOUP_STATUS_MALFORMED,
+		"Missing <%s> in SOAP response", name);
+
 	return NULL;
 }
 
@@ -572,21 +593,17 @@ e_soap_response_get_first_parameter_by_n
  * object.
  *
  * Returns: a #ESoapParameter representing the parameter.
- *
- * Since: 2.92
  */
 ESoapParameter *
 e_soap_response_get_next_parameter (ESoapResponse *response,
-				       ESoapParameter *from)
+                                    ESoapParameter *from)
 {
-	ESoapResponsePrivate *priv;
 	GList *l;
 
 	g_return_val_if_fail (E_IS_SOAP_RESPONSE (response), NULL);
-	priv = E_SOAP_RESPONSE_GET_PRIVATE (response);
 	g_return_val_if_fail (from != NULL, NULL);
 
-	l = g_list_find (priv->parameters, (gconstpointer) from);
+	l = g_list_find (response->priv->parameters, (gconstpointer) from);
 	if (!l)
 		return NULL;
 
@@ -603,13 +620,11 @@ e_soap_response_get_next_parameter (ESoa
  * #ESoapResponse object whose name matches @name.
  *
  * Returns: a #ESoapParameter representing the parameter.
- *
- * Since: 2.92
  */
 ESoapParameter *
 e_soap_response_get_next_parameter_by_name (ESoapResponse *response,
-					       ESoapParameter *from,
-					       const gchar *name)
+                                            ESoapParameter *from,
+                                            const gchar *name)
 {
 	ESoapParameter *param;
 
@@ -632,29 +647,21 @@ e_soap_response_get_next_parameter_by_na
 	return NULL;
 }
 
-static xmlNode *
-soup_xml_real_node (xmlNode *node)
-{
-	while (node && (node->type == XML_COMMENT_NODE ||
-			xmlIsBlankNode (node)))
-		node = node->next;
-	return node;
-}
-
 /**
  * e_soap_response_dump_response:
- *
- * Since: 2.92
  **/
 gint
-e_soap_response_dump_response (ESoapResponse *response, FILE *buffer)
+e_soap_response_dump_response (ESoapResponse *response,
+                               FILE *buffer)
 {
 	xmlChar *xmlbuff;
 	gint buffersize, ret;
 
-	ESoapResponsePrivate *priv = E_SOAP_RESPONSE_GET_PRIVATE (response);
-	xmlDocDumpFormatMemory (priv->xmldoc, &xmlbuff, &buffersize, 1);
+	g_return_val_if_fail (E_IS_SOAP_RESPONSE (response), -1);
 
+	xmlDocDumpFormatMemory (
+		response->priv->xmldoc,
+		&xmlbuff, &buffersize, 1);
 	ret = fputs ((gchar *) xmlbuff, buffer);
 	xmlFree (xmlbuff);
 
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/e-soap-response.h evolution-ews.sync-with-3.8.2/src/server/e-soap-response.h
--- evolution-ews.git-gnome-3-0/src/server/e-soap-response.h	2013-05-17 14:36:16.358670992 +0200
+++ evolution-ews.sync-with-3.8.2/src/server/e-soap-response.h	2013-05-28 08:59:53.431713406 +0200
@@ -3,68 +3,104 @@
  * Copyright (C) 1999-2008 Novell, Inc. (www.novell.com)
  */
 
-#ifndef EWS_SOAP_RESPONSE_H
-#define EWS_SOAP_RESPONSE_H
+#ifndef E_SOAP_RESPONSE_H
+#define E_SOAP_RESPONSE_H
 
 #include <glib-object.h>
 #include <libxml/tree.h>
 
+/* Standard GObject macros */
+#define E_TYPE_SOAP_RESPONSE \
+	(e_soap_response_get_type ())
+#define E_SOAP_RESPONSE(obj) \
+	(G_TYPE_CHECK_INSTANCE_CAST \
+	((obj), E_TYPE_SOAP_RESPONSE, ESoapResponse))
+#define E_SOAP_RESPONSE_CLASS(cls) \
+	(G_TYPE_CHECK_CLASS_CAST \
+	((cls), E_TYPE_SOAP_RESPONSE, ESoapResponseClass))
+#define E_IS_SOAP_RESPONSE(obj) \
+	(G_TYPE_CHECK_INSTANCE_TYPE \
+	((obj), E_TYPE_SOAP_RESPONSE))
+#define E_IS_SOAP_RESPONSE_CLASS(cls) \
+	(G_TYPE_CHECK_CLASS_TYPE \
+	((cls), E_TYPE_SOAP_RESPONSE))
+#define E_SOAP_RESPONSE_GET_CLASS(obj) \
+	(G_TYPE_INSTANCE_GET_CLASS \
+	((obj), E_TYPE_SOAP_RESPONSE, ESoapResponseClass))
+
 G_BEGIN_DECLS
 
-#define E_TYPE_SOAP_RESPONSE            (e_soap_response_get_type ())
-#define E_SOAP_RESPONSE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), E_TYPE_SOAP_RESPONSE, ESoapResponse))
-#define E_SOAP_RESPONSE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), E_TYPE_SOAP_RESPONSE, ESoapResponseClass))
-#define E_IS_SOAP_RESPONSE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), E_TYPE_SOAP_RESPONSE))
-#define E_IS_SOAP_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), E_TYPE_SOAP_RESPONSE))
-#define E_SOAP_RESPONSE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), E_TYPE_SOAP_RESPONSE, ESoapResponseClass))
+typedef struct _ESoapResponse ESoapResponse;
+typedef struct _ESoapResponseClass ESoapResponseClass;
+typedef struct _ESoapResponsePrivate ESoapResponsePrivate;
 
-typedef struct {
+struct _ESoapResponse {
 	GObject parent;
+	ESoapResponsePrivate *priv;
+};
 
-} ESoapResponse;
-
-typedef struct {
+struct _ESoapResponseClass {
 	GObjectClass parent_class;
-} ESoapResponseClass;
-
-GType             e_soap_response_get_type (void);
-
-ESoapResponse *e_soap_response_new (void);
-ESoapResponse *e_soap_response_new_from_string (const gchar *xmlstr);
-ESoapResponse *e_soap_response_new_from_xmldoc (xmlDoc *xmldoc);
+};
 
-gboolean          e_soap_response_from_string (ESoapResponse *response, const gchar *xmlstr);
-gboolean          e_soap_response_from_xmldoc (ESoapResponse *response, xmlDoc *xmldoc);
-
-const gchar       *e_soap_response_get_method_name (ESoapResponse *response);
-void              e_soap_response_set_method_name (ESoapResponse *response,
-						      const gchar *method_name);
+GType		e_soap_response_get_type	(void) G_GNUC_CONST;
+ESoapResponse *	e_soap_response_new		(void);
+ESoapResponse *	e_soap_response_new_from_string	(const gchar *xmlstr);
+ESoapResponse *	e_soap_response_new_from_xmldoc	(xmlDoc *xmldoc);
+gboolean	e_soap_response_from_string	(ESoapResponse *response,
+						 const gchar *xmlstr);
+gboolean	e_soap_response_from_xmldoc	(ESoapResponse *response,
+						 xmlDoc *xmldoc);
+const gchar *	e_soap_response_get_method_name	(ESoapResponse *response);
+void		e_soap_response_set_method_name	(ESoapResponse *response,
+						 const gchar *method_name);
 
 typedef xmlNode ESoapParameter;
 
-const gchar        *e_soap_parameter_get_name (ESoapParameter *param);
-gint                e_soap_parameter_get_int_value (ESoapParameter *param);
-gchar              *e_soap_parameter_get_string_value (ESoapParameter *param);
-ESoapParameter *e_soap_parameter_get_first_child (ESoapParameter *param);
-ESoapParameter *e_soap_parameter_get_first_child_by_name (ESoapParameter *param,
-								const gchar *name);
-ESoapParameter *e_soap_parameter_get_next_child (ESoapParameter *param);
-ESoapParameter *e_soap_parameter_get_next_child_by_name (ESoapParameter *param,
-							       const gchar *name);
-gchar              *e_soap_parameter_get_property (ESoapParameter *param, const gchar *prop_name);
-
-const GList       *e_soap_response_get_parameters (ESoapResponse *response);
-ESoapParameter *e_soap_response_get_first_parameter (ESoapResponse *response);
-ESoapParameter *e_soap_response_get_first_parameter_by_name (ESoapResponse *response,
-								   const gchar *name);
-ESoapParameter *e_soap_response_get_next_parameter (ESoapResponse *response,
-							  ESoapParameter *from);
-ESoapParameter *e_soap_response_get_next_parameter_by_name (ESoapResponse *response,
-								  ESoapParameter *from,
-								  const gchar *name);
-
-gint e_soap_response_dump_response (ESoapResponse *response, FILE *buffer);
+const gchar *	e_soap_parameter_get_name	(ESoapParameter *param);
+gint		e_soap_parameter_get_int_value	(ESoapParameter *param);
+gchar *		e_soap_parameter_get_string_value
+						(ESoapParameter *param);
+ESoapParameter *
+		e_soap_parameter_get_first_child
+						(ESoapParameter *param);
+ESoapParameter *
+		e_soap_parameter_get_first_child_by_name
+						(ESoapParameter *param,
+						 const gchar *name);
+ESoapParameter *
+		e_soap_parameter_get_next_child	(ESoapParameter *param);
+ESoapParameter *
+		e_soap_parameter_get_next_child_by_name
+						(ESoapParameter *param,
+						 const gchar *name);
+gchar *		e_soap_parameter_get_property	(ESoapParameter *param,
+						 const gchar *prop_name);
+
+const GList *	e_soap_response_get_parameters	(ESoapResponse *response);
+ESoapParameter *
+		e_soap_response_get_parameter	(ESoapResponse *response);
+ESoapParameter *
+		e_soap_response_get_first_parameter
+						(ESoapResponse *response);
+ESoapParameter *
+		e_soap_response_get_first_parameter_by_name
+						(ESoapResponse *response,
+						 const gchar *name,
+						 GError **error);
+ESoapParameter *
+		e_soap_response_get_next_parameter
+						(ESoapResponse *response,
+						 ESoapParameter *from);
+ESoapParameter *
+		e_soap_response_get_next_parameter_by_name
+						(ESoapResponse *response,
+						 ESoapParameter *from,
+						 const gchar *name);
+gint		e_soap_response_dump_response	(ESoapResponse *response,
+						 FILE *buffer);
 
 G_END_DECLS
 
-#endif
+#endif /* E_SOAP_RESPONSE_H */
+
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/ews-errors.c evolution-ews.sync-with-3.8.2/src/server/ews-errors.c
--- evolution-ews.git-gnome-3-0/src/server/ews-errors.c	2013-05-17 14:36:16.358670992 +0200
+++ evolution-ews.sync-with-3.8.2/src/server/ews-errors.c	2013-05-28 08:59:53.425713426 +0200
@@ -1,10 +1,14 @@
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include "ews-errors.h"
 
 static GHashTable *ews_error_hash = NULL;
 static GOnce setup_error_once = G_ONCE_INIT;
 
 static struct EwsErrorMap
-ews_conn_errors [] =
+ews_conn_errors[] =
 {
 	{"ErrorAccessDenied",					EWS_CONNECTION_ERROR_ACCESSDENIED},
 	{"ErrorAccountDisabled",				EWS_CONNECTION_ERROR_ACCOUNTDISABLED},
@@ -28,6 +32,7 @@ ews_conn_errors [] =
 	{"ErrorCalendarInvalidDayForTimeChangePattern",		EWS_CONNECTION_ERROR_CALENDARINVALIDDAYFORTIMECHANGEPATTERN},
 	{"ErrorCalendarInvalidDayForWeeklyRecurrence",		EWS_CONNECTION_ERROR_CALENDARINVALIDDAYFORWEEKLYRECURRENCE},
 	{"ErrorCalendarInvalidPropertyState",			EWS_CONNECTION_ERROR_CALENDARINVALIDPROPERTYSTATE},
+	{"ErrorCalendarInvalidPropertyValue",			EWS_CONNECTION_ERROR_CALENDARINVALIDPROPERTYVALUE},
 	{"ErrorCalendarInvalidRecurrence",			EWS_CONNECTION_ERROR_CALENDARINVALIDRECURRENCE},
 	{"ErrorCalendarInvalidTimeZone",			EWS_CONNECTION_ERROR_CALENDARINVALIDTIMEZONE},
 	{"ErrorCalendarIsDelegatedForAccept",			EWS_CONNECTION_ERROR_CALENDARISDELEGATEDFORACCEPT},
@@ -299,10 +304,11 @@ setup_error_map (gpointer data)
 {
 	gint i;
 
-	ews_error_hash = g_hash_table_new	(g_str_hash, g_str_equal);
-	for (i = 0; i < G_N_ELEMENTS(ews_conn_errors); i++)
-		g_hash_table_insert	(ews_error_hash, (gpointer) ews_conn_errors[i].error_id,
-					 GINT_TO_POINTER (ews_conn_errors[i].error_code));
+	ews_error_hash = g_hash_table_new (g_str_hash, g_str_equal);
+	for (i = 0; i < G_N_ELEMENTS (ews_conn_errors); i++)
+		g_hash_table_insert (
+			ews_error_hash, (gpointer) ews_conn_errors[i].error_id,
+			GINT_TO_POINTER (ews_conn_errors[i].error_code));
 	return NULL;
 }
 
@@ -320,3 +326,67 @@ ews_get_error_code (const gchar *str)
 
 	return error_code;
 }
+
+gboolean
+ews_get_response_status (ESoapParameter *param,
+                         GError **error)
+{
+	ESoapParameter *subparam;
+	gchar *value;
+	gchar *message_text;
+	gchar *response_code;
+	gint error_code;
+	gboolean success = TRUE;
+
+	value = e_soap_parameter_get_property (param, "ResponseClass");
+	g_return_val_if_fail (value != NULL, FALSE);
+
+	if (g_ascii_strcasecmp (value, "Error") != 0)
+		goto exit;
+
+	subparam = e_soap_parameter_get_first_child_by_name (param, "MessageText");
+	message_text = e_soap_parameter_get_string_value (subparam);
+
+	subparam = e_soap_parameter_get_first_child_by_name (param, "ResponseCode");
+	response_code = e_soap_parameter_get_string_value (subparam);
+	error_code = ews_get_error_code (response_code);
+
+	switch (error_code) {
+		case EWS_CONNECTION_ERROR_CORRUPTDATA:
+			/* FIXME: This happens because of a bug in the
+			 * Exchange server, which doesn't like returning
+			 * <Recurrence> for any appointment without a
+			 * timezone, even if it's an all day event like a
+			 * birthday. We need to handle the error and
+			 * correctly report it to the user, but for now
+			 * we'll just ignore it... */
+			break;
+
+		case EWS_CONNECTION_ERROR_INVALIDPROPERTYREQUEST:
+			/* Ick, another one. If we try to set the IsRead
+			 * flag on certain types of item (task requests,
+			 * those stupid 'recall' requests), it complains.
+			 * We really need to find a better way to return
+			 * individual errors for each response to a multiple
+			 * request; it isn't necessarily the case that a
+			 * single error should be reported as an error for
+			 * the whole transaction */
+			break;
+
+		default:
+			g_set_error (
+				error, EWS_CONNECTION_ERROR,
+				error_code, "%s", message_text);
+			success = FALSE;
+			break;
+	}
+
+	g_free (message_text);
+	g_free (response_code);
+
+exit:
+	g_free (value);
+
+	return success;
+}
+
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/ews-errors.h evolution-ews.sync-with-3.8.2/src/server/ews-errors.h
--- evolution-ews.git-gnome-3-0/src/server/ews-errors.h	2013-05-17 14:36:16.358670992 +0200
+++ evolution-ews.sync-with-3.8.2/src/server/ews-errors.h	2013-05-28 08:59:53.429713328 +0200
@@ -1,7 +1,7 @@
 #ifndef EWS_ERRORS_H
 #define EWS_ERRORS_H
 
-#include <glib.h>
+#include <server/e-soap-response.h>
 
 G_BEGIN_DECLS
 
@@ -32,6 +32,7 @@ enum {
 	EWS_CONNECTION_ERROR_CALENDARINVALIDDAYFORTIMECHANGEPATTERN,
 	EWS_CONNECTION_ERROR_CALENDARINVALIDDAYFORWEEKLYRECURRENCE,
 	EWS_CONNECTION_ERROR_CALENDARINVALIDPROPERTYSTATE,
+	EWS_CONNECTION_ERROR_CALENDARINVALIDPROPERTYVALUE,
 	EWS_CONNECTION_ERROR_CALENDARINVALIDRECURRENCE,
 	EWS_CONNECTION_ERROR_CALENDARINVALIDTIMEZONE,
 	EWS_CONNECTION_ERROR_CALENDARISDELEGATEDFORACCEPT,
@@ -308,8 +309,10 @@ struct EwsErrorMap {
 	gint error_code;
 };
 
-gint ews_get_error_code (const gchar *str);
+gint		ews_get_error_code		(const gchar *str);
+gboolean	ews_get_response_status		(ESoapParameter *param,
+						 GError **error);
 
 G_END_DECLS
 
-#endif
+#endif /* EWS_ERRORS_H */
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/server/Makefile.am evolution-ews.sync-with-3.8.2/src/server/Makefile.am
--- evolution-ews.git-gnome-3-0/src/server/Makefile.am	2013-05-17 14:36:16.352669671 +0200
+++ evolution-ews.sync-with-3.8.2/src/server/Makefile.am	2013-05-28 12:55:41.298837176 +0200
@@ -16,12 +16,27 @@ ews-marshal.c: ews-marshal.h
 
 e-ews-connection.c: $(MARSHAL_GENERATED)
 
+GNOME_3_8_COMPAT_HEADER_FILES = \
+	e-ews-enums.h			\
+	e-ews-enumtypes.h		\
+	e-ews-gnome-3-8-compat.h	\
+	e-ews-oof-settings.h
+
+GNOME_3_8_COMPAT_FILES = \
+	$(GNOME_3_8_COMPAT_HEADER_FILES) \
+	e-ews-enumtypes.c		\
+	e-ews-gnome-3-8-compat.c	\
+	e-ews-oof-settings.c
+
 libeews_1_2_la_CPPFLAGS = \
 	$(AM_CPPFLAGS)					\
 	-DG_LOG_DOMAIN=\"libeews\"			\
 	-I$(top_srcdir)					\
 	-I$(top_builddir)				\
+	-I$(top_builddir)/src				\
 	-I$(top_builddir)/src/server			\
+	-DCAMEL_COMPILATION=1				\
+	$(CAMEL_CFLAGS)					\
 	$(SOUP_CFLAGS)					\
 	$(LIBECAL_CFLAGS)				\
 	$(LIBICAL_CFLAGS)				\
@@ -43,9 +58,11 @@ libeews_1_2_la_SOURCES =		\
 	e-soap-message.h		\
 	e-soap-response.c		\
 	e-soap-response.h		\
-	e-ews-compat.h
+	e-ews-compat.h			\
+	$(GNOME_3_8_COMPAT_FILES)
 
 libeews_1_2_la_LIBADD =						\
+	$(CAMEL_LIBS)						\
 	$(SOUP_LIBS)						\
 	$(LIBECAL_LIBS)						\
 	$(LIBICAL_LIBS)						\
@@ -62,7 +79,8 @@ libeewsinclude_HEADERS =		\
 	e-ews-folder.h			\
 	e-ews-item.h			\
 	e-ews-item-change.h		\
-	e-ews-message.h			
+	e-ews-message.h			\
+	$(GNOME_3_8_COMPAT_HEADER_FILES)
 
 %-$(API_VERSION).pc: %.pc
 	 cp $< $@
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/utils/e-ews-query-to-restriction.c evolution-ews.sync-with-3.8.2/src/utils/e-ews-query-to-restriction.c
--- evolution-ews.git-gnome-3-0/src/utils/e-ews-query-to-restriction.c	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/utils/e-ews-query-to-restriction.c	2013-05-28 08:59:53.123838523 +0200
@@ -0,0 +1,1251 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/*
+ * Authors :
+ *    Punit Jain <jpunit@novell.com>
+ * Copyright (C) 1999-2008 Novell, Inc. (www.novell.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU Lesser General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
+ * USA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h>
+#include <glib/gi18n-lib.h>
+#include <glib/gstdio.h>
+#include <camel/camel.h>
+#include <libedata-cal/e-cal-backend-sexp.h>
+
+#include "e-ews-query-to-restriction.h"
+
+#include "server/e-ews-message.h"
+
+#define d(x) x
+
+static time_t
+camel_folder_search_util_add_months (time_t t,
+                                     gint months)
+{
+	GDateTime *dt, *dt2;
+	time_t res;
+
+	if (!months)
+		return t;
+
+	dt = g_date_time_new_from_unix_utc (t);
+
+	/* just for issues, to return something inaccurate, but sane */
+	res = t + (60 * 60 * 24 * 30 * months);
+
+	g_return_val_if_fail (dt != NULL, res);
+
+	dt2 = g_date_time_add_months (dt, months);
+	g_date_time_unref (dt);
+	g_return_val_if_fail (dt2 != NULL, res);
+
+	res = g_date_time_to_unix (dt2);
+	g_date_time_unref (dt2);
+
+	return res;
+}
+
+#define WRITE_CONTAINS_MESSAGE(msg, mode, compare, uri, val) \
+	G_STMT_START { \
+		e_soap_message_start_element (msg, "Contains", NULL, NULL); \
+		e_soap_message_add_attribute (msg, "ContainmentMode", mode, NULL, NULL); \
+		e_soap_message_add_attribute (msg, "ContainmentComparison", compare, NULL, NULL); \
+		e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL, "FieldURI", uri); \
+		e_ews_message_write_string_parameter_with_attribute (msg, "Constant", NULL, NULL, "Value", val); \
+		e_soap_message_end_element (msg); \
+	} G_STMT_END
+
+#define WRITE_CONTAINS_MESSAGE_INDEXED(msg, mode, compare, uri, index, val) \
+	G_STMT_START { \
+		e_soap_message_start_element (msg, "Contains", NULL, NULL); \
+		e_soap_message_add_attribute (msg, "ContainmentMode", mode, NULL, NULL); \
+		e_soap_message_add_attribute (msg, "ContainmentComparison", compare, NULL, NULL); \
+		e_soap_message_start_element (msg, "IndexedFieldURI", NULL, NULL); \
+		e_soap_message_add_attribute (msg, "FieldURI", uri, NULL, NULL); \
+		e_soap_message_add_attribute (msg, "FieldIndex", index, NULL, NULL); \
+		e_soap_message_end_element (msg); \
+		e_ews_message_write_string_parameter_with_attribute (msg, "Constant", NULL, NULL, "Value", val); \
+		e_soap_message_end_element (msg); \
+	} G_STMT_END
+
+#define WRITE_EXISTS_MESSAGE(msg, uri) \
+	G_STMT_START { \
+		e_soap_message_start_element (msg, "Exists", NULL, NULL); \
+		e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL, "FieldURI", uri);\
+		e_soap_message_end_element (msg); \
+	} G_STMT_END
+
+#define WRITE_GREATER_THAN_OR_EQUAL_TO_MESSAGE(msg, uri, val) \
+	G_STMT_START { \
+		e_soap_message_start_element (msg, "IsGreaterThanOrEqualTo", NULL, NULL); \
+		e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL, "FieldURI", uri); \
+		e_soap_message_start_element (msg, "FieldURIOrConstant", NULL, NULL); \
+		e_ews_message_write_string_parameter_with_attribute (msg, "Constant", NULL, NULL, "Value", val); \
+		e_soap_message_end_element (msg); \
+		e_soap_message_end_element (msg); \
+	} G_STMT_END
+
+#define WRITE_LESS_THAN_OR_EQUAL_TO_MESSAGE(msg, uri, val) \
+	G_STMT_START { \
+		e_soap_message_start_element (msg, "IsLessThanOrEqualTo", NULL, NULL); \
+		e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL, "FieldURI", uri); \
+		e_soap_message_start_element (msg, "FieldURIOrConstant", NULL, NULL); \
+		e_ews_message_write_string_parameter_with_attribute (msg, "Constant", NULL, NULL, "Value", val); \
+		e_soap_message_end_element (msg); \
+		e_soap_message_end_element (msg); \
+	} G_STMT_END
+
+#define WRITE_GREATER_THAN_MESSAGE(msg, uri, val) \
+	G_STMT_START { \
+		e_soap_message_start_element (msg, "IsGreaterThan", NULL, NULL); \
+		e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL, "FieldURI", uri); \
+		e_soap_message_start_element (msg, "FieldURIOrConstant", NULL, NULL); \
+		e_ews_message_write_string_parameter_with_attribute (msg, "Constant", NULL, NULL, "Value", val); \
+		e_soap_message_end_element (msg); \
+		e_soap_message_end_element (msg); \
+	} G_STMT_END
+
+#define WRITE_LESS_THAN_MESSAGE(msg, uri, val) \
+	G_STMT_START { \
+		e_soap_message_start_element (msg, "IsLessThan", NULL, NULL); \
+		e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL, "FieldURI", uri); \
+		e_soap_message_start_element (msg, "FieldURIOrConstant", NULL, NULL); \
+		e_ews_message_write_string_parameter_with_attribute (msg, "Constant", NULL, NULL, "Value", val); \
+		e_soap_message_end_element (msg); \
+		e_soap_message_end_element (msg); \
+	} G_STMT_END
+
+#define WRITE_IS_EQUAL_TO_MESSAGE(msg, uri, val) \
+	G_STMT_START { \
+		e_soap_message_start_element (msg, "IsEqualTo", NULL, NULL); \
+		e_ews_message_write_string_parameter_with_attribute (msg, "FieldURI", NULL, NULL, "FieldURI", uri); \
+		e_soap_message_start_element (msg, "FieldURIOrConstant", NULL, NULL); \
+		e_ews_message_write_string_parameter_with_attribute (msg, "Constant", NULL, NULL, "Value", val); \
+		e_soap_message_end_element (msg); \
+		e_soap_message_end_element (msg); \
+	} G_STMT_END
+
+typedef enum {
+	MATCH_CONTAINS,
+	MATCH_IS,
+	MATCH_BEGINS_WITH,
+	MATCH_ENDS_WITH,
+	MATCH_AND,
+	MATCH_OR,
+	MATCH_NOT
+} match_type;
+
+typedef enum {
+	CONTACT_NAME,
+	CONTACT_NAME_OTHER,
+	CONTACT_EMAIL,
+	CONTACT_IM,
+	CONTACT_ADDRESS,
+	CONTACT_PHONE,
+	CONTACT_OTHER
+} contact_type;
+
+typedef struct ContactField {
+	gboolean indexed;
+	contact_type flag;
+	const gchar *field_uri;
+} ContactField;
+
+static ContactField contact_field[] = {
+	{FALSE, CONTACT_NAME, "contacts:DisplayName"},
+	{FALSE, CONTACT_NAME, "contacts:GivenName"},
+	{FALSE, CONTACT_NAME, "contacts:Nickname"},
+	{FALSE, CONTACT_NAME, "contacts:Surname"},
+	{FALSE, CONTACT_NAME, "contacts:MiddleName"},
+	{FALSE, CONTACT_NAME_OTHER, "contacts:AssistantName"},
+	{FALSE, CONTACT_NAME_OTHER, "contacts:CompanyName"},
+	{FALSE, CONTACT_NAME_OTHER, "contacts:Manager"},
+	{FALSE, CONTACT_NAME_OTHER, "contacts:SpouseName"},
+	{FALSE, CONTACT_OTHER, "contacts:BusinessHomePage"},
+	{FALSE, CONTACT_OTHER, "contacts:JobTitle"},
+	{FALSE, CONTACT_OTHER, "contacts:Department"},
+	{FALSE, CONTACT_OTHER, "contacts:Profession"},
+
+	{TRUE, CONTACT_IM, "contacts:ImAddress"},
+	{TRUE, CONTACT_ADDRESS, "contacts:PhysicalAddress:Street"},
+	{TRUE, CONTACT_ADDRESS, "contacts:PhysicalAddress:City"},
+	{TRUE, CONTACT_ADDRESS, "contacts:PhysicalAddress:State"},
+	{TRUE, CONTACT_ADDRESS, "contacts:PhysicalAddress:Country"},
+	{TRUE, CONTACT_ADDRESS, "contacts:PhysicalAddress:PostalCode"},
+	{TRUE, CONTACT_PHONE, "contacts:PhoneNumber"},
+	{TRUE, CONTACT_EMAIL, "contacts:EmailAddress"}
+};
+
+typedef struct CalendarField {
+	gboolean any_field;
+	const gchar *field_uri;
+} CalendarField;
+
+static CalendarField calendar_field[] = {
+	{FALSE, "calendar:Start"},
+	{FALSE, "calendar:End"},
+	{FALSE, "calendar:OriginalStart"},
+	{FALSE, "calendar:IsAllDayEvent"},
+	{FALSE, "calendar:LegacyFreeBusyStatus"},
+	{TRUE, "calendar:Location"},
+	{FALSE, "calendar:When"},
+	{FALSE, "calendar:IsMeeting"},
+	{FALSE, "calendar:IsCancelled"},
+	{FALSE, "calendar:IsRecurring"},
+	{FALSE, "calendar:MeetingRequestWasSent"},
+	{FALSE, "calendar:IsResponseRequested"},
+	{FALSE, "calendar:CalendarItemType"},
+	{TRUE, "calendar:Organizer"},
+	{TRUE, "calendar:RequiredAttendees"},
+	{TRUE, "calendar:OptionalAttendees"},
+	{TRUE, "calendar:Resources"},
+	{FALSE, "calendar:Duration"},
+	{FALSE, "calendar:TimeZone"},
+	{FALSE, "calendar:AppointmentState"},
+	{FALSE, "calendar:ConferenceType"},
+	{FALSE, "calendar:IsOnlineMeeting"},
+	{TRUE, "calendar:MeetingWorkspaceUrl"}
+};
+
+typedef struct ItemField {
+	gboolean any_field;
+	const gchar *field_uri;
+} ItemField;
+
+static ItemField item_field[] = {
+	{TRUE, "item:Subject"},
+	{TRUE, "item:Body"},
+	{FALSE, "item:HasAttachments"},
+	{TRUE, "item:Categories"},
+	{FALSE, "item:Importance"},
+	{FALSE, "item:Sensitivity"},
+	{FALSE, "item:InternetMessageHeader"}
+};
+
+struct EmailIndex {
+	const gchar *field_index;
+} email_index[] = {
+	{"EmailAddress1"},
+	{"EmailAddress2"},
+	{"EmailAddress3"}
+};
+
+static ESExpResult *
+e_ews_implement_contact_contains (ESExp *f,
+                                  gint argc,
+                                  ESExpResult **argv,
+                                  gpointer data,
+                                  match_type type)
+{
+	ESExpResult *r;
+	ESoapMessage *msg;
+
+	msg = (ESoapMessage *) data;
+
+	if (argc > 1 && argv[0]->type == ESEXP_RES_STRING) {
+		const gchar *field;
+		field = argv[0]->value.string;
+
+		if (argv[1]->type == ESEXP_RES_STRING && argv[1]->value.string != NULL) {
+			gchar *mode = NULL;
+
+			if (type == MATCH_CONTAINS || type == MATCH_ENDS_WITH)
+				mode = g_strdup ("Substring");
+			else if (type == MATCH_BEGINS_WITH)
+				mode = g_strdup ("Prefixed");
+			else if (type == MATCH_IS)
+				mode = g_strdup ("FullString");
+			else
+				mode = g_strdup ("Substring");
+
+			if (!strcmp (field, "full_name")) {
+				gint n = 0;
+				const gchar *value;
+				value = argv[1]->value.string;
+
+				e_soap_message_start_element (msg, "Or", NULL, NULL);
+				while (n < G_N_ELEMENTS (contact_field)) {
+					if ((contact_field[n].flag == CONTACT_NAME) && (!contact_field[n].indexed)) {
+						WRITE_CONTAINS_MESSAGE (msg, mode, "IgnoreCase", contact_field[n].field_uri, value);
+					}
+					n++;
+				}
+				e_soap_message_end_element (msg);
+
+			} else if (!strcmp (field, "x-evolution-any-field")) {
+				gint n = 0;
+				const gchar *value;
+				value = argv[1]->value.string;
+
+				e_soap_message_start_element (msg, "Or", NULL, NULL);
+				while (n < G_N_ELEMENTS (contact_field)) {
+					if (!contact_field[n].indexed) {
+						WRITE_CONTAINS_MESSAGE (msg, "Substring", "IgnoreCase", contact_field[n].field_uri, value);
+					} else if (contact_field[n].flag == CONTACT_EMAIL && contact_field[n].indexed) {
+						gint i = 0;
+						while (i < G_N_ELEMENTS (email_index)) {
+							WRITE_CONTAINS_MESSAGE_INDEXED (msg, "Substring", "IgnoreCase", "contacts:EmailAddress", email_index[i].field_index, value);
+							i++;
+						}
+					}
+					n++;
+				}
+				e_soap_message_end_element (msg);
+			} else if (!strcmp (field, "email")) {
+				const gchar *value;
+				gint n = 0;
+				value = argv[1]->value.string;
+
+				e_soap_message_start_element (msg, "Or", NULL, NULL);
+				while (n < G_N_ELEMENTS (email_index)) {
+					WRITE_CONTAINS_MESSAGE_INDEXED (msg, mode, "IgnoreCase", "contacts:EmailAddress", email_index[n].field_index, value);
+					n++;
+				}
+				e_soap_message_end_element (msg);
+			} else if (!strcmp (field, "category_list")) {
+				const gchar *value;
+				value = argv[1]->value.string;
+
+				WRITE_CONTAINS_MESSAGE (msg, mode, "IgnoreCase", "item:Categories", value);
+			}
+
+			g_free (mode);
+		}
+	}
+
+	r = e_sexp_result_new (f, ESEXP_RES_UNDEFINED);
+
+	return r;
+}
+
+static ESExpResult *
+e_ews_func_and_or_not (ESExp *f,
+                       gint argc,
+                       ESExpTerm **argv,
+                       gpointer data,
+                       match_type type)
+{
+	ESExpResult *r, *r1;
+	ESoapMessage *msg;
+	gint i;
+
+	msg = (ESoapMessage *) data;
+
+	/* "and" and "or" expects atleast two arguments */
+
+	if (argc == 0)
+		goto result;
+
+	if (type == MATCH_AND) {
+		if (argc >= 2)
+			e_soap_message_start_element (msg, "And", NULL, NULL);
+
+	} else if (type == MATCH_OR) {
+		if (argc >= 2)
+			e_soap_message_start_element (msg, "Or", NULL, NULL);
+
+	} else if (type == MATCH_NOT)
+		e_soap_message_start_element (msg, "Not", NULL, NULL);
+
+	for (i = 0; i < argc; i++) {
+		r1 = e_sexp_term_eval (f, argv[i]);
+		e_sexp_result_free (f, r1);
+	}
+
+	if (argc >= 2 || type == MATCH_NOT)
+		e_soap_message_end_element (msg);
+
+result:
+	r = e_sexp_result_new (f, ESEXP_RES_UNDEFINED);
+
+	return r;
+}
+
+static ESExpResult *
+calendar_func_contains (ESExp *f,
+                        gint argc,
+                        ESExpResult **argv,
+                        gpointer data)
+{
+	ESExpResult *r;
+	ESoapMessage *msg;
+
+	msg = (ESoapMessage *) data;
+
+	if (argc > 1 && argv[0]->type == ESEXP_RES_STRING) {
+		const gchar *field;
+		field = argv[0]->value.string;
+
+		if (argv[1]->type == ESEXP_RES_STRING && argv[1]->value.string[0] != 0) {
+			if (!g_strcmp0 (field, "summary")) {
+				const gchar *value;
+				value = argv[1]->value.string;
+
+				WRITE_CONTAINS_MESSAGE (msg, "Substring", "IgnoreCase", "item:Subject", value);
+			} else if (!g_strcmp0 (field, "description")) {
+				const gchar *value;
+				value = argv[1]->value.string;
+
+				WRITE_CONTAINS_MESSAGE (msg, "Substring", "IgnoreCase", "item:Body", value);
+			} else if (!g_strcmp0 (field, "location")) {
+				const gchar *value;
+				value = argv[1]->value.string;
+
+				WRITE_CONTAINS_MESSAGE (msg, "Substring", "IgnoreCase", "calendar:Location", value);
+			} else if (!g_strcmp0 (field, "attendee")) {
+				const gchar *value;
+				value = argv[1]->value.string;
+
+				e_soap_message_start_element (msg, "Or", NULL, NULL);
+				WRITE_CONTAINS_MESSAGE (msg, "Substring", "IgnoreCase", "calendar:RequiredAttendees", value);
+				WRITE_CONTAINS_MESSAGE (msg, "Substring", "IgnoreCase", "calendar:OptionalAttendees", value);
+				e_soap_message_end_element (msg);
+			} else if (!g_strcmp0 (field, "organizer")) {
+				const gchar *value;
+				value = argv[1]->value.string;
+
+				WRITE_CONTAINS_MESSAGE (msg, "Substring", "IgnoreCase", "calendar:Organizer", value);
+			} else if (!g_strcmp0 (field, "classification")) {
+				const gchar *value;
+				value = argv[1]->value.string;
+
+				WRITE_CONTAINS_MESSAGE (msg, "Substring", "IgnoreCase", "item:Sensitivity", value);
+			} else if (!g_strcmp0 (field, "priority")) {
+				const gchar *value;
+				value = argv[1]->value.string;
+
+				WRITE_CONTAINS_MESSAGE (msg, "Substring", "IgnoreCase", "item:Importance", value);
+			} else if (!g_strcmp0 (field, "any")) {
+				const gchar *value;
+				gint n = 0;
+				value = argv[1]->value.string;
+
+				e_soap_message_start_element (msg, "Or", NULL, NULL);
+				while (n < G_N_ELEMENTS (calendar_field)) {
+					if (calendar_field[n].any_field) {
+						WRITE_CONTAINS_MESSAGE (msg, "Substring", "IgnoreCase", calendar_field[n].field_uri, value);
+					}
+					n++;
+				}
+				n = 0;
+				while (n < G_N_ELEMENTS (item_field)) {
+					if (item_field[n].any_field) {
+						WRITE_CONTAINS_MESSAGE (msg, "Substring", "IgnoreCase", item_field[n].field_uri, value);
+					}
+					n++;
+				}
+				e_soap_message_end_element (msg);
+			}
+		}
+	}
+
+	r = e_sexp_result_new (f, ESEXP_RES_UNDEFINED);
+
+	return r;
+}
+
+static ESExpResult *
+calendar_func_has_categories (ESExp *f,
+                              gint argc,
+                              ESExpResult **argv,
+                              gpointer data)
+{
+	ESExpResult *r;
+	ESoapMessage *msg;
+
+	msg = (ESoapMessage *) data;
+
+	if (argc == 1 && argv[0]->type == ESEXP_RES_STRING) {
+		const gchar *value;
+		value = argv[0]->value.string;
+
+		WRITE_CONTAINS_MESSAGE (msg, "Substring", "IgnoreCase", "item:Categories", value);
+	}
+
+	r = e_sexp_result_new (f, ESEXP_RES_UNDEFINED);
+
+	return r;
+}
+
+static ESExpResult *
+calendar_func_has_attachment (ESExp *f,
+                              gint argc,
+                              ESExpResult **argv,
+                              gpointer data)
+{
+	ESExpResult *r;
+	ESoapMessage *msg;
+
+	msg = (ESoapMessage *) data;
+
+	if (argc == 0) {
+		WRITE_EXISTS_MESSAGE (msg, "item:HasAttachments");
+	}
+
+	r = e_sexp_result_new (f, ESEXP_RES_UNDEFINED);
+
+	return r;
+}
+
+static ESExpResult *
+calendar_func_has_recurrence (ESExp *f,
+                              gint argc,
+                              ESExpResult **argv,
+                              gpointer data)
+{
+	ESExpResult *r;
+	ESoapMessage *msg;
+
+	msg = (ESoapMessage *) data;
+
+	if (argc == 0) {
+		WRITE_EXISTS_MESSAGE (msg, "calendar:IsRecurring");
+	}
+
+	r = e_sexp_result_new (f, ESEXP_RES_UNDEFINED);
+
+	return r;
+}
+
+static gchar *
+e_ews_make_timestamp (time_t when)
+{
+	struct tm *tm;
+
+	tm = gmtime (&when);
+	return g_strdup_printf (
+		"%04d-%02d-%02dT%02d:%02d:%02dZ",
+		tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
+		tm->tm_hour, tm->tm_min, tm->tm_sec);
+}
+
+static ESExpResult *
+calendar_func_occur_in_time_range (ESExp *f,
+                                   gint argc,
+                                   ESExpResult **argv,
+                                   gpointer data)
+{
+	ESExpResult *r;
+	ESoapMessage *msg;
+	gchar *start, *end;
+
+	msg = (ESoapMessage *) data;
+
+	if (argv[0]->type != ESEXP_RES_TIME) {
+		e_sexp_fatal_error (
+			f, "occur-in-time-range? expects argument 1 "
+			"to be a time_t");
+		return NULL;
+	}
+
+	if (argv[1]->type != ESEXP_RES_TIME) {
+		e_sexp_fatal_error (
+			f, "occur-in-time-range? expects argument 2 "
+			"to be a time_t");
+		return NULL;
+	}
+
+	start = e_ews_make_timestamp (argv[0]->value.time);
+	end = e_ews_make_timestamp (argv[1]->value.time);
+
+	e_soap_message_start_element (msg, "And", NULL, NULL);
+	WRITE_GREATER_THAN_OR_EQUAL_TO_MESSAGE (msg, "calendar:Start", start);
+	WRITE_LESS_THAN_OR_EQUAL_TO_MESSAGE (msg, "calendar:End", end);
+	e_soap_message_end_element (msg);
+
+	r = e_sexp_result_new (f, ESEXP_RES_UNDEFINED);
+
+	g_free (start);
+	g_free (end);
+
+	return r;
+}
+
+static ESExpResult *
+calendar_func_occurrences_count (ESExp *f,
+                                 gint argc,
+                                 ESExpResult **argv,
+                                 gpointer data)
+{
+	ESExpResult *r;
+
+	/*ews doesn't support restriction based on number of occurrences*/
+	r = e_sexp_result_new (f, ESEXP_RES_UNDEFINED);
+
+	return r;
+}
+
+static ESExpResult *
+message_func_body_contains (ESExp *f,
+                            gint argc,
+                            ESExpResult **argv,
+                            gpointer data)
+
+{
+	ESExpResult *r;
+	ESoapMessage *msg;
+
+	msg = (ESoapMessage *) data;
+
+	if (argv[0]->type == ESEXP_RES_STRING) {
+		const gchar *value;
+		value = argv[0]->value.string;
+
+		WRITE_CONTAINS_MESSAGE (msg, "Substring", "IgnoreCase", "item:Body", value);
+	}
+
+	r = e_sexp_result_new (f, ESEXP_RES_UNDEFINED);
+
+	return r;
+}
+
+static ESExpResult *
+common_message_func_header_contains (ESExp *f,
+                                     gint argc,
+                                     ESExpResult **argv,
+                                     gpointer data,
+                                     match_type type)
+
+{
+	ESExpResult *r;
+	ESoapMessage *msg;
+	gchar *mode;
+
+	msg = (ESoapMessage *) data;
+
+	if (type == MATCH_CONTAINS || type == MATCH_ENDS_WITH)
+		mode = g_strdup ("Substring");
+	else if (type == MATCH_BEGINS_WITH)
+		mode = g_strdup ("Prefixed");
+	else if (type == MATCH_IS)
+		mode = g_strdup ("FullString");
+	else
+		mode = g_strdup ("Substring");
+
+	if (argv[0]->type == ESEXP_RES_STRING) {
+		const gchar *headername;
+		headername = argv[0]->value.string;
+
+		if (argv[1]->type == ESEXP_RES_STRING) {
+			const gchar *value;
+			value = argv[1]->value.string;
+
+			if (!g_ascii_strcasecmp (headername, "subject")) {
+				WRITE_CONTAINS_MESSAGE (msg, mode, "IgnoreCase", "item:Subject", value);
+			} else if (!g_ascii_strcasecmp (headername, "from")) {
+				WRITE_CONTAINS_MESSAGE (msg, mode, "IgnoreCase", "message:From", value);
+			} else if (!g_ascii_strcasecmp (headername, "to")) {
+				WRITE_CONTAINS_MESSAGE (msg, mode, "IgnoreCase", "message:ToRecipients", value);
+			} else if (!g_ascii_strcasecmp (headername, "cc")) {
+				WRITE_CONTAINS_MESSAGE (msg, mode, "IgnoreCase", "message:CcRecipients", value);
+			} else if (!g_ascii_strcasecmp (headername, "bcc")) {
+				WRITE_CONTAINS_MESSAGE (msg, mode, "IgnoreCase", "message:BccRecipients", value);
+			}
+		}
+	}
+
+	r = e_sexp_result_new (f, ESEXP_RES_UNDEFINED);
+
+	g_free (mode);
+
+	return r;
+}
+
+static ESExpResult *
+message_func_header_exists (ESExp *f,
+                            gint argc,
+                            ESExpResult **argv,
+                            gpointer data)
+{
+	ESExpResult *r;
+	ESoapMessage *msg;
+
+	msg = (ESoapMessage *) data;
+
+	if (argv[0]->type == ESEXP_RES_STRING) {
+		const gchar *headername;
+		headername = argv[0]->value.string;
+
+		if (!g_ascii_strcasecmp (headername, "subject")) {
+			WRITE_EXISTS_MESSAGE (msg, "item:Subject");
+		} else if (!g_ascii_strcasecmp (headername, "from")) {
+			WRITE_EXISTS_MESSAGE (msg, "message:From");
+		} else if (!g_ascii_strcasecmp (headername, "to")) {
+			WRITE_EXISTS_MESSAGE (msg, "message:ToRecipients");
+		} else if (!g_ascii_strcasecmp (headername, "cc")) {
+			WRITE_EXISTS_MESSAGE (msg, "message:CcRecipients");
+		} else if (!g_ascii_strcasecmp (headername, "bcc")) {
+			WRITE_EXISTS_MESSAGE (msg, "message:BccRecipients");
+		}
+	}
+
+	r = e_sexp_result_new (f, ESEXP_RES_UNDEFINED);
+
+	return r;
+}
+
+static ESExpResult *
+message_func_system_flag (ESExp *f,
+                          gint argc,
+                          ESExpResult **argv,
+                          gpointer data)
+{
+	ESExpResult *r;
+	ESoapMessage *msg;
+
+	msg = (ESoapMessage *) data;
+
+	if (argv[0]->type == ESEXP_RES_STRING) {
+		const gchar *name;
+		name = argv[0]->value.string;
+		if (!g_ascii_strcasecmp (name, "Attachments")) {
+			WRITE_EXISTS_MESSAGE (msg, "item:HasAttachments");
+		} else if (!g_ascii_strcasecmp (name, "deleted") || !g_ascii_strcasecmp (name, "junk")) {
+			r = e_sexp_result_new (f, ESEXP_RES_BOOL);
+			r->value.boolean = FALSE;
+			return r;
+		}
+	}
+
+	r = e_sexp_result_new (f, ESEXP_RES_UNDEFINED);
+
+	return r;
+
+}
+
+static ESExpResult *
+message_func_sent_date (ESExp *f,
+                        gint argc,
+                        ESExpResult **argv,
+                        gpointer data)
+{
+	ESExpResult *r;
+
+	r = e_sexp_result_new (f, ESEXP_RES_STRING);
+	r->value.string = g_strdup ("sent-date");
+
+	return r;
+}
+
+static ESExpResult *
+message_func_received_date (ESExp *f,
+                            gint argc,
+                            ESExpResult **argv,
+                            gpointer data)
+{
+	ESExpResult *r;
+
+	r = e_sexp_result_new (f, ESEXP_RES_STRING);
+	r->value.string = g_strdup ("received-date");
+
+	return r;
+}
+
+static ESExpResult *
+message_func_current_date (ESExp *f,
+                           gint argc,
+                           ESExpResult **argv,
+                           gpointer data)
+{
+	ESExpResult *r;
+
+	r = e_sexp_result_new (f, ESEXP_RES_INT);
+	r->value.time = time (NULL);
+	return r;
+}
+
+static ESExpResult *
+message_func_relative_months (ESExp *f,
+                              gint argc,
+                              ESExpResult **argv,
+                              gpointer data)
+{
+	ESExpResult *r;
+
+	if (argc != 1 || argv[0]->type != ESEXP_RES_INT) {
+		r = e_sexp_result_new (f, ESEXP_RES_BOOL);
+		r->value.boolean = FALSE;
+
+	} else {
+		r = e_sexp_result_new (f, ESEXP_RES_INT);
+		r->value.number = camel_folder_search_util_add_months (time (NULL), argv[0]->value.number);
+	}
+
+	return r;
+}
+
+static ESExpResult *
+message_func_get_size (ESExp *f,
+                       gint argc,
+                       ESExpResult **argv,
+                       gpointer data)
+{
+	ESExpResult *r;
+
+	r = e_sexp_result_new (f, ESEXP_RES_STRING);
+	r->value.string = g_strdup ("message-size");
+
+	return r;
+}
+
+static ESExpResult *
+func_eq (ESExp *f,
+         gint argc,
+         ESExpResult **argv,
+         gpointer data)
+{
+	ESExpResult *r;
+	ESoapMessage *msg;
+
+	msg = (ESoapMessage *) data;
+
+	if (argc != 2) {
+		e_sexp_fatal_error (f, "two arguments are required for this operation");
+		return NULL;
+	}
+
+	if (argv[0]->type == ESEXP_RES_STRING) {
+		const gchar *name;
+		gchar *field_uri = NULL;
+
+		name = argv[0]->value.string;
+
+		if (!g_strcmp0 (name, "sent-date")) {
+			field_uri = g_strdup ("item:DateTimeSent");
+		} else if (!g_strcmp0 (name, "received-date")) {
+			field_uri = g_strdup ("item:DateTimeReceived");
+		}
+
+		if (field_uri && argv[1]->type == ESEXP_RES_INT && argv[1]->value.number != 0) {
+			time_t time;
+			gchar *date;
+			time = argv[1]->value.number;
+			date = e_ews_make_timestamp (time);
+
+			WRITE_IS_EQUAL_TO_MESSAGE (msg, field_uri, date);
+			g_free (date);
+		}
+		g_free (field_uri);
+	}
+
+	r = e_sexp_result_new (f, ESEXP_RES_UNDEFINED);
+
+	return r;
+}
+
+static ESExpResult *
+func_gt (ESExp *f,
+         gint argc,
+         ESExpResult **argv,
+         gpointer data)
+{
+	ESExpResult *r;
+	ESoapMessage *msg;
+
+	msg = (ESoapMessage *) data;
+
+	if (argc != 2) {
+		e_sexp_fatal_error (f, "two arguments are required for this operation");
+		return NULL;
+	}
+
+	if (argv[0]->type == ESEXP_RES_STRING) {
+		const gchar *name;
+		gchar *field_uri = NULL;
+		gboolean is_time = FALSE;
+
+		name = argv[0]->value.string;
+
+		if (!g_strcmp0 (name, "sent-date")) {
+			field_uri = g_strdup ("item:DateTimeSent");
+			is_time = TRUE;
+		} else if (!g_strcmp0 (name, "received-date")) {
+			field_uri = g_strdup ("item:DateTimeReceived");
+			is_time = TRUE;
+		} else if (!g_strcmp0 (name, "message-size")) {
+			field_uri = g_strdup ("item:Size");
+			is_time = FALSE;
+		}
+
+		if (field_uri && argv[1]->type == ESEXP_RES_INT && argv[1]->value.number != 0) {
+			if (is_time) {
+				time_t time;
+				gchar *date;
+				time = argv[1]->value.number;
+				date = e_ews_make_timestamp (time);
+
+				WRITE_GREATER_THAN_MESSAGE (msg, field_uri, date);
+				g_free (date);
+			} else {
+				gint value;
+				gchar val_str[16];
+
+				value = argv[1]->value.number;
+				value = value * (1024); //conver kB to Bytes.
+				g_sprintf (val_str, "%d", value);
+
+				WRITE_GREATER_THAN_MESSAGE (msg, field_uri, val_str);
+			}
+		}
+		g_free (field_uri);
+	}
+
+	r = e_sexp_result_new (f, ESEXP_RES_UNDEFINED);
+
+	return r;
+}
+
+static ESExpResult *
+func_lt (ESExp *f,
+         gint argc,
+         ESExpResult **argv,
+         gpointer data)
+{
+	ESExpResult *r;
+	ESoapMessage *msg;
+
+	msg = (ESoapMessage *) data;
+
+	if (argc != 2) {
+		e_sexp_fatal_error (f, "two arguments are required for this operation");
+		return NULL;
+	}
+
+	if (argv[0]->type == ESEXP_RES_STRING) {
+		const gchar *name;
+		gchar *field_uri = NULL;
+		gboolean is_time = FALSE;
+		name = argv[0]->value.string;
+
+		if (!g_strcmp0 (name, "sent-date")) {
+			field_uri = g_strdup ("item:DateTimeSent");
+			is_time = TRUE;
+		} else if (!g_strcmp0 (name, "received-date")) {
+			field_uri = g_strdup ("item:DateTimeReceived");
+			is_time = TRUE;
+		} else if (!g_strcmp0 (name, "message-size")) {
+			field_uri = g_strdup ("item:Size");
+			is_time = FALSE;
+		}
+
+		if (field_uri && argv[1]->type == ESEXP_RES_INT && argv[1]->value.number != 0) {
+			if (is_time) {
+				time_t time;
+				gchar *date;
+				time = argv[1]->value.number;
+				date = e_ews_make_timestamp (time);
+
+				WRITE_LESS_THAN_MESSAGE (msg, field_uri, date);
+				g_free (date);
+			} else {
+				gint value;
+				gchar val_str[16];
+
+				value = argv[1]->value.number;
+				value = value * (1024); //conver kB to Bytes.
+				g_sprintf (val_str, "%d", value);
+
+				WRITE_LESS_THAN_MESSAGE (msg, field_uri, val_str);
+			}
+		}
+		g_free (field_uri);
+	}
+
+	r = e_sexp_result_new (f, ESEXP_RES_UNDEFINED);
+
+	return r;
+}
+
+static ESExpResult *
+message_func_match_all (ESExp *f,
+                        gint argc,
+                        ESExpResult **argv,
+                        gpointer data)
+{
+	ESExpResult *r;
+
+	r = e_sexp_result_new (f, ESEXP_RES_UNDEFINED);
+
+	return r;
+}
+
+static ESExpResult *
+message_func_header_contains (ESExp *f,
+                              gint argc,
+                              ESExpResult **argv,
+                              gpointer data)
+{
+	return common_message_func_header_contains (f, argc, argv, data, MATCH_CONTAINS);
+}
+
+static ESExpResult *
+message_func_header_matches (ESExp *f,
+                             gint argc,
+                             ESExpResult **argv,
+                             gpointer data)
+{
+	return common_message_func_header_contains (f, argc, argv, data, MATCH_IS);
+}
+
+static ESExpResult *
+message_func_header_starts_with (ESExp *f,
+                                 gint argc,
+                                 ESExpResult **argv,
+                                 gpointer data)
+{
+	return common_message_func_header_contains (f, argc, argv, data, MATCH_BEGINS_WITH);
+}
+
+static ESExpResult *
+message_func_header_ends_with (ESExp *f,
+                               gint argc,
+                               ESExpResult **argv,
+                               gpointer data)
+{
+	return common_message_func_header_contains (f, argc, argv, data, MATCH_ENDS_WITH);
+}
+
+static ESExpResult *
+contact_func_contains (ESExp *f,
+                       gint argc,
+                       ESExpResult **argv,
+                       gpointer data)
+{
+	return e_ews_implement_contact_contains (f, argc, argv, data, MATCH_CONTAINS);
+}
+
+static ESExpResult *
+contact_func_is (ESExp *f,
+                 gint argc,
+                 ESExpResult **argv,
+                 gpointer data)
+{
+	return e_ews_implement_contact_contains (f, argc, argv, data, MATCH_IS);
+}
+
+static ESExpResult *
+contact_func_beginswith (ESExp *f,
+                         gint argc,
+                         ESExpResult **argv,
+                         gpointer data)
+{
+	return e_ews_implement_contact_contains (f, argc, argv, data, MATCH_BEGINS_WITH);
+}
+
+static ESExpResult *
+contact_func_endswith (ESExp *f,
+                       gint argc,
+                       ESExpResult **argv,
+                       gpointer data)
+{
+	return e_ews_implement_contact_contains (f, argc, argv, data, MATCH_ENDS_WITH);
+}
+
+static ESExpResult *
+func_or (ESExp *f,
+         gint argc,
+         ESExpTerm **argv,
+         gpointer data)
+{
+	return e_ews_func_and_or_not (f, argc, argv, data, MATCH_OR);
+}
+
+static ESExpResult *
+func_and (ESExp *f,
+          gint argc,
+          ESExpTerm **argv,
+          gpointer data)
+{
+	return e_ews_func_and_or_not (f, argc, argv, data, MATCH_AND);
+}
+
+static ESExpResult *
+func_not (ESExp *f,
+          gint argc,
+          ESExpTerm **argv,
+          gpointer data)
+{
+	return e_ews_func_and_or_not (f, argc, argv, data, MATCH_NOT);
+}
+
+static struct {
+	const gchar *name;
+	ESExpFunc *func;
+	guint immediate :1;
+} contact_symbols[] = {
+	{ "and", (ESExpFunc *) func_and, 1},
+	{ "or", (ESExpFunc *) func_or, 1},
+	{ "not", (ESExpFunc *) func_not, 1},
+
+	{ "contains", contact_func_contains, 0 },
+	{ "is", contact_func_is, 0 },
+	{ "beginswith", contact_func_beginswith, 0 },
+	{ "endswith", contact_func_endswith, 0 },
+};
+
+static struct {
+	const gchar *name;
+	ESExpFunc *func;
+	guint immediate :1;
+} calendar_symbols[] = {
+	{ "and", (ESExpFunc *) func_and, 1},
+	{ "or", (ESExpFunc *) func_or, 1},
+	{ "not", (ESExpFunc *) func_not, 1},
+
+	/* Time-related functions */
+	{ "make-time", e_cal_backend_sexp_func_make_time, 0 },
+
+	/* Component-related functions */
+	{ "contains?", calendar_func_contains, 0},
+	{ "has-categories?", calendar_func_has_categories, 0 },
+	{ "has-attachments?", calendar_func_has_attachment, 0 },
+	{ "has-recurrences?", calendar_func_has_recurrence, 0 },
+	{ "occur-in-time-range?", calendar_func_occur_in_time_range, 0 },
+	{ "occurrences-count?", calendar_func_occurrences_count, 0 }
+};
+
+static struct {
+	const gchar *name;
+	ESExpFunc *func;
+	guint immediate :1;
+} message_symbols[] = {
+	{ "and", (ESExpFunc *) func_and, 1},
+	{ "or", (ESExpFunc *) func_or, 1},
+	{ "not", (ESExpFunc *) func_not, 1},
+
+	{"=",  (ESExpFunc *) func_eq, 0},
+	{">",  (ESExpFunc *) func_gt, 0},
+	{"<",  (ESExpFunc *) func_lt, 0},
+
+	{ "match-all", message_func_match_all, 0 },
+	{ "body-contains", message_func_body_contains, 0 },
+	{ "header-contains", message_func_header_contains, 0 },
+	{ "header-matches", message_func_header_matches, 0 },
+	{ "header-starts-with", message_func_header_starts_with, 0 },
+	{ "header-ends-with", message_func_header_ends_with, 0 },
+	{ "header-exists", message_func_header_exists, 0 },
+	{ "system-flag", message_func_system_flag, 0 },
+	{ "get-sent-date", message_func_sent_date, 0 },
+	{ "get-received-date", message_func_received_date, 0 },
+	{ "get-current-date", message_func_current_date, 0 },
+	{ "get-relative-months", message_func_relative_months, 0 },
+	{ "get-size", message_func_get_size, 0 },
+};
+
+static void
+e_ews_convert_sexp_to_restriction (ESoapMessage *msg,
+                                   const gchar *query,
+                                   EEwsFolderType type)
+{
+	ESExp *sexp;
+	ESExpResult *r;
+	gint i;
+
+	sexp = e_sexp_new ();
+
+	if (type == E_EWS_FOLDER_TYPE_CONTACTS) {
+		for (i = 0; i < G_N_ELEMENTS (contact_symbols); i++) {
+			if (contact_symbols[i].immediate)
+				e_sexp_add_ifunction (
+					sexp, 0, contact_symbols[i].name,
+					(ESExpIFunc *) contact_symbols[i].func, msg);
+			else
+				e_sexp_add_function (
+					sexp, 0, contact_symbols[i].name,
+					contact_symbols[i].func, msg);
+		}
+
+	} else if (type == E_EWS_FOLDER_TYPE_CALENDAR || type == E_EWS_FOLDER_TYPE_TASKS || type == E_EWS_FOLDER_TYPE_MEMOS) {
+		for (i = 0; i < G_N_ELEMENTS (calendar_symbols); i++) {
+			if (calendar_symbols[i].immediate)
+				e_sexp_add_ifunction (
+					sexp, 0, calendar_symbols[i].name,
+					(ESExpIFunc *) calendar_symbols[i].func, msg);
+			else
+				e_sexp_add_function (
+					sexp, 0, calendar_symbols[i].name,
+					calendar_symbols[i].func, msg);
+		}
+	} else if (type == E_EWS_FOLDER_TYPE_MAILBOX) {
+		for (i = 0; i < G_N_ELEMENTS (message_symbols); i++) {
+			if (message_symbols[i].immediate)
+				e_sexp_add_ifunction (
+					sexp, 0, message_symbols[i].name,
+					(ESExpIFunc *) message_symbols[i].func, msg);
+			else
+				e_sexp_add_function (
+					sexp, 0, message_symbols[i].name,
+					message_symbols[i].func, msg);
+		}
+
+	}
+
+	e_sexp_input_text (sexp, query, strlen (query));
+	e_sexp_parse (sexp);
+
+	r = e_sexp_eval (sexp);
+	if (!r)
+		return;
+
+	e_sexp_result_free (sexp, r);
+	e_sexp_unref (sexp);
+}
+
+static gboolean
+e_ews_check_is_query (const gchar *query,
+                      EEwsFolderType type)
+{
+
+	if (!query)
+		return FALSE;
+
+	if (type == E_EWS_FOLDER_TYPE_CONTACTS) {
+		if (!g_strcmp0 (query, "(contains \"x-evolution-any-field\" \"\")"))
+			return FALSE;
+		else
+			return TRUE;
+
+	} else if (type == E_EWS_FOLDER_TYPE_CALENDAR || type == E_EWS_FOLDER_TYPE_TASKS || type == E_EWS_FOLDER_TYPE_MEMOS) {
+		if (!g_strcmp0 (query, "(contains? \"summary\"  \"\")"))
+			return FALSE;
+		else
+			return TRUE;
+	} else if (type == E_EWS_FOLDER_TYPE_MAILBOX) {
+		return TRUE;
+	} else
+		return FALSE;
+}
+
+void
+e_ews_query_to_restriction (ESoapMessage *msg,
+                            const gchar *query,
+                            EEwsFolderType type)
+{
+	gboolean is_query;
+
+	is_query = e_ews_check_is_query (query, type);
+
+	if (is_query) {
+		e_soap_message_start_element (msg, "Restriction", "messages", NULL);
+		e_ews_convert_sexp_to_restriction (msg, query, type);
+		e_soap_message_end_element (msg);
+	}
+	return;
+}
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/utils/e-ews-query-to-restriction.h evolution-ews.sync-with-3.8.2/src/utils/e-ews-query-to-restriction.h
--- evolution-ews.git-gnome-3-0/src/utils/e-ews-query-to-restriction.h	1970-01-01 01:00:00.000000000 +0100
+++ evolution-ews.sync-with-3.8.2/src/utils/e-ews-query-to-restriction.h	2013-05-28 08:59:53.124837281 +0200
@@ -0,0 +1,26 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/*
+ * Authors :
+ *  Punit Jain <jpunit@novell.com>
+ *
+ * Copyright (C) 1999-2008 Novell, Inc. (www.novell.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU Lesser General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
+ * USA
+ */
+
+#include "server/e-soap-message.h"
+#include "server/e-ews-folder.h"
+
+void		e_ews_query_to_restriction (ESoapMessage *msg, const gchar *query, EEwsFolderType type);
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/utils/e-sqlite3-vfs.c evolution-ews.sync-with-3.8.2/src/utils/e-sqlite3-vfs.c
--- evolution-ews.git-gnome-3-0/src/utils/e-sqlite3-vfs.c	2013-05-17 14:36:16.360670426 +0200
+++ evolution-ews.sync-with-3.8.2/src/utils/e-sqlite3-vfs.c	2013-05-28 08:59:53.122838517 +0200
@@ -18,9 +18,12 @@
  * USA
  */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include <sqlite3.h>
 #include <glib.h>
-#include <config.h>
 #include <ctype.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -29,6 +32,8 @@
 #include <glib/gi18n-lib.h>
 #include <libedataserver/e-flag.h>
 
+#include "server/e-ews-gnome-3-8-compat.h"
+
 #include "e-sqlite3-vfs.h"
 
 #define SYNC_TIMEOUT_SECONDS 5
@@ -39,13 +44,14 @@ static GThreadPool *sync_pool = NULL;
 typedef struct {
 	sqlite3_file parent;
 	sqlite3_file *old_vfs_file; /* pointer to old_vfs' file */
-	GStaticRecMutex sync_mutex;
+	GRecMutex sync_mutex;
 	guint timeout_id;
 	gint flags;
 } ESqlite3File;
 
 static gint
-call_old_file_Sync (ESqlite3File *cFile, gint flags)
+call_old_file_Sync (ESqlite3File *cFile,
+                    gint flags)
 {
 	g_return_val_if_fail (old_vfs != NULL, SQLITE_ERROR);
 	g_return_val_if_fail (cFile != NULL, SQLITE_ERROR);
@@ -62,7 +68,8 @@ struct SyncRequestData
 };
 
 static void
-sync_request_thread_cb (gpointer task_data, gpointer null_data)
+sync_request_thread_cb (gpointer task_data,
+                        gpointer null_data)
 {
 	struct SyncRequestData *sync_data = task_data;
 	EFlag *sync_op;
@@ -80,7 +87,8 @@ sync_request_thread_cb (gpointer task_da
 }
 
 static void
-sync_push_request (ESqlite3File *cFile, gboolean wait_for_finish)
+sync_push_request (ESqlite3File *cFile,
+                   gboolean wait_for_finish)
 {
 	struct SyncRequestData *data;
 	EFlag *sync_op = NULL;
@@ -89,7 +97,7 @@ sync_push_request (ESqlite3File *cFile, 
 	g_return_if_fail (cFile != NULL);
 	g_return_if_fail (sync_pool != NULL);
 
-	g_static_rec_mutex_lock (&cFile->sync_mutex);
+	g_rec_mutex_lock (&cFile->sync_mutex);
 
 	if (wait_for_finish)
 		sync_op = e_flag_new ();
@@ -101,7 +109,7 @@ sync_push_request (ESqlite3File *cFile, 
 
 	cFile->flags = 0;
 
-	g_static_rec_mutex_unlock (&cFile->sync_mutex);
+	g_rec_mutex_unlock (&cFile->sync_mutex);
 
 	g_thread_pool_push (sync_pool, data, &error);
 
@@ -124,14 +132,14 @@ sync_push_request (ESqlite3File *cFile, 
 static gboolean
 sync_push_request_timeout (ESqlite3File *cFile)
 {
-	g_static_rec_mutex_lock (&cFile->sync_mutex);
+	g_rec_mutex_lock (&cFile->sync_mutex);
 
 	if (cFile->timeout_id != 0) {
 		sync_push_request (cFile, FALSE);
 		cFile->timeout_id = 0;
 	}
 
-	g_static_rec_mutex_unlock (&cFile->sync_mutex);
+	g_rec_mutex_unlock (&cFile->sync_mutex);
 
 	return FALSE;
 }
@@ -163,7 +171,8 @@ def_subclassed (xDeviceCharacteristics, 
 #undef def_subclassed
 
 static gint
-e_sqlite3_file_xCheckReservedLock (sqlite3_file *pFile, gint *pResOut)
+e_sqlite3_file_xCheckReservedLock (sqlite3_file *pFile,
+                                   gint *pResOut)
 {
 	ESqlite3File *cFile;
 
@@ -191,7 +200,7 @@ e_sqlite3_file_xClose (sqlite3_file *pFi
 
 	cFile = (ESqlite3File *) pFile;
 
-	g_static_rec_mutex_lock (&cFile->sync_mutex);
+	g_rec_mutex_lock (&cFile->sync_mutex);
 
 	/* Cancel any pending sync requests. */
 	if (cFile->timeout_id > 0) {
@@ -199,7 +208,7 @@ e_sqlite3_file_xClose (sqlite3_file *pFi
 		cFile->timeout_id = 0;
 	}
 
-	g_static_rec_mutex_unlock (&cFile->sync_mutex);
+	g_rec_mutex_unlock (&cFile->sync_mutex);
 
 	/* Make the last sync. */
 	sync_push_request (cFile, TRUE);
@@ -212,13 +221,14 @@ e_sqlite3_file_xClose (sqlite3_file *pFi
 	g_free (cFile->old_vfs_file);
 	cFile->old_vfs_file = NULL;
 
-	g_static_rec_mutex_free (&cFile->sync_mutex);
+	g_rec_mutex_clear (&cFile->sync_mutex);
 
 	return res;
 }
 
 static gint
-e_sqlite3_file_xSync (sqlite3_file *pFile, gint flags)
+e_sqlite3_file_xSync (sqlite3_file *pFile,
+                      gint flags)
 {
 	ESqlite3File *cFile;
 
@@ -227,7 +237,7 @@ e_sqlite3_file_xSync (sqlite3_file *pFil
 
 	cFile = (ESqlite3File *) pFile;
 
-	g_static_rec_mutex_lock (&cFile->sync_mutex);
+	g_rec_mutex_lock (&cFile->sync_mutex);
 
 	/* If a sync request is already scheduled, accumulate flags. */
 	cFile->flags |= flags;
@@ -241,15 +251,19 @@ e_sqlite3_file_xSync (sqlite3_file *pFil
 		SYNC_TIMEOUT_SECONDS, (GSourceFunc)
 		sync_push_request_timeout, cFile);
 
-	g_static_rec_mutex_unlock (&cFile->sync_mutex);
+	g_rec_mutex_unlock (&cFile->sync_mutex);
 
 	return SQLITE_OK;
 }
 
 static gint
-e_sqlite3_vfs_xOpen (sqlite3_vfs *pVfs, const gchar *zPath, sqlite3_file *pFile, gint flags, gint *pOutFlags)
+e_sqlite3_vfs_xOpen (sqlite3_vfs *pVfs,
+                     const gchar *zPath,
+                     sqlite3_file *pFile,
+                     gint flags,
+                     gint *pOutFlags)
 {
-	static GStaticRecMutex only_once_lock = G_STATIC_REC_MUTEX_INIT;
+	static GRecMutex only_once_lock;
 	static sqlite3_io_methods io_methods = {0};
 	ESqlite3File *cFile;
 	gint res;
@@ -257,7 +271,7 @@ e_sqlite3_vfs_xOpen (sqlite3_vfs *pVfs, 
 	g_return_val_if_fail (old_vfs != NULL, -1);
 	g_return_val_if_fail (pFile != NULL, -1);
 
-	cFile = (ESqlite3File *)pFile;
+	cFile = (ESqlite3File *) pFile;
 	cFile->old_vfs_file = g_malloc0 (old_vfs->szOsFile);
 
 	res = old_vfs->xOpen (old_vfs, zPath, cFile->old_vfs_file, flags, pOutFlags);
@@ -266,15 +280,15 @@ e_sqlite3_vfs_xOpen (sqlite3_vfs *pVfs, 
 		return res;
 	}
 
-	g_static_rec_mutex_init (&cFile->sync_mutex);
+	g_rec_mutex_init (&cFile->sync_mutex);
 
-	g_static_rec_mutex_lock (&only_once_lock);
+	g_rec_mutex_lock (&only_once_lock);
 
 	if (!sync_pool)
 		sync_pool = g_thread_pool_new (sync_request_thread_cb, NULL, 2, FALSE, NULL);
 
 	/* cFile->old_vfs_file->pMethods is NULL when open failed for some reason,
-	   thus do not initialize our structure when do not know the version */
+	 * thus do not initialize our structure when do not know the version */
 	if (io_methods.xClose == NULL && cFile->old_vfs_file->pMethods) {
 		/* initialize our subclass function only once */
 		io_methods.iVersion = cFile->old_vfs_file->pMethods->iVersion;
@@ -301,7 +315,7 @@ e_sqlite3_vfs_xOpen (sqlite3_vfs *pVfs, 
 		#undef use_subclassed
 	}
 
-	g_static_rec_mutex_unlock (&only_once_lock);
+	g_rec_mutex_unlock (&only_once_lock);
 
 	cFile->parent.pMethods = &io_methods;
 
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/utils/ews-camel-common.c evolution-ews.sync-with-3.8.2/src/utils/ews-camel-common.c
--- evolution-ews.git-gnome-3-0/src/utils/ews-camel-common.c	2013-05-17 14:36:16.360670426 +0200
+++ evolution-ews.sync-with-3.8.2/src/utils/ews-camel-common.c	2013-05-28 08:59:53.123838523 +0200
@@ -26,8 +26,9 @@
 #include <glib/gstdio.h>
 
 #include "ews-camel-common.h"
-#include "e-ews-compat.h"
-#include "e-ews-message.h"
+
+#include "server/e-ews-compat.h"
+#include "server/e-ews-message.h"
 
 struct _create_mime_msg_data {
 	CamelMimeMessage *message;
@@ -40,31 +41,35 @@ struct _create_mime_msg_data {
 #define MAPI_MSGFLAG_UNSENT	0x08
 
 static void
-create_mime_message_cb (ESoapMessage *msg, gpointer user_data)
+create_mime_message_cb (ESoapMessage *msg,
+                        gpointer user_data)
 {
 	struct _create_mime_msg_data *create_data = user_data;
 	CamelStream *mem, *filtered;
 	CamelMimeFilter *filter;
+	CamelContentType *content_type;
 	GByteArray *bytes;
 	gchar *base64;
-	int msgflag;
+	gint msgflag;
 
 	e_soap_message_start_element (msg, "Message", NULL, NULL);
 	e_soap_message_start_element (msg, "MimeContent", NULL, NULL);
 
 	/* This is horrid. We really need to extend ESoapMessage to allow us
-	   to stream this directly rather than storing it in RAM. Which right
-	   now we are doing about four times: the GByteArray in the mem stream,
-	   then the base64 version, then the xmlDoc, then the soup request. */
-	camel_mime_message_set_best_encoding (create_data->message,
-					      CAMEL_BESTENC_GET_ENCODING,
-					      CAMEL_BESTENC_8BIT);
+	 * to stream this directly rather than storing it in RAM. Which right
+	 * now we are doing about four times: the GByteArray in the mem stream,
+	 * then the base64 version, then the xmlDoc, then the soup request. */
+	camel_mime_message_set_best_encoding (
+		create_data->message,
+		CAMEL_BESTENC_GET_ENCODING,
+		CAMEL_BESTENC_8BIT);
 
-	mem = camel_stream_mem_new();
+	mem = camel_stream_mem_new ();
 	filtered = camel_stream_filter_new (mem);
 
-	filter = camel_mime_filter_crlf_new (CAMEL_MIME_FILTER_CRLF_ENCODE,
-				     CAMEL_MIME_FILTER_CRLF_MODE_CRLF_ONLY);
+	filter = camel_mime_filter_crlf_new (
+		CAMEL_MIME_FILTER_CRLF_ENCODE,
+		CAMEL_MIME_FILTER_CRLF_MODE_CRLF_ONLY);
 	camel_stream_filter_add (CAMEL_STREAM_FILTER (filtered), filter);
 	g_object_unref (filter);
 
@@ -84,6 +89,16 @@ create_mime_message_cb (ESoapMessage *ms
 
 	e_soap_message_end_element (msg); /* MimeContent */
 
+	content_type = camel_mime_part_get_content_type (CAMEL_MIME_PART (create_data->message));
+	if (content_type && camel_content_type_is (content_type, "multipart", "report") &&
+	    camel_content_type_param (content_type, "report-type") &&
+	    g_ascii_strcasecmp (camel_content_type_param (content_type, "report-type"), "disposition-notification") == 0) {
+		/* it's a disposition notification reply, set ItemClass too */
+		e_soap_message_start_element (msg, "ItemClass", NULL, NULL);
+		e_soap_message_write_string (msg, "REPORT.IPM.NOTE.IPNRN");
+		e_soap_message_end_element (msg); /* ItemClass */
+	}
+
 	/* more MAPI crap.  You can't just set the IsDraft property
 	 * here you have to use the MAPI MSGFLAG_UNSENT extended
 	 * property Further crap is that Exchange 2007 assumes when it
@@ -108,16 +123,22 @@ create_mime_message_cb (ESoapMessage *ms
 }
 
 gboolean
-camel_ews_utils_create_mime_message (EEwsConnection *cnc, const gchar *disposition,
-				     const gchar *save_folder, CamelMimeMessage *message,
-				     gint32 message_camel_flags, CamelAddress *from,
-				     gchar **itemid, gchar **changekey,
-				     GCancellable *cancellable, GError **error)
+camel_ews_utils_create_mime_message (EEwsConnection *cnc,
+                                     const gchar *disposition,
+                                     const EwsFolderId *fid,
+                                     CamelMimeMessage *message,
+                                     gint32 message_camel_flags,
+                                     CamelAddress *from,
+                                     gchar **itemid,
+                                     gchar **changekey,
+                                     GCancellable *cancellable,
+                                     GError **error)
 {
 	struct _create_mime_msg_data *create_data;
 	GSList *ids;
 	EEwsItem *item;
 	const EwsId *ewsid;
+	gchar *restore_from = NULL;
 	gboolean res;
 
 	create_data = g_new0 (struct _create_mime_msg_data, 1);
@@ -126,17 +147,45 @@ camel_ews_utils_create_mime_message (EEw
 	create_data->message_camel_flags = message_camel_flags;
 	create_data->from = from;
 
-	res = e_ews_connection_create_items (cnc, EWS_PRIORITY_MEDIUM,
-					     disposition, NULL, save_folder,
-					     create_mime_message_cb, create_data,
-					     &ids, cancellable, error);
+	if (g_strcmp0 (disposition, "SendOnly") == 0 ||
+	    g_strcmp0 (disposition, "SendAndSaveCopy") == 0) {
+		struct _camel_header_raw *header;
+
+		for (header = CAMEL_MIME_PART (message)->headers; header; header = header->next) {
+			if (header->name && g_ascii_strcasecmp (header->name, "From") == 0) {
+				restore_from = header->value;
+				header->value = g_strdup ("");
+				break;
+			}
+		}
+	}
+
+	res = e_ews_connection_create_items_sync (
+		cnc, EWS_PRIORITY_MEDIUM,
+		disposition, NULL, fid,
+		create_mime_message_cb, create_data,
+		&ids, cancellable, error);
+
+	if (restore_from) {
+		struct _camel_header_raw *header;
+
+		for (header = CAMEL_MIME_PART (message)->headers; header; header = header->next) {
+			if (header->name && g_ascii_strcasecmp (header->name, "From") == 0) {
+				g_free (header->value);
+				header->value = restore_from;
+				break;
+			}
+		}
+	}
+
 	if (!res || (!itemid && !changekey))
 		return res;
 
-	item = (EEwsItem *)ids->data;
+	item = (EEwsItem *) ids->data;
 	if (!item || !(ewsid = e_ews_item_get_id (item))) {
-		g_set_error(error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
-			    _("CreateItem call failed to return ID for new message"));
+		g_set_error (
+			error, CAMEL_ERROR, CAMEL_ERROR_GENERIC,
+			_("CreateItem call failed to return ID for new message"));
 		return FALSE;
 	}
 
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/utils/ews-camel-common.h evolution-ews.sync-with-3.8.2/src/utils/ews-camel-common.h
--- evolution-ews.git-gnome-3-0/src/utils/ews-camel-common.h	2013-05-17 14:36:16.360670426 +0200
+++ evolution-ews.sync-with-3.8.2/src/utils/ews-camel-common.h	2013-05-28 08:59:53.124837281 +0200
@@ -21,20 +21,26 @@
 #define	EWS_CAMEL_COMMON_H
 
 #include <camel/camel.h>
-#include <e-ews-connection.h>
+
+#include "server/e-ews-connection.h"
+#include "server/e-ews-folder.h"
 
 G_BEGIN_DECLS
 
 gboolean
-camel_ews_utils_create_mime_message (EEwsConnection *cnc, const gchar *disposition,
-				     const gchar *save_folder, CamelMimeMessage *message,
-				     gint32 message_camel_flags, CamelAddress *from,
-				     gchar **itemid, gchar **changekey,
-				     GCancellable *cancellable, GError **error);
+camel_ews_utils_create_mime_message (EEwsConnection *cnc,
+				     const gchar *disposition,
+				     const EwsFolderId *fid,
+				     CamelMimeMessage *message,
+				     gint32 message_camel_flags,
+				     CamelAddress *from,
+				     gchar **itemid,
+				     gchar **changekey,
+				     GCancellable *cancellable,
+				     GError **error);
 
 G_END_DECLS
 
-
 #ifdef	__cplusplus
 }
 #endif
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/utils/ews-esource-utils.c evolution-ews.sync-with-3.8.2/src/utils/ews-esource-utils.c
--- evolution-ews.git-gnome-3-0/src/utils/ews-esource-utils.c	2013-05-17 14:36:16.361670494 +0200
+++ evolution-ews.sync-with-3.8.2/src/utils/ews-esource-utils.c	2013-05-28 08:59:53.122838517 +0200
@@ -100,7 +100,7 @@ ews_esource_utils_add_esource	(EEwsFolde
 	ESourceList *source_list;
 	ESourceGroup *group;
 	ESource *source;
-	EwsFolderType ftype;
+	EEwsFolderType ftype;
 	const EwsFolderId *fid;
 	GConfClient* client;
 	const gchar *conf_key, *selection_key = NULL;
@@ -113,13 +113,13 @@ ews_esource_utils_add_esource	(EEwsFolde
 	source_name = e_ews_folder_get_name (folder);
 	fid = e_ews_folder_get_id (folder);
 
-	if (ftype == EWS_FOLDER_TYPE_CALENDAR) {
+	if (ftype == E_EWS_FOLDER_TYPE_CALENDAR) {
 		conf_key = CALENDAR_SOURCES;
 		selection_key = SELECTED_CALENDARS;
-	} else if (ftype == EWS_FOLDER_TYPE_TASKS){
+	} else if (ftype == E_EWS_FOLDER_TYPE_TASKS){
 		conf_key = TASKS_SOURCES;
 		selection_key = SELECTED_TASKS;
-	} else if (ftype == EWS_FOLDER_TYPE_CONTACTS) {
+	} else if (ftype == E_EWS_FOLDER_TYPE_CONTACTS) {
 		conf_key = CONTACT_SOURCES;
 	} else
 		return FALSE;
@@ -139,7 +139,7 @@ ews_esource_utils_add_esource	(EEwsFolde
 	   in *either* calendar or mail code. Note the tricks we have to
 	   play in the calendar back end to make the cache directory
 	   unique again. */
-	if (ftype == EWS_FOLDER_TYPE_CONTACTS)
+	if (ftype == E_EWS_FOLDER_TYPE_CONTACTS)
 		source_uri = g_strdup_printf ("%s;folderid=%s", account_uri + strlen (EWS_BASE_URI), fid->id);
 	else
 		source_uri = g_strdup (account_uri + strlen (EWS_BASE_URI));
@@ -157,7 +157,7 @@ ews_esource_utils_add_esource	(EEwsFolde
 
 	g_free (source_uri);
 	/* set props required for contacts */
-	if (ftype == EWS_FOLDER_TYPE_CONTACTS) {
+	if (ftype == E_EWS_FOLDER_TYPE_CONTACTS) {
 		e_source_set_property (source, "auth", "plain/password");
 		e_source_set_property (source, "completion", "true");
 	} else
@@ -190,7 +190,7 @@ exit:
 gboolean
 ews_esource_utils_remove_esource	(const gchar *fid,
 					 const gchar *account_name,
-					 EwsFolderType ftype)
+					 EEwsFolderType ftype)
 {
 	ESourceList *source_list;
 	ESourceGroup *group;
@@ -200,11 +200,11 @@ ews_esource_utils_remove_esource	(const 
 	GSList *sources;
 	gboolean ret = TRUE;
 
-	if (ftype == EWS_FOLDER_TYPE_CALENDAR) {
+	if (ftype == E_EWS_FOLDER_TYPE_CALENDAR) {
 		conf_key = CALENDAR_SOURCES;
-	} else if (ftype == EWS_FOLDER_TYPE_TASKS){
+	} else if (ftype == E_EWS_FOLDER_TYPE_TASKS){
 		conf_key = TASKS_SOURCES;
-	} else if (ftype == EWS_FOLDER_TYPE_CONTACTS) {
+	} else if (ftype == E_EWS_FOLDER_TYPE_CONTACTS) {
 		conf_key = CONTACT_SOURCES;
 	} else
 		return FALSE;
@@ -231,7 +231,7 @@ exit:
 }
 
 gboolean
-ews_source_utils_remove_group (const gchar *account_name, EwsFolderType ftype)
+ews_source_utils_remove_group (const gchar *account_name, EEwsFolderType ftype)
 {
 	ESourceList *source_list;
 	ESourceGroup *group;
@@ -240,11 +240,11 @@ ews_source_utils_remove_group (const gch
 	const gchar *conf_key;
 	gboolean ret = TRUE;
 
-	if (ftype == EWS_FOLDER_TYPE_CALENDAR) {
+	if (ftype == E_EWS_FOLDER_TYPE_CALENDAR) {
 		conf_key = CALENDAR_SOURCES;
-	} else if (ftype == EWS_FOLDER_TYPE_TASKS){
+	} else if (ftype == E_EWS_FOLDER_TYPE_TASKS){
 		conf_key = TASKS_SOURCES;
-	} else if (ftype == EWS_FOLDER_TYPE_CONTACTS) {
+	} else if (ftype == E_EWS_FOLDER_TYPE_CONTACTS) {
 		conf_key = CONTACT_SOURCES;
 	} else
 		return FALSE;
@@ -271,7 +271,7 @@ ews_source_utils_remove_group (const gch
 void
 ews_esource_utils_remove_groups	(const gchar *account_name)
 {
-	ews_source_utils_remove_group (account_name, EWS_FOLDER_TYPE_CALENDAR);
-	ews_source_utils_remove_group (account_name, EWS_FOLDER_TYPE_CONTACTS);
-	ews_source_utils_remove_group (account_name, EWS_FOLDER_TYPE_TASKS);
+	ews_source_utils_remove_group (account_name, E_EWS_FOLDER_TYPE_CALENDAR);
+	ews_source_utils_remove_group (account_name, E_EWS_FOLDER_TYPE_CONTACTS);
+	ews_source_utils_remove_group (account_name, E_EWS_FOLDER_TYPE_TASKS);
 }
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/utils/ews-esource-utils.h evolution-ews.sync-with-3.8.2/src/utils/ews-esource-utils.h
--- evolution-ews.git-gnome-3-0/src/utils/ews-esource-utils.h	2013-05-17 14:36:16.361670494 +0200
+++ evolution-ews.sync-with-3.8.2/src/utils/ews-esource-utils.h	2013-05-28 08:59:53.123838523 +0200
@@ -21,7 +21,8 @@
 #define EWS_ESOURCE_UTILS_H
 
 #include <libedataserver/e-source-list.h>
-#include <e-ews-folder.h>
+#include <server/e-ews-enums.h>
+#include <server/e-ews-folder.h>
 
 G_BEGIN_DECLS
 
@@ -44,13 +45,13 @@ gboolean
 ews_esource_utils_remove_esource
 				(const gchar *fid,
 				 const gchar *account_name,
-				 EwsFolderType ftype);
+				 EEwsFolderType ftype);
 
 void
 ews_esource_utils_remove_groups	(const gchar *account_name);
 
 gboolean
-ews_source_utils_remove_group (const gchar *account_name, EwsFolderType ftype);
+ews_source_utils_remove_group (const gchar *account_name, EEwsFolderType ftype);
 
 ESource *
 ews_find_source_by_matched_prop (GSList *sources, const gchar *prop, const gchar *val);
diff -upr -x.git -x.svn -N evolution-ews.git-gnome-3-0/src/utils/Makefile.am evolution-ews.sync-with-3.8.2/src/utils/Makefile.am
--- evolution-ews.git-gnome-3-0/src/utils/Makefile.am	2013-05-17 14:36:16.360670426 +0200
+++ evolution-ews.sync-with-3.8.2/src/utils/Makefile.am	2013-05-28 08:59:53.123838523 +0200
@@ -1,32 +1,41 @@
-lib_LTLIBRARIES = libewsutils.la
+NULL =
+
+privlib_LTLIBRARIES = libewsutils.la
 
 libewsutils_la_CPPFLAGS = \
-	$(AM_CPPFLAGS)					\
-	-DG_LOG_DOMAIN=\"libeews\"			\
-	-I$(top_srcdir)					\
-	-I$(top_srcdir)/src/server			\
-	-I$(top_builddir)				\
-	-I$(top_builddir)/src/server			\
-	$(LIBEDATASERVER_CFLAGS)			\
-	$(SQLITE3_CFLAGS)				\
-	$(DEBUG_CFLAGS)					\
-	$(CAMEL_CFLAGS)
-
-libewsutils_la_SOURCES =				\
-	ews-camel-compat.h				\
-	ews-camel-compat.c				\
-	ews-esource-utils.h				\
-	ews-esource-utils.c				\
-	e-sqlite3-vfs.c					\
-	e-sqlite3-vfs.h					\
-	ews-camel-common.c				\
-	ews-camel-common.h
-
-libewsutils_la_LIBADD =					\
-	$(top_builddir)/src/server/libeews-1.2.la 	\
-	$(SQLITE3_LIBS)	\
-	$(LIBEDATASERVER_LIBS)				\
-	$(CAMEL_LIBS)
+	$(AM_CPPFLAGS) \
+	-DG_LOG_DOMAIN=\"libeews\" \
+	-I$(top_srcdir) \
+	-I$(top_srcdir)/src \
+	-I$(top_builddir) \
+	-I$(top_builddir)/src \
+	$(LIBEDATASERVER_CFLAGS) \
+	$(SQLITE3_CFLAGS) \
+	$(DEBUG_CFLAGS) \
+	$(CAMEL_CFLAGS) \
+	$(LIBEDATACAL_CFLAGS) \
+	$(NULL)
+
+libewsutils_la_SOURCES = \
+	e-sqlite3-vfs.c \
+	e-sqlite3-vfs.h \
+	ews-camel-common.c \
+	ews-camel-common.h \
+	ews-camel-compat.c \
+	ews-camel-compat.h \
+	ews-esource-utils.c \
+	ews-esource-utils.h \
+	e-ews-query-to-restriction.c \
+	e-ews-query-to-restriction.h \
+	$(NULL)
+
+libewsutils_la_LIBADD = \
+	$(top_builddir)/src/server/libeews-1.2.la  \
+	$(SQLITE3_LIBS) \
+	$(LIBEDATASERVER_LIBS) \
+	$(CAMEL_LIBS) \
+	$(LIBEDATACAL_LIBS) \
+	$(NULL)
 
 libewsutils_la_LDFLAGS = $(NO_UNDEFINED)
 
